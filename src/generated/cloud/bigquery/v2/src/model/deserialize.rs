// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::BigLakeConfiguration {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __connection_id,
            __storage_uri,
            __file_format,
            __table_format,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BigLakeConfiguration")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "connectionId" => Ok(__FieldTag::__connection_id),
                            "connection_id" => Ok(__FieldTag::__connection_id),
                            "storageUri" => Ok(__FieldTag::__storage_uri),
                            "storage_uri" => Ok(__FieldTag::__storage_uri),
                            "fileFormat" => Ok(__FieldTag::__file_format),
                            "file_format" => Ok(__FieldTag::__file_format),
                            "tableFormat" => Ok(__FieldTag::__table_format),
                            "table_format" => Ok(__FieldTag::__table_format),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::BigLakeConfiguration;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BigLakeConfiguration")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__connection_id => {
                            if !fields.insert(__FieldTag::__connection_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection_id",
                                ));
                            }
                            result.connection_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__storage_uri => {
                            if !fields.insert(__FieldTag::__storage_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_uri",
                                ));
                            }
                            result.storage_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__file_format => {
                            if !fields.insert(__FieldTag::__file_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_format",
                                ));
                            }
                            result.file_format = map
                                .next_value::<std::option::Option<
                                    crate::model::big_lake_configuration::FileFormat,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table_format => {
                            if !fields.insert(__FieldTag::__table_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_format",
                                ));
                            }
                            result.table_format = map
                                .next_value::<std::option::Option<
                                    crate::model::big_lake_configuration::TableFormat,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Clustering {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __fields,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Clustering")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fields" => Ok(__FieldTag::__fields),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Clustering;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Clustering")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__fields => {
                            if !fields.insert(__FieldTag::__fields) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fields",
                                ));
                            }
                            result.fields = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DataFormatOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __use_int64_timestamp,
            __timestamp_output_format,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataFormatOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "useInt64Timestamp" => Ok(__FieldTag::__use_int64_timestamp),
                            "use_int64_timestamp" => Ok(__FieldTag::__use_int64_timestamp),
                            "timestampOutputFormat" => Ok(__FieldTag::__timestamp_output_format),
                            "timestamp_output_format" => Ok(__FieldTag::__timestamp_output_format),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DataFormatOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataFormatOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__use_int64_timestamp => {
                            if !fields.insert(__FieldTag::__use_int64_timestamp) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for use_int64_timestamp",
                                ));
                            }
                            result.use_int64_timestamp = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__timestamp_output_format => {
                            if !fields.insert(__FieldTag::__timestamp_output_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timestamp_output_format",
                                ));
                            }
                            result.timestamp_output_format = map
                                .next_value::<std::option::Option<
                                    crate::model::data_format_options::TimestampOutputFormat,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DatasetAccessEntry {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dataset,
            __target_types,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DatasetAccessEntry")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dataset" => Ok(__FieldTag::__dataset),
                            "targetTypes" => Ok(__FieldTag::__target_types),
                            "target_types" => Ok(__FieldTag::__target_types),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DatasetAccessEntry;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DatasetAccessEntry")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dataset => {
                            if !fields.insert(__FieldTag::__dataset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset",
                                ));
                            }
                            result.dataset = map
                                .next_value::<std::option::Option<crate::model::DatasetReference>>(
                                )?;
                        }
                        __FieldTag::__target_types => {
                            if !fields.insert(__FieldTag::__target_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_types",
                                ));
                            }
                            result.target_types = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::dataset_access_entry::TargetType>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Access {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __role,
            __user_by_email,
            __group_by_email,
            __domain,
            __special_group,
            __iam_member,
            __view,
            __routine,
            __dataset,
            __condition,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Access")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "role" => Ok(__FieldTag::__role),
                            "userByEmail" => Ok(__FieldTag::__user_by_email),
                            "user_by_email" => Ok(__FieldTag::__user_by_email),
                            "groupByEmail" => Ok(__FieldTag::__group_by_email),
                            "group_by_email" => Ok(__FieldTag::__group_by_email),
                            "domain" => Ok(__FieldTag::__domain),
                            "specialGroup" => Ok(__FieldTag::__special_group),
                            "special_group" => Ok(__FieldTag::__special_group),
                            "iamMember" => Ok(__FieldTag::__iam_member),
                            "iam_member" => Ok(__FieldTag::__iam_member),
                            "view" => Ok(__FieldTag::__view),
                            "routine" => Ok(__FieldTag::__routine),
                            "dataset" => Ok(__FieldTag::__dataset),
                            "condition" => Ok(__FieldTag::__condition),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Access;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Access")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__role => {
                            if !fields.insert(__FieldTag::__role) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for role",
                                ));
                            }
                            result.role = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__user_by_email => {
                            if !fields.insert(__FieldTag::__user_by_email) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_by_email",
                                ));
                            }
                            result.user_by_email = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__group_by_email => {
                            if !fields.insert(__FieldTag::__group_by_email) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for group_by_email",
                                ));
                            }
                            result.group_by_email = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__domain => {
                            if !fields.insert(__FieldTag::__domain) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for domain",
                                ));
                            }
                            result.domain = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__special_group => {
                            if !fields.insert(__FieldTag::__special_group) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for special_group",
                                ));
                            }
                            result.special_group = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__iam_member => {
                            if !fields.insert(__FieldTag::__iam_member) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for iam_member",
                                ));
                            }
                            result.iam_member = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<crate::model::TableReference>>(
                                )?;
                        }
                        __FieldTag::__routine => {
                            if !fields.insert(__FieldTag::__routine) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for routine",
                                ));
                            }
                            result.routine = map
                                .next_value::<std::option::Option<crate::model::RoutineReference>>(
                                )?;
                        }
                        __FieldTag::__dataset => {
                            if !fields.insert(__FieldTag::__dataset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset",
                                ));
                            }
                            result.dataset = map.next_value::<std::option::Option<crate::model::DatasetAccessEntry>>()?
                                ;
                        }
                        __FieldTag::__condition => {
                            if !fields.insert(__FieldTag::__condition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for condition",
                                ));
                            }
                            result.condition =
                                map.next_value::<std::option::Option<gtype::model::Expr>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Dataset {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __etag,
            __id,
            __self_link,
            __dataset_reference,
            __friendly_name,
            __description,
            __default_table_expiration_ms,
            __default_partition_expiration_ms,
            __labels,
            __access,
            __creation_time,
            __last_modified_time,
            __location,
            __default_encryption_configuration,
            __satisfies_pzs,
            __satisfies_pzi,
            __type,
            __linked_dataset_source,
            __linked_dataset_metadata,
            __external_dataset_reference,
            __external_catalog_dataset_options,
            __is_case_insensitive,
            __default_collation,
            __default_rounding_mode,
            __max_time_travel_hours,
            __tags,
            __storage_billing_model,
            __restrictions,
            __resource_tags,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Dataset")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "etag" => Ok(__FieldTag::__etag),
                            "id" => Ok(__FieldTag::__id),
                            "selfLink" => Ok(__FieldTag::__self_link),
                            "self_link" => Ok(__FieldTag::__self_link),
                            "datasetReference" => Ok(__FieldTag::__dataset_reference),
                            "dataset_reference" => Ok(__FieldTag::__dataset_reference),
                            "friendlyName" => Ok(__FieldTag::__friendly_name),
                            "friendly_name" => Ok(__FieldTag::__friendly_name),
                            "description" => Ok(__FieldTag::__description),
                            "defaultTableExpirationMs" => {
                                Ok(__FieldTag::__default_table_expiration_ms)
                            }
                            "default_table_expiration_ms" => {
                                Ok(__FieldTag::__default_table_expiration_ms)
                            }
                            "defaultPartitionExpirationMs" => {
                                Ok(__FieldTag::__default_partition_expiration_ms)
                            }
                            "default_partition_expiration_ms" => {
                                Ok(__FieldTag::__default_partition_expiration_ms)
                            }
                            "labels" => Ok(__FieldTag::__labels),
                            "access" => Ok(__FieldTag::__access),
                            "creationTime" => Ok(__FieldTag::__creation_time),
                            "creation_time" => Ok(__FieldTag::__creation_time),
                            "lastModifiedTime" => Ok(__FieldTag::__last_modified_time),
                            "last_modified_time" => Ok(__FieldTag::__last_modified_time),
                            "location" => Ok(__FieldTag::__location),
                            "defaultEncryptionConfiguration" => {
                                Ok(__FieldTag::__default_encryption_configuration)
                            }
                            "default_encryption_configuration" => {
                                Ok(__FieldTag::__default_encryption_configuration)
                            }
                            "satisfiesPzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfies_pzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfiesPzi" => Ok(__FieldTag::__satisfies_pzi),
                            "satisfies_pzi" => Ok(__FieldTag::__satisfies_pzi),
                            "type" => Ok(__FieldTag::__type),
                            "linkedDatasetSource" => Ok(__FieldTag::__linked_dataset_source),
                            "linked_dataset_source" => Ok(__FieldTag::__linked_dataset_source),
                            "linkedDatasetMetadata" => Ok(__FieldTag::__linked_dataset_metadata),
                            "linked_dataset_metadata" => Ok(__FieldTag::__linked_dataset_metadata),
                            "externalDatasetReference" => {
                                Ok(__FieldTag::__external_dataset_reference)
                            }
                            "external_dataset_reference" => {
                                Ok(__FieldTag::__external_dataset_reference)
                            }
                            "externalCatalogDatasetOptions" => {
                                Ok(__FieldTag::__external_catalog_dataset_options)
                            }
                            "external_catalog_dataset_options" => {
                                Ok(__FieldTag::__external_catalog_dataset_options)
                            }
                            "isCaseInsensitive" => Ok(__FieldTag::__is_case_insensitive),
                            "is_case_insensitive" => Ok(__FieldTag::__is_case_insensitive),
                            "defaultCollation" => Ok(__FieldTag::__default_collation),
                            "default_collation" => Ok(__FieldTag::__default_collation),
                            "defaultRoundingMode" => Ok(__FieldTag::__default_rounding_mode),
                            "default_rounding_mode" => Ok(__FieldTag::__default_rounding_mode),
                            "maxTimeTravelHours" => Ok(__FieldTag::__max_time_travel_hours),
                            "max_time_travel_hours" => Ok(__FieldTag::__max_time_travel_hours),
                            "tags" => Ok(__FieldTag::__tags),
                            "storageBillingModel" => Ok(__FieldTag::__storage_billing_model),
                            "storage_billing_model" => Ok(__FieldTag::__storage_billing_model),
                            "restrictions" => Ok(__FieldTag::__restrictions),
                            "resourceTags" => Ok(__FieldTag::__resource_tags),
                            "resource_tags" => Ok(__FieldTag::__resource_tags),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Dataset;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Dataset")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__self_link => {
                            if !fields.insert(__FieldTag::__self_link) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for self_link",
                                ));
                            }
                            result.self_link = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_reference => {
                            if !fields.insert(__FieldTag::__dataset_reference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_reference",
                                ));
                            }
                            result.dataset_reference = map
                                .next_value::<std::option::Option<crate::model::DatasetReference>>(
                                )?;
                        }
                        __FieldTag::__friendly_name => {
                            if !fields.insert(__FieldTag::__friendly_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for friendly_name",
                                ));
                            }
                            result.friendly_name =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::__default_table_expiration_ms => {
                            if !fields.insert(__FieldTag::__default_table_expiration_ms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_table_expiration_ms",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.default_table_expiration_ms = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__default_partition_expiration_ms => {
                            if !fields.insert(__FieldTag::__default_partition_expiration_ms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_partition_expiration_ms",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.default_partition_expiration_ms = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__access => {
                            if !fields.insert(__FieldTag::__access) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for access",
                                ));
                            }
                            result.access = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Access>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__creation_time => {
                            if !fields.insert(__FieldTag::__creation_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for creation_time",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.creation_time =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__last_modified_time => {
                            if !fields.insert(__FieldTag::__last_modified_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_modified_time",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.last_modified_time =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__default_encryption_configuration => {
                            if !fields.insert(__FieldTag::__default_encryption_configuration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_encryption_configuration",
                                ));
                            }
                            result.default_encryption_configuration = map.next_value::<std::option::Option<crate::model::EncryptionConfiguration>>()?
                                ;
                        }
                        __FieldTag::__satisfies_pzs => {
                            if !fields.insert(__FieldTag::__satisfies_pzs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzs",
                                ));
                            }
                            result.satisfies_pzs =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__satisfies_pzi => {
                            if !fields.insert(__FieldTag::__satisfies_pzi) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzi",
                                ));
                            }
                            result.satisfies_pzi =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__linked_dataset_source => {
                            if !fields.insert(__FieldTag::__linked_dataset_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for linked_dataset_source",
                                ));
                            }
                            result.linked_dataset_source = map.next_value::<std::option::Option<crate::model::LinkedDatasetSource>>()?
                                ;
                        }
                        __FieldTag::__linked_dataset_metadata => {
                            if !fields.insert(__FieldTag::__linked_dataset_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for linked_dataset_metadata",
                                ));
                            }
                            result.linked_dataset_metadata = map.next_value::<std::option::Option<crate::model::LinkedDatasetMetadata>>()?
                                ;
                        }
                        __FieldTag::__external_dataset_reference => {
                            if !fields.insert(__FieldTag::__external_dataset_reference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_dataset_reference",
                                ));
                            }
                            result.external_dataset_reference = map.next_value::<std::option::Option<crate::model::ExternalDatasetReference>>()?
                                ;
                        }
                        __FieldTag::__external_catalog_dataset_options => {
                            if !fields.insert(__FieldTag::__external_catalog_dataset_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_catalog_dataset_options",
                                ));
                            }
                            result.external_catalog_dataset_options =
                                map.next_value::<std::option::Option<
                                    crate::model::ExternalCatalogDatasetOptions,
                                >>()?;
                        }
                        __FieldTag::__is_case_insensitive => {
                            if !fields.insert(__FieldTag::__is_case_insensitive) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_case_insensitive",
                                ));
                            }
                            result.is_case_insensitive =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__default_collation => {
                            if !fields.insert(__FieldTag::__default_collation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_collation",
                                ));
                            }
                            result.default_collation =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::__default_rounding_mode => {
                            if !fields.insert(__FieldTag::__default_rounding_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_rounding_mode",
                                ));
                            }
                            result.default_rounding_mode =
                                map.next_value::<std::option::Option<
                                    crate::model::table_field_schema::RoundingMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__max_time_travel_hours => {
                            if !fields.insert(__FieldTag::__max_time_travel_hours) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_time_travel_hours",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_time_travel_hours = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__tags => {
                            if !fields.insert(__FieldTag::__tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tags",
                                ));
                            }
                            result.tags = map.next_value::<std::option::Option<std::vec::Vec<crate::model::GcpTag>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__storage_billing_model => {
                            if !fields.insert(__FieldTag::__storage_billing_model) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_billing_model",
                                ));
                            }
                            result.storage_billing_model = map.next_value::<std::option::Option<crate::model::dataset::StorageBillingModel>>()?.unwrap_or_default();
                        }
                        __FieldTag::__restrictions => {
                            if !fields.insert(__FieldTag::__restrictions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for restrictions",
                                ));
                            }
                            result.restrictions = map
                                .next_value::<std::option::Option<crate::model::RestrictionConfig>>(
                                )?;
                        }
                        __FieldTag::__resource_tags => {
                            if !fields.insert(__FieldTag::__resource_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_tags",
                                ));
                            }
                            result.resource_tags = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GcpTag {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __tag_key,
            __tag_value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GcpTag")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "tagKey" => Ok(__FieldTag::__tag_key),
                            "tag_key" => Ok(__FieldTag::__tag_key),
                            "tagValue" => Ok(__FieldTag::__tag_value),
                            "tag_value" => Ok(__FieldTag::__tag_value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GcpTag;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GcpTag")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__tag_key => {
                            if !fields.insert(__FieldTag::__tag_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tag_key",
                                ));
                            }
                            result.tag_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tag_value => {
                            if !fields.insert(__FieldTag::__tag_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tag_value",
                                ));
                            }
                            result.tag_value = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::LinkedDatasetSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source_dataset,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LinkedDatasetSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sourceDataset" => Ok(__FieldTag::__source_dataset),
                            "source_dataset" => Ok(__FieldTag::__source_dataset),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::LinkedDatasetSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LinkedDatasetSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source_dataset => {
                            if !fields.insert(__FieldTag::__source_dataset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_dataset",
                                ));
                            }
                            result.source_dataset = map
                                .next_value::<std::option::Option<crate::model::DatasetReference>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::LinkedDatasetMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __link_state,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LinkedDatasetMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "linkState" => Ok(__FieldTag::__link_state),
                            "link_state" => Ok(__FieldTag::__link_state),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::LinkedDatasetMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LinkedDatasetMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__link_state => {
                            if !fields.insert(__FieldTag::__link_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for link_state",
                                ));
                            }
                            result.link_state = map
                                .next_value::<std::option::Option<
                                    crate::model::linked_dataset_metadata::LinkState,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetDatasetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __dataset_view,
            __access_policy_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetDatasetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "datasetView" => Ok(__FieldTag::__dataset_view),
                            "dataset_view" => Ok(__FieldTag::__dataset_view),
                            "accessPolicyVersion" => Ok(__FieldTag::__access_policy_version),
                            "access_policy_version" => Ok(__FieldTag::__access_policy_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetDatasetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetDatasetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_view => {
                            if !fields.insert(__FieldTag::__dataset_view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_view",
                                ));
                            }
                            result.dataset_view =
                                map.next_value::<std::option::Option<
                                    crate::model::get_dataset_request::DatasetView,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__access_policy_version => {
                            if !fields.insert(__FieldTag::__access_policy_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for access_policy_version",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.access_policy_version =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::InsertDatasetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset,
            __access_policy_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InsertDatasetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "dataset" => Ok(__FieldTag::__dataset),
                            "accessPolicyVersion" => Ok(__FieldTag::__access_policy_version),
                            "access_policy_version" => Ok(__FieldTag::__access_policy_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::InsertDatasetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InsertDatasetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset => {
                            if !fields.insert(__FieldTag::__dataset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset",
                                ));
                            }
                            result.dataset =
                                map.next_value::<std::option::Option<crate::model::Dataset>>()?;
                        }
                        __FieldTag::__access_policy_version => {
                            if !fields.insert(__FieldTag::__access_policy_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for access_policy_version",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.access_policy_version =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UpdateOrPatchDatasetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __dataset,
            __update_mode,
            __access_policy_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateOrPatchDatasetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "dataset" => Ok(__FieldTag::__dataset),
                            "updateMode" => Ok(__FieldTag::__update_mode),
                            "update_mode" => Ok(__FieldTag::__update_mode),
                            "accessPolicyVersion" => Ok(__FieldTag::__access_policy_version),
                            "access_policy_version" => Ok(__FieldTag::__access_policy_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UpdateOrPatchDatasetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateOrPatchDatasetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset => {
                            if !fields.insert(__FieldTag::__dataset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset",
                                ));
                            }
                            result.dataset =
                                map.next_value::<std::option::Option<crate::model::Dataset>>()?;
                        }
                        __FieldTag::__update_mode => {
                            if !fields.insert(__FieldTag::__update_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mode",
                                ));
                            }
                            result.update_mode = map
                                .next_value::<std::option::Option<
                                    crate::model::update_or_patch_dataset_request::UpdateMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__access_policy_version => {
                            if !fields.insert(__FieldTag::__access_policy_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for access_policy_version",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.access_policy_version =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeleteDatasetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __delete_contents,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteDatasetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "deleteContents" => Ok(__FieldTag::__delete_contents),
                            "delete_contents" => Ok(__FieldTag::__delete_contents),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeleteDatasetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteDatasetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__delete_contents => {
                            if !fields.insert(__FieldTag::__delete_contents) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delete_contents",
                                ));
                            }
                            result.delete_contents = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListDatasetsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __max_results,
            __page_token,
            __all,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDatasetsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "maxResults" => Ok(__FieldTag::__max_results),
                            "max_results" => Ok(__FieldTag::__max_results),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "all" => Ok(__FieldTag::__all),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListDatasetsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDatasetsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__max_results => {
                            if !fields.insert(__FieldTag::__max_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_results",
                                ));
                            }
                            struct __With(std::option::Option<wkt::UInt32Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_results = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__all => {
                            if !fields.insert(__FieldTag::__all) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for all",
                                ));
                            }
                            result.all = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListFormatDataset {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __id,
            __dataset_reference,
            __labels,
            __friendly_name,
            __location,
            __external_dataset_reference,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListFormatDataset")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "id" => Ok(__FieldTag::__id),
                            "datasetReference" => Ok(__FieldTag::__dataset_reference),
                            "dataset_reference" => Ok(__FieldTag::__dataset_reference),
                            "labels" => Ok(__FieldTag::__labels),
                            "friendlyName" => Ok(__FieldTag::__friendly_name),
                            "friendly_name" => Ok(__FieldTag::__friendly_name),
                            "location" => Ok(__FieldTag::__location),
                            "externalDatasetReference" => {
                                Ok(__FieldTag::__external_dataset_reference)
                            }
                            "external_dataset_reference" => {
                                Ok(__FieldTag::__external_dataset_reference)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListFormatDataset;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListFormatDataset")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_reference => {
                            if !fields.insert(__FieldTag::__dataset_reference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_reference",
                                ));
                            }
                            result.dataset_reference = map
                                .next_value::<std::option::Option<crate::model::DatasetReference>>(
                                )?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__friendly_name => {
                            if !fields.insert(__FieldTag::__friendly_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for friendly_name",
                                ));
                            }
                            result.friendly_name =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__external_dataset_reference => {
                            if !fields.insert(__FieldTag::__external_dataset_reference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_dataset_reference",
                                ));
                            }
                            result.external_dataset_reference = map.next_value::<std::option::Option<crate::model::ExternalDatasetReference>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DatasetList {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __etag,
            __next_page_token,
            __datasets,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DatasetList")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "etag" => Ok(__FieldTag::__etag),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "datasets" => Ok(__FieldTag::__datasets),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DatasetList;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DatasetList")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__datasets => {
                            if !fields.insert(__FieldTag::__datasets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for datasets",
                                ));
                            }
                            result.datasets =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ListFormatDataset>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UndeleteDatasetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __deletion_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UndeleteDatasetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "deletionTime" => Ok(__FieldTag::__deletion_time),
                            "deletion_time" => Ok(__FieldTag::__deletion_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UndeleteDatasetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UndeleteDatasetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__deletion_time => {
                            if !fields.insert(__FieldTag::__deletion_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deletion_time",
                                ));
                            }
                            result.deletion_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DatasetReference {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dataset_id,
            __project_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DatasetReference")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DatasetReference;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DatasetReference")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::EncryptionConfiguration {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kms_key_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EncryptionConfiguration")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kmsKeyName" => Ok(__FieldTag::__kms_key_name),
                            "kms_key_name" => Ok(__FieldTag::__kms_key_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::EncryptionConfiguration;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EncryptionConfiguration")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kms_key_name => {
                            if !fields.insert(__FieldTag::__kms_key_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key_name",
                                ));
                            }
                            result.kms_key_name =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ErrorProto {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __reason,
            __location,
            __debug_info,
            __message,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ErrorProto")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "reason" => Ok(__FieldTag::__reason),
                            "location" => Ok(__FieldTag::__location),
                            "debugInfo" => Ok(__FieldTag::__debug_info),
                            "debug_info" => Ok(__FieldTag::__debug_info),
                            "message" => Ok(__FieldTag::__message),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ErrorProto;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ErrorProto")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__reason => {
                            if !fields.insert(__FieldTag::__reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reason",
                                ));
                            }
                            result.reason = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__debug_info => {
                            if !fields.insert(__FieldTag::__debug_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for debug_info",
                                ));
                            }
                            result.debug_info = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ExternalCatalogDatasetOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parameters,
            __default_storage_location_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExternalCatalogDatasetOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parameters" => Ok(__FieldTag::__parameters),
                            "defaultStorageLocationUri" => {
                                Ok(__FieldTag::__default_storage_location_uri)
                            }
                            "default_storage_location_uri" => {
                                Ok(__FieldTag::__default_storage_location_uri)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ExternalCatalogDatasetOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExternalCatalogDatasetOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parameters => {
                            if !fields.insert(__FieldTag::__parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parameters",
                                ));
                            }
                            result.parameters = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__default_storage_location_uri => {
                            if !fields.insert(__FieldTag::__default_storage_location_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_storage_location_uri",
                                ));
                            }
                            result.default_storage_location_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ExternalCatalogTableOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parameters,
            __storage_descriptor,
            __connection_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExternalCatalogTableOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parameters" => Ok(__FieldTag::__parameters),
                            "storageDescriptor" => Ok(__FieldTag::__storage_descriptor),
                            "storage_descriptor" => Ok(__FieldTag::__storage_descriptor),
                            "connectionId" => Ok(__FieldTag::__connection_id),
                            "connection_id" => Ok(__FieldTag::__connection_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ExternalCatalogTableOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExternalCatalogTableOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parameters => {
                            if !fields.insert(__FieldTag::__parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parameters",
                                ));
                            }
                            result.parameters = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__storage_descriptor => {
                            if !fields.insert(__FieldTag::__storage_descriptor) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_descriptor",
                                ));
                            }
                            result.storage_descriptor = map
                                .next_value::<std::option::Option<crate::model::StorageDescriptor>>(
                                )?;
                        }
                        __FieldTag::__connection_id => {
                            if !fields.insert(__FieldTag::__connection_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection_id",
                                ));
                            }
                            result.connection_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::StorageDescriptor {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __location_uri,
            __input_format,
            __output_format,
            __serde_info,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StorageDescriptor")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "locationUri" => Ok(__FieldTag::__location_uri),
                            "location_uri" => Ok(__FieldTag::__location_uri),
                            "inputFormat" => Ok(__FieldTag::__input_format),
                            "input_format" => Ok(__FieldTag::__input_format),
                            "outputFormat" => Ok(__FieldTag::__output_format),
                            "output_format" => Ok(__FieldTag::__output_format),
                            "serdeInfo" => Ok(__FieldTag::__serde_info),
                            "serde_info" => Ok(__FieldTag::__serde_info),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::StorageDescriptor;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StorageDescriptor")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__location_uri => {
                            if !fields.insert(__FieldTag::__location_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location_uri",
                                ));
                            }
                            result.location_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__input_format => {
                            if !fields.insert(__FieldTag::__input_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input_format",
                                ));
                            }
                            result.input_format = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__output_format => {
                            if !fields.insert(__FieldTag::__output_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_format",
                                ));
                            }
                            result.output_format = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__serde_info => {
                            if !fields.insert(__FieldTag::__serde_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for serde_info",
                                ));
                            }
                            result.serde_info =
                                map.next_value::<std::option::Option<crate::model::SerDeInfo>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SerDeInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __serialization_library,
            __parameters,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SerDeInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "serializationLibrary" => Ok(__FieldTag::__serialization_library),
                            "serialization_library" => Ok(__FieldTag::__serialization_library),
                            "parameters" => Ok(__FieldTag::__parameters),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SerDeInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SerDeInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__serialization_library => {
                            if !fields.insert(__FieldTag::__serialization_library) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for serialization_library",
                                ));
                            }
                            result.serialization_library = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parameters => {
                            if !fields.insert(__FieldTag::__parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parameters",
                                ));
                            }
                            result.parameters = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AvroOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __use_avro_logical_types,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AvroOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "useAvroLogicalTypes" => Ok(__FieldTag::__use_avro_logical_types),
                            "use_avro_logical_types" => Ok(__FieldTag::__use_avro_logical_types),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AvroOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AvroOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__use_avro_logical_types => {
                            if !fields.insert(__FieldTag::__use_avro_logical_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for use_avro_logical_types",
                                ));
                            }
                            result.use_avro_logical_types =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ParquetOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enum_as_string,
            __enable_list_inference,
            __map_target_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ParquetOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enumAsString" => Ok(__FieldTag::__enum_as_string),
                            "enum_as_string" => Ok(__FieldTag::__enum_as_string),
                            "enableListInference" => Ok(__FieldTag::__enable_list_inference),
                            "enable_list_inference" => Ok(__FieldTag::__enable_list_inference),
                            "mapTargetType" => Ok(__FieldTag::__map_target_type),
                            "map_target_type" => Ok(__FieldTag::__map_target_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ParquetOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ParquetOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enum_as_string => {
                            if !fields.insert(__FieldTag::__enum_as_string) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enum_as_string",
                                ));
                            }
                            result.enum_as_string =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__enable_list_inference => {
                            if !fields.insert(__FieldTag::__enable_list_inference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_list_inference",
                                ));
                            }
                            result.enable_list_inference =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__map_target_type => {
                            if !fields.insert(__FieldTag::__map_target_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map_target_type",
                                ));
                            }
                            result.map_target_type = map
                                .next_value::<std::option::Option<crate::model::MapTargetType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CsvOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __field_delimiter,
            __skip_leading_rows,
            __quote,
            __allow_quoted_newlines,
            __allow_jagged_rows,
            __encoding,
            __preserve_ascii_control_characters,
            __null_marker,
            __null_markers,
            __source_column_match,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CsvOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fieldDelimiter" => Ok(__FieldTag::__field_delimiter),
                            "field_delimiter" => Ok(__FieldTag::__field_delimiter),
                            "skipLeadingRows" => Ok(__FieldTag::__skip_leading_rows),
                            "skip_leading_rows" => Ok(__FieldTag::__skip_leading_rows),
                            "quote" => Ok(__FieldTag::__quote),
                            "allowQuotedNewlines" => Ok(__FieldTag::__allow_quoted_newlines),
                            "allow_quoted_newlines" => Ok(__FieldTag::__allow_quoted_newlines),
                            "allowJaggedRows" => Ok(__FieldTag::__allow_jagged_rows),
                            "allow_jagged_rows" => Ok(__FieldTag::__allow_jagged_rows),
                            "encoding" => Ok(__FieldTag::__encoding),
                            "preserveAsciiControlCharacters" => {
                                Ok(__FieldTag::__preserve_ascii_control_characters)
                            }
                            "preserve_ascii_control_characters" => {
                                Ok(__FieldTag::__preserve_ascii_control_characters)
                            }
                            "nullMarker" => Ok(__FieldTag::__null_marker),
                            "null_marker" => Ok(__FieldTag::__null_marker),
                            "nullMarkers" => Ok(__FieldTag::__null_markers),
                            "null_markers" => Ok(__FieldTag::__null_markers),
                            "sourceColumnMatch" => Ok(__FieldTag::__source_column_match),
                            "source_column_match" => Ok(__FieldTag::__source_column_match),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CsvOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CsvOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__field_delimiter => {
                            if !fields.insert(__FieldTag::__field_delimiter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field_delimiter",
                                ));
                            }
                            result.field_delimiter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__skip_leading_rows => {
                            if !fields.insert(__FieldTag::__skip_leading_rows) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for skip_leading_rows",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.skip_leading_rows = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__quote => {
                            if !fields.insert(__FieldTag::__quote) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for quote",
                                ));
                            }
                            result.quote =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::__allow_quoted_newlines => {
                            if !fields.insert(__FieldTag::__allow_quoted_newlines) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_quoted_newlines",
                                ));
                            }
                            result.allow_quoted_newlines =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__allow_jagged_rows => {
                            if !fields.insert(__FieldTag::__allow_jagged_rows) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_jagged_rows",
                                ));
                            }
                            result.allow_jagged_rows =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__encoding => {
                            if !fields.insert(__FieldTag::__encoding) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encoding",
                                ));
                            }
                            result.encoding = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__preserve_ascii_control_characters => {
                            if !fields.insert(__FieldTag::__preserve_ascii_control_characters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for preserve_ascii_control_characters",
                                ));
                            }
                            result.preserve_ascii_control_characters =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__null_marker => {
                            if !fields.insert(__FieldTag::__null_marker) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for null_marker",
                                ));
                            }
                            result.null_marker =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::__null_markers => {
                            if !fields.insert(__FieldTag::__null_markers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for null_markers",
                                ));
                            }
                            result.null_markers = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__source_column_match => {
                            if !fields.insert(__FieldTag::__source_column_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_column_match",
                                ));
                            }
                            result.source_column_match = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::JsonOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __encoding,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for JsonOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "encoding" => Ok(__FieldTag::__encoding),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::JsonOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct JsonOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__encoding => {
                            if !fields.insert(__FieldTag::__encoding) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encoding",
                                ));
                            }
                            result.encoding = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::BigtableColumn {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __qualifier_encoded,
            __qualifier_string,
            __field_name,
            __type,
            __encoding,
            __only_read_latest,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BigtableColumn")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "qualifierEncoded" => Ok(__FieldTag::__qualifier_encoded),
                            "qualifier_encoded" => Ok(__FieldTag::__qualifier_encoded),
                            "qualifierString" => Ok(__FieldTag::__qualifier_string),
                            "qualifier_string" => Ok(__FieldTag::__qualifier_string),
                            "fieldName" => Ok(__FieldTag::__field_name),
                            "field_name" => Ok(__FieldTag::__field_name),
                            "type" => Ok(__FieldTag::__type),
                            "encoding" => Ok(__FieldTag::__encoding),
                            "onlyReadLatest" => Ok(__FieldTag::__only_read_latest),
                            "only_read_latest" => Ok(__FieldTag::__only_read_latest),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::BigtableColumn;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BigtableColumn")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__qualifier_encoded => {
                            if !fields.insert(__FieldTag::__qualifier_encoded) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for qualifier_encoded",
                                ));
                            }
                            struct __With(std::option::Option<wkt::BytesValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.qualifier_encoded = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__qualifier_string => {
                            if !fields.insert(__FieldTag::__qualifier_string) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for qualifier_string",
                                ));
                            }
                            result.qualifier_string =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::__field_name => {
                            if !fields.insert(__FieldTag::__field_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field_name",
                                ));
                            }
                            result.field_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__encoding => {
                            if !fields.insert(__FieldTag::__encoding) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encoding",
                                ));
                            }
                            result.encoding = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__only_read_latest => {
                            if !fields.insert(__FieldTag::__only_read_latest) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for only_read_latest",
                                ));
                            }
                            result.only_read_latest =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::BigtableColumnFamily {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __family_id,
            __type,
            __encoding,
            __columns,
            __only_read_latest,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BigtableColumnFamily")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "familyId" => Ok(__FieldTag::__family_id),
                            "family_id" => Ok(__FieldTag::__family_id),
                            "type" => Ok(__FieldTag::__type),
                            "encoding" => Ok(__FieldTag::__encoding),
                            "columns" => Ok(__FieldTag::__columns),
                            "onlyReadLatest" => Ok(__FieldTag::__only_read_latest),
                            "only_read_latest" => Ok(__FieldTag::__only_read_latest),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::BigtableColumnFamily;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BigtableColumnFamily")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__family_id => {
                            if !fields.insert(__FieldTag::__family_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for family_id",
                                ));
                            }
                            result.family_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__encoding => {
                            if !fields.insert(__FieldTag::__encoding) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encoding",
                                ));
                            }
                            result.encoding = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__columns => {
                            if !fields.insert(__FieldTag::__columns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for columns",
                                ));
                            }
                            result.columns =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::BigtableColumn>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__only_read_latest => {
                            if !fields.insert(__FieldTag::__only_read_latest) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for only_read_latest",
                                ));
                            }
                            result.only_read_latest =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::BigtableOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __column_families,
            __ignore_unspecified_column_families,
            __read_rowkey_as_string,
            __output_column_families_as_json,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BigtableOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "columnFamilies" => Ok(__FieldTag::__column_families),
                            "column_families" => Ok(__FieldTag::__column_families),
                            "ignoreUnspecifiedColumnFamilies" => {
                                Ok(__FieldTag::__ignore_unspecified_column_families)
                            }
                            "ignore_unspecified_column_families" => {
                                Ok(__FieldTag::__ignore_unspecified_column_families)
                            }
                            "readRowkeyAsString" => Ok(__FieldTag::__read_rowkey_as_string),
                            "read_rowkey_as_string" => Ok(__FieldTag::__read_rowkey_as_string),
                            "outputColumnFamiliesAsJson" => {
                                Ok(__FieldTag::__output_column_families_as_json)
                            }
                            "output_column_families_as_json" => {
                                Ok(__FieldTag::__output_column_families_as_json)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::BigtableOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BigtableOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__column_families => {
                            if !fields.insert(__FieldTag::__column_families) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for column_families",
                                ));
                            }
                            result.column_families = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::BigtableColumnFamily>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ignore_unspecified_column_families => {
                            if !fields.insert(__FieldTag::__ignore_unspecified_column_families) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ignore_unspecified_column_families",
                                ));
                            }
                            result.ignore_unspecified_column_families =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__read_rowkey_as_string => {
                            if !fields.insert(__FieldTag::__read_rowkey_as_string) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_rowkey_as_string",
                                ));
                            }
                            result.read_rowkey_as_string =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__output_column_families_as_json => {
                            if !fields.insert(__FieldTag::__output_column_families_as_json) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_column_families_as_json",
                                ));
                            }
                            result.output_column_families_as_json =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GoogleSheetsOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __skip_leading_rows,
            __range,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GoogleSheetsOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "skipLeadingRows" => Ok(__FieldTag::__skip_leading_rows),
                            "skip_leading_rows" => Ok(__FieldTag::__skip_leading_rows),
                            "range" => Ok(__FieldTag::__range),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GoogleSheetsOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GoogleSheetsOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__skip_leading_rows => {
                            if !fields.insert(__FieldTag::__skip_leading_rows) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for skip_leading_rows",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.skip_leading_rows = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__range => {
                            if !fields.insert(__FieldTag::__range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for range",
                                ));
                            }
                            result.range = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ExternalDataConfiguration {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source_uris,
            __file_set_spec_type,
            __schema,
            __source_format,
            __max_bad_records,
            __autodetect,
            __ignore_unknown_values,
            __compression,
            __csv_options,
            __json_options,
            __bigtable_options,
            __google_sheets_options,
            __hive_partitioning_options,
            __connection_id,
            __decimal_target_types,
            __avro_options,
            __json_extension,
            __parquet_options,
            __object_metadata,
            __reference_file_schema_uri,
            __metadata_cache_mode,
            __time_zone,
            __date_format,
            __datetime_format,
            __time_format,
            __timestamp_format,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExternalDataConfiguration")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sourceUris" => Ok(__FieldTag::__source_uris),
                            "source_uris" => Ok(__FieldTag::__source_uris),
                            "fileSetSpecType" => Ok(__FieldTag::__file_set_spec_type),
                            "file_set_spec_type" => Ok(__FieldTag::__file_set_spec_type),
                            "schema" => Ok(__FieldTag::__schema),
                            "sourceFormat" => Ok(__FieldTag::__source_format),
                            "source_format" => Ok(__FieldTag::__source_format),
                            "maxBadRecords" => Ok(__FieldTag::__max_bad_records),
                            "max_bad_records" => Ok(__FieldTag::__max_bad_records),
                            "autodetect" => Ok(__FieldTag::__autodetect),
                            "ignoreUnknownValues" => Ok(__FieldTag::__ignore_unknown_values),
                            "ignore_unknown_values" => Ok(__FieldTag::__ignore_unknown_values),
                            "compression" => Ok(__FieldTag::__compression),
                            "csvOptions" => Ok(__FieldTag::__csv_options),
                            "csv_options" => Ok(__FieldTag::__csv_options),
                            "jsonOptions" => Ok(__FieldTag::__json_options),
                            "json_options" => Ok(__FieldTag::__json_options),
                            "bigtableOptions" => Ok(__FieldTag::__bigtable_options),
                            "bigtable_options" => Ok(__FieldTag::__bigtable_options),
                            "googleSheetsOptions" => Ok(__FieldTag::__google_sheets_options),
                            "google_sheets_options" => Ok(__FieldTag::__google_sheets_options),
                            "hivePartitioningOptions" => {
                                Ok(__FieldTag::__hive_partitioning_options)
                            }
                            "hive_partitioning_options" => {
                                Ok(__FieldTag::__hive_partitioning_options)
                            }
                            "connectionId" => Ok(__FieldTag::__connection_id),
                            "connection_id" => Ok(__FieldTag::__connection_id),
                            "decimalTargetTypes" => Ok(__FieldTag::__decimal_target_types),
                            "decimal_target_types" => Ok(__FieldTag::__decimal_target_types),
                            "avroOptions" => Ok(__FieldTag::__avro_options),
                            "avro_options" => Ok(__FieldTag::__avro_options),
                            "jsonExtension" => Ok(__FieldTag::__json_extension),
                            "json_extension" => Ok(__FieldTag::__json_extension),
                            "parquetOptions" => Ok(__FieldTag::__parquet_options),
                            "parquet_options" => Ok(__FieldTag::__parquet_options),
                            "objectMetadata" => Ok(__FieldTag::__object_metadata),
                            "object_metadata" => Ok(__FieldTag::__object_metadata),
                            "referenceFileSchemaUri" => Ok(__FieldTag::__reference_file_schema_uri),
                            "reference_file_schema_uri" => {
                                Ok(__FieldTag::__reference_file_schema_uri)
                            }
                            "metadataCacheMode" => Ok(__FieldTag::__metadata_cache_mode),
                            "metadata_cache_mode" => Ok(__FieldTag::__metadata_cache_mode),
                            "timeZone" => Ok(__FieldTag::__time_zone),
                            "time_zone" => Ok(__FieldTag::__time_zone),
                            "dateFormat" => Ok(__FieldTag::__date_format),
                            "date_format" => Ok(__FieldTag::__date_format),
                            "datetimeFormat" => Ok(__FieldTag::__datetime_format),
                            "datetime_format" => Ok(__FieldTag::__datetime_format),
                            "timeFormat" => Ok(__FieldTag::__time_format),
                            "time_format" => Ok(__FieldTag::__time_format),
                            "timestampFormat" => Ok(__FieldTag::__timestamp_format),
                            "timestamp_format" => Ok(__FieldTag::__timestamp_format),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ExternalDataConfiguration;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExternalDataConfiguration")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source_uris => {
                            if !fields.insert(__FieldTag::__source_uris) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_uris",
                                ));
                            }
                            result.source_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__file_set_spec_type => {
                            if !fields.insert(__FieldTag::__file_set_spec_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_set_spec_type",
                                ));
                            }
                            result.file_set_spec_type = map
                                .next_value::<std::option::Option<crate::model::FileSetSpecType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__schema => {
                            if !fields.insert(__FieldTag::__schema) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schema",
                                ));
                            }
                            result.schema =
                                map.next_value::<std::option::Option<crate::model::TableSchema>>()?;
                        }
                        __FieldTag::__source_format => {
                            if !fields.insert(__FieldTag::__source_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_format",
                                ));
                            }
                            result.source_format = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__max_bad_records => {
                            if !fields.insert(__FieldTag::__max_bad_records) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_bad_records",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int32Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_bad_records = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__autodetect => {
                            if !fields.insert(__FieldTag::__autodetect) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autodetect",
                                ));
                            }
                            result.autodetect =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__ignore_unknown_values => {
                            if !fields.insert(__FieldTag::__ignore_unknown_values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ignore_unknown_values",
                                ));
                            }
                            result.ignore_unknown_values =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__compression => {
                            if !fields.insert(__FieldTag::__compression) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compression",
                                ));
                            }
                            result.compression = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__csv_options => {
                            if !fields.insert(__FieldTag::__csv_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for csv_options",
                                ));
                            }
                            result.csv_options =
                                map.next_value::<std::option::Option<crate::model::CsvOptions>>()?;
                        }
                        __FieldTag::__json_options => {
                            if !fields.insert(__FieldTag::__json_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for json_options",
                                ));
                            }
                            result.json_options =
                                map.next_value::<std::option::Option<crate::model::JsonOptions>>()?;
                        }
                        __FieldTag::__bigtable_options => {
                            if !fields.insert(__FieldTag::__bigtable_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bigtable_options",
                                ));
                            }
                            result.bigtable_options = map
                                .next_value::<std::option::Option<crate::model::BigtableOptions>>(
                                )?;
                        }
                        __FieldTag::__google_sheets_options => {
                            if !fields.insert(__FieldTag::__google_sheets_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for google_sheets_options",
                                ));
                            }
                            result.google_sheets_options = map.next_value::<std::option::Option<crate::model::GoogleSheetsOptions>>()?
                                ;
                        }
                        __FieldTag::__hive_partitioning_options => {
                            if !fields.insert(__FieldTag::__hive_partitioning_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hive_partitioning_options",
                                ));
                            }
                            result.hive_partitioning_options = map.next_value::<std::option::Option<crate::model::HivePartitioningOptions>>()?
                                ;
                        }
                        __FieldTag::__connection_id => {
                            if !fields.insert(__FieldTag::__connection_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection_id",
                                ));
                            }
                            result.connection_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__decimal_target_types => {
                            if !fields.insert(__FieldTag::__decimal_target_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for decimal_target_types",
                                ));
                            }
                            result.decimal_target_types =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::DecimalTargetType>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__avro_options => {
                            if !fields.insert(__FieldTag::__avro_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for avro_options",
                                ));
                            }
                            result.avro_options =
                                map.next_value::<std::option::Option<crate::model::AvroOptions>>()?;
                        }
                        __FieldTag::__json_extension => {
                            if !fields.insert(__FieldTag::__json_extension) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for json_extension",
                                ));
                            }
                            result.json_extension = map
                                .next_value::<std::option::Option<crate::model::JsonExtension>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parquet_options => {
                            if !fields.insert(__FieldTag::__parquet_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parquet_options",
                                ));
                            }
                            result.parquet_options = map
                                .next_value::<std::option::Option<crate::model::ParquetOptions>>(
                                )?;
                        }
                        __FieldTag::__object_metadata => {
                            if !fields.insert(__FieldTag::__object_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for object_metadata",
                                ));
                            }
                            result.object_metadata = map.next_value::<std::option::Option<
                                crate::model::external_data_configuration::ObjectMetadata,
                            >>()?;
                        }
                        __FieldTag::__reference_file_schema_uri => {
                            if !fields.insert(__FieldTag::__reference_file_schema_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reference_file_schema_uri",
                                ));
                            }
                            result.reference_file_schema_uri =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::__metadata_cache_mode => {
                            if !fields.insert(__FieldTag::__metadata_cache_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata_cache_mode",
                                ));
                            }
                            result.metadata_cache_mode = map
                                .next_value::<std::option::Option<
                                    crate::model::external_data_configuration::MetadataCacheMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__time_zone => {
                            if !fields.insert(__FieldTag::__time_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_zone",
                                ));
                            }
                            result.time_zone =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__date_format => {
                            if !fields.insert(__FieldTag::__date_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for date_format",
                                ));
                            }
                            result.date_format =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__datetime_format => {
                            if !fields.insert(__FieldTag::__datetime_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for datetime_format",
                                ));
                            }
                            result.datetime_format =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__time_format => {
                            if !fields.insert(__FieldTag::__time_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_format",
                                ));
                            }
                            result.time_format =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__timestamp_format => {
                            if !fields.insert(__FieldTag::__timestamp_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timestamp_format",
                                ));
                            }
                            result.timestamp_format =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ExternalDatasetReference {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __external_source,
            __connection,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExternalDatasetReference")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "externalSource" => Ok(__FieldTag::__external_source),
                            "external_source" => Ok(__FieldTag::__external_source),
                            "connection" => Ok(__FieldTag::__connection),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ExternalDatasetReference;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExternalDatasetReference")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__external_source => {
                            if !fields.insert(__FieldTag::__external_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_source",
                                ));
                            }
                            result.external_source = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__connection => {
                            if !fields.insert(__FieldTag::__connection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection",
                                ));
                            }
                            result.connection = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::HivePartitioningOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __mode,
            __source_uri_prefix,
            __require_partition_filter,
            __fields,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HivePartitioningOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "mode" => Ok(__FieldTag::__mode),
                            "sourceUriPrefix" => Ok(__FieldTag::__source_uri_prefix),
                            "source_uri_prefix" => Ok(__FieldTag::__source_uri_prefix),
                            "requirePartitionFilter" => Ok(__FieldTag::__require_partition_filter),
                            "require_partition_filter" => {
                                Ok(__FieldTag::__require_partition_filter)
                            }
                            "fields" => Ok(__FieldTag::__fields),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::HivePartitioningOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HivePartitioningOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__mode => {
                            if !fields.insert(__FieldTag::__mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mode",
                                ));
                            }
                            result.mode = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_uri_prefix => {
                            if !fields.insert(__FieldTag::__source_uri_prefix) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_uri_prefix",
                                ));
                            }
                            result.source_uri_prefix = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__require_partition_filter => {
                            if !fields.insert(__FieldTag::__require_partition_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for require_partition_filter",
                                ));
                            }
                            result.require_partition_filter =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__fields => {
                            if !fields.insert(__FieldTag::__fields) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fields",
                                ));
                            }
                            result.fields = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Job {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __etag,
            __id,
            __self_link,
            __user_email,
            __configuration,
            __job_reference,
            __statistics,
            __status,
            __principal_subject,
            __job_creation_reason,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Job")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "etag" => Ok(__FieldTag::__etag),
                            "id" => Ok(__FieldTag::__id),
                            "selfLink" => Ok(__FieldTag::__self_link),
                            "self_link" => Ok(__FieldTag::__self_link),
                            "user_email" => Ok(__FieldTag::__user_email),
                            "configuration" => Ok(__FieldTag::__configuration),
                            "jobReference" => Ok(__FieldTag::__job_reference),
                            "job_reference" => Ok(__FieldTag::__job_reference),
                            "statistics" => Ok(__FieldTag::__statistics),
                            "status" => Ok(__FieldTag::__status),
                            "principal_subject" => Ok(__FieldTag::__principal_subject),
                            "jobCreationReason" => Ok(__FieldTag::__job_creation_reason),
                            "job_creation_reason" => Ok(__FieldTag::__job_creation_reason),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Job;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Job")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__self_link => {
                            if !fields.insert(__FieldTag::__self_link) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for self_link",
                                ));
                            }
                            result.self_link = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__user_email => {
                            if !fields.insert(__FieldTag::__user_email) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_email",
                                ));
                            }
                            result.user_email = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__configuration => {
                            if !fields.insert(__FieldTag::__configuration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for configuration",
                                ));
                            }
                            result.configuration = map
                                .next_value::<std::option::Option<crate::model::JobConfiguration>>(
                                )?;
                        }
                        __FieldTag::__job_reference => {
                            if !fields.insert(__FieldTag::__job_reference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_reference",
                                ));
                            }
                            result.job_reference = map
                                .next_value::<std::option::Option<crate::model::JobReference>>()?;
                        }
                        __FieldTag::__statistics => {
                            if !fields.insert(__FieldTag::__statistics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for statistics",
                                ));
                            }
                            result.statistics = map
                                .next_value::<std::option::Option<crate::model::JobStatistics>>()?;
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status =
                                map.next_value::<std::option::Option<crate::model::JobStatus>>()?;
                        }
                        __FieldTag::__principal_subject => {
                            if !fields.insert(__FieldTag::__principal_subject) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for principal_subject",
                                ));
                            }
                            result.principal_subject = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__job_creation_reason => {
                            if !fields.insert(__FieldTag::__job_creation_reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_creation_reason",
                                ));
                            }
                            result.job_creation_reason = map
                                .next_value::<std::option::Option<crate::model::JobCreationReason>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CancelJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __job_id,
            __location,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CancelJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "jobId" => Ok(__FieldTag::__job_id),
                            "job_id" => Ok(__FieldTag::__job_id),
                            "location" => Ok(__FieldTag::__location),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CancelJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CancelJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__job_id => {
                            if !fields.insert(__FieldTag::__job_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_id",
                                ));
                            }
                            result.job_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::JobCancelResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __job,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for JobCancelResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "job" => Ok(__FieldTag::__job),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::JobCancelResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct JobCancelResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__job => {
                            if !fields.insert(__FieldTag::__job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job",
                                ));
                            }
                            result.job =
                                map.next_value::<std::option::Option<crate::model::Job>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __job_id,
            __location,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "jobId" => Ok(__FieldTag::__job_id),
                            "job_id" => Ok(__FieldTag::__job_id),
                            "location" => Ok(__FieldTag::__location),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__job_id => {
                            if !fields.insert(__FieldTag::__job_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_id",
                                ));
                            }
                            result.job_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::InsertJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __job,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InsertJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "job" => Ok(__FieldTag::__job),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::InsertJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InsertJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__job => {
                            if !fields.insert(__FieldTag::__job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job",
                                ));
                            }
                            result.job =
                                map.next_value::<std::option::Option<crate::model::Job>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeleteJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __job_id,
            __location,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "jobId" => Ok(__FieldTag::__job_id),
                            "job_id" => Ok(__FieldTag::__job_id),
                            "location" => Ok(__FieldTag::__location),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeleteJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__job_id => {
                            if !fields.insert(__FieldTag::__job_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_id",
                                ));
                            }
                            result.job_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListJobsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __all_users,
            __max_results,
            __min_creation_time,
            __max_creation_time,
            __page_token,
            __projection,
            __state_filter,
            __parent_job_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListJobsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "allUsers" => Ok(__FieldTag::__all_users),
                            "all_users" => Ok(__FieldTag::__all_users),
                            "maxResults" => Ok(__FieldTag::__max_results),
                            "max_results" => Ok(__FieldTag::__max_results),
                            "minCreationTime" => Ok(__FieldTag::__min_creation_time),
                            "min_creation_time" => Ok(__FieldTag::__min_creation_time),
                            "maxCreationTime" => Ok(__FieldTag::__max_creation_time),
                            "max_creation_time" => Ok(__FieldTag::__max_creation_time),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "projection" => Ok(__FieldTag::__projection),
                            "stateFilter" => Ok(__FieldTag::__state_filter),
                            "state_filter" => Ok(__FieldTag::__state_filter),
                            "parentJobId" => Ok(__FieldTag::__parent_job_id),
                            "parent_job_id" => Ok(__FieldTag::__parent_job_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListJobsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListJobsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__all_users => {
                            if !fields.insert(__FieldTag::__all_users) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for all_users",
                                ));
                            }
                            result.all_users = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__max_results => {
                            if !fields.insert(__FieldTag::__max_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_results",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int32Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_results = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__min_creation_time => {
                            if !fields.insert(__FieldTag::__min_creation_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_creation_time",
                                ));
                            }
                            struct __With(std::option::Option<u64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.min_creation_time =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_creation_time => {
                            if !fields.insert(__FieldTag::__max_creation_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_creation_time",
                                ));
                            }
                            struct __With(std::option::Option<wkt::UInt64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_creation_time = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__projection => {
                            if !fields.insert(__FieldTag::__projection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for projection",
                                ));
                            }
                            result.projection =
                                map.next_value::<std::option::Option<
                                    crate::model::list_jobs_request::Projection,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state_filter => {
                            if !fields.insert(__FieldTag::__state_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_filter",
                                ));
                            }
                            result.state_filter = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::list_jobs_request::StateFilter>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parent_job_id => {
                            if !fields.insert(__FieldTag::__parent_job_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent_job_id",
                                ));
                            }
                            result.parent_job_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListFormatJob {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            __kind,
            __job_reference,
            __state,
            __error_result,
            __statistics,
            __configuration,
            __status,
            __user_email,
            __principal_subject,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListFormatJob")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            "kind" => Ok(__FieldTag::__kind),
                            "jobReference" => Ok(__FieldTag::__job_reference),
                            "job_reference" => Ok(__FieldTag::__job_reference),
                            "state" => Ok(__FieldTag::__state),
                            "errorResult" => Ok(__FieldTag::__error_result),
                            "error_result" => Ok(__FieldTag::__error_result),
                            "statistics" => Ok(__FieldTag::__statistics),
                            "configuration" => Ok(__FieldTag::__configuration),
                            "status" => Ok(__FieldTag::__status),
                            "user_email" => Ok(__FieldTag::__user_email),
                            "principal_subject" => Ok(__FieldTag::__principal_subject),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListFormatJob;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListFormatJob")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__job_reference => {
                            if !fields.insert(__FieldTag::__job_reference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_reference",
                                ));
                            }
                            result.job_reference = map
                                .next_value::<std::option::Option<crate::model::JobReference>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__error_result => {
                            if !fields.insert(__FieldTag::__error_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_result",
                                ));
                            }
                            result.error_result =
                                map.next_value::<std::option::Option<crate::model::ErrorProto>>()?;
                        }
                        __FieldTag::__statistics => {
                            if !fields.insert(__FieldTag::__statistics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for statistics",
                                ));
                            }
                            result.statistics = map
                                .next_value::<std::option::Option<crate::model::JobStatistics>>()?;
                        }
                        __FieldTag::__configuration => {
                            if !fields.insert(__FieldTag::__configuration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for configuration",
                                ));
                            }
                            result.configuration = map
                                .next_value::<std::option::Option<crate::model::JobConfiguration>>(
                                )?;
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status =
                                map.next_value::<std::option::Option<crate::model::JobStatus>>()?;
                        }
                        __FieldTag::__user_email => {
                            if !fields.insert(__FieldTag::__user_email) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_email",
                                ));
                            }
                            result.user_email = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__principal_subject => {
                            if !fields.insert(__FieldTag::__principal_subject) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for principal_subject",
                                ));
                            }
                            result.principal_subject = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::JobList {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __etag,
            __kind,
            __next_page_token,
            __jobs,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for JobList")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "etag" => Ok(__FieldTag::__etag),
                            "kind" => Ok(__FieldTag::__kind),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "jobs" => Ok(__FieldTag::__jobs),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::JobList;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct JobList")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__jobs => {
                            if !fields.insert(__FieldTag::__jobs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for jobs",
                                ));
                            }
                            result.jobs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ListFormatJob>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetQueryResultsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __job_id,
            __start_index,
            __page_token,
            __max_results,
            __timeout_ms,
            __location,
            __format_options,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetQueryResultsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "jobId" => Ok(__FieldTag::__job_id),
                            "job_id" => Ok(__FieldTag::__job_id),
                            "startIndex" => Ok(__FieldTag::__start_index),
                            "start_index" => Ok(__FieldTag::__start_index),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "maxResults" => Ok(__FieldTag::__max_results),
                            "max_results" => Ok(__FieldTag::__max_results),
                            "timeoutMs" => Ok(__FieldTag::__timeout_ms),
                            "timeout_ms" => Ok(__FieldTag::__timeout_ms),
                            "location" => Ok(__FieldTag::__location),
                            "formatOptions" => Ok(__FieldTag::__format_options),
                            "format_options" => Ok(__FieldTag::__format_options),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetQueryResultsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetQueryResultsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__job_id => {
                            if !fields.insert(__FieldTag::__job_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_id",
                                ));
                            }
                            result.job_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__start_index => {
                            if !fields.insert(__FieldTag::__start_index) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_index",
                                ));
                            }
                            struct __With(std::option::Option<wkt::UInt64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.start_index = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__max_results => {
                            if !fields.insert(__FieldTag::__max_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_results",
                                ));
                            }
                            struct __With(std::option::Option<wkt::UInt32Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_results = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__timeout_ms => {
                            if !fields.insert(__FieldTag::__timeout_ms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timeout_ms",
                                ));
                            }
                            struct __With(std::option::Option<wkt::UInt32Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.timeout_ms = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__format_options => {
                            if !fields.insert(__FieldTag::__format_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for format_options",
                                ));
                            }
                            result.format_options = map
                                .next_value::<std::option::Option<crate::model::DataFormatOptions>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetQueryResultsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __etag,
            __schema,
            __job_reference,
            __total_rows,
            __page_token,
            __rows,
            __total_bytes_processed,
            __job_complete,
            __errors,
            __cache_hit,
            __num_dml_affected_rows,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetQueryResultsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "etag" => Ok(__FieldTag::__etag),
                            "schema" => Ok(__FieldTag::__schema),
                            "jobReference" => Ok(__FieldTag::__job_reference),
                            "job_reference" => Ok(__FieldTag::__job_reference),
                            "totalRows" => Ok(__FieldTag::__total_rows),
                            "total_rows" => Ok(__FieldTag::__total_rows),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "rows" => Ok(__FieldTag::__rows),
                            "totalBytesProcessed" => Ok(__FieldTag::__total_bytes_processed),
                            "total_bytes_processed" => Ok(__FieldTag::__total_bytes_processed),
                            "jobComplete" => Ok(__FieldTag::__job_complete),
                            "job_complete" => Ok(__FieldTag::__job_complete),
                            "errors" => Ok(__FieldTag::__errors),
                            "cacheHit" => Ok(__FieldTag::__cache_hit),
                            "cache_hit" => Ok(__FieldTag::__cache_hit),
                            "numDmlAffectedRows" => Ok(__FieldTag::__num_dml_affected_rows),
                            "num_dml_affected_rows" => Ok(__FieldTag::__num_dml_affected_rows),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetQueryResultsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetQueryResultsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__schema => {
                            if !fields.insert(__FieldTag::__schema) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schema",
                                ));
                            }
                            result.schema =
                                map.next_value::<std::option::Option<crate::model::TableSchema>>()?;
                        }
                        __FieldTag::__job_reference => {
                            if !fields.insert(__FieldTag::__job_reference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_reference",
                                ));
                            }
                            result.job_reference = map
                                .next_value::<std::option::Option<crate::model::JobReference>>()?;
                        }
                        __FieldTag::__total_rows => {
                            if !fields.insert(__FieldTag::__total_rows) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_rows",
                                ));
                            }
                            struct __With(std::option::Option<wkt::UInt64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_rows = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rows => {
                            if !fields.insert(__FieldTag::__rows) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rows",
                                ));
                            }
                            result.rows = map
                                .next_value::<std::option::Option<std::vec::Vec<wkt::Struct>>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__total_bytes_processed => {
                            if !fields.insert(__FieldTag::__total_bytes_processed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_bytes_processed",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_bytes_processed = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__job_complete => {
                            if !fields.insert(__FieldTag::__job_complete) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_complete",
                                ));
                            }
                            result.job_complete =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__errors => {
                            if !fields.insert(__FieldTag::__errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for errors",
                                ));
                            }
                            result.errors = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ErrorProto>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__cache_hit => {
                            if !fields.insert(__FieldTag::__cache_hit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cache_hit",
                                ));
                            }
                            result.cache_hit =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__num_dml_affected_rows => {
                            if !fields.insert(__FieldTag::__num_dml_affected_rows) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for num_dml_affected_rows",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.num_dml_affected_rows = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::PostQueryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __query_request,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PostQueryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "queryRequest" => Ok(__FieldTag::__query_request),
                            "query_request" => Ok(__FieldTag::__query_request),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::PostQueryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PostQueryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__query_request => {
                            if !fields.insert(__FieldTag::__query_request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_request",
                                ));
                            }
                            result.query_request = map
                                .next_value::<std::option::Option<crate::model::QueryRequest>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::QueryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __query,
            __max_results,
            __default_dataset,
            __timeout_ms,
            __job_timeout_ms,
            __max_slots,
            __destination_encryption_configuration,
            __dry_run,
            __use_query_cache,
            __use_legacy_sql,
            __parameter_mode,
            __query_parameters,
            __location,
            __format_options,
            __connection_properties,
            __labels,
            __maximum_bytes_billed,
            __request_id,
            __create_session,
            __job_creation_mode,
            __reservation,
            __write_incremental_results,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QueryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "query" => Ok(__FieldTag::__query),
                            "maxResults" => Ok(__FieldTag::__max_results),
                            "max_results" => Ok(__FieldTag::__max_results),
                            "defaultDataset" => Ok(__FieldTag::__default_dataset),
                            "default_dataset" => Ok(__FieldTag::__default_dataset),
                            "timeoutMs" => Ok(__FieldTag::__timeout_ms),
                            "timeout_ms" => Ok(__FieldTag::__timeout_ms),
                            "jobTimeoutMs" => Ok(__FieldTag::__job_timeout_ms),
                            "job_timeout_ms" => Ok(__FieldTag::__job_timeout_ms),
                            "maxSlots" => Ok(__FieldTag::__max_slots),
                            "max_slots" => Ok(__FieldTag::__max_slots),
                            "destinationEncryptionConfiguration" => {
                                Ok(__FieldTag::__destination_encryption_configuration)
                            }
                            "destination_encryption_configuration" => {
                                Ok(__FieldTag::__destination_encryption_configuration)
                            }
                            "dryRun" => Ok(__FieldTag::__dry_run),
                            "dry_run" => Ok(__FieldTag::__dry_run),
                            "useQueryCache" => Ok(__FieldTag::__use_query_cache),
                            "use_query_cache" => Ok(__FieldTag::__use_query_cache),
                            "useLegacySql" => Ok(__FieldTag::__use_legacy_sql),
                            "use_legacy_sql" => Ok(__FieldTag::__use_legacy_sql),
                            "parameterMode" => Ok(__FieldTag::__parameter_mode),
                            "parameter_mode" => Ok(__FieldTag::__parameter_mode),
                            "queryParameters" => Ok(__FieldTag::__query_parameters),
                            "query_parameters" => Ok(__FieldTag::__query_parameters),
                            "location" => Ok(__FieldTag::__location),
                            "formatOptions" => Ok(__FieldTag::__format_options),
                            "format_options" => Ok(__FieldTag::__format_options),
                            "connectionProperties" => Ok(__FieldTag::__connection_properties),
                            "connection_properties" => Ok(__FieldTag::__connection_properties),
                            "labels" => Ok(__FieldTag::__labels),
                            "maximumBytesBilled" => Ok(__FieldTag::__maximum_bytes_billed),
                            "maximum_bytes_billed" => Ok(__FieldTag::__maximum_bytes_billed),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "createSession" => Ok(__FieldTag::__create_session),
                            "create_session" => Ok(__FieldTag::__create_session),
                            "jobCreationMode" => Ok(__FieldTag::__job_creation_mode),
                            "job_creation_mode" => Ok(__FieldTag::__job_creation_mode),
                            "reservation" => Ok(__FieldTag::__reservation),
                            "writeIncrementalResults" => {
                                Ok(__FieldTag::__write_incremental_results)
                            }
                            "write_incremental_results" => {
                                Ok(__FieldTag::__write_incremental_results)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::QueryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QueryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__query => {
                            if !fields.insert(__FieldTag::__query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query",
                                ));
                            }
                            result.query = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__max_results => {
                            if !fields.insert(__FieldTag::__max_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_results",
                                ));
                            }
                            struct __With(std::option::Option<wkt::UInt32Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_results = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__default_dataset => {
                            if !fields.insert(__FieldTag::__default_dataset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_dataset",
                                ));
                            }
                            result.default_dataset = map
                                .next_value::<std::option::Option<crate::model::DatasetReference>>(
                                )?;
                        }
                        __FieldTag::__timeout_ms => {
                            if !fields.insert(__FieldTag::__timeout_ms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timeout_ms",
                                ));
                            }
                            struct __With(std::option::Option<wkt::UInt32Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.timeout_ms = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__job_timeout_ms => {
                            if !fields.insert(__FieldTag::__job_timeout_ms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_timeout_ms",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.job_timeout_ms = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__max_slots => {
                            if !fields.insert(__FieldTag::__max_slots) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_slots",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_slots = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__destination_encryption_configuration => {
                            if !fields.insert(__FieldTag::__destination_encryption_configuration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_encryption_configuration",
                                ));
                            }
                            result.destination_encryption_configuration = map.next_value::<std::option::Option<crate::model::EncryptionConfiguration>>()?
                                ;
                        }
                        __FieldTag::__dry_run => {
                            if !fields.insert(__FieldTag::__dry_run) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dry_run",
                                ));
                            }
                            result.dry_run = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__use_query_cache => {
                            if !fields.insert(__FieldTag::__use_query_cache) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for use_query_cache",
                                ));
                            }
                            result.use_query_cache =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__use_legacy_sql => {
                            if !fields.insert(__FieldTag::__use_legacy_sql) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for use_legacy_sql",
                                ));
                            }
                            result.use_legacy_sql =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__parameter_mode => {
                            if !fields.insert(__FieldTag::__parameter_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parameter_mode",
                                ));
                            }
                            result.parameter_mode = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__query_parameters => {
                            if !fields.insert(__FieldTag::__query_parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_parameters",
                                ));
                            }
                            result.query_parameters =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::QueryParameter>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__format_options => {
                            if !fields.insert(__FieldTag::__format_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for format_options",
                                ));
                            }
                            result.format_options = map
                                .next_value::<std::option::Option<crate::model::DataFormatOptions>>(
                                )?;
                        }
                        __FieldTag::__connection_properties => {
                            if !fields.insert(__FieldTag::__connection_properties) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection_properties",
                                ));
                            }
                            result.connection_properties = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ConnectionProperty>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__maximum_bytes_billed => {
                            if !fields.insert(__FieldTag::__maximum_bytes_billed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for maximum_bytes_billed",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.maximum_bytes_billed = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_session => {
                            if !fields.insert(__FieldTag::__create_session) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_session",
                                ));
                            }
                            result.create_session =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__job_creation_mode => {
                            if !fields.insert(__FieldTag::__job_creation_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_creation_mode",
                                ));
                            }
                            result.job_creation_mode =
                                map.next_value::<std::option::Option<
                                    crate::model::query_request::JobCreationMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reservation => {
                            if !fields.insert(__FieldTag::__reservation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reservation",
                                ));
                            }
                            result.reservation =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__write_incremental_results => {
                            if !fields.insert(__FieldTag::__write_incremental_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for write_incremental_results",
                                ));
                            }
                            result.write_incremental_results = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::QueryResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __schema,
            __job_reference,
            __job_creation_reason,
            __query_id,
            __location,
            __total_rows,
            __page_token,
            __rows,
            __total_bytes_processed,
            __total_bytes_billed,
            __total_slot_ms,
            __job_complete,
            __errors,
            __cache_hit,
            __num_dml_affected_rows,
            __session_info,
            __dml_stats,
            __creation_time,
            __start_time,
            __end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QueryResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "schema" => Ok(__FieldTag::__schema),
                            "jobReference" => Ok(__FieldTag::__job_reference),
                            "job_reference" => Ok(__FieldTag::__job_reference),
                            "jobCreationReason" => Ok(__FieldTag::__job_creation_reason),
                            "job_creation_reason" => Ok(__FieldTag::__job_creation_reason),
                            "queryId" => Ok(__FieldTag::__query_id),
                            "query_id" => Ok(__FieldTag::__query_id),
                            "location" => Ok(__FieldTag::__location),
                            "totalRows" => Ok(__FieldTag::__total_rows),
                            "total_rows" => Ok(__FieldTag::__total_rows),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "rows" => Ok(__FieldTag::__rows),
                            "totalBytesProcessed" => Ok(__FieldTag::__total_bytes_processed),
                            "total_bytes_processed" => Ok(__FieldTag::__total_bytes_processed),
                            "totalBytesBilled" => Ok(__FieldTag::__total_bytes_billed),
                            "total_bytes_billed" => Ok(__FieldTag::__total_bytes_billed),
                            "totalSlotMs" => Ok(__FieldTag::__total_slot_ms),
                            "total_slot_ms" => Ok(__FieldTag::__total_slot_ms),
                            "jobComplete" => Ok(__FieldTag::__job_complete),
                            "job_complete" => Ok(__FieldTag::__job_complete),
                            "errors" => Ok(__FieldTag::__errors),
                            "cacheHit" => Ok(__FieldTag::__cache_hit),
                            "cache_hit" => Ok(__FieldTag::__cache_hit),
                            "numDmlAffectedRows" => Ok(__FieldTag::__num_dml_affected_rows),
                            "num_dml_affected_rows" => Ok(__FieldTag::__num_dml_affected_rows),
                            "sessionInfo" => Ok(__FieldTag::__session_info),
                            "session_info" => Ok(__FieldTag::__session_info),
                            "dmlStats" => Ok(__FieldTag::__dml_stats),
                            "dml_stats" => Ok(__FieldTag::__dml_stats),
                            "creationTime" => Ok(__FieldTag::__creation_time),
                            "creation_time" => Ok(__FieldTag::__creation_time),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::QueryResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QueryResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__schema => {
                            if !fields.insert(__FieldTag::__schema) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schema",
                                ));
                            }
                            result.schema =
                                map.next_value::<std::option::Option<crate::model::TableSchema>>()?;
                        }
                        __FieldTag::__job_reference => {
                            if !fields.insert(__FieldTag::__job_reference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_reference",
                                ));
                            }
                            result.job_reference = map
                                .next_value::<std::option::Option<crate::model::JobReference>>()?;
                        }
                        __FieldTag::__job_creation_reason => {
                            if !fields.insert(__FieldTag::__job_creation_reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_creation_reason",
                                ));
                            }
                            result.job_creation_reason = map
                                .next_value::<std::option::Option<crate::model::JobCreationReason>>(
                                )?;
                        }
                        __FieldTag::__query_id => {
                            if !fields.insert(__FieldTag::__query_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_id",
                                ));
                            }
                            result.query_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__total_rows => {
                            if !fields.insert(__FieldTag::__total_rows) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_rows",
                                ));
                            }
                            struct __With(std::option::Option<wkt::UInt64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_rows = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rows => {
                            if !fields.insert(__FieldTag::__rows) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rows",
                                ));
                            }
                            result.rows = map
                                .next_value::<std::option::Option<std::vec::Vec<wkt::Struct>>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__total_bytes_processed => {
                            if !fields.insert(__FieldTag::__total_bytes_processed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_bytes_processed",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_bytes_processed = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__total_bytes_billed => {
                            if !fields.insert(__FieldTag::__total_bytes_billed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_bytes_billed",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_bytes_billed = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__total_slot_ms => {
                            if !fields.insert(__FieldTag::__total_slot_ms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_slot_ms",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_slot_ms = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__job_complete => {
                            if !fields.insert(__FieldTag::__job_complete) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_complete",
                                ));
                            }
                            result.job_complete =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__errors => {
                            if !fields.insert(__FieldTag::__errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for errors",
                                ));
                            }
                            result.errors = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ErrorProto>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__cache_hit => {
                            if !fields.insert(__FieldTag::__cache_hit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cache_hit",
                                ));
                            }
                            result.cache_hit =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__num_dml_affected_rows => {
                            if !fields.insert(__FieldTag::__num_dml_affected_rows) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for num_dml_affected_rows",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.num_dml_affected_rows = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__session_info => {
                            if !fields.insert(__FieldTag::__session_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for session_info",
                                ));
                            }
                            result.session_info =
                                map.next_value::<std::option::Option<crate::model::SessionInfo>>()?;
                        }
                        __FieldTag::__dml_stats => {
                            if !fields.insert(__FieldTag::__dml_stats) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dml_stats",
                                ));
                            }
                            result.dml_stats =
                                map.next_value::<std::option::Option<crate::model::DmlStats>>()?;
                        }
                        __FieldTag::__creation_time => {
                            if !fields.insert(__FieldTag::__creation_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for creation_time",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.creation_time = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.start_time = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.end_time = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DestinationTableProperties {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __friendly_name,
            __description,
            __labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DestinationTableProperties")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "friendlyName" => Ok(__FieldTag::__friendly_name),
                            "friendly_name" => Ok(__FieldTag::__friendly_name),
                            "description" => Ok(__FieldTag::__description),
                            "labels" => Ok(__FieldTag::__labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DestinationTableProperties;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DestinationTableProperties")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__friendly_name => {
                            if !fields.insert(__FieldTag::__friendly_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for friendly_name",
                                ));
                            }
                            result.friendly_name =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ConnectionProperty {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __key,
            __value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConnectionProperty")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "key" => Ok(__FieldTag::__key),
                            "value" => Ok(__FieldTag::__value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ConnectionProperty;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConnectionProperty")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__key => {
                            if !fields.insert(__FieldTag::__key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key",
                                ));
                            }
                            result.key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            result.value = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::JobConfigurationQuery {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __query,
            __destination_table,
            __external_table_definitions,
            __user_defined_function_resources,
            __create_disposition,
            __write_disposition,
            __default_dataset,
            __priority,
            __allow_large_results,
            __use_query_cache,
            __flatten_results,
            __maximum_bytes_billed,
            __use_legacy_sql,
            __parameter_mode,
            __query_parameters,
            __system_variables,
            __schema_update_options,
            __time_partitioning,
            __range_partitioning,
            __clustering,
            __destination_encryption_configuration,
            __script_options,
            __connection_properties,
            __create_session,
            __continuous,
            __write_incremental_results,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for JobConfigurationQuery")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "query" => Ok(__FieldTag::__query),
                            "destinationTable" => Ok(__FieldTag::__destination_table),
                            "destination_table" => Ok(__FieldTag::__destination_table),
                            "tableDefinitions" => Ok(__FieldTag::__external_table_definitions),
                            "external_table_definitions" => {
                                Ok(__FieldTag::__external_table_definitions)
                            }
                            "userDefinedFunctionResources" => {
                                Ok(__FieldTag::__user_defined_function_resources)
                            }
                            "user_defined_function_resources" => {
                                Ok(__FieldTag::__user_defined_function_resources)
                            }
                            "createDisposition" => Ok(__FieldTag::__create_disposition),
                            "create_disposition" => Ok(__FieldTag::__create_disposition),
                            "writeDisposition" => Ok(__FieldTag::__write_disposition),
                            "write_disposition" => Ok(__FieldTag::__write_disposition),
                            "defaultDataset" => Ok(__FieldTag::__default_dataset),
                            "default_dataset" => Ok(__FieldTag::__default_dataset),
                            "priority" => Ok(__FieldTag::__priority),
                            "allowLargeResults" => Ok(__FieldTag::__allow_large_results),
                            "allow_large_results" => Ok(__FieldTag::__allow_large_results),
                            "useQueryCache" => Ok(__FieldTag::__use_query_cache),
                            "use_query_cache" => Ok(__FieldTag::__use_query_cache),
                            "flattenResults" => Ok(__FieldTag::__flatten_results),
                            "flatten_results" => Ok(__FieldTag::__flatten_results),
                            "maximumBytesBilled" => Ok(__FieldTag::__maximum_bytes_billed),
                            "maximum_bytes_billed" => Ok(__FieldTag::__maximum_bytes_billed),
                            "useLegacySql" => Ok(__FieldTag::__use_legacy_sql),
                            "use_legacy_sql" => Ok(__FieldTag::__use_legacy_sql),
                            "parameterMode" => Ok(__FieldTag::__parameter_mode),
                            "parameter_mode" => Ok(__FieldTag::__parameter_mode),
                            "queryParameters" => Ok(__FieldTag::__query_parameters),
                            "query_parameters" => Ok(__FieldTag::__query_parameters),
                            "systemVariables" => Ok(__FieldTag::__system_variables),
                            "system_variables" => Ok(__FieldTag::__system_variables),
                            "schemaUpdateOptions" => Ok(__FieldTag::__schema_update_options),
                            "schema_update_options" => Ok(__FieldTag::__schema_update_options),
                            "timePartitioning" => Ok(__FieldTag::__time_partitioning),
                            "time_partitioning" => Ok(__FieldTag::__time_partitioning),
                            "rangePartitioning" => Ok(__FieldTag::__range_partitioning),
                            "range_partitioning" => Ok(__FieldTag::__range_partitioning),
                            "clustering" => Ok(__FieldTag::__clustering),
                            "destinationEncryptionConfiguration" => {
                                Ok(__FieldTag::__destination_encryption_configuration)
                            }
                            "destination_encryption_configuration" => {
                                Ok(__FieldTag::__destination_encryption_configuration)
                            }
                            "scriptOptions" => Ok(__FieldTag::__script_options),
                            "script_options" => Ok(__FieldTag::__script_options),
                            "connectionProperties" => Ok(__FieldTag::__connection_properties),
                            "connection_properties" => Ok(__FieldTag::__connection_properties),
                            "createSession" => Ok(__FieldTag::__create_session),
                            "create_session" => Ok(__FieldTag::__create_session),
                            "continuous" => Ok(__FieldTag::__continuous),
                            "writeIncrementalResults" => {
                                Ok(__FieldTag::__write_incremental_results)
                            }
                            "write_incremental_results" => {
                                Ok(__FieldTag::__write_incremental_results)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::JobConfigurationQuery;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct JobConfigurationQuery")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__query => {
                            if !fields.insert(__FieldTag::__query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query",
                                ));
                            }
                            result.query = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__destination_table => {
                            if !fields.insert(__FieldTag::__destination_table) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_table",
                                ));
                            }
                            result.destination_table = map
                                .next_value::<std::option::Option<crate::model::TableReference>>(
                                )?;
                        }
                        __FieldTag::__external_table_definitions => {
                            if !fields.insert(__FieldTag::__external_table_definitions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_table_definitions",
                                ));
                            }
                            result.external_table_definitions = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::ExternalDataConfiguration,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__user_defined_function_resources => {
                            if !fields.insert(__FieldTag::__user_defined_function_resources) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_defined_function_resources",
                                ));
                            }
                            result.user_defined_function_resources = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::UserDefinedFunctionResource>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_disposition => {
                            if !fields.insert(__FieldTag::__create_disposition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_disposition",
                                ));
                            }
                            result.create_disposition = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__write_disposition => {
                            if !fields.insert(__FieldTag::__write_disposition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for write_disposition",
                                ));
                            }
                            result.write_disposition = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__default_dataset => {
                            if !fields.insert(__FieldTag::__default_dataset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_dataset",
                                ));
                            }
                            result.default_dataset = map
                                .next_value::<std::option::Option<crate::model::DatasetReference>>(
                                )?;
                        }
                        __FieldTag::__priority => {
                            if !fields.insert(__FieldTag::__priority) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for priority",
                                ));
                            }
                            result.priority = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_large_results => {
                            if !fields.insert(__FieldTag::__allow_large_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_large_results",
                                ));
                            }
                            result.allow_large_results =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__use_query_cache => {
                            if !fields.insert(__FieldTag::__use_query_cache) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for use_query_cache",
                                ));
                            }
                            result.use_query_cache =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__flatten_results => {
                            if !fields.insert(__FieldTag::__flatten_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for flatten_results",
                                ));
                            }
                            result.flatten_results =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__maximum_bytes_billed => {
                            if !fields.insert(__FieldTag::__maximum_bytes_billed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for maximum_bytes_billed",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.maximum_bytes_billed = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__use_legacy_sql => {
                            if !fields.insert(__FieldTag::__use_legacy_sql) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for use_legacy_sql",
                                ));
                            }
                            result.use_legacy_sql =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__parameter_mode => {
                            if !fields.insert(__FieldTag::__parameter_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parameter_mode",
                                ));
                            }
                            result.parameter_mode = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__query_parameters => {
                            if !fields.insert(__FieldTag::__query_parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_parameters",
                                ));
                            }
                            result.query_parameters =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::QueryParameter>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__system_variables => {
                            if !fields.insert(__FieldTag::__system_variables) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for system_variables",
                                ));
                            }
                            result.system_variables = map
                                .next_value::<std::option::Option<crate::model::SystemVariables>>(
                                )?;
                        }
                        __FieldTag::__schema_update_options => {
                            if !fields.insert(__FieldTag::__schema_update_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schema_update_options",
                                ));
                            }
                            result.schema_update_options = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__time_partitioning => {
                            if !fields.insert(__FieldTag::__time_partitioning) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_partitioning",
                                ));
                            }
                            result.time_partitioning = map
                                .next_value::<std::option::Option<crate::model::TimePartitioning>>(
                                )?;
                        }
                        __FieldTag::__range_partitioning => {
                            if !fields.insert(__FieldTag::__range_partitioning) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for range_partitioning",
                                ));
                            }
                            result.range_partitioning = map
                                .next_value::<std::option::Option<crate::model::RangePartitioning>>(
                                )?;
                        }
                        __FieldTag::__clustering => {
                            if !fields.insert(__FieldTag::__clustering) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for clustering",
                                ));
                            }
                            result.clustering =
                                map.next_value::<std::option::Option<crate::model::Clustering>>()?;
                        }
                        __FieldTag::__destination_encryption_configuration => {
                            if !fields.insert(__FieldTag::__destination_encryption_configuration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_encryption_configuration",
                                ));
                            }
                            result.destination_encryption_configuration = map.next_value::<std::option::Option<crate::model::EncryptionConfiguration>>()?
                                ;
                        }
                        __FieldTag::__script_options => {
                            if !fields.insert(__FieldTag::__script_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for script_options",
                                ));
                            }
                            result.script_options = map
                                .next_value::<std::option::Option<crate::model::ScriptOptions>>()?;
                        }
                        __FieldTag::__connection_properties => {
                            if !fields.insert(__FieldTag::__connection_properties) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection_properties",
                                ));
                            }
                            result.connection_properties = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ConnectionProperty>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_session => {
                            if !fields.insert(__FieldTag::__create_session) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_session",
                                ));
                            }
                            result.create_session =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__continuous => {
                            if !fields.insert(__FieldTag::__continuous) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for continuous",
                                ));
                            }
                            result.continuous =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__write_incremental_results => {
                            if !fields.insert(__FieldTag::__write_incremental_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for write_incremental_results",
                                ));
                            }
                            result.write_incremental_results = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ScriptOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __statement_timeout_ms,
            __statement_byte_budget,
            __key_result_statement,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ScriptOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "statementTimeoutMs" => Ok(__FieldTag::__statement_timeout_ms),
                            "statement_timeout_ms" => Ok(__FieldTag::__statement_timeout_ms),
                            "statementByteBudget" => Ok(__FieldTag::__statement_byte_budget),
                            "statement_byte_budget" => Ok(__FieldTag::__statement_byte_budget),
                            "keyResultStatement" => Ok(__FieldTag::__key_result_statement),
                            "key_result_statement" => Ok(__FieldTag::__key_result_statement),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ScriptOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ScriptOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__statement_timeout_ms => {
                            if !fields.insert(__FieldTag::__statement_timeout_ms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for statement_timeout_ms",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.statement_timeout_ms = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__statement_byte_budget => {
                            if !fields.insert(__FieldTag::__statement_byte_budget) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for statement_byte_budget",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.statement_byte_budget = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__key_result_statement => {
                            if !fields.insert(__FieldTag::__key_result_statement) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key_result_statement",
                                ));
                            }
                            result.key_result_statement = map
                                .next_value::<std::option::Option<
                                    crate::model::script_options::KeyResultStatementKind,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::JobConfigurationLoad {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source_uris,
            __file_set_spec_type,
            __schema,
            __destination_table,
            __destination_table_properties,
            __create_disposition,
            __write_disposition,
            __null_marker,
            __field_delimiter,
            __skip_leading_rows,
            __encoding,
            __quote,
            __max_bad_records,
            __allow_quoted_newlines,
            __source_format,
            __allow_jagged_rows,
            __ignore_unknown_values,
            __projection_fields,
            __autodetect,
            __schema_update_options,
            __time_partitioning,
            __range_partitioning,
            __clustering,
            __destination_encryption_configuration,
            __use_avro_logical_types,
            __reference_file_schema_uri,
            __hive_partitioning_options,
            __decimal_target_types,
            __json_extension,
            __parquet_options,
            __preserve_ascii_control_characters,
            __connection_properties,
            __create_session,
            __column_name_character_map,
            __copy_files_only,
            __time_zone,
            __null_markers,
            __date_format,
            __datetime_format,
            __time_format,
            __timestamp_format,
            __source_column_match,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for JobConfigurationLoad")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sourceUris" => Ok(__FieldTag::__source_uris),
                            "source_uris" => Ok(__FieldTag::__source_uris),
                            "fileSetSpecType" => Ok(__FieldTag::__file_set_spec_type),
                            "file_set_spec_type" => Ok(__FieldTag::__file_set_spec_type),
                            "schema" => Ok(__FieldTag::__schema),
                            "destinationTable" => Ok(__FieldTag::__destination_table),
                            "destination_table" => Ok(__FieldTag::__destination_table),
                            "destinationTableProperties" => {
                                Ok(__FieldTag::__destination_table_properties)
                            }
                            "destination_table_properties" => {
                                Ok(__FieldTag::__destination_table_properties)
                            }
                            "createDisposition" => Ok(__FieldTag::__create_disposition),
                            "create_disposition" => Ok(__FieldTag::__create_disposition),
                            "writeDisposition" => Ok(__FieldTag::__write_disposition),
                            "write_disposition" => Ok(__FieldTag::__write_disposition),
                            "nullMarker" => Ok(__FieldTag::__null_marker),
                            "null_marker" => Ok(__FieldTag::__null_marker),
                            "fieldDelimiter" => Ok(__FieldTag::__field_delimiter),
                            "field_delimiter" => Ok(__FieldTag::__field_delimiter),
                            "skipLeadingRows" => Ok(__FieldTag::__skip_leading_rows),
                            "skip_leading_rows" => Ok(__FieldTag::__skip_leading_rows),
                            "encoding" => Ok(__FieldTag::__encoding),
                            "quote" => Ok(__FieldTag::__quote),
                            "maxBadRecords" => Ok(__FieldTag::__max_bad_records),
                            "max_bad_records" => Ok(__FieldTag::__max_bad_records),
                            "allowQuotedNewlines" => Ok(__FieldTag::__allow_quoted_newlines),
                            "allow_quoted_newlines" => Ok(__FieldTag::__allow_quoted_newlines),
                            "sourceFormat" => Ok(__FieldTag::__source_format),
                            "source_format" => Ok(__FieldTag::__source_format),
                            "allowJaggedRows" => Ok(__FieldTag::__allow_jagged_rows),
                            "allow_jagged_rows" => Ok(__FieldTag::__allow_jagged_rows),
                            "ignoreUnknownValues" => Ok(__FieldTag::__ignore_unknown_values),
                            "ignore_unknown_values" => Ok(__FieldTag::__ignore_unknown_values),
                            "projectionFields" => Ok(__FieldTag::__projection_fields),
                            "projection_fields" => Ok(__FieldTag::__projection_fields),
                            "autodetect" => Ok(__FieldTag::__autodetect),
                            "schemaUpdateOptions" => Ok(__FieldTag::__schema_update_options),
                            "schema_update_options" => Ok(__FieldTag::__schema_update_options),
                            "timePartitioning" => Ok(__FieldTag::__time_partitioning),
                            "time_partitioning" => Ok(__FieldTag::__time_partitioning),
                            "rangePartitioning" => Ok(__FieldTag::__range_partitioning),
                            "range_partitioning" => Ok(__FieldTag::__range_partitioning),
                            "clustering" => Ok(__FieldTag::__clustering),
                            "destinationEncryptionConfiguration" => {
                                Ok(__FieldTag::__destination_encryption_configuration)
                            }
                            "destination_encryption_configuration" => {
                                Ok(__FieldTag::__destination_encryption_configuration)
                            }
                            "useAvroLogicalTypes" => Ok(__FieldTag::__use_avro_logical_types),
                            "use_avro_logical_types" => Ok(__FieldTag::__use_avro_logical_types),
                            "referenceFileSchemaUri" => Ok(__FieldTag::__reference_file_schema_uri),
                            "reference_file_schema_uri" => {
                                Ok(__FieldTag::__reference_file_schema_uri)
                            }
                            "hivePartitioningOptions" => {
                                Ok(__FieldTag::__hive_partitioning_options)
                            }
                            "hive_partitioning_options" => {
                                Ok(__FieldTag::__hive_partitioning_options)
                            }
                            "decimalTargetTypes" => Ok(__FieldTag::__decimal_target_types),
                            "decimal_target_types" => Ok(__FieldTag::__decimal_target_types),
                            "jsonExtension" => Ok(__FieldTag::__json_extension),
                            "json_extension" => Ok(__FieldTag::__json_extension),
                            "parquetOptions" => Ok(__FieldTag::__parquet_options),
                            "parquet_options" => Ok(__FieldTag::__parquet_options),
                            "preserveAsciiControlCharacters" => {
                                Ok(__FieldTag::__preserve_ascii_control_characters)
                            }
                            "preserve_ascii_control_characters" => {
                                Ok(__FieldTag::__preserve_ascii_control_characters)
                            }
                            "connectionProperties" => Ok(__FieldTag::__connection_properties),
                            "connection_properties" => Ok(__FieldTag::__connection_properties),
                            "createSession" => Ok(__FieldTag::__create_session),
                            "create_session" => Ok(__FieldTag::__create_session),
                            "columnNameCharacterMap" => Ok(__FieldTag::__column_name_character_map),
                            "column_name_character_map" => {
                                Ok(__FieldTag::__column_name_character_map)
                            }
                            "copyFilesOnly" => Ok(__FieldTag::__copy_files_only),
                            "copy_files_only" => Ok(__FieldTag::__copy_files_only),
                            "timeZone" => Ok(__FieldTag::__time_zone),
                            "time_zone" => Ok(__FieldTag::__time_zone),
                            "nullMarkers" => Ok(__FieldTag::__null_markers),
                            "null_markers" => Ok(__FieldTag::__null_markers),
                            "dateFormat" => Ok(__FieldTag::__date_format),
                            "date_format" => Ok(__FieldTag::__date_format),
                            "datetimeFormat" => Ok(__FieldTag::__datetime_format),
                            "datetime_format" => Ok(__FieldTag::__datetime_format),
                            "timeFormat" => Ok(__FieldTag::__time_format),
                            "time_format" => Ok(__FieldTag::__time_format),
                            "timestampFormat" => Ok(__FieldTag::__timestamp_format),
                            "timestamp_format" => Ok(__FieldTag::__timestamp_format),
                            "sourceColumnMatch" => Ok(__FieldTag::__source_column_match),
                            "source_column_match" => Ok(__FieldTag::__source_column_match),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::JobConfigurationLoad;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct JobConfigurationLoad")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source_uris => {
                            if !fields.insert(__FieldTag::__source_uris) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_uris",
                                ));
                            }
                            result.source_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__file_set_spec_type => {
                            if !fields.insert(__FieldTag::__file_set_spec_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_set_spec_type",
                                ));
                            }
                            result.file_set_spec_type = map
                                .next_value::<std::option::Option<crate::model::FileSetSpecType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__schema => {
                            if !fields.insert(__FieldTag::__schema) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schema",
                                ));
                            }
                            result.schema =
                                map.next_value::<std::option::Option<crate::model::TableSchema>>()?;
                        }
                        __FieldTag::__destination_table => {
                            if !fields.insert(__FieldTag::__destination_table) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_table",
                                ));
                            }
                            result.destination_table = map
                                .next_value::<std::option::Option<crate::model::TableReference>>(
                                )?;
                        }
                        __FieldTag::__destination_table_properties => {
                            if !fields.insert(__FieldTag::__destination_table_properties) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_table_properties",
                                ));
                            }
                            result.destination_table_properties = map.next_value::<std::option::Option<crate::model::DestinationTableProperties>>()?
                                ;
                        }
                        __FieldTag::__create_disposition => {
                            if !fields.insert(__FieldTag::__create_disposition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_disposition",
                                ));
                            }
                            result.create_disposition = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__write_disposition => {
                            if !fields.insert(__FieldTag::__write_disposition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for write_disposition",
                                ));
                            }
                            result.write_disposition = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__null_marker => {
                            if !fields.insert(__FieldTag::__null_marker) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for null_marker",
                                ));
                            }
                            result.null_marker =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::__field_delimiter => {
                            if !fields.insert(__FieldTag::__field_delimiter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field_delimiter",
                                ));
                            }
                            result.field_delimiter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__skip_leading_rows => {
                            if !fields.insert(__FieldTag::__skip_leading_rows) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for skip_leading_rows",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int32Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.skip_leading_rows = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__encoding => {
                            if !fields.insert(__FieldTag::__encoding) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encoding",
                                ));
                            }
                            result.encoding = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__quote => {
                            if !fields.insert(__FieldTag::__quote) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for quote",
                                ));
                            }
                            result.quote =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::__max_bad_records => {
                            if !fields.insert(__FieldTag::__max_bad_records) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_bad_records",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int32Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_bad_records = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__allow_quoted_newlines => {
                            if !fields.insert(__FieldTag::__allow_quoted_newlines) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_quoted_newlines",
                                ));
                            }
                            result.allow_quoted_newlines =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__source_format => {
                            if !fields.insert(__FieldTag::__source_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_format",
                                ));
                            }
                            result.source_format = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_jagged_rows => {
                            if !fields.insert(__FieldTag::__allow_jagged_rows) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_jagged_rows",
                                ));
                            }
                            result.allow_jagged_rows =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__ignore_unknown_values => {
                            if !fields.insert(__FieldTag::__ignore_unknown_values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ignore_unknown_values",
                                ));
                            }
                            result.ignore_unknown_values =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__projection_fields => {
                            if !fields.insert(__FieldTag::__projection_fields) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for projection_fields",
                                ));
                            }
                            result.projection_fields = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__autodetect => {
                            if !fields.insert(__FieldTag::__autodetect) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autodetect",
                                ));
                            }
                            result.autodetect =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__schema_update_options => {
                            if !fields.insert(__FieldTag::__schema_update_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schema_update_options",
                                ));
                            }
                            result.schema_update_options = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__time_partitioning => {
                            if !fields.insert(__FieldTag::__time_partitioning) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_partitioning",
                                ));
                            }
                            result.time_partitioning = map
                                .next_value::<std::option::Option<crate::model::TimePartitioning>>(
                                )?;
                        }
                        __FieldTag::__range_partitioning => {
                            if !fields.insert(__FieldTag::__range_partitioning) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for range_partitioning",
                                ));
                            }
                            result.range_partitioning = map
                                .next_value::<std::option::Option<crate::model::RangePartitioning>>(
                                )?;
                        }
                        __FieldTag::__clustering => {
                            if !fields.insert(__FieldTag::__clustering) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for clustering",
                                ));
                            }
                            result.clustering =
                                map.next_value::<std::option::Option<crate::model::Clustering>>()?;
                        }
                        __FieldTag::__destination_encryption_configuration => {
                            if !fields.insert(__FieldTag::__destination_encryption_configuration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_encryption_configuration",
                                ));
                            }
                            result.destination_encryption_configuration = map.next_value::<std::option::Option<crate::model::EncryptionConfiguration>>()?
                                ;
                        }
                        __FieldTag::__use_avro_logical_types => {
                            if !fields.insert(__FieldTag::__use_avro_logical_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for use_avro_logical_types",
                                ));
                            }
                            result.use_avro_logical_types =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__reference_file_schema_uri => {
                            if !fields.insert(__FieldTag::__reference_file_schema_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reference_file_schema_uri",
                                ));
                            }
                            result.reference_file_schema_uri =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::__hive_partitioning_options => {
                            if !fields.insert(__FieldTag::__hive_partitioning_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hive_partitioning_options",
                                ));
                            }
                            result.hive_partitioning_options = map.next_value::<std::option::Option<crate::model::HivePartitioningOptions>>()?
                                ;
                        }
                        __FieldTag::__decimal_target_types => {
                            if !fields.insert(__FieldTag::__decimal_target_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for decimal_target_types",
                                ));
                            }
                            result.decimal_target_types =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::DecimalTargetType>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__json_extension => {
                            if !fields.insert(__FieldTag::__json_extension) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for json_extension",
                                ));
                            }
                            result.json_extension = map
                                .next_value::<std::option::Option<crate::model::JsonExtension>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parquet_options => {
                            if !fields.insert(__FieldTag::__parquet_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parquet_options",
                                ));
                            }
                            result.parquet_options = map
                                .next_value::<std::option::Option<crate::model::ParquetOptions>>(
                                )?;
                        }
                        __FieldTag::__preserve_ascii_control_characters => {
                            if !fields.insert(__FieldTag::__preserve_ascii_control_characters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for preserve_ascii_control_characters",
                                ));
                            }
                            result.preserve_ascii_control_characters =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__connection_properties => {
                            if !fields.insert(__FieldTag::__connection_properties) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection_properties",
                                ));
                            }
                            result.connection_properties = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ConnectionProperty>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_session => {
                            if !fields.insert(__FieldTag::__create_session) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_session",
                                ));
                            }
                            result.create_session =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__column_name_character_map => {
                            if !fields.insert(__FieldTag::__column_name_character_map) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for column_name_character_map",
                                ));
                            }
                            result.column_name_character_map = map
                                .next_value::<std::option::Option<
                                    crate::model::job_configuration_load::ColumnNameCharacterMap,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__copy_files_only => {
                            if !fields.insert(__FieldTag::__copy_files_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for copy_files_only",
                                ));
                            }
                            result.copy_files_only =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__time_zone => {
                            if !fields.insert(__FieldTag::__time_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_zone",
                                ));
                            }
                            result.time_zone =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::__null_markers => {
                            if !fields.insert(__FieldTag::__null_markers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for null_markers",
                                ));
                            }
                            result.null_markers = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__date_format => {
                            if !fields.insert(__FieldTag::__date_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for date_format",
                                ));
                            }
                            result.date_format =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__datetime_format => {
                            if !fields.insert(__FieldTag::__datetime_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for datetime_format",
                                ));
                            }
                            result.datetime_format =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__time_format => {
                            if !fields.insert(__FieldTag::__time_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_format",
                                ));
                            }
                            result.time_format =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__timestamp_format => {
                            if !fields.insert(__FieldTag::__timestamp_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timestamp_format",
                                ));
                            }
                            result.timestamp_format =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__source_column_match => {
                            if !fields.insert(__FieldTag::__source_column_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_column_match",
                                ));
                            }
                            result.source_column_match = map
                                .next_value::<std::option::Option<
                                    crate::model::job_configuration_load::SourceColumnMatch,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::JobConfigurationTableCopy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source_table,
            __source_tables,
            __destination_table,
            __create_disposition,
            __write_disposition,
            __destination_encryption_configuration,
            __operation_type,
            __destination_expiration_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for JobConfigurationTableCopy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sourceTable" => Ok(__FieldTag::__source_table),
                            "source_table" => Ok(__FieldTag::__source_table),
                            "sourceTables" => Ok(__FieldTag::__source_tables),
                            "source_tables" => Ok(__FieldTag::__source_tables),
                            "destinationTable" => Ok(__FieldTag::__destination_table),
                            "destination_table" => Ok(__FieldTag::__destination_table),
                            "createDisposition" => Ok(__FieldTag::__create_disposition),
                            "create_disposition" => Ok(__FieldTag::__create_disposition),
                            "writeDisposition" => Ok(__FieldTag::__write_disposition),
                            "write_disposition" => Ok(__FieldTag::__write_disposition),
                            "destinationEncryptionConfiguration" => {
                                Ok(__FieldTag::__destination_encryption_configuration)
                            }
                            "destination_encryption_configuration" => {
                                Ok(__FieldTag::__destination_encryption_configuration)
                            }
                            "operationType" => Ok(__FieldTag::__operation_type),
                            "operation_type" => Ok(__FieldTag::__operation_type),
                            "destinationExpirationTime" => {
                                Ok(__FieldTag::__destination_expiration_time)
                            }
                            "destination_expiration_time" => {
                                Ok(__FieldTag::__destination_expiration_time)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::JobConfigurationTableCopy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct JobConfigurationTableCopy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source_table => {
                            if !fields.insert(__FieldTag::__source_table) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_table",
                                ));
                            }
                            result.source_table = map
                                .next_value::<std::option::Option<crate::model::TableReference>>(
                                )?;
                        }
                        __FieldTag::__source_tables => {
                            if !fields.insert(__FieldTag::__source_tables) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_tables",
                                ));
                            }
                            result.source_tables =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::TableReference>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__destination_table => {
                            if !fields.insert(__FieldTag::__destination_table) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_table",
                                ));
                            }
                            result.destination_table = map
                                .next_value::<std::option::Option<crate::model::TableReference>>(
                                )?;
                        }
                        __FieldTag::__create_disposition => {
                            if !fields.insert(__FieldTag::__create_disposition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_disposition",
                                ));
                            }
                            result.create_disposition = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__write_disposition => {
                            if !fields.insert(__FieldTag::__write_disposition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for write_disposition",
                                ));
                            }
                            result.write_disposition = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__destination_encryption_configuration => {
                            if !fields.insert(__FieldTag::__destination_encryption_configuration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_encryption_configuration",
                                ));
                            }
                            result.destination_encryption_configuration = map.next_value::<std::option::Option<crate::model::EncryptionConfiguration>>()?
                                ;
                        }
                        __FieldTag::__operation_type => {
                            if !fields.insert(__FieldTag::__operation_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operation_type",
                                ));
                            }
                            result.operation_type = map
                                .next_value::<std::option::Option<
                                    crate::model::job_configuration_table_copy::OperationType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__destination_expiration_time => {
                            if !fields.insert(__FieldTag::__destination_expiration_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_expiration_time",
                                ));
                            }
                            result.destination_expiration_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::JobConfigurationExtract {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source_table,
            __source_model,
            __destination_uris,
            __print_header,
            __field_delimiter,
            __destination_format,
            __compression,
            __use_avro_logical_types,
            __model_extract_options,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for JobConfigurationExtract")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sourceTable" => Ok(__FieldTag::__source_table),
                            "source_table" => Ok(__FieldTag::__source_table),
                            "sourceModel" => Ok(__FieldTag::__source_model),
                            "source_model" => Ok(__FieldTag::__source_model),
                            "destinationUris" => Ok(__FieldTag::__destination_uris),
                            "destination_uris" => Ok(__FieldTag::__destination_uris),
                            "printHeader" => Ok(__FieldTag::__print_header),
                            "print_header" => Ok(__FieldTag::__print_header),
                            "fieldDelimiter" => Ok(__FieldTag::__field_delimiter),
                            "field_delimiter" => Ok(__FieldTag::__field_delimiter),
                            "destinationFormat" => Ok(__FieldTag::__destination_format),
                            "destination_format" => Ok(__FieldTag::__destination_format),
                            "compression" => Ok(__FieldTag::__compression),
                            "useAvroLogicalTypes" => Ok(__FieldTag::__use_avro_logical_types),
                            "use_avro_logical_types" => Ok(__FieldTag::__use_avro_logical_types),
                            "modelExtractOptions" => Ok(__FieldTag::__model_extract_options),
                            "model_extract_options" => Ok(__FieldTag::__model_extract_options),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::JobConfigurationExtract;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct JobConfigurationExtract")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source_table => {
                            if !fields.insert(__FieldTag::__source_table) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_table",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.bigquery.v2.JobConfigurationExtract.source_table, latest field was sourceTable",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::job_configuration_extract::Source::SourceTable(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::TableReference>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__source_model => {
                            if !fields.insert(__FieldTag::__source_model) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_model",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.bigquery.v2.JobConfigurationExtract.source_model, latest field was sourceModel",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::job_configuration_extract::Source::SourceModel(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ModelReference>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__destination_uris => {
                            if !fields.insert(__FieldTag::__destination_uris) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_uris",
                                ));
                            }
                            result.destination_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__print_header => {
                            if !fields.insert(__FieldTag::__print_header) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for print_header",
                                ));
                            }
                            result.print_header =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__field_delimiter => {
                            if !fields.insert(__FieldTag::__field_delimiter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field_delimiter",
                                ));
                            }
                            result.field_delimiter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__destination_format => {
                            if !fields.insert(__FieldTag::__destination_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_format",
                                ));
                            }
                            result.destination_format = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__compression => {
                            if !fields.insert(__FieldTag::__compression) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compression",
                                ));
                            }
                            result.compression = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__use_avro_logical_types => {
                            if !fields.insert(__FieldTag::__use_avro_logical_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for use_avro_logical_types",
                                ));
                            }
                            result.use_avro_logical_types =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__model_extract_options => {
                            if !fields.insert(__FieldTag::__model_extract_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model_extract_options",
                                ));
                            }
                            result.model_extract_options = map.next_value::<std::option::Option<
                                crate::model::job_configuration_extract::ModelExtractOptions,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::job_configuration_extract::ModelExtractOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __trial_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ModelExtractOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "trialId" => Ok(__FieldTag::__trial_id),
                            "trial_id" => Ok(__FieldTag::__trial_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::job_configuration_extract::ModelExtractOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ModelExtractOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__trial_id => {
                            if !fields.insert(__FieldTag::__trial_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trial_id",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.trial_id = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::JobConfiguration {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __job_type,
            __query,
            __load,
            __copy,
            __extract,
            __dry_run,
            __job_timeout_ms,
            __max_slots,
            __labels,
            __reservation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for JobConfiguration")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "jobType" => Ok(__FieldTag::__job_type),
                            "job_type" => Ok(__FieldTag::__job_type),
                            "query" => Ok(__FieldTag::__query),
                            "load" => Ok(__FieldTag::__load),
                            "copy" => Ok(__FieldTag::__copy),
                            "extract" => Ok(__FieldTag::__extract),
                            "dryRun" => Ok(__FieldTag::__dry_run),
                            "dry_run" => Ok(__FieldTag::__dry_run),
                            "jobTimeoutMs" => Ok(__FieldTag::__job_timeout_ms),
                            "job_timeout_ms" => Ok(__FieldTag::__job_timeout_ms),
                            "maxSlots" => Ok(__FieldTag::__max_slots),
                            "max_slots" => Ok(__FieldTag::__max_slots),
                            "labels" => Ok(__FieldTag::__labels),
                            "reservation" => Ok(__FieldTag::__reservation),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::JobConfiguration;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct JobConfiguration")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__job_type => {
                            if !fields.insert(__FieldTag::__job_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_type",
                                ));
                            }
                            result.job_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__query => {
                            if !fields.insert(__FieldTag::__query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query",
                                ));
                            }
                            result.query = map.next_value::<std::option::Option<crate::model::JobConfigurationQuery>>()?
                                ;
                        }
                        __FieldTag::__load => {
                            if !fields.insert(__FieldTag::__load) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for load",
                                ));
                            }
                            result.load = map.next_value::<std::option::Option<crate::model::JobConfigurationLoad>>()?
                                ;
                        }
                        __FieldTag::__copy => {
                            if !fields.insert(__FieldTag::__copy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for copy",
                                ));
                            }
                            result.copy = map.next_value::<std::option::Option<crate::model::JobConfigurationTableCopy>>()?
                                ;
                        }
                        __FieldTag::__extract => {
                            if !fields.insert(__FieldTag::__extract) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for extract",
                                ));
                            }
                            result.extract = map.next_value::<std::option::Option<crate::model::JobConfigurationExtract>>()?
                                ;
                        }
                        __FieldTag::__dry_run => {
                            if !fields.insert(__FieldTag::__dry_run) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dry_run",
                                ));
                            }
                            result.dry_run =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__job_timeout_ms => {
                            if !fields.insert(__FieldTag::__job_timeout_ms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_timeout_ms",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.job_timeout_ms = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__max_slots => {
                            if !fields.insert(__FieldTag::__max_slots) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_slots",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_slots = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reservation => {
                            if !fields.insert(__FieldTag::__reservation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reservation",
                                ));
                            }
                            result.reservation =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::JobCreationReason {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for JobCreationReason")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "code" => Ok(__FieldTag::__code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::JobCreationReason;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct JobCreationReason")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__code => {
                            if !fields.insert(__FieldTag::__code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for code",
                                ));
                            }
                            result.code = map.next_value::<std::option::Option<crate::model::job_creation_reason::Code>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::JobReference {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __job_id,
            __location,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for JobReference")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "jobId" => Ok(__FieldTag::__job_id),
                            "job_id" => Ok(__FieldTag::__job_id),
                            "location" => Ok(__FieldTag::__location),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::JobReference;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct JobReference")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__job_id => {
                            if !fields.insert(__FieldTag::__job_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_id",
                                ));
                            }
                            result.job_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ExplainQueryStep {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __substeps,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExplainQueryStep")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "substeps" => Ok(__FieldTag::__substeps),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ExplainQueryStep;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExplainQueryStep")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__substeps => {
                            if !fields.insert(__FieldTag::__substeps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for substeps",
                                ));
                            }
                            result.substeps = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ExplainQueryStage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __id,
            __start_ms,
            __end_ms,
            __input_stages,
            __wait_ratio_avg,
            __wait_ms_avg,
            __wait_ratio_max,
            __wait_ms_max,
            __read_ratio_avg,
            __read_ms_avg,
            __read_ratio_max,
            __read_ms_max,
            __compute_ratio_avg,
            __compute_ms_avg,
            __compute_ratio_max,
            __compute_ms_max,
            __write_ratio_avg,
            __write_ms_avg,
            __write_ratio_max,
            __write_ms_max,
            __shuffle_output_bytes,
            __shuffle_output_bytes_spilled,
            __records_read,
            __records_written,
            __parallel_inputs,
            __completed_parallel_inputs,
            __status,
            __steps,
            __slot_ms,
            __compute_mode,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExplainQueryStage")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "id" => Ok(__FieldTag::__id),
                            "startMs" => Ok(__FieldTag::__start_ms),
                            "start_ms" => Ok(__FieldTag::__start_ms),
                            "endMs" => Ok(__FieldTag::__end_ms),
                            "end_ms" => Ok(__FieldTag::__end_ms),
                            "inputStages" => Ok(__FieldTag::__input_stages),
                            "input_stages" => Ok(__FieldTag::__input_stages),
                            "waitRatioAvg" => Ok(__FieldTag::__wait_ratio_avg),
                            "wait_ratio_avg" => Ok(__FieldTag::__wait_ratio_avg),
                            "waitMsAvg" => Ok(__FieldTag::__wait_ms_avg),
                            "wait_ms_avg" => Ok(__FieldTag::__wait_ms_avg),
                            "waitRatioMax" => Ok(__FieldTag::__wait_ratio_max),
                            "wait_ratio_max" => Ok(__FieldTag::__wait_ratio_max),
                            "waitMsMax" => Ok(__FieldTag::__wait_ms_max),
                            "wait_ms_max" => Ok(__FieldTag::__wait_ms_max),
                            "readRatioAvg" => Ok(__FieldTag::__read_ratio_avg),
                            "read_ratio_avg" => Ok(__FieldTag::__read_ratio_avg),
                            "readMsAvg" => Ok(__FieldTag::__read_ms_avg),
                            "read_ms_avg" => Ok(__FieldTag::__read_ms_avg),
                            "readRatioMax" => Ok(__FieldTag::__read_ratio_max),
                            "read_ratio_max" => Ok(__FieldTag::__read_ratio_max),
                            "readMsMax" => Ok(__FieldTag::__read_ms_max),
                            "read_ms_max" => Ok(__FieldTag::__read_ms_max),
                            "computeRatioAvg" => Ok(__FieldTag::__compute_ratio_avg),
                            "compute_ratio_avg" => Ok(__FieldTag::__compute_ratio_avg),
                            "computeMsAvg" => Ok(__FieldTag::__compute_ms_avg),
                            "compute_ms_avg" => Ok(__FieldTag::__compute_ms_avg),
                            "computeRatioMax" => Ok(__FieldTag::__compute_ratio_max),
                            "compute_ratio_max" => Ok(__FieldTag::__compute_ratio_max),
                            "computeMsMax" => Ok(__FieldTag::__compute_ms_max),
                            "compute_ms_max" => Ok(__FieldTag::__compute_ms_max),
                            "writeRatioAvg" => Ok(__FieldTag::__write_ratio_avg),
                            "write_ratio_avg" => Ok(__FieldTag::__write_ratio_avg),
                            "writeMsAvg" => Ok(__FieldTag::__write_ms_avg),
                            "write_ms_avg" => Ok(__FieldTag::__write_ms_avg),
                            "writeRatioMax" => Ok(__FieldTag::__write_ratio_max),
                            "write_ratio_max" => Ok(__FieldTag::__write_ratio_max),
                            "writeMsMax" => Ok(__FieldTag::__write_ms_max),
                            "write_ms_max" => Ok(__FieldTag::__write_ms_max),
                            "shuffleOutputBytes" => Ok(__FieldTag::__shuffle_output_bytes),
                            "shuffle_output_bytes" => Ok(__FieldTag::__shuffle_output_bytes),
                            "shuffleOutputBytesSpilled" => {
                                Ok(__FieldTag::__shuffle_output_bytes_spilled)
                            }
                            "shuffle_output_bytes_spilled" => {
                                Ok(__FieldTag::__shuffle_output_bytes_spilled)
                            }
                            "recordsRead" => Ok(__FieldTag::__records_read),
                            "records_read" => Ok(__FieldTag::__records_read),
                            "recordsWritten" => Ok(__FieldTag::__records_written),
                            "records_written" => Ok(__FieldTag::__records_written),
                            "parallelInputs" => Ok(__FieldTag::__parallel_inputs),
                            "parallel_inputs" => Ok(__FieldTag::__parallel_inputs),
                            "completedParallelInputs" => {
                                Ok(__FieldTag::__completed_parallel_inputs)
                            }
                            "completed_parallel_inputs" => {
                                Ok(__FieldTag::__completed_parallel_inputs)
                            }
                            "status" => Ok(__FieldTag::__status),
                            "steps" => Ok(__FieldTag::__steps),
                            "slotMs" => Ok(__FieldTag::__slot_ms),
                            "slot_ms" => Ok(__FieldTag::__slot_ms),
                            "computeMode" => Ok(__FieldTag::__compute_mode),
                            "compute_mode" => Ok(__FieldTag::__compute_mode),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ExplainQueryStage;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExplainQueryStage")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.id = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__start_ms => {
                            if !fields.insert(__FieldTag::__start_ms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_ms",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.start_ms = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__end_ms => {
                            if !fields.insert(__FieldTag::__end_ms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_ms",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.end_ms = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__input_stages => {
                            if !fields.insert(__FieldTag::__input_stages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input_stages",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i64>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I64>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.input_stages = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__wait_ratio_avg => {
                            if !fields.insert(__FieldTag::__wait_ratio_avg) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for wait_ratio_avg",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.wait_ratio_avg = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__wait_ms_avg => {
                            if !fields.insert(__FieldTag::__wait_ms_avg) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for wait_ms_avg",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.wait_ms_avg = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__wait_ratio_max => {
                            if !fields.insert(__FieldTag::__wait_ratio_max) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for wait_ratio_max",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.wait_ratio_max = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__wait_ms_max => {
                            if !fields.insert(__FieldTag::__wait_ms_max) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for wait_ms_max",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.wait_ms_max = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__read_ratio_avg => {
                            if !fields.insert(__FieldTag::__read_ratio_avg) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_ratio_avg",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.read_ratio_avg = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__read_ms_avg => {
                            if !fields.insert(__FieldTag::__read_ms_avg) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_ms_avg",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.read_ms_avg = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__read_ratio_max => {
                            if !fields.insert(__FieldTag::__read_ratio_max) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_ratio_max",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.read_ratio_max = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__read_ms_max => {
                            if !fields.insert(__FieldTag::__read_ms_max) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_ms_max",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.read_ms_max = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__compute_ratio_avg => {
                            if !fields.insert(__FieldTag::__compute_ratio_avg) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compute_ratio_avg",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.compute_ratio_avg = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__compute_ms_avg => {
                            if !fields.insert(__FieldTag::__compute_ms_avg) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compute_ms_avg",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.compute_ms_avg = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__compute_ratio_max => {
                            if !fields.insert(__FieldTag::__compute_ratio_max) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compute_ratio_max",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.compute_ratio_max = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__compute_ms_max => {
                            if !fields.insert(__FieldTag::__compute_ms_max) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compute_ms_max",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.compute_ms_max = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__write_ratio_avg => {
                            if !fields.insert(__FieldTag::__write_ratio_avg) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for write_ratio_avg",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.write_ratio_avg = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__write_ms_avg => {
                            if !fields.insert(__FieldTag::__write_ms_avg) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for write_ms_avg",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.write_ms_avg = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__write_ratio_max => {
                            if !fields.insert(__FieldTag::__write_ratio_max) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for write_ratio_max",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.write_ratio_max = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__write_ms_max => {
                            if !fields.insert(__FieldTag::__write_ms_max) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for write_ms_max",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.write_ms_max = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__shuffle_output_bytes => {
                            if !fields.insert(__FieldTag::__shuffle_output_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for shuffle_output_bytes",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.shuffle_output_bytes = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__shuffle_output_bytes_spilled => {
                            if !fields.insert(__FieldTag::__shuffle_output_bytes_spilled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for shuffle_output_bytes_spilled",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.shuffle_output_bytes_spilled = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__records_read => {
                            if !fields.insert(__FieldTag::__records_read) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for records_read",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.records_read = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__records_written => {
                            if !fields.insert(__FieldTag::__records_written) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for records_written",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.records_written = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__parallel_inputs => {
                            if !fields.insert(__FieldTag::__parallel_inputs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parallel_inputs",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.parallel_inputs = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__completed_parallel_inputs => {
                            if !fields.insert(__FieldTag::__completed_parallel_inputs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for completed_parallel_inputs",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.completed_parallel_inputs = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__steps => {
                            if !fields.insert(__FieldTag::__steps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for steps",
                                ));
                            }
                            result.steps =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ExplainQueryStep>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__slot_ms => {
                            if !fields.insert(__FieldTag::__slot_ms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for slot_ms",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.slot_ms = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__compute_mode => {
                            if !fields.insert(__FieldTag::__compute_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compute_mode",
                                ));
                            }
                            result.compute_mode =
                                map.next_value::<std::option::Option<
                                    crate::model::explain_query_stage::ComputeMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::QueryTimelineSample {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __elapsed_ms,
            __total_slot_ms,
            __pending_units,
            __completed_units,
            __active_units,
            __shuffle_ram_usage_ratio,
            __estimated_runnable_units,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QueryTimelineSample")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "elapsedMs" => Ok(__FieldTag::__elapsed_ms),
                            "elapsed_ms" => Ok(__FieldTag::__elapsed_ms),
                            "totalSlotMs" => Ok(__FieldTag::__total_slot_ms),
                            "total_slot_ms" => Ok(__FieldTag::__total_slot_ms),
                            "pendingUnits" => Ok(__FieldTag::__pending_units),
                            "pending_units" => Ok(__FieldTag::__pending_units),
                            "completedUnits" => Ok(__FieldTag::__completed_units),
                            "completed_units" => Ok(__FieldTag::__completed_units),
                            "activeUnits" => Ok(__FieldTag::__active_units),
                            "active_units" => Ok(__FieldTag::__active_units),
                            "shuffleRamUsageRatio" => Ok(__FieldTag::__shuffle_ram_usage_ratio),
                            "shuffle_ram_usage_ratio" => Ok(__FieldTag::__shuffle_ram_usage_ratio),
                            "estimatedRunnableUnits" => Ok(__FieldTag::__estimated_runnable_units),
                            "estimated_runnable_units" => {
                                Ok(__FieldTag::__estimated_runnable_units)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::QueryTimelineSample;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QueryTimelineSample")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__elapsed_ms => {
                            if !fields.insert(__FieldTag::__elapsed_ms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for elapsed_ms",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.elapsed_ms = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__total_slot_ms => {
                            if !fields.insert(__FieldTag::__total_slot_ms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_slot_ms",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_slot_ms = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__pending_units => {
                            if !fields.insert(__FieldTag::__pending_units) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pending_units",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.pending_units = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__completed_units => {
                            if !fields.insert(__FieldTag::__completed_units) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for completed_units",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.completed_units = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__active_units => {
                            if !fields.insert(__FieldTag::__active_units) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for active_units",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.active_units = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__shuffle_ram_usage_ratio => {
                            if !fields.insert(__FieldTag::__shuffle_ram_usage_ratio) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for shuffle_ram_usage_ratio",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.shuffle_ram_usage_ratio = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__estimated_runnable_units => {
                            if !fields.insert(__FieldTag::__estimated_runnable_units) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for estimated_runnable_units",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.estimated_runnable_units = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ExternalServiceCost {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __external_service,
            __bytes_processed,
            __bytes_billed,
            __slot_ms,
            __reserved_slot_count,
            __billing_method,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExternalServiceCost")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "externalService" => Ok(__FieldTag::__external_service),
                            "external_service" => Ok(__FieldTag::__external_service),
                            "bytesProcessed" => Ok(__FieldTag::__bytes_processed),
                            "bytes_processed" => Ok(__FieldTag::__bytes_processed),
                            "bytesBilled" => Ok(__FieldTag::__bytes_billed),
                            "bytes_billed" => Ok(__FieldTag::__bytes_billed),
                            "slotMs" => Ok(__FieldTag::__slot_ms),
                            "slot_ms" => Ok(__FieldTag::__slot_ms),
                            "reservedSlotCount" => Ok(__FieldTag::__reserved_slot_count),
                            "reserved_slot_count" => Ok(__FieldTag::__reserved_slot_count),
                            "billingMethod" => Ok(__FieldTag::__billing_method),
                            "billing_method" => Ok(__FieldTag::__billing_method),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ExternalServiceCost;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExternalServiceCost")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__external_service => {
                            if !fields.insert(__FieldTag::__external_service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_service",
                                ));
                            }
                            result.external_service = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__bytes_processed => {
                            if !fields.insert(__FieldTag::__bytes_processed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bytes_processed",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.bytes_processed = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__bytes_billed => {
                            if !fields.insert(__FieldTag::__bytes_billed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bytes_billed",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.bytes_billed = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__slot_ms => {
                            if !fields.insert(__FieldTag::__slot_ms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for slot_ms",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.slot_ms = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__reserved_slot_count => {
                            if !fields.insert(__FieldTag::__reserved_slot_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reserved_slot_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.reserved_slot_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__billing_method => {
                            if !fields.insert(__FieldTag::__billing_method) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for billing_method",
                                ));
                            }
                            result.billing_method = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ExportDataStatistics {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __file_count,
            __row_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportDataStatistics")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fileCount" => Ok(__FieldTag::__file_count),
                            "file_count" => Ok(__FieldTag::__file_count),
                            "rowCount" => Ok(__FieldTag::__row_count),
                            "row_count" => Ok(__FieldTag::__row_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ExportDataStatistics;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportDataStatistics")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__file_count => {
                            if !fields.insert(__FieldTag::__file_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_count",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.file_count = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__row_count => {
                            if !fields.insert(__FieldTag::__row_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for row_count",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.row_count = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::BiEngineReason {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __code,
            __message,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BiEngineReason")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "code" => Ok(__FieldTag::__code),
                            "message" => Ok(__FieldTag::__message),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::BiEngineReason;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BiEngineReason")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__code => {
                            if !fields.insert(__FieldTag::__code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for code",
                                ));
                            }
                            result.code = map.next_value::<std::option::Option<crate::model::bi_engine_reason::Code>>()?.unwrap_or_default();
                        }
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::BiEngineStatistics {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bi_engine_mode,
            __acceleration_mode,
            __bi_engine_reasons,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BiEngineStatistics")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "biEngineMode" => Ok(__FieldTag::__bi_engine_mode),
                            "bi_engine_mode" => Ok(__FieldTag::__bi_engine_mode),
                            "accelerationMode" => Ok(__FieldTag::__acceleration_mode),
                            "acceleration_mode" => Ok(__FieldTag::__acceleration_mode),
                            "biEngineReasons" => Ok(__FieldTag::__bi_engine_reasons),
                            "bi_engine_reasons" => Ok(__FieldTag::__bi_engine_reasons),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::BiEngineStatistics;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BiEngineStatistics")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bi_engine_mode => {
                            if !fields.insert(__FieldTag::__bi_engine_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bi_engine_mode",
                                ));
                            }
                            result.bi_engine_mode = map
                                .next_value::<std::option::Option<
                                    crate::model::bi_engine_statistics::BiEngineMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__acceleration_mode => {
                            if !fields.insert(__FieldTag::__acceleration_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for acceleration_mode",
                                ));
                            }
                            result.acceleration_mode = map
                                .next_value::<std::option::Option<
                                    crate::model::bi_engine_statistics::BiEngineAccelerationMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__bi_engine_reasons => {
                            if !fields.insert(__FieldTag::__bi_engine_reasons) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bi_engine_reasons",
                                ));
                            }
                            result.bi_engine_reasons =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::BiEngineReason>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::IndexUnusedReason {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __code,
            __message,
            __base_table,
            __index_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IndexUnusedReason")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "code" => Ok(__FieldTag::__code),
                            "message" => Ok(__FieldTag::__message),
                            "baseTable" => Ok(__FieldTag::__base_table),
                            "base_table" => Ok(__FieldTag::__base_table),
                            "indexName" => Ok(__FieldTag::__index_name),
                            "index_name" => Ok(__FieldTag::__index_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::IndexUnusedReason;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IndexUnusedReason")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__code => {
                            if !fields.insert(__FieldTag::__code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for code",
                                ));
                            }
                            result.code = map.next_value::<std::option::Option<crate::model::index_unused_reason::Code>>()?
                                ;
                        }
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__base_table => {
                            if !fields.insert(__FieldTag::__base_table) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for base_table",
                                ));
                            }
                            result.base_table = map
                                .next_value::<std::option::Option<crate::model::TableReference>>(
                                )?;
                        }
                        __FieldTag::__index_name => {
                            if !fields.insert(__FieldTag::__index_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for index_name",
                                ));
                            }
                            result.index_name =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::StoredColumnsUsage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __is_query_accelerated,
            __base_table,
            __stored_columns_unused_reasons,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StoredColumnsUsage")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "isQueryAccelerated" => Ok(__FieldTag::__is_query_accelerated),
                            "is_query_accelerated" => Ok(__FieldTag::__is_query_accelerated),
                            "baseTable" => Ok(__FieldTag::__base_table),
                            "base_table" => Ok(__FieldTag::__base_table),
                            "storedColumnsUnusedReasons" => {
                                Ok(__FieldTag::__stored_columns_unused_reasons)
                            }
                            "stored_columns_unused_reasons" => {
                                Ok(__FieldTag::__stored_columns_unused_reasons)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::StoredColumnsUsage;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StoredColumnsUsage")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__is_query_accelerated => {
                            if !fields.insert(__FieldTag::__is_query_accelerated) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_query_accelerated",
                                ));
                            }
                            result.is_query_accelerated =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__base_table => {
                            if !fields.insert(__FieldTag::__base_table) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for base_table",
                                ));
                            }
                            result.base_table = map
                                .next_value::<std::option::Option<crate::model::TableReference>>(
                                )?;
                        }
                        __FieldTag::__stored_columns_unused_reasons => {
                            if !fields.insert(__FieldTag::__stored_columns_unused_reasons) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stored_columns_unused_reasons",
                                ));
                            }
                            result.stored_columns_unused_reasons = map.next_value::<std::option::Option<std::vec::Vec<crate::model::stored_columns_usage::StoredColumnsUnusedReason>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::stored_columns_usage::StoredColumnsUnusedReason {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __code,
            __message,
            __uncovered_columns,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StoredColumnsUnusedReason")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "code" => Ok(__FieldTag::__code),
                            "message" => Ok(__FieldTag::__message),
                            "uncoveredColumns" => Ok(__FieldTag::__uncovered_columns),
                            "uncovered_columns" => Ok(__FieldTag::__uncovered_columns),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::stored_columns_usage::StoredColumnsUnusedReason;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StoredColumnsUnusedReason")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__code => {
                            if !fields.insert(__FieldTag::__code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for code",
                                ));
                            }
                            result.code = map.next_value::<std::option::Option<crate::model::stored_columns_usage::stored_columns_unused_reason::Code>>()?
                                ;
                        }
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__uncovered_columns => {
                            if !fields.insert(__FieldTag::__uncovered_columns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uncovered_columns",
                                ));
                            }
                            result.uncovered_columns = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SearchStatistics {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __index_usage_mode,
            __index_unused_reasons,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchStatistics")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "indexUsageMode" => Ok(__FieldTag::__index_usage_mode),
                            "index_usage_mode" => Ok(__FieldTag::__index_usage_mode),
                            "indexUnusedReasons" => Ok(__FieldTag::__index_unused_reasons),
                            "index_unused_reasons" => Ok(__FieldTag::__index_unused_reasons),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SearchStatistics;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchStatistics")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__index_usage_mode => {
                            if !fields.insert(__FieldTag::__index_usage_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for index_usage_mode",
                                ));
                            }
                            result.index_usage_mode = map
                                .next_value::<std::option::Option<
                                    crate::model::search_statistics::IndexUsageMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__index_unused_reasons => {
                            if !fields.insert(__FieldTag::__index_unused_reasons) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for index_unused_reasons",
                                ));
                            }
                            result.index_unused_reasons =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::IndexUnusedReason>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::VectorSearchStatistics {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __index_usage_mode,
            __index_unused_reasons,
            __stored_columns_usages,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VectorSearchStatistics")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "indexUsageMode" => Ok(__FieldTag::__index_usage_mode),
                            "index_usage_mode" => Ok(__FieldTag::__index_usage_mode),
                            "indexUnusedReasons" => Ok(__FieldTag::__index_unused_reasons),
                            "index_unused_reasons" => Ok(__FieldTag::__index_unused_reasons),
                            "storedColumnsUsages" => Ok(__FieldTag::__stored_columns_usages),
                            "stored_columns_usages" => Ok(__FieldTag::__stored_columns_usages),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::VectorSearchStatistics;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VectorSearchStatistics")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__index_usage_mode => {
                            if !fields.insert(__FieldTag::__index_usage_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for index_usage_mode",
                                ));
                            }
                            result.index_usage_mode = map
                                .next_value::<std::option::Option<
                                    crate::model::vector_search_statistics::IndexUsageMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__index_unused_reasons => {
                            if !fields.insert(__FieldTag::__index_unused_reasons) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for index_unused_reasons",
                                ));
                            }
                            result.index_unused_reasons =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::IndexUnusedReason>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__stored_columns_usages => {
                            if !fields.insert(__FieldTag::__stored_columns_usages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stored_columns_usages",
                                ));
                            }
                            result.stored_columns_usages = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::StoredColumnsUsage>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::QueryInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __optimization_details,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QueryInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "optimizationDetails" => Ok(__FieldTag::__optimization_details),
                            "optimization_details" => Ok(__FieldTag::__optimization_details),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::QueryInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QueryInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__optimization_details => {
                            if !fields.insert(__FieldTag::__optimization_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optimization_details",
                                ));
                            }
                            result.optimization_details =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::LoadQueryStatistics {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __input_files,
            __input_file_bytes,
            __output_rows,
            __output_bytes,
            __bad_records,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LoadQueryStatistics")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "inputFiles" => Ok(__FieldTag::__input_files),
                            "input_files" => Ok(__FieldTag::__input_files),
                            "inputFileBytes" => Ok(__FieldTag::__input_file_bytes),
                            "input_file_bytes" => Ok(__FieldTag::__input_file_bytes),
                            "outputRows" => Ok(__FieldTag::__output_rows),
                            "output_rows" => Ok(__FieldTag::__output_rows),
                            "outputBytes" => Ok(__FieldTag::__output_bytes),
                            "output_bytes" => Ok(__FieldTag::__output_bytes),
                            "badRecords" => Ok(__FieldTag::__bad_records),
                            "bad_records" => Ok(__FieldTag::__bad_records),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::LoadQueryStatistics;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LoadQueryStatistics")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__input_files => {
                            if !fields.insert(__FieldTag::__input_files) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input_files",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.input_files = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__input_file_bytes => {
                            if !fields.insert(__FieldTag::__input_file_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input_file_bytes",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.input_file_bytes = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__output_rows => {
                            if !fields.insert(__FieldTag::__output_rows) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_rows",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.output_rows = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__output_bytes => {
                            if !fields.insert(__FieldTag::__output_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_bytes",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.output_bytes = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__bad_records => {
                            if !fields.insert(__FieldTag::__bad_records) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bad_records",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.bad_records = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::JobStatistics2 {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __query_plan,
            __estimated_bytes_processed,
            __timeline,
            __total_partitions_processed,
            __total_bytes_processed,
            __total_bytes_processed_accuracy,
            __total_bytes_billed,
            __billing_tier,
            __total_slot_ms,
            __total_services_sku_slot_ms,
            __cache_hit,
            __referenced_tables,
            __referenced_routines,
            __schema,
            __num_dml_affected_rows,
            __dml_stats,
            __undeclared_query_parameters,
            __statement_type,
            __ddl_operation_performed,
            __ddl_target_table,
            __ddl_destination_table,
            __ddl_target_row_access_policy,
            __ddl_affected_row_access_policy_count,
            __ddl_target_routine,
            __ddl_target_dataset,
            __ml_statistics,
            __export_data_statistics,
            __external_service_costs,
            __bi_engine_statistics,
            __load_query_statistics,
            __dcl_target_table,
            __dcl_target_view,
            __dcl_target_dataset,
            __search_statistics,
            __vector_search_statistics,
            __performance_insights,
            __query_info,
            __spark_statistics,
            __transferred_bytes,
            __materialized_view_statistics,
            __metadata_cache_statistics,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for JobStatistics2")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "queryPlan" => Ok(__FieldTag::__query_plan),
                            "query_plan" => Ok(__FieldTag::__query_plan),
                            "estimatedBytesProcessed" => {
                                Ok(__FieldTag::__estimated_bytes_processed)
                            }
                            "estimated_bytes_processed" => {
                                Ok(__FieldTag::__estimated_bytes_processed)
                            }
                            "timeline" => Ok(__FieldTag::__timeline),
                            "totalPartitionsProcessed" => {
                                Ok(__FieldTag::__total_partitions_processed)
                            }
                            "total_partitions_processed" => {
                                Ok(__FieldTag::__total_partitions_processed)
                            }
                            "totalBytesProcessed" => Ok(__FieldTag::__total_bytes_processed),
                            "total_bytes_processed" => Ok(__FieldTag::__total_bytes_processed),
                            "totalBytesProcessedAccuracy" => {
                                Ok(__FieldTag::__total_bytes_processed_accuracy)
                            }
                            "total_bytes_processed_accuracy" => {
                                Ok(__FieldTag::__total_bytes_processed_accuracy)
                            }
                            "totalBytesBilled" => Ok(__FieldTag::__total_bytes_billed),
                            "total_bytes_billed" => Ok(__FieldTag::__total_bytes_billed),
                            "billingTier" => Ok(__FieldTag::__billing_tier),
                            "billing_tier" => Ok(__FieldTag::__billing_tier),
                            "totalSlotMs" => Ok(__FieldTag::__total_slot_ms),
                            "total_slot_ms" => Ok(__FieldTag::__total_slot_ms),
                            "totalServicesSkuSlotMs" => {
                                Ok(__FieldTag::__total_services_sku_slot_ms)
                            }
                            "total_services_sku_slot_ms" => {
                                Ok(__FieldTag::__total_services_sku_slot_ms)
                            }
                            "cacheHit" => Ok(__FieldTag::__cache_hit),
                            "cache_hit" => Ok(__FieldTag::__cache_hit),
                            "referencedTables" => Ok(__FieldTag::__referenced_tables),
                            "referenced_tables" => Ok(__FieldTag::__referenced_tables),
                            "referencedRoutines" => Ok(__FieldTag::__referenced_routines),
                            "referenced_routines" => Ok(__FieldTag::__referenced_routines),
                            "schema" => Ok(__FieldTag::__schema),
                            "numDmlAffectedRows" => Ok(__FieldTag::__num_dml_affected_rows),
                            "num_dml_affected_rows" => Ok(__FieldTag::__num_dml_affected_rows),
                            "dmlStats" => Ok(__FieldTag::__dml_stats),
                            "dml_stats" => Ok(__FieldTag::__dml_stats),
                            "undeclaredQueryParameters" => {
                                Ok(__FieldTag::__undeclared_query_parameters)
                            }
                            "undeclared_query_parameters" => {
                                Ok(__FieldTag::__undeclared_query_parameters)
                            }
                            "statementType" => Ok(__FieldTag::__statement_type),
                            "statement_type" => Ok(__FieldTag::__statement_type),
                            "ddlOperationPerformed" => Ok(__FieldTag::__ddl_operation_performed),
                            "ddl_operation_performed" => Ok(__FieldTag::__ddl_operation_performed),
                            "ddlTargetTable" => Ok(__FieldTag::__ddl_target_table),
                            "ddl_target_table" => Ok(__FieldTag::__ddl_target_table),
                            "ddlDestinationTable" => Ok(__FieldTag::__ddl_destination_table),
                            "ddl_destination_table" => Ok(__FieldTag::__ddl_destination_table),
                            "ddlTargetRowAccessPolicy" => {
                                Ok(__FieldTag::__ddl_target_row_access_policy)
                            }
                            "ddl_target_row_access_policy" => {
                                Ok(__FieldTag::__ddl_target_row_access_policy)
                            }
                            "ddlAffectedRowAccessPolicyCount" => {
                                Ok(__FieldTag::__ddl_affected_row_access_policy_count)
                            }
                            "ddl_affected_row_access_policy_count" => {
                                Ok(__FieldTag::__ddl_affected_row_access_policy_count)
                            }
                            "ddlTargetRoutine" => Ok(__FieldTag::__ddl_target_routine),
                            "ddl_target_routine" => Ok(__FieldTag::__ddl_target_routine),
                            "ddlTargetDataset" => Ok(__FieldTag::__ddl_target_dataset),
                            "ddl_target_dataset" => Ok(__FieldTag::__ddl_target_dataset),
                            "mlStatistics" => Ok(__FieldTag::__ml_statistics),
                            "ml_statistics" => Ok(__FieldTag::__ml_statistics),
                            "exportDataStatistics" => Ok(__FieldTag::__export_data_statistics),
                            "export_data_statistics" => Ok(__FieldTag::__export_data_statistics),
                            "externalServiceCosts" => Ok(__FieldTag::__external_service_costs),
                            "external_service_costs" => Ok(__FieldTag::__external_service_costs),
                            "biEngineStatistics" => Ok(__FieldTag::__bi_engine_statistics),
                            "bi_engine_statistics" => Ok(__FieldTag::__bi_engine_statistics),
                            "loadQueryStatistics" => Ok(__FieldTag::__load_query_statistics),
                            "load_query_statistics" => Ok(__FieldTag::__load_query_statistics),
                            "dclTargetTable" => Ok(__FieldTag::__dcl_target_table),
                            "dcl_target_table" => Ok(__FieldTag::__dcl_target_table),
                            "dclTargetView" => Ok(__FieldTag::__dcl_target_view),
                            "dcl_target_view" => Ok(__FieldTag::__dcl_target_view),
                            "dclTargetDataset" => Ok(__FieldTag::__dcl_target_dataset),
                            "dcl_target_dataset" => Ok(__FieldTag::__dcl_target_dataset),
                            "searchStatistics" => Ok(__FieldTag::__search_statistics),
                            "search_statistics" => Ok(__FieldTag::__search_statistics),
                            "vectorSearchStatistics" => Ok(__FieldTag::__vector_search_statistics),
                            "vector_search_statistics" => {
                                Ok(__FieldTag::__vector_search_statistics)
                            }
                            "performanceInsights" => Ok(__FieldTag::__performance_insights),
                            "performance_insights" => Ok(__FieldTag::__performance_insights),
                            "queryInfo" => Ok(__FieldTag::__query_info),
                            "query_info" => Ok(__FieldTag::__query_info),
                            "sparkStatistics" => Ok(__FieldTag::__spark_statistics),
                            "spark_statistics" => Ok(__FieldTag::__spark_statistics),
                            "transferredBytes" => Ok(__FieldTag::__transferred_bytes),
                            "transferred_bytes" => Ok(__FieldTag::__transferred_bytes),
                            "materializedViewStatistics" => {
                                Ok(__FieldTag::__materialized_view_statistics)
                            }
                            "materialized_view_statistics" => {
                                Ok(__FieldTag::__materialized_view_statistics)
                            }
                            "metadataCacheStatistics" => {
                                Ok(__FieldTag::__metadata_cache_statistics)
                            }
                            "metadata_cache_statistics" => {
                                Ok(__FieldTag::__metadata_cache_statistics)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::JobStatistics2;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct JobStatistics2")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__query_plan => {
                            if !fields.insert(__FieldTag::__query_plan) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_plan",
                                ));
                            }
                            result.query_plan =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ExplainQueryStage>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__estimated_bytes_processed => {
                            if !fields.insert(__FieldTag::__estimated_bytes_processed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for estimated_bytes_processed",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.estimated_bytes_processed = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__timeline => {
                            if !fields.insert(__FieldTag::__timeline) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timeline",
                                ));
                            }
                            result.timeline = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::QueryTimelineSample>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__total_partitions_processed => {
                            if !fields.insert(__FieldTag::__total_partitions_processed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_partitions_processed",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_partitions_processed = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__total_bytes_processed => {
                            if !fields.insert(__FieldTag::__total_bytes_processed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_bytes_processed",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_bytes_processed = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__total_bytes_processed_accuracy => {
                            if !fields.insert(__FieldTag::__total_bytes_processed_accuracy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_bytes_processed_accuracy",
                                ));
                            }
                            result.total_bytes_processed_accuracy = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__total_bytes_billed => {
                            if !fields.insert(__FieldTag::__total_bytes_billed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_bytes_billed",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_bytes_billed = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__billing_tier => {
                            if !fields.insert(__FieldTag::__billing_tier) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for billing_tier",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int32Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.billing_tier = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__total_slot_ms => {
                            if !fields.insert(__FieldTag::__total_slot_ms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_slot_ms",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_slot_ms = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__total_services_sku_slot_ms => {
                            if !fields.insert(__FieldTag::__total_services_sku_slot_ms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_services_sku_slot_ms",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_services_sku_slot_ms = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__cache_hit => {
                            if !fields.insert(__FieldTag::__cache_hit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cache_hit",
                                ));
                            }
                            result.cache_hit =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__referenced_tables => {
                            if !fields.insert(__FieldTag::__referenced_tables) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for referenced_tables",
                                ));
                            }
                            result.referenced_tables =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::TableReference>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__referenced_routines => {
                            if !fields.insert(__FieldTag::__referenced_routines) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for referenced_routines",
                                ));
                            }
                            result.referenced_routines =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::RoutineReference>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__schema => {
                            if !fields.insert(__FieldTag::__schema) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schema",
                                ));
                            }
                            result.schema =
                                map.next_value::<std::option::Option<crate::model::TableSchema>>()?;
                        }
                        __FieldTag::__num_dml_affected_rows => {
                            if !fields.insert(__FieldTag::__num_dml_affected_rows) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for num_dml_affected_rows",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.num_dml_affected_rows = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__dml_stats => {
                            if !fields.insert(__FieldTag::__dml_stats) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dml_stats",
                                ));
                            }
                            result.dml_stats =
                                map.next_value::<std::option::Option<crate::model::DmlStats>>()?;
                        }
                        __FieldTag::__undeclared_query_parameters => {
                            if !fields.insert(__FieldTag::__undeclared_query_parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for undeclared_query_parameters",
                                ));
                            }
                            result.undeclared_query_parameters =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::QueryParameter>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__statement_type => {
                            if !fields.insert(__FieldTag::__statement_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for statement_type",
                                ));
                            }
                            result.statement_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ddl_operation_performed => {
                            if !fields.insert(__FieldTag::__ddl_operation_performed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ddl_operation_performed",
                                ));
                            }
                            result.ddl_operation_performed = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ddl_target_table => {
                            if !fields.insert(__FieldTag::__ddl_target_table) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ddl_target_table",
                                ));
                            }
                            result.ddl_target_table = map
                                .next_value::<std::option::Option<crate::model::TableReference>>(
                                )?;
                        }
                        __FieldTag::__ddl_destination_table => {
                            if !fields.insert(__FieldTag::__ddl_destination_table) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ddl_destination_table",
                                ));
                            }
                            result.ddl_destination_table = map
                                .next_value::<std::option::Option<crate::model::TableReference>>(
                                )?;
                        }
                        __FieldTag::__ddl_target_row_access_policy => {
                            if !fields.insert(__FieldTag::__ddl_target_row_access_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ddl_target_row_access_policy",
                                ));
                            }
                            result.ddl_target_row_access_policy = map.next_value::<std::option::Option<crate::model::RowAccessPolicyReference>>()?
                                ;
                        }
                        __FieldTag::__ddl_affected_row_access_policy_count => {
                            if !fields.insert(__FieldTag::__ddl_affected_row_access_policy_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ddl_affected_row_access_policy_count",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.ddl_affected_row_access_policy_count =
                                map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__ddl_target_routine => {
                            if !fields.insert(__FieldTag::__ddl_target_routine) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ddl_target_routine",
                                ));
                            }
                            result.ddl_target_routine = map
                                .next_value::<std::option::Option<crate::model::RoutineReference>>(
                                )?;
                        }
                        __FieldTag::__ddl_target_dataset => {
                            if !fields.insert(__FieldTag::__ddl_target_dataset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ddl_target_dataset",
                                ));
                            }
                            result.ddl_target_dataset = map
                                .next_value::<std::option::Option<crate::model::DatasetReference>>(
                                )?;
                        }
                        __FieldTag::__ml_statistics => {
                            if !fields.insert(__FieldTag::__ml_statistics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ml_statistics",
                                ));
                            }
                            result.ml_statistics = map
                                .next_value::<std::option::Option<crate::model::MlStatistics>>()?;
                        }
                        __FieldTag::__export_data_statistics => {
                            if !fields.insert(__FieldTag::__export_data_statistics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for export_data_statistics",
                                ));
                            }
                            result.export_data_statistics = map.next_value::<std::option::Option<crate::model::ExportDataStatistics>>()?
                                ;
                        }
                        __FieldTag::__external_service_costs => {
                            if !fields.insert(__FieldTag::__external_service_costs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_service_costs",
                                ));
                            }
                            result.external_service_costs = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ExternalServiceCost>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__bi_engine_statistics => {
                            if !fields.insert(__FieldTag::__bi_engine_statistics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bi_engine_statistics",
                                ));
                            }
                            result.bi_engine_statistics = map.next_value::<std::option::Option<crate::model::BiEngineStatistics>>()?
                                ;
                        }
                        __FieldTag::__load_query_statistics => {
                            if !fields.insert(__FieldTag::__load_query_statistics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for load_query_statistics",
                                ));
                            }
                            result.load_query_statistics = map.next_value::<std::option::Option<crate::model::LoadQueryStatistics>>()?
                                ;
                        }
                        __FieldTag::__dcl_target_table => {
                            if !fields.insert(__FieldTag::__dcl_target_table) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dcl_target_table",
                                ));
                            }
                            result.dcl_target_table = map
                                .next_value::<std::option::Option<crate::model::TableReference>>(
                                )?;
                        }
                        __FieldTag::__dcl_target_view => {
                            if !fields.insert(__FieldTag::__dcl_target_view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dcl_target_view",
                                ));
                            }
                            result.dcl_target_view = map
                                .next_value::<std::option::Option<crate::model::TableReference>>(
                                )?;
                        }
                        __FieldTag::__dcl_target_dataset => {
                            if !fields.insert(__FieldTag::__dcl_target_dataset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dcl_target_dataset",
                                ));
                            }
                            result.dcl_target_dataset = map
                                .next_value::<std::option::Option<crate::model::DatasetReference>>(
                                )?;
                        }
                        __FieldTag::__search_statistics => {
                            if !fields.insert(__FieldTag::__search_statistics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for search_statistics",
                                ));
                            }
                            result.search_statistics = map
                                .next_value::<std::option::Option<crate::model::SearchStatistics>>(
                                )?;
                        }
                        __FieldTag::__vector_search_statistics => {
                            if !fields.insert(__FieldTag::__vector_search_statistics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vector_search_statistics",
                                ));
                            }
                            result.vector_search_statistics = map.next_value::<std::option::Option<crate::model::VectorSearchStatistics>>()?
                                ;
                        }
                        __FieldTag::__performance_insights => {
                            if !fields.insert(__FieldTag::__performance_insights) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for performance_insights",
                                ));
                            }
                            result.performance_insights = map.next_value::<std::option::Option<crate::model::PerformanceInsights>>()?
                                ;
                        }
                        __FieldTag::__query_info => {
                            if !fields.insert(__FieldTag::__query_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_info",
                                ));
                            }
                            result.query_info =
                                map.next_value::<std::option::Option<crate::model::QueryInfo>>()?;
                        }
                        __FieldTag::__spark_statistics => {
                            if !fields.insert(__FieldTag::__spark_statistics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for spark_statistics",
                                ));
                            }
                            result.spark_statistics = map
                                .next_value::<std::option::Option<crate::model::SparkStatistics>>(
                                )?;
                        }
                        __FieldTag::__transferred_bytes => {
                            if !fields.insert(__FieldTag::__transferred_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transferred_bytes",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.transferred_bytes = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__materialized_view_statistics => {
                            if !fields.insert(__FieldTag::__materialized_view_statistics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for materialized_view_statistics",
                                ));
                            }
                            result.materialized_view_statistics = map.next_value::<std::option::Option<crate::model::MaterializedViewStatistics>>()?
                                ;
                        }
                        __FieldTag::__metadata_cache_statistics => {
                            if !fields.insert(__FieldTag::__metadata_cache_statistics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata_cache_statistics",
                                ));
                            }
                            result.metadata_cache_statistics = map.next_value::<std::option::Option<crate::model::MetadataCacheStatistics>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::JobStatistics3 {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __input_files,
            __input_file_bytes,
            __output_rows,
            __output_bytes,
            __bad_records,
            __timeline,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for JobStatistics3")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "inputFiles" => Ok(__FieldTag::__input_files),
                            "input_files" => Ok(__FieldTag::__input_files),
                            "inputFileBytes" => Ok(__FieldTag::__input_file_bytes),
                            "input_file_bytes" => Ok(__FieldTag::__input_file_bytes),
                            "outputRows" => Ok(__FieldTag::__output_rows),
                            "output_rows" => Ok(__FieldTag::__output_rows),
                            "outputBytes" => Ok(__FieldTag::__output_bytes),
                            "output_bytes" => Ok(__FieldTag::__output_bytes),
                            "badRecords" => Ok(__FieldTag::__bad_records),
                            "bad_records" => Ok(__FieldTag::__bad_records),
                            "timeline" => Ok(__FieldTag::__timeline),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::JobStatistics3;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct JobStatistics3")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__input_files => {
                            if !fields.insert(__FieldTag::__input_files) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input_files",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.input_files = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__input_file_bytes => {
                            if !fields.insert(__FieldTag::__input_file_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input_file_bytes",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.input_file_bytes = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__output_rows => {
                            if !fields.insert(__FieldTag::__output_rows) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_rows",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.output_rows = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__output_bytes => {
                            if !fields.insert(__FieldTag::__output_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_bytes",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.output_bytes = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__bad_records => {
                            if !fields.insert(__FieldTag::__bad_records) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bad_records",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.bad_records = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__timeline => {
                            if !fields.insert(__FieldTag::__timeline) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timeline",
                                ));
                            }
                            result.timeline = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::QueryTimelineSample>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::JobStatistics4 {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __destination_uri_file_counts,
            __input_bytes,
            __timeline,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for JobStatistics4")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "destinationUriFileCounts" => {
                                Ok(__FieldTag::__destination_uri_file_counts)
                            }
                            "destination_uri_file_counts" => {
                                Ok(__FieldTag::__destination_uri_file_counts)
                            }
                            "inputBytes" => Ok(__FieldTag::__input_bytes),
                            "input_bytes" => Ok(__FieldTag::__input_bytes),
                            "timeline" => Ok(__FieldTag::__timeline),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::JobStatistics4;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct JobStatistics4")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__destination_uri_file_counts => {
                            if !fields.insert(__FieldTag::__destination_uri_file_counts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_uri_file_counts",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i64>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I64>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.destination_uri_file_counts =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__input_bytes => {
                            if !fields.insert(__FieldTag::__input_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input_bytes",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.input_bytes = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__timeline => {
                            if !fields.insert(__FieldTag::__timeline) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timeline",
                                ));
                            }
                            result.timeline = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::QueryTimelineSample>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CopyJobStatistics {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __copied_rows,
            __copied_logical_bytes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CopyJobStatistics")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "copiedRows" => Ok(__FieldTag::__copied_rows),
                            "copied_rows" => Ok(__FieldTag::__copied_rows),
                            "copiedLogicalBytes" => Ok(__FieldTag::__copied_logical_bytes),
                            "copied_logical_bytes" => Ok(__FieldTag::__copied_logical_bytes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CopyJobStatistics;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CopyJobStatistics")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__copied_rows => {
                            if !fields.insert(__FieldTag::__copied_rows) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for copied_rows",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.copied_rows = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__copied_logical_bytes => {
                            if !fields.insert(__FieldTag::__copied_logical_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for copied_logical_bytes",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.copied_logical_bytes = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MlStatistics {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __max_iterations,
            __iteration_results,
            __model_type,
            __training_type,
            __hparam_trials,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MlStatistics")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "maxIterations" => Ok(__FieldTag::__max_iterations),
                            "max_iterations" => Ok(__FieldTag::__max_iterations),
                            "iterationResults" => Ok(__FieldTag::__iteration_results),
                            "iteration_results" => Ok(__FieldTag::__iteration_results),
                            "modelType" => Ok(__FieldTag::__model_type),
                            "model_type" => Ok(__FieldTag::__model_type),
                            "trainingType" => Ok(__FieldTag::__training_type),
                            "training_type" => Ok(__FieldTag::__training_type),
                            "hparamTrials" => Ok(__FieldTag::__hparam_trials),
                            "hparam_trials" => Ok(__FieldTag::__hparam_trials),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MlStatistics;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MlStatistics")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__max_iterations => {
                            if !fields.insert(__FieldTag::__max_iterations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_iterations",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_iterations =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__iteration_results => {
                            if !fields.insert(__FieldTag::__iteration_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for iteration_results",
                                ));
                            }
                            result.iteration_results = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::model::training_run::IterationResult,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__model_type => {
                            if !fields.insert(__FieldTag::__model_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model_type",
                                ));
                            }
                            result.model_type = map
                                .next_value::<std::option::Option<crate::model::model::ModelType>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__training_type => {
                            if !fields.insert(__FieldTag::__training_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for training_type",
                                ));
                            }
                            result.training_type = map.next_value::<std::option::Option<crate::model::ml_statistics::TrainingType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__hparam_trials => {
                            if !fields.insert(__FieldTag::__hparam_trials) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hparam_trials",
                                ));
                            }
                            result.hparam_trials = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::model::HparamTuningTrial>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ScriptStatistics {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __evaluation_kind,
            __stack_frames,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ScriptStatistics")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "evaluationKind" => Ok(__FieldTag::__evaluation_kind),
                            "evaluation_kind" => Ok(__FieldTag::__evaluation_kind),
                            "stackFrames" => Ok(__FieldTag::__stack_frames),
                            "stack_frames" => Ok(__FieldTag::__stack_frames),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ScriptStatistics;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ScriptStatistics")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__evaluation_kind => {
                            if !fields.insert(__FieldTag::__evaluation_kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for evaluation_kind",
                                ));
                            }
                            result.evaluation_kind = map
                                .next_value::<std::option::Option<
                                    crate::model::script_statistics::EvaluationKind,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__stack_frames => {
                            if !fields.insert(__FieldTag::__stack_frames) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stack_frames",
                                ));
                            }
                            result.stack_frames = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::script_statistics::ScriptStackFrame,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::script_statistics::ScriptStackFrame {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __start_line,
            __start_column,
            __end_line,
            __end_column,
            __procedure_id,
            __text,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ScriptStackFrame")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "startLine" => Ok(__FieldTag::__start_line),
                            "start_line" => Ok(__FieldTag::__start_line),
                            "startColumn" => Ok(__FieldTag::__start_column),
                            "start_column" => Ok(__FieldTag::__start_column),
                            "endLine" => Ok(__FieldTag::__end_line),
                            "end_line" => Ok(__FieldTag::__end_line),
                            "endColumn" => Ok(__FieldTag::__end_column),
                            "end_column" => Ok(__FieldTag::__end_column),
                            "procedureId" => Ok(__FieldTag::__procedure_id),
                            "procedure_id" => Ok(__FieldTag::__procedure_id),
                            "text" => Ok(__FieldTag::__text),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::script_statistics::ScriptStackFrame;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ScriptStackFrame")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__start_line => {
                            if !fields.insert(__FieldTag::__start_line) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_line",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.start_line = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__start_column => {
                            if !fields.insert(__FieldTag::__start_column) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_column",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.start_column = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__end_line => {
                            if !fields.insert(__FieldTag::__end_line) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_line",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.end_line = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__end_column => {
                            if !fields.insert(__FieldTag::__end_column) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_column",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.end_column = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__procedure_id => {
                            if !fields.insert(__FieldTag::__procedure_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for procedure_id",
                                ));
                            }
                            result.procedure_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__text => {
                            if !fields.insert(__FieldTag::__text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for text",
                                ));
                            }
                            result.text = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RowLevelSecurityStatistics {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __row_level_security_applied,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RowLevelSecurityStatistics")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rowLevelSecurityApplied" => {
                                Ok(__FieldTag::__row_level_security_applied)
                            }
                            "row_level_security_applied" => {
                                Ok(__FieldTag::__row_level_security_applied)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RowLevelSecurityStatistics;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RowLevelSecurityStatistics")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__row_level_security_applied => {
                            if !fields.insert(__FieldTag::__row_level_security_applied) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for row_level_security_applied",
                                ));
                            }
                            result.row_level_security_applied = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DataMaskingStatistics {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __data_masking_applied,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataMaskingStatistics")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dataMaskingApplied" => Ok(__FieldTag::__data_masking_applied),
                            "data_masking_applied" => Ok(__FieldTag::__data_masking_applied),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DataMaskingStatistics;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataMaskingStatistics")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__data_masking_applied => {
                            if !fields.insert(__FieldTag::__data_masking_applied) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_masking_applied",
                                ));
                            }
                            result.data_masking_applied = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::JobStatistics {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __creation_time,
            __start_time,
            __end_time,
            __total_bytes_processed,
            __completion_ratio,
            __quota_deferments,
            __query,
            __load,
            __extract,
            __copy,
            __total_slot_ms,
            __reservation_id,
            __num_child_jobs,
            __parent_job_id,
            __script_statistics,
            __row_level_security_statistics,
            __data_masking_statistics,
            __transaction_info,
            __session_info,
            __final_execution_duration_ms,
            __edition,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for JobStatistics")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "creationTime" => Ok(__FieldTag::__creation_time),
                            "creation_time" => Ok(__FieldTag::__creation_time),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "totalBytesProcessed" => Ok(__FieldTag::__total_bytes_processed),
                            "total_bytes_processed" => Ok(__FieldTag::__total_bytes_processed),
                            "completionRatio" => Ok(__FieldTag::__completion_ratio),
                            "completion_ratio" => Ok(__FieldTag::__completion_ratio),
                            "quotaDeferments" => Ok(__FieldTag::__quota_deferments),
                            "quota_deferments" => Ok(__FieldTag::__quota_deferments),
                            "query" => Ok(__FieldTag::__query),
                            "load" => Ok(__FieldTag::__load),
                            "extract" => Ok(__FieldTag::__extract),
                            "copy" => Ok(__FieldTag::__copy),
                            "totalSlotMs" => Ok(__FieldTag::__total_slot_ms),
                            "total_slot_ms" => Ok(__FieldTag::__total_slot_ms),
                            "reservation_id" => Ok(__FieldTag::__reservation_id),
                            "numChildJobs" => Ok(__FieldTag::__num_child_jobs),
                            "num_child_jobs" => Ok(__FieldTag::__num_child_jobs),
                            "parentJobId" => Ok(__FieldTag::__parent_job_id),
                            "parent_job_id" => Ok(__FieldTag::__parent_job_id),
                            "scriptStatistics" => Ok(__FieldTag::__script_statistics),
                            "script_statistics" => Ok(__FieldTag::__script_statistics),
                            "rowLevelSecurityStatistics" => {
                                Ok(__FieldTag::__row_level_security_statistics)
                            }
                            "row_level_security_statistics" => {
                                Ok(__FieldTag::__row_level_security_statistics)
                            }
                            "dataMaskingStatistics" => Ok(__FieldTag::__data_masking_statistics),
                            "data_masking_statistics" => Ok(__FieldTag::__data_masking_statistics),
                            "transactionInfo" => Ok(__FieldTag::__transaction_info),
                            "transaction_info" => Ok(__FieldTag::__transaction_info),
                            "sessionInfo" => Ok(__FieldTag::__session_info),
                            "session_info" => Ok(__FieldTag::__session_info),
                            "finalExecutionDurationMs" => {
                                Ok(__FieldTag::__final_execution_duration_ms)
                            }
                            "final_execution_duration_ms" => {
                                Ok(__FieldTag::__final_execution_duration_ms)
                            }
                            "edition" => Ok(__FieldTag::__edition),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::JobStatistics;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct JobStatistics")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__creation_time => {
                            if !fields.insert(__FieldTag::__creation_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for creation_time",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.creation_time =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.start_time = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.end_time = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__total_bytes_processed => {
                            if !fields.insert(__FieldTag::__total_bytes_processed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_bytes_processed",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_bytes_processed = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__completion_ratio => {
                            if !fields.insert(__FieldTag::__completion_ratio) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for completion_ratio",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.completion_ratio = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__quota_deferments => {
                            if !fields.insert(__FieldTag::__quota_deferments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for quota_deferments",
                                ));
                            }
                            result.quota_deferments = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__query => {
                            if !fields.insert(__FieldTag::__query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query",
                                ));
                            }
                            result.query = map
                                .next_value::<std::option::Option<crate::model::JobStatistics2>>(
                                )?;
                        }
                        __FieldTag::__load => {
                            if !fields.insert(__FieldTag::__load) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for load",
                                ));
                            }
                            result.load = map
                                .next_value::<std::option::Option<crate::model::JobStatistics3>>(
                                )?;
                        }
                        __FieldTag::__extract => {
                            if !fields.insert(__FieldTag::__extract) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for extract",
                                ));
                            }
                            result.extract = map
                                .next_value::<std::option::Option<crate::model::JobStatistics4>>(
                                )?;
                        }
                        __FieldTag::__copy => {
                            if !fields.insert(__FieldTag::__copy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for copy",
                                ));
                            }
                            result.copy = map
                                .next_value::<std::option::Option<crate::model::CopyJobStatistics>>(
                                )?;
                        }
                        __FieldTag::__total_slot_ms => {
                            if !fields.insert(__FieldTag::__total_slot_ms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_slot_ms",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_slot_ms = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__reservation_id => {
                            if !fields.insert(__FieldTag::__reservation_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reservation_id",
                                ));
                            }
                            result.reservation_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__num_child_jobs => {
                            if !fields.insert(__FieldTag::__num_child_jobs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for num_child_jobs",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.num_child_jobs =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__parent_job_id => {
                            if !fields.insert(__FieldTag::__parent_job_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent_job_id",
                                ));
                            }
                            result.parent_job_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__script_statistics => {
                            if !fields.insert(__FieldTag::__script_statistics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for script_statistics",
                                ));
                            }
                            result.script_statistics = map
                                .next_value::<std::option::Option<crate::model::ScriptStatistics>>(
                                )?;
                        }
                        __FieldTag::__row_level_security_statistics => {
                            if !fields.insert(__FieldTag::__row_level_security_statistics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for row_level_security_statistics",
                                ));
                            }
                            result.row_level_security_statistics = map.next_value::<std::option::Option<crate::model::RowLevelSecurityStatistics>>()?
                                ;
                        }
                        __FieldTag::__data_masking_statistics => {
                            if !fields.insert(__FieldTag::__data_masking_statistics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_masking_statistics",
                                ));
                            }
                            result.data_masking_statistics = map.next_value::<std::option::Option<crate::model::DataMaskingStatistics>>()?
                                ;
                        }
                        __FieldTag::__transaction_info => {
                            if !fields.insert(__FieldTag::__transaction_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transaction_info",
                                ));
                            }
                            result.transaction_info = map.next_value::<std::option::Option<
                                crate::model::job_statistics::TransactionInfo,
                            >>()?;
                        }
                        __FieldTag::__session_info => {
                            if !fields.insert(__FieldTag::__session_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for session_info",
                                ));
                            }
                            result.session_info =
                                map.next_value::<std::option::Option<crate::model::SessionInfo>>()?;
                        }
                        __FieldTag::__final_execution_duration_ms => {
                            if !fields.insert(__FieldTag::__final_execution_duration_ms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for final_execution_duration_ms",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.final_execution_duration_ms =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__edition => {
                            if !fields.insert(__FieldTag::__edition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for edition",
                                ));
                            }
                            result.edition = map.next_value::<std::option::Option<crate::model::ReservationEdition>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::job_statistics::TransactionInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __transaction_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TransactionInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "transactionId" => Ok(__FieldTag::__transaction_id),
                            "transaction_id" => Ok(__FieldTag::__transaction_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::job_statistics::TransactionInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TransactionInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__transaction_id => {
                            if !fields.insert(__FieldTag::__transaction_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transaction_id",
                                ));
                            }
                            result.transaction_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DmlStats {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __inserted_row_count,
            __deleted_row_count,
            __updated_row_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DmlStats")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "insertedRowCount" => Ok(__FieldTag::__inserted_row_count),
                            "inserted_row_count" => Ok(__FieldTag::__inserted_row_count),
                            "deletedRowCount" => Ok(__FieldTag::__deleted_row_count),
                            "deleted_row_count" => Ok(__FieldTag::__deleted_row_count),
                            "updatedRowCount" => Ok(__FieldTag::__updated_row_count),
                            "updated_row_count" => Ok(__FieldTag::__updated_row_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DmlStats;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DmlStats")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__inserted_row_count => {
                            if !fields.insert(__FieldTag::__inserted_row_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inserted_row_count",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.inserted_row_count = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__deleted_row_count => {
                            if !fields.insert(__FieldTag::__deleted_row_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deleted_row_count",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.deleted_row_count = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__updated_row_count => {
                            if !fields.insert(__FieldTag::__updated_row_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for updated_row_count",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.updated_row_count = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::PerformanceInsights {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __avg_previous_execution_ms,
            __stage_performance_standalone_insights,
            __stage_performance_change_insights,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PerformanceInsights")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "avgPreviousExecutionMs" => Ok(__FieldTag::__avg_previous_execution_ms),
                            "avg_previous_execution_ms" => {
                                Ok(__FieldTag::__avg_previous_execution_ms)
                            }
                            "stagePerformanceStandaloneInsights" => {
                                Ok(__FieldTag::__stage_performance_standalone_insights)
                            }
                            "stage_performance_standalone_insights" => {
                                Ok(__FieldTag::__stage_performance_standalone_insights)
                            }
                            "stagePerformanceChangeInsights" => {
                                Ok(__FieldTag::__stage_performance_change_insights)
                            }
                            "stage_performance_change_insights" => {
                                Ok(__FieldTag::__stage_performance_change_insights)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::PerformanceInsights;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PerformanceInsights")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__avg_previous_execution_ms => {
                            if !fields.insert(__FieldTag::__avg_previous_execution_ms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for avg_previous_execution_ms",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.avg_previous_execution_ms =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__stage_performance_standalone_insights => {
                            if !fields.insert(__FieldTag::__stage_performance_standalone_insights) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stage_performance_standalone_insights",
                                ));
                            }
                            result.stage_performance_standalone_insights = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::StagePerformanceStandaloneInsight>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__stage_performance_change_insights => {
                            if !fields.insert(__FieldTag::__stage_performance_change_insights) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stage_performance_change_insights",
                                ));
                            }
                            result.stage_performance_change_insights = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::StagePerformanceChangeInsight>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::StagePerformanceChangeInsight {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __stage_id,
            __input_data_change,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StagePerformanceChangeInsight")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "stageId" => Ok(__FieldTag::__stage_id),
                            "stage_id" => Ok(__FieldTag::__stage_id),
                            "inputDataChange" => Ok(__FieldTag::__input_data_change),
                            "input_data_change" => Ok(__FieldTag::__input_data_change),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::StagePerformanceChangeInsight;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StagePerformanceChangeInsight")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__stage_id => {
                            if !fields.insert(__FieldTag::__stage_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stage_id",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.stage_id = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__input_data_change => {
                            if !fields.insert(__FieldTag::__input_data_change) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input_data_change",
                                ));
                            }
                            result.input_data_change = map
                                .next_value::<std::option::Option<crate::model::InputDataChange>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::InputDataChange {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __records_read_diff_percentage,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InputDataChange")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "recordsReadDiffPercentage" => {
                                Ok(__FieldTag::__records_read_diff_percentage)
                            }
                            "records_read_diff_percentage" => {
                                Ok(__FieldTag::__records_read_diff_percentage)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::InputDataChange;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InputDataChange")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__records_read_diff_percentage => {
                            if !fields.insert(__FieldTag::__records_read_diff_percentage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for records_read_diff_percentage",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.records_read_diff_percentage =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::StagePerformanceStandaloneInsight {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __stage_id,
            __slot_contention,
            __insufficient_shuffle_quota,
            __bi_engine_reasons,
            __high_cardinality_joins,
            __partition_skew,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StagePerformanceStandaloneInsight")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "stageId" => Ok(__FieldTag::__stage_id),
                            "stage_id" => Ok(__FieldTag::__stage_id),
                            "slotContention" => Ok(__FieldTag::__slot_contention),
                            "slot_contention" => Ok(__FieldTag::__slot_contention),
                            "insufficientShuffleQuota" => {
                                Ok(__FieldTag::__insufficient_shuffle_quota)
                            }
                            "insufficient_shuffle_quota" => {
                                Ok(__FieldTag::__insufficient_shuffle_quota)
                            }
                            "biEngineReasons" => Ok(__FieldTag::__bi_engine_reasons),
                            "bi_engine_reasons" => Ok(__FieldTag::__bi_engine_reasons),
                            "highCardinalityJoins" => Ok(__FieldTag::__high_cardinality_joins),
                            "high_cardinality_joins" => Ok(__FieldTag::__high_cardinality_joins),
                            "partitionSkew" => Ok(__FieldTag::__partition_skew),
                            "partition_skew" => Ok(__FieldTag::__partition_skew),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::StagePerformanceStandaloneInsight;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StagePerformanceStandaloneInsight")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__stage_id => {
                            if !fields.insert(__FieldTag::__stage_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stage_id",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.stage_id = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__slot_contention => {
                            if !fields.insert(__FieldTag::__slot_contention) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for slot_contention",
                                ));
                            }
                            result.slot_contention =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__insufficient_shuffle_quota => {
                            if !fields.insert(__FieldTag::__insufficient_shuffle_quota) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for insufficient_shuffle_quota",
                                ));
                            }
                            result.insufficient_shuffle_quota =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__bi_engine_reasons => {
                            if !fields.insert(__FieldTag::__bi_engine_reasons) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bi_engine_reasons",
                                ));
                            }
                            result.bi_engine_reasons =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::BiEngineReason>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__high_cardinality_joins => {
                            if !fields.insert(__FieldTag::__high_cardinality_joins) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for high_cardinality_joins",
                                ));
                            }
                            result.high_cardinality_joins = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::HighCardinalityJoin>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__partition_skew => {
                            if !fields.insert(__FieldTag::__partition_skew) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for partition_skew",
                                ));
                            }
                            result.partition_skew = map
                                .next_value::<std::option::Option<crate::model::PartitionSkew>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::HighCardinalityJoin {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __left_rows,
            __right_rows,
            __output_rows,
            __step_index,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HighCardinalityJoin")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "leftRows" => Ok(__FieldTag::__left_rows),
                            "left_rows" => Ok(__FieldTag::__left_rows),
                            "rightRows" => Ok(__FieldTag::__right_rows),
                            "right_rows" => Ok(__FieldTag::__right_rows),
                            "outputRows" => Ok(__FieldTag::__output_rows),
                            "output_rows" => Ok(__FieldTag::__output_rows),
                            "stepIndex" => Ok(__FieldTag::__step_index),
                            "step_index" => Ok(__FieldTag::__step_index),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::HighCardinalityJoin;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HighCardinalityJoin")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__left_rows => {
                            if !fields.insert(__FieldTag::__left_rows) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for left_rows",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.left_rows = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__right_rows => {
                            if !fields.insert(__FieldTag::__right_rows) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for right_rows",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.right_rows = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__output_rows => {
                            if !fields.insert(__FieldTag::__output_rows) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_rows",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.output_rows = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__step_index => {
                            if !fields.insert(__FieldTag::__step_index) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for step_index",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.step_index = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::PartitionSkew {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __skew_sources,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PartitionSkew")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "skewSources" => Ok(__FieldTag::__skew_sources),
                            "skew_sources" => Ok(__FieldTag::__skew_sources),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::PartitionSkew;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PartitionSkew")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__skew_sources => {
                            if !fields.insert(__FieldTag::__skew_sources) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for skew_sources",
                                ));
                            }
                            result.skew_sources = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::partition_skew::SkewSource>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::partition_skew::SkewSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __stage_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SkewSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "stageId" => Ok(__FieldTag::__stage_id),
                            "stage_id" => Ok(__FieldTag::__stage_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::partition_skew::SkewSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SkewSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__stage_id => {
                            if !fields.insert(__FieldTag::__stage_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stage_id",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.stage_id = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SparkStatistics {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __spark_job_id,
            __spark_job_location,
            __endpoints,
            __logging_info,
            __kms_key_name,
            __gcs_staging_bucket,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SparkStatistics")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sparkJobId" => Ok(__FieldTag::__spark_job_id),
                            "spark_job_id" => Ok(__FieldTag::__spark_job_id),
                            "sparkJobLocation" => Ok(__FieldTag::__spark_job_location),
                            "spark_job_location" => Ok(__FieldTag::__spark_job_location),
                            "endpoints" => Ok(__FieldTag::__endpoints),
                            "loggingInfo" => Ok(__FieldTag::__logging_info),
                            "logging_info" => Ok(__FieldTag::__logging_info),
                            "kmsKeyName" => Ok(__FieldTag::__kms_key_name),
                            "kms_key_name" => Ok(__FieldTag::__kms_key_name),
                            "gcsStagingBucket" => Ok(__FieldTag::__gcs_staging_bucket),
                            "gcs_staging_bucket" => Ok(__FieldTag::__gcs_staging_bucket),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SparkStatistics;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SparkStatistics")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__spark_job_id => {
                            if !fields.insert(__FieldTag::__spark_job_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for spark_job_id",
                                ));
                            }
                            result.spark_job_id =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__spark_job_location => {
                            if !fields.insert(__FieldTag::__spark_job_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for spark_job_location",
                                ));
                            }
                            result.spark_job_location =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__endpoints => {
                            if !fields.insert(__FieldTag::__endpoints) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for endpoints",
                                ));
                            }
                            result.endpoints = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__logging_info => {
                            if !fields.insert(__FieldTag::__logging_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logging_info",
                                ));
                            }
                            result.logging_info =
                                map.next_value::<std::option::Option<
                                    crate::model::spark_statistics::LoggingInfo,
                                >>()?;
                        }
                        __FieldTag::__kms_key_name => {
                            if !fields.insert(__FieldTag::__kms_key_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key_name",
                                ));
                            }
                            result.kms_key_name =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__gcs_staging_bucket => {
                            if !fields.insert(__FieldTag::__gcs_staging_bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_staging_bucket",
                                ));
                            }
                            result.gcs_staging_bucket =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::spark_statistics::LoggingInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __resource_type,
            __project_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LoggingInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resourceType" => Ok(__FieldTag::__resource_type),
                            "resource_type" => Ok(__FieldTag::__resource_type),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::spark_statistics::LoggingInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LoggingInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__resource_type => {
                            if !fields.insert(__FieldTag::__resource_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_type",
                                ));
                            }
                            result.resource_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MaterializedViewStatistics {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __materialized_view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MaterializedViewStatistics")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "materializedView" => Ok(__FieldTag::__materialized_view),
                            "materialized_view" => Ok(__FieldTag::__materialized_view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MaterializedViewStatistics;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MaterializedViewStatistics")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__materialized_view => {
                            if !fields.insert(__FieldTag::__materialized_view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for materialized_view",
                                ));
                            }
                            result.materialized_view =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::MaterializedView>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MaterializedView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __table_reference,
            __chosen,
            __estimated_bytes_saved,
            __rejected_reason,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MaterializedView")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "tableReference" => Ok(__FieldTag::__table_reference),
                            "table_reference" => Ok(__FieldTag::__table_reference),
                            "chosen" => Ok(__FieldTag::__chosen),
                            "estimatedBytesSaved" => Ok(__FieldTag::__estimated_bytes_saved),
                            "estimated_bytes_saved" => Ok(__FieldTag::__estimated_bytes_saved),
                            "rejectedReason" => Ok(__FieldTag::__rejected_reason),
                            "rejected_reason" => Ok(__FieldTag::__rejected_reason),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MaterializedView;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MaterializedView")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__table_reference => {
                            if !fields.insert(__FieldTag::__table_reference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_reference",
                                ));
                            }
                            result.table_reference = map
                                .next_value::<std::option::Option<crate::model::TableReference>>(
                                )?;
                        }
                        __FieldTag::__chosen => {
                            if !fields.insert(__FieldTag::__chosen) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for chosen",
                                ));
                            }
                            result.chosen = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__estimated_bytes_saved => {
                            if !fields.insert(__FieldTag::__estimated_bytes_saved) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for estimated_bytes_saved",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.estimated_bytes_saved = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__rejected_reason => {
                            if !fields.insert(__FieldTag::__rejected_reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rejected_reason",
                                ));
                            }
                            result.rejected_reason = map.next_value::<std::option::Option<
                                crate::model::materialized_view::RejectedReason,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::TableMetadataCacheUsage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __table_reference,
            __unused_reason,
            __explanation,
            __staleness,
            __table_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TableMetadataCacheUsage")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "tableReference" => Ok(__FieldTag::__table_reference),
                            "table_reference" => Ok(__FieldTag::__table_reference),
                            "unusedReason" => Ok(__FieldTag::__unused_reason),
                            "unused_reason" => Ok(__FieldTag::__unused_reason),
                            "explanation" => Ok(__FieldTag::__explanation),
                            "staleness" => Ok(__FieldTag::__staleness),
                            "tableType" => Ok(__FieldTag::__table_type),
                            "table_type" => Ok(__FieldTag::__table_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::TableMetadataCacheUsage;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TableMetadataCacheUsage")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__table_reference => {
                            if !fields.insert(__FieldTag::__table_reference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_reference",
                                ));
                            }
                            result.table_reference = map
                                .next_value::<std::option::Option<crate::model::TableReference>>(
                                )?;
                        }
                        __FieldTag::__unused_reason => {
                            if !fields.insert(__FieldTag::__unused_reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unused_reason",
                                ));
                            }
                            result.unused_reason = map.next_value::<std::option::Option<
                                crate::model::table_metadata_cache_usage::UnusedReason,
                            >>()?;
                        }
                        __FieldTag::__explanation => {
                            if !fields.insert(__FieldTag::__explanation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for explanation",
                                ));
                            }
                            result.explanation =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__staleness => {
                            if !fields.insert(__FieldTag::__staleness) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for staleness",
                                ));
                            }
                            result.staleness =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__table_type => {
                            if !fields.insert(__FieldTag::__table_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_type",
                                ));
                            }
                            result.table_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MetadataCacheStatistics {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __table_metadata_cache_usage,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MetadataCacheStatistics")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "tableMetadataCacheUsage" => {
                                Ok(__FieldTag::__table_metadata_cache_usage)
                            }
                            "table_metadata_cache_usage" => {
                                Ok(__FieldTag::__table_metadata_cache_usage)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MetadataCacheStatistics;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MetadataCacheStatistics")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__table_metadata_cache_usage => {
                            if !fields.insert(__FieldTag::__table_metadata_cache_usage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_metadata_cache_usage",
                                ));
                            }
                            result.table_metadata_cache_usage = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::TableMetadataCacheUsage>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::JobStatus {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __error_result,
            __errors,
            __state,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for JobStatus")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "errorResult" => Ok(__FieldTag::__error_result),
                            "error_result" => Ok(__FieldTag::__error_result),
                            "errors" => Ok(__FieldTag::__errors),
                            "state" => Ok(__FieldTag::__state),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::JobStatus;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct JobStatus")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__error_result => {
                            if !fields.insert(__FieldTag::__error_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_result",
                                ));
                            }
                            result.error_result =
                                map.next_value::<std::option::Option<crate::model::ErrorProto>>()?;
                        }
                        __FieldTag::__errors => {
                            if !fields.insert(__FieldTag::__errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for errors",
                                ));
                            }
                            result.errors = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ErrorProto>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::LocationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __legacy_location_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LocationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "legacyLocationId" => Ok(__FieldTag::__legacy_location_id),
                            "legacy_location_id" => Ok(__FieldTag::__legacy_location_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::LocationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LocationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__legacy_location_id => {
                            if !fields.insert(__FieldTag::__legacy_location_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for legacy_location_id",
                                ));
                            }
                            result.legacy_location_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RemoteModelInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __endpoint,
            __remote_service_type,
            __connection,
            __max_batching_rows,
            __remote_model_version,
            __speech_recognizer,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RemoteModelInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "endpoint" => Ok(__FieldTag::__endpoint),
                            "remoteServiceType" => Ok(__FieldTag::__remote_service_type),
                            "remote_service_type" => Ok(__FieldTag::__remote_service_type),
                            "connection" => Ok(__FieldTag::__connection),
                            "maxBatchingRows" => Ok(__FieldTag::__max_batching_rows),
                            "max_batching_rows" => Ok(__FieldTag::__max_batching_rows),
                            "remoteModelVersion" => Ok(__FieldTag::__remote_model_version),
                            "remote_model_version" => Ok(__FieldTag::__remote_model_version),
                            "speechRecognizer" => Ok(__FieldTag::__speech_recognizer),
                            "speech_recognizer" => Ok(__FieldTag::__speech_recognizer),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RemoteModelInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RemoteModelInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__endpoint => {
                            if !fields.insert(__FieldTag::__endpoint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for endpoint",
                                ));
                            }
                            if result.remote_service.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `remote_service`, a oneof with full ID .google.cloud.bigquery.v2.RemoteModelInfo.endpoint, latest field was endpoint",
                                ));
                            }
                            result.remote_service = std::option::Option::Some(
                                crate::model::remote_model_info::RemoteService::Endpoint(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__remote_service_type => {
                            if !fields.insert(__FieldTag::__remote_service_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for remote_service_type",
                                ));
                            }
                            if result.remote_service.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `remote_service`, a oneof with full ID .google.cloud.bigquery.v2.RemoteModelInfo.remote_service_type, latest field was remoteServiceType",
                                ));
                            }
                            result.remote_service = std::option::Option::Some(
                                crate::model::remote_model_info::RemoteService::RemoteServiceType(
                                    map.next_value::<std::option::Option<
                                        crate::model::remote_model_info::RemoteServiceType,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__connection => {
                            if !fields.insert(__FieldTag::__connection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection",
                                ));
                            }
                            result.connection = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__max_batching_rows => {
                            if !fields.insert(__FieldTag::__max_batching_rows) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_batching_rows",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_batching_rows =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__remote_model_version => {
                            if !fields.insert(__FieldTag::__remote_model_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for remote_model_version",
                                ));
                            }
                            result.remote_model_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__speech_recognizer => {
                            if !fields.insert(__FieldTag::__speech_recognizer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for speech_recognizer",
                                ));
                            }
                            result.speech_recognizer = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::TransformColumn {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __type,
            __transform_sql,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TransformColumn")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "type" => Ok(__FieldTag::__type),
                            "transformSql" => Ok(__FieldTag::__transform_sql),
                            "transform_sql" => Ok(__FieldTag::__transform_sql),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::TransformColumn;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TransformColumn")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::StandardSqlDataType>>()?
                                ;
                        }
                        __FieldTag::__transform_sql => {
                            if !fields.insert(__FieldTag::__transform_sql) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transform_sql",
                                ));
                            }
                            result.transform_sql = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Model {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __etag,
            __model_reference,
            __creation_time,
            __last_modified_time,
            __description,
            __friendly_name,
            __labels,
            __expiration_time,
            __location,
            __encryption_configuration,
            __model_type,
            __training_runs,
            __feature_columns,
            __label_columns,
            __transform_columns,
            __hparam_search_spaces,
            __default_trial_id,
            __hparam_trials,
            __optimal_trial_ids,
            __remote_model_info,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Model")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "etag" => Ok(__FieldTag::__etag),
                            "modelReference" => Ok(__FieldTag::__model_reference),
                            "model_reference" => Ok(__FieldTag::__model_reference),
                            "creationTime" => Ok(__FieldTag::__creation_time),
                            "creation_time" => Ok(__FieldTag::__creation_time),
                            "lastModifiedTime" => Ok(__FieldTag::__last_modified_time),
                            "last_modified_time" => Ok(__FieldTag::__last_modified_time),
                            "description" => Ok(__FieldTag::__description),
                            "friendlyName" => Ok(__FieldTag::__friendly_name),
                            "friendly_name" => Ok(__FieldTag::__friendly_name),
                            "labels" => Ok(__FieldTag::__labels),
                            "expirationTime" => Ok(__FieldTag::__expiration_time),
                            "expiration_time" => Ok(__FieldTag::__expiration_time),
                            "location" => Ok(__FieldTag::__location),
                            "encryptionConfiguration" => Ok(__FieldTag::__encryption_configuration),
                            "encryption_configuration" => {
                                Ok(__FieldTag::__encryption_configuration)
                            }
                            "modelType" => Ok(__FieldTag::__model_type),
                            "model_type" => Ok(__FieldTag::__model_type),
                            "trainingRuns" => Ok(__FieldTag::__training_runs),
                            "training_runs" => Ok(__FieldTag::__training_runs),
                            "featureColumns" => Ok(__FieldTag::__feature_columns),
                            "feature_columns" => Ok(__FieldTag::__feature_columns),
                            "labelColumns" => Ok(__FieldTag::__label_columns),
                            "label_columns" => Ok(__FieldTag::__label_columns),
                            "transformColumns" => Ok(__FieldTag::__transform_columns),
                            "transform_columns" => Ok(__FieldTag::__transform_columns),
                            "hparamSearchSpaces" => Ok(__FieldTag::__hparam_search_spaces),
                            "hparam_search_spaces" => Ok(__FieldTag::__hparam_search_spaces),
                            "defaultTrialId" => Ok(__FieldTag::__default_trial_id),
                            "default_trial_id" => Ok(__FieldTag::__default_trial_id),
                            "hparamTrials" => Ok(__FieldTag::__hparam_trials),
                            "hparam_trials" => Ok(__FieldTag::__hparam_trials),
                            "optimalTrialIds" => Ok(__FieldTag::__optimal_trial_ids),
                            "optimal_trial_ids" => Ok(__FieldTag::__optimal_trial_ids),
                            "remoteModelInfo" => Ok(__FieldTag::__remote_model_info),
                            "remote_model_info" => Ok(__FieldTag::__remote_model_info),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Model;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Model")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__model_reference => {
                            if !fields.insert(__FieldTag::__model_reference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model_reference",
                                ));
                            }
                            result.model_reference = map
                                .next_value::<std::option::Option<crate::model::ModelReference>>(
                                )?;
                        }
                        __FieldTag::__creation_time => {
                            if !fields.insert(__FieldTag::__creation_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for creation_time",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.creation_time =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__last_modified_time => {
                            if !fields.insert(__FieldTag::__last_modified_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_modified_time",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.last_modified_time =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__friendly_name => {
                            if !fields.insert(__FieldTag::__friendly_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for friendly_name",
                                ));
                            }
                            result.friendly_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__expiration_time => {
                            if !fields.insert(__FieldTag::__expiration_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expiration_time",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.expiration_time =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__encryption_configuration => {
                            if !fields.insert(__FieldTag::__encryption_configuration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption_configuration",
                                ));
                            }
                            result.encryption_configuration = map.next_value::<std::option::Option<crate::model::EncryptionConfiguration>>()?
                                ;
                        }
                        __FieldTag::__model_type => {
                            if !fields.insert(__FieldTag::__model_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model_type",
                                ));
                            }
                            result.model_type = map
                                .next_value::<std::option::Option<crate::model::model::ModelType>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__training_runs => {
                            if !fields.insert(__FieldTag::__training_runs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for training_runs",
                                ));
                            }
                            result.training_runs = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::model::TrainingRun>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__feature_columns => {
                            if !fields.insert(__FieldTag::__feature_columns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for feature_columns",
                                ));
                            }
                            result.feature_columns =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::StandardSqlField>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__label_columns => {
                            if !fields.insert(__FieldTag::__label_columns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for label_columns",
                                ));
                            }
                            result.label_columns =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::StandardSqlField>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__transform_columns => {
                            if !fields.insert(__FieldTag::__transform_columns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transform_columns",
                                ));
                            }
                            result.transform_columns =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::TransformColumn>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__hparam_search_spaces => {
                            if !fields.insert(__FieldTag::__hparam_search_spaces) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hparam_search_spaces",
                                ));
                            }
                            result.hparam_search_spaces = map.next_value::<std::option::Option<crate::model::model::HparamSearchSpaces>>()?
                                ;
                        }
                        __FieldTag::__default_trial_id => {
                            if !fields.insert(__FieldTag::__default_trial_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_trial_id",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.default_trial_id =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__hparam_trials => {
                            if !fields.insert(__FieldTag::__hparam_trials) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hparam_trials",
                                ));
                            }
                            result.hparam_trials = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::model::HparamTuningTrial>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__optimal_trial_ids => {
                            if !fields.insert(__FieldTag::__optimal_trial_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optimal_trial_ids",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i64>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I64>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.optimal_trial_ids =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__remote_model_info => {
                            if !fields.insert(__FieldTag::__remote_model_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for remote_model_info",
                                ));
                            }
                            result.remote_model_info = map
                                .next_value::<std::option::Option<crate::model::RemoteModelInfo>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::model::SeasonalPeriod {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SeasonalPeriod")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::model::SeasonalPeriod;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SeasonalPeriod")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::model::KmeansEnums {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for KmeansEnums")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::model::KmeansEnums;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct KmeansEnums")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::model::BoostedTreeOptionEnums {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BoostedTreeOptionEnums")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::model::BoostedTreeOptionEnums;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BoostedTreeOptionEnums")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::model::HparamTuningEnums {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HparamTuningEnums")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::model::HparamTuningEnums;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HparamTuningEnums")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::model::RegressionMetrics {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __mean_absolute_error,
            __mean_squared_error,
            __mean_squared_log_error,
            __median_absolute_error,
            __r_squared,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RegressionMetrics")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "meanAbsoluteError" => Ok(__FieldTag::__mean_absolute_error),
                            "mean_absolute_error" => Ok(__FieldTag::__mean_absolute_error),
                            "meanSquaredError" => Ok(__FieldTag::__mean_squared_error),
                            "mean_squared_error" => Ok(__FieldTag::__mean_squared_error),
                            "meanSquaredLogError" => Ok(__FieldTag::__mean_squared_log_error),
                            "mean_squared_log_error" => Ok(__FieldTag::__mean_squared_log_error),
                            "medianAbsoluteError" => Ok(__FieldTag::__median_absolute_error),
                            "median_absolute_error" => Ok(__FieldTag::__median_absolute_error),
                            "rSquared" => Ok(__FieldTag::__r_squared),
                            "r_squared" => Ok(__FieldTag::__r_squared),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::model::RegressionMetrics;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RegressionMetrics")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__mean_absolute_error => {
                            if !fields.insert(__FieldTag::__mean_absolute_error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mean_absolute_error",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.mean_absolute_error = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__mean_squared_error => {
                            if !fields.insert(__FieldTag::__mean_squared_error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mean_squared_error",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.mean_squared_error = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__mean_squared_log_error => {
                            if !fields.insert(__FieldTag::__mean_squared_log_error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mean_squared_log_error",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.mean_squared_log_error = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__median_absolute_error => {
                            if !fields.insert(__FieldTag::__median_absolute_error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for median_absolute_error",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.median_absolute_error = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__r_squared => {
                            if !fields.insert(__FieldTag::__r_squared) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for r_squared",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.r_squared = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::model::AggregateClassificationMetrics {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __precision,
            __recall,
            __accuracy,
            __threshold,
            __f1_score,
            __log_loss,
            __roc_auc,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AggregateClassificationMetrics")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "precision" => Ok(__FieldTag::__precision),
                            "recall" => Ok(__FieldTag::__recall),
                            "accuracy" => Ok(__FieldTag::__accuracy),
                            "threshold" => Ok(__FieldTag::__threshold),
                            "f1Score" => Ok(__FieldTag::__f1_score),
                            "f1_score" => Ok(__FieldTag::__f1_score),
                            "logLoss" => Ok(__FieldTag::__log_loss),
                            "log_loss" => Ok(__FieldTag::__log_loss),
                            "rocAuc" => Ok(__FieldTag::__roc_auc),
                            "roc_auc" => Ok(__FieldTag::__roc_auc),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::model::AggregateClassificationMetrics;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AggregateClassificationMetrics")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__precision => {
                            if !fields.insert(__FieldTag::__precision) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for precision",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.precision = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__recall => {
                            if !fields.insert(__FieldTag::__recall) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recall",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.recall = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__accuracy => {
                            if !fields.insert(__FieldTag::__accuracy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for accuracy",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.accuracy = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__threshold => {
                            if !fields.insert(__FieldTag::__threshold) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for threshold",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.threshold = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__f1_score => {
                            if !fields.insert(__FieldTag::__f1_score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for f1_score",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.f1_score = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__log_loss => {
                            if !fields.insert(__FieldTag::__log_loss) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for log_loss",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.log_loss = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__roc_auc => {
                            if !fields.insert(__FieldTag::__roc_auc) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for roc_auc",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.roc_auc = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::model::BinaryClassificationMetrics {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __aggregate_classification_metrics,
            __binary_confusion_matrix_list,
            __positive_label,
            __negative_label,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BinaryClassificationMetrics")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "aggregateClassificationMetrics" => {
                                Ok(__FieldTag::__aggregate_classification_metrics)
                            }
                            "aggregate_classification_metrics" => {
                                Ok(__FieldTag::__aggregate_classification_metrics)
                            }
                            "binaryConfusionMatrixList" => {
                                Ok(__FieldTag::__binary_confusion_matrix_list)
                            }
                            "binary_confusion_matrix_list" => {
                                Ok(__FieldTag::__binary_confusion_matrix_list)
                            }
                            "positiveLabel" => Ok(__FieldTag::__positive_label),
                            "positive_label" => Ok(__FieldTag::__positive_label),
                            "negativeLabel" => Ok(__FieldTag::__negative_label),
                            "negative_label" => Ok(__FieldTag::__negative_label),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::model::BinaryClassificationMetrics;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BinaryClassificationMetrics")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__aggregate_classification_metrics => {
                            if !fields.insert(__FieldTag::__aggregate_classification_metrics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aggregate_classification_metrics",
                                ));
                            }
                            result.aggregate_classification_metrics = map
                                .next_value::<std::option::Option<
                                    crate::model::model::AggregateClassificationMetrics,
                                >>()?;
                        }
                        __FieldTag::__binary_confusion_matrix_list => {
                            if !fields.insert(__FieldTag::__binary_confusion_matrix_list) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for binary_confusion_matrix_list",
                                ));
                            }
                            result.binary_confusion_matrix_list = map.next_value::<std::option::Option<std::vec::Vec<crate::model::model::binary_classification_metrics::BinaryConfusionMatrix>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__positive_label => {
                            if !fields.insert(__FieldTag::__positive_label) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for positive_label",
                                ));
                            }
                            result.positive_label = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__negative_label => {
                            if !fields.insert(__FieldTag::__negative_label) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for negative_label",
                                ));
                            }
                            result.negative_label = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de>
    for super::model::binary_classification_metrics::BinaryConfusionMatrix
{
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __positive_class_threshold,
            __true_positives,
            __false_positives,
            __true_negatives,
            __false_negatives,
            __precision,
            __recall,
            __f1_score,
            __accuracy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BinaryConfusionMatrix")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "positiveClassThreshold" => Ok(__FieldTag::__positive_class_threshold),
                            "positive_class_threshold" => {
                                Ok(__FieldTag::__positive_class_threshold)
                            }
                            "truePositives" => Ok(__FieldTag::__true_positives),
                            "true_positives" => Ok(__FieldTag::__true_positives),
                            "falsePositives" => Ok(__FieldTag::__false_positives),
                            "false_positives" => Ok(__FieldTag::__false_positives),
                            "trueNegatives" => Ok(__FieldTag::__true_negatives),
                            "true_negatives" => Ok(__FieldTag::__true_negatives),
                            "falseNegatives" => Ok(__FieldTag::__false_negatives),
                            "false_negatives" => Ok(__FieldTag::__false_negatives),
                            "precision" => Ok(__FieldTag::__precision),
                            "recall" => Ok(__FieldTag::__recall),
                            "f1Score" => Ok(__FieldTag::__f1_score),
                            "f1_score" => Ok(__FieldTag::__f1_score),
                            "accuracy" => Ok(__FieldTag::__accuracy),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::model::binary_classification_metrics::BinaryConfusionMatrix;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BinaryConfusionMatrix")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__positive_class_threshold => {
                            if !fields.insert(__FieldTag::__positive_class_threshold) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for positive_class_threshold",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.positive_class_threshold = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__true_positives => {
                            if !fields.insert(__FieldTag::__true_positives) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for true_positives",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.true_positives = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__false_positives => {
                            if !fields.insert(__FieldTag::__false_positives) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for false_positives",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.false_positives = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__true_negatives => {
                            if !fields.insert(__FieldTag::__true_negatives) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for true_negatives",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.true_negatives = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__false_negatives => {
                            if !fields.insert(__FieldTag::__false_negatives) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for false_negatives",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.false_negatives = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__precision => {
                            if !fields.insert(__FieldTag::__precision) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for precision",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.precision = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__recall => {
                            if !fields.insert(__FieldTag::__recall) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recall",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.recall = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__f1_score => {
                            if !fields.insert(__FieldTag::__f1_score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for f1_score",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.f1_score = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__accuracy => {
                            if !fields.insert(__FieldTag::__accuracy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for accuracy",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.accuracy = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::model::MultiClassClassificationMetrics {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __aggregate_classification_metrics,
            __confusion_matrix_list,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MultiClassClassificationMetrics")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "aggregateClassificationMetrics" => {
                                Ok(__FieldTag::__aggregate_classification_metrics)
                            }
                            "aggregate_classification_metrics" => {
                                Ok(__FieldTag::__aggregate_classification_metrics)
                            }
                            "confusionMatrixList" => Ok(__FieldTag::__confusion_matrix_list),
                            "confusion_matrix_list" => Ok(__FieldTag::__confusion_matrix_list),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::model::MultiClassClassificationMetrics;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MultiClassClassificationMetrics")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__aggregate_classification_metrics => {
                            if !fields.insert(__FieldTag::__aggregate_classification_metrics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aggregate_classification_metrics",
                                ));
                            }
                            result.aggregate_classification_metrics = map
                                .next_value::<std::option::Option<
                                    crate::model::model::AggregateClassificationMetrics,
                                >>()?;
                        }
                        __FieldTag::__confusion_matrix_list => {
                            if !fields.insert(__FieldTag::__confusion_matrix_list) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for confusion_matrix_list",
                                ));
                            }
                            result.confusion_matrix_list = map.next_value::<std::option::Option<std::vec::Vec<crate::model::model::multi_class_classification_metrics::ConfusionMatrix>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de>
    for super::model::multi_class_classification_metrics::ConfusionMatrix
{
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __confidence_threshold,
            __rows,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConfusionMatrix")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "confidenceThreshold" => Ok(__FieldTag::__confidence_threshold),
                            "confidence_threshold" => Ok(__FieldTag::__confidence_threshold),
                            "rows" => Ok(__FieldTag::__rows),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::model::multi_class_classification_metrics::ConfusionMatrix;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConfusionMatrix")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__confidence_threshold => {
                            if !fields.insert(__FieldTag::__confidence_threshold) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for confidence_threshold",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.confidence_threshold = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__rows => {
                            if !fields.insert(__FieldTag::__rows) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rows",
                                ));
                            }
                            result.rows = map.next_value::<std::option::Option<std::vec::Vec<crate::model::model::multi_class_classification_metrics::confusion_matrix::Row>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de>
    for super::model::multi_class_classification_metrics::confusion_matrix::Entry
{
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __predicted_label,
            __item_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Entry")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "predictedLabel" => Ok(__FieldTag::__predicted_label),
                            "predicted_label" => Ok(__FieldTag::__predicted_label),
                            "itemCount" => Ok(__FieldTag::__item_count),
                            "item_count" => Ok(__FieldTag::__item_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::model::multi_class_classification_metrics::confusion_matrix::Entry;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Entry")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__predicted_label => {
                            if !fields.insert(__FieldTag::__predicted_label) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for predicted_label",
                                ));
                            }
                            result.predicted_label = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__item_count => {
                            if !fields.insert(__FieldTag::__item_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for item_count",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.item_count = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de>
    for super::model::multi_class_classification_metrics::confusion_matrix::Row
{
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __actual_label,
            __entries,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Row")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "actualLabel" => Ok(__FieldTag::__actual_label),
                            "actual_label" => Ok(__FieldTag::__actual_label),
                            "entries" => Ok(__FieldTag::__entries),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::model::multi_class_classification_metrics::confusion_matrix::Row;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Row")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__actual_label => {
                            if !fields.insert(__FieldTag::__actual_label) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for actual_label",
                                ));
                            }
                            result.actual_label = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entries => {
                            if !fields.insert(__FieldTag::__entries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entries",
                                ));
                            }
                            result.entries = map.next_value::<std::option::Option<std::vec::Vec<crate::model::model::multi_class_classification_metrics::confusion_matrix::Entry>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::model::ClusteringMetrics {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __davies_bouldin_index,
            __mean_squared_distance,
            __clusters,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ClusteringMetrics")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "daviesBouldinIndex" => Ok(__FieldTag::__davies_bouldin_index),
                            "davies_bouldin_index" => Ok(__FieldTag::__davies_bouldin_index),
                            "meanSquaredDistance" => Ok(__FieldTag::__mean_squared_distance),
                            "mean_squared_distance" => Ok(__FieldTag::__mean_squared_distance),
                            "clusters" => Ok(__FieldTag::__clusters),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::model::ClusteringMetrics;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ClusteringMetrics")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__davies_bouldin_index => {
                            if !fields.insert(__FieldTag::__davies_bouldin_index) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for davies_bouldin_index",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.davies_bouldin_index = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__mean_squared_distance => {
                            if !fields.insert(__FieldTag::__mean_squared_distance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mean_squared_distance",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.mean_squared_distance = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__clusters => {
                            if !fields.insert(__FieldTag::__clusters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for clusters",
                                ));
                            }
                            result.clusters = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::model::clustering_metrics::Cluster>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::model::clustering_metrics::Cluster {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __centroid_id,
            __feature_values,
            __count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Cluster")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "centroidId" => Ok(__FieldTag::__centroid_id),
                            "centroid_id" => Ok(__FieldTag::__centroid_id),
                            "featureValues" => Ok(__FieldTag::__feature_values),
                            "feature_values" => Ok(__FieldTag::__feature_values),
                            "count" => Ok(__FieldTag::__count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::model::clustering_metrics::Cluster;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Cluster")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__centroid_id => {
                            if !fields.insert(__FieldTag::__centroid_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for centroid_id",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.centroid_id = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__feature_values => {
                            if !fields.insert(__FieldTag::__feature_values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for feature_values",
                                ));
                            }
                            result.feature_values = map.next_value::<std::option::Option<std::vec::Vec<crate::model::model::clustering_metrics::cluster::FeatureValue>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__count => {
                            if !fields.insert(__FieldTag::__count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for count",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.count = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::model::clustering_metrics::cluster::FeatureValue {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __feature_column,
            __numerical_value,
            __categorical_value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FeatureValue")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "featureColumn" => Ok(__FieldTag::__feature_column),
                            "feature_column" => Ok(__FieldTag::__feature_column),
                            "numericalValue" => Ok(__FieldTag::__numerical_value),
                            "numerical_value" => Ok(__FieldTag::__numerical_value),
                            "categoricalValue" => Ok(__FieldTag::__categorical_value),
                            "categorical_value" => Ok(__FieldTag::__categorical_value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::model::clustering_metrics::cluster::FeatureValue;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FeatureValue")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__feature_column => {
                            if !fields.insert(__FieldTag::__feature_column) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for feature_column",
                                ));
                            }
                            result.feature_column = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__numerical_value => {
                            if !fields.insert(__FieldTag::__numerical_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for numerical_value",
                                ));
                            }
                            struct __With(std::option::Option<std::boxed::Box<wkt::DoubleValue>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::boxed::Box<wkt::internal::F64>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.cloud.bigquery.v2.Model.ClusteringMetrics.Cluster.FeatureValue.numerical_value, latest field was numericalValue",
                                ));
                            }
                            result.value = std::option::Option::Some(
                                crate::model::model::clustering_metrics::cluster::feature_value::Value::NumericalValue(
                                    map.next_value::<__With>()?.0.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__categorical_value => {
                            if !fields.insert(__FieldTag::__categorical_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for categorical_value",
                                ));
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.cloud.bigquery.v2.Model.ClusteringMetrics.Cluster.FeatureValue.categorical_value, latest field was categoricalValue",
                                ));
                            }
                            result.value = std::option::Option::Some(
                                crate::model::model::clustering_metrics::cluster::feature_value::Value::CategoricalValue(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::model::clustering_metrics::cluster::feature_value::CategoricalValue>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de>
    for super::model::clustering_metrics::cluster::feature_value::CategoricalValue
{
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __category_counts,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CategoricalValue")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "categoryCounts" => Ok(__FieldTag::__category_counts),
                            "category_counts" => Ok(__FieldTag::__category_counts),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::model::clustering_metrics::cluster::feature_value::CategoricalValue;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CategoricalValue")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__category_counts => {
                            if !fields.insert(__FieldTag::__category_counts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for category_counts",
                                ));
                            }
                            result.category_counts = map.next_value::<std::option::Option<std::vec::Vec<crate::model::model::clustering_metrics::cluster::feature_value::categorical_value::CategoryCount>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de>
    for super::model::clustering_metrics::cluster::feature_value::categorical_value::CategoryCount
{
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __category,
            __count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CategoryCount")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "category" => Ok(__FieldTag::__category),
                            "count" => Ok(__FieldTag::__count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::model::clustering_metrics::cluster::feature_value::categorical_value::CategoryCount;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CategoryCount")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__category => {
                            if !fields.insert(__FieldTag::__category) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for category",
                                ));
                            }
                            result.category = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__count => {
                            if !fields.insert(__FieldTag::__count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for count",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.count = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::model::RankingMetrics {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __mean_average_precision,
            __mean_squared_error,
            __normalized_discounted_cumulative_gain,
            __average_rank,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RankingMetrics")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "meanAveragePrecision" => Ok(__FieldTag::__mean_average_precision),
                            "mean_average_precision" => Ok(__FieldTag::__mean_average_precision),
                            "meanSquaredError" => Ok(__FieldTag::__mean_squared_error),
                            "mean_squared_error" => Ok(__FieldTag::__mean_squared_error),
                            "normalizedDiscountedCumulativeGain" => {
                                Ok(__FieldTag::__normalized_discounted_cumulative_gain)
                            }
                            "normalized_discounted_cumulative_gain" => {
                                Ok(__FieldTag::__normalized_discounted_cumulative_gain)
                            }
                            "averageRank" => Ok(__FieldTag::__average_rank),
                            "average_rank" => Ok(__FieldTag::__average_rank),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::model::RankingMetrics;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RankingMetrics")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__mean_average_precision => {
                            if !fields.insert(__FieldTag::__mean_average_precision) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mean_average_precision",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.mean_average_precision = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__mean_squared_error => {
                            if !fields.insert(__FieldTag::__mean_squared_error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mean_squared_error",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.mean_squared_error = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__normalized_discounted_cumulative_gain => {
                            if !fields.insert(__FieldTag::__normalized_discounted_cumulative_gain) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for normalized_discounted_cumulative_gain",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.normalized_discounted_cumulative_gain =
                                map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__average_rank => {
                            if !fields.insert(__FieldTag::__average_rank) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for average_rank",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.average_rank = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::model::ArimaForecastingMetrics {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __arima_single_model_forecasting_metrics,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ArimaForecastingMetrics")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "arimaSingleModelForecastingMetrics" => {
                                Ok(__FieldTag::__arima_single_model_forecasting_metrics)
                            }
                            "arima_single_model_forecasting_metrics" => {
                                Ok(__FieldTag::__arima_single_model_forecasting_metrics)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::model::ArimaForecastingMetrics;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ArimaForecastingMetrics")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__arima_single_model_forecasting_metrics => {
                            if !fields.insert(__FieldTag::__arima_single_model_forecasting_metrics)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for arima_single_model_forecasting_metrics",
                                ));
                            }
                            result.arima_single_model_forecasting_metrics = map.next_value::<std::option::Option<std::vec::Vec<crate::model::model::arima_forecasting_metrics::ArimaSingleModelForecastingMetrics>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de>
    for super::model::arima_forecasting_metrics::ArimaSingleModelForecastingMetrics
{
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __non_seasonal_order,
            __arima_fitting_metrics,
            __has_drift,
            __time_series_id,
            __time_series_ids,
            __seasonal_periods,
            __has_holiday_effect,
            __has_spikes_and_dips,
            __has_step_changes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ArimaSingleModelForecastingMetrics")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "nonSeasonalOrder" => Ok(__FieldTag::__non_seasonal_order),
                            "non_seasonal_order" => Ok(__FieldTag::__non_seasonal_order),
                            "arimaFittingMetrics" => Ok(__FieldTag::__arima_fitting_metrics),
                            "arima_fitting_metrics" => Ok(__FieldTag::__arima_fitting_metrics),
                            "hasDrift" => Ok(__FieldTag::__has_drift),
                            "has_drift" => Ok(__FieldTag::__has_drift),
                            "timeSeriesId" => Ok(__FieldTag::__time_series_id),
                            "time_series_id" => Ok(__FieldTag::__time_series_id),
                            "timeSeriesIds" => Ok(__FieldTag::__time_series_ids),
                            "time_series_ids" => Ok(__FieldTag::__time_series_ids),
                            "seasonalPeriods" => Ok(__FieldTag::__seasonal_periods),
                            "seasonal_periods" => Ok(__FieldTag::__seasonal_periods),
                            "hasHolidayEffect" => Ok(__FieldTag::__has_holiday_effect),
                            "has_holiday_effect" => Ok(__FieldTag::__has_holiday_effect),
                            "hasSpikesAndDips" => Ok(__FieldTag::__has_spikes_and_dips),
                            "has_spikes_and_dips" => Ok(__FieldTag::__has_spikes_and_dips),
                            "hasStepChanges" => Ok(__FieldTag::__has_step_changes),
                            "has_step_changes" => Ok(__FieldTag::__has_step_changes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value =
                super::model::arima_forecasting_metrics::ArimaSingleModelForecastingMetrics;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ArimaSingleModelForecastingMetrics")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__non_seasonal_order => {
                            if !fields.insert(__FieldTag::__non_seasonal_order) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for non_seasonal_order",
                                ));
                            }
                            result.non_seasonal_order = map
                                .next_value::<std::option::Option<crate::model::model::ArimaOrder>>(
                                )?;
                        }
                        __FieldTag::__arima_fitting_metrics => {
                            if !fields.insert(__FieldTag::__arima_fitting_metrics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for arima_fitting_metrics",
                                ));
                            }
                            result.arima_fitting_metrics = map.next_value::<std::option::Option<crate::model::model::ArimaFittingMetrics>>()?
                                ;
                        }
                        __FieldTag::__has_drift => {
                            if !fields.insert(__FieldTag::__has_drift) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for has_drift",
                                ));
                            }
                            result.has_drift =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__time_series_id => {
                            if !fields.insert(__FieldTag::__time_series_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_series_id",
                                ));
                            }
                            result.time_series_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__time_series_ids => {
                            if !fields.insert(__FieldTag::__time_series_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_series_ids",
                                ));
                            }
                            result.time_series_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__seasonal_periods => {
                            if !fields.insert(__FieldTag::__seasonal_periods) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for seasonal_periods",
                                ));
                            }
                            result.seasonal_periods = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::model::seasonal_period::SeasonalPeriodType,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__has_holiday_effect => {
                            if !fields.insert(__FieldTag::__has_holiday_effect) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for has_holiday_effect",
                                ));
                            }
                            result.has_holiday_effect =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__has_spikes_and_dips => {
                            if !fields.insert(__FieldTag::__has_spikes_and_dips) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for has_spikes_and_dips",
                                ));
                            }
                            result.has_spikes_and_dips =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__has_step_changes => {
                            if !fields.insert(__FieldTag::__has_step_changes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for has_step_changes",
                                ));
                            }
                            result.has_step_changes =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::model::DimensionalityReductionMetrics {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __total_explained_variance_ratio,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DimensionalityReductionMetrics")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "totalExplainedVarianceRatio" => {
                                Ok(__FieldTag::__total_explained_variance_ratio)
                            }
                            "total_explained_variance_ratio" => {
                                Ok(__FieldTag::__total_explained_variance_ratio)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::model::DimensionalityReductionMetrics;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DimensionalityReductionMetrics")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__total_explained_variance_ratio => {
                            if !fields.insert(__FieldTag::__total_explained_variance_ratio) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_explained_variance_ratio",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_explained_variance_ratio = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::model::EvaluationMetrics {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __regression_metrics,
            __binary_classification_metrics,
            __multi_class_classification_metrics,
            __clustering_metrics,
            __ranking_metrics,
            __arima_forecasting_metrics,
            __dimensionality_reduction_metrics,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EvaluationMetrics")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "regressionMetrics" => Ok(__FieldTag::__regression_metrics),
                            "regression_metrics" => Ok(__FieldTag::__regression_metrics),
                            "binaryClassificationMetrics" => {
                                Ok(__FieldTag::__binary_classification_metrics)
                            }
                            "binary_classification_metrics" => {
                                Ok(__FieldTag::__binary_classification_metrics)
                            }
                            "multiClassClassificationMetrics" => {
                                Ok(__FieldTag::__multi_class_classification_metrics)
                            }
                            "multi_class_classification_metrics" => {
                                Ok(__FieldTag::__multi_class_classification_metrics)
                            }
                            "clusteringMetrics" => Ok(__FieldTag::__clustering_metrics),
                            "clustering_metrics" => Ok(__FieldTag::__clustering_metrics),
                            "rankingMetrics" => Ok(__FieldTag::__ranking_metrics),
                            "ranking_metrics" => Ok(__FieldTag::__ranking_metrics),
                            "arimaForecastingMetrics" => {
                                Ok(__FieldTag::__arima_forecasting_metrics)
                            }
                            "arima_forecasting_metrics" => {
                                Ok(__FieldTag::__arima_forecasting_metrics)
                            }
                            "dimensionalityReductionMetrics" => {
                                Ok(__FieldTag::__dimensionality_reduction_metrics)
                            }
                            "dimensionality_reduction_metrics" => {
                                Ok(__FieldTag::__dimensionality_reduction_metrics)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::model::EvaluationMetrics;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EvaluationMetrics")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__regression_metrics => {
                            if !fields.insert(__FieldTag::__regression_metrics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for regression_metrics",
                                ));
                            }
                            if result.metrics.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `metrics`, a oneof with full ID .google.cloud.bigquery.v2.Model.EvaluationMetrics.regression_metrics, latest field was regressionMetrics",
                                ));
                            }
                            result.metrics = std::option::Option::Some(
                                crate::model::model::evaluation_metrics::Metrics::RegressionMetrics(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::model::RegressionMetrics>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__binary_classification_metrics => {
                            if !fields.insert(__FieldTag::__binary_classification_metrics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for binary_classification_metrics",
                                ));
                            }
                            if result.metrics.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `metrics`, a oneof with full ID .google.cloud.bigquery.v2.Model.EvaluationMetrics.binary_classification_metrics, latest field was binaryClassificationMetrics",
                                ));
                            }
                            result.metrics = std::option::Option::Some(
                                crate::model::model::evaluation_metrics::Metrics::BinaryClassificationMetrics(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::model::BinaryClassificationMetrics>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__multi_class_classification_metrics => {
                            if !fields.insert(__FieldTag::__multi_class_classification_metrics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for multi_class_classification_metrics",
                                ));
                            }
                            if result.metrics.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `metrics`, a oneof with full ID .google.cloud.bigquery.v2.Model.EvaluationMetrics.multi_class_classification_metrics, latest field was multiClassClassificationMetrics",
                                ));
                            }
                            result.metrics = std::option::Option::Some(
                                crate::model::model::evaluation_metrics::Metrics::MultiClassClassificationMetrics(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::model::MultiClassClassificationMetrics>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__clustering_metrics => {
                            if !fields.insert(__FieldTag::__clustering_metrics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for clustering_metrics",
                                ));
                            }
                            if result.metrics.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `metrics`, a oneof with full ID .google.cloud.bigquery.v2.Model.EvaluationMetrics.clustering_metrics, latest field was clusteringMetrics",
                                ));
                            }
                            result.metrics = std::option::Option::Some(
                                crate::model::model::evaluation_metrics::Metrics::ClusteringMetrics(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::model::ClusteringMetrics>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__ranking_metrics => {
                            if !fields.insert(__FieldTag::__ranking_metrics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ranking_metrics",
                                ));
                            }
                            if result.metrics.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `metrics`, a oneof with full ID .google.cloud.bigquery.v2.Model.EvaluationMetrics.ranking_metrics, latest field was rankingMetrics",
                                ));
                            }
                            result.metrics = std::option::Option::Some(
                                crate::model::model::evaluation_metrics::Metrics::RankingMetrics(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::model::RankingMetrics>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__arima_forecasting_metrics => {
                            if !fields.insert(__FieldTag::__arima_forecasting_metrics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for arima_forecasting_metrics",
                                ));
                            }
                            if result.metrics.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `metrics`, a oneof with full ID .google.cloud.bigquery.v2.Model.EvaluationMetrics.arima_forecasting_metrics, latest field was arimaForecastingMetrics",
                                ));
                            }
                            result.metrics = std::option::Option::Some(
                                crate::model::model::evaluation_metrics::Metrics::ArimaForecastingMetrics(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::model::ArimaForecastingMetrics>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__dimensionality_reduction_metrics => {
                            if !fields.insert(__FieldTag::__dimensionality_reduction_metrics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dimensionality_reduction_metrics",
                                ));
                            }
                            if result.metrics.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `metrics`, a oneof with full ID .google.cloud.bigquery.v2.Model.EvaluationMetrics.dimensionality_reduction_metrics, latest field was dimensionalityReductionMetrics",
                                ));
                            }
                            result.metrics = std::option::Option::Some(
                                crate::model::model::evaluation_metrics::Metrics::DimensionalityReductionMetrics(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::model::DimensionalityReductionMetrics>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::model::DataSplitResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __training_table,
            __evaluation_table,
            __test_table,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataSplitResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "trainingTable" => Ok(__FieldTag::__training_table),
                            "training_table" => Ok(__FieldTag::__training_table),
                            "evaluationTable" => Ok(__FieldTag::__evaluation_table),
                            "evaluation_table" => Ok(__FieldTag::__evaluation_table),
                            "testTable" => Ok(__FieldTag::__test_table),
                            "test_table" => Ok(__FieldTag::__test_table),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::model::DataSplitResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataSplitResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__training_table => {
                            if !fields.insert(__FieldTag::__training_table) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for training_table",
                                ));
                            }
                            result.training_table = map
                                .next_value::<std::option::Option<crate::model::TableReference>>(
                                )?;
                        }
                        __FieldTag::__evaluation_table => {
                            if !fields.insert(__FieldTag::__evaluation_table) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for evaluation_table",
                                ));
                            }
                            result.evaluation_table = map
                                .next_value::<std::option::Option<crate::model::TableReference>>(
                                )?;
                        }
                        __FieldTag::__test_table => {
                            if !fields.insert(__FieldTag::__test_table) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for test_table",
                                ));
                            }
                            result.test_table = map
                                .next_value::<std::option::Option<crate::model::TableReference>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::model::ArimaOrder {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __p,
            __d,
            __q,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ArimaOrder")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "p" => Ok(__FieldTag::__p),
                            "d" => Ok(__FieldTag::__d),
                            "q" => Ok(__FieldTag::__q),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::model::ArimaOrder;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ArimaOrder")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__p => {
                            if !fields.insert(__FieldTag::__p) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for p",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.p = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__d => {
                            if !fields.insert(__FieldTag::__d) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for d",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.d = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__q => {
                            if !fields.insert(__FieldTag::__q) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for q",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.q = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::model::ArimaFittingMetrics {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __log_likelihood,
            __aic,
            __variance,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ArimaFittingMetrics")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "logLikelihood" => Ok(__FieldTag::__log_likelihood),
                            "log_likelihood" => Ok(__FieldTag::__log_likelihood),
                            "aic" => Ok(__FieldTag::__aic),
                            "variance" => Ok(__FieldTag::__variance),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::model::ArimaFittingMetrics;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ArimaFittingMetrics")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__log_likelihood => {
                            if !fields.insert(__FieldTag::__log_likelihood) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for log_likelihood",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.log_likelihood = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__aic => {
                            if !fields.insert(__FieldTag::__aic) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aic",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.aic = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__variance => {
                            if !fields.insert(__FieldTag::__variance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for variance",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.variance = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::model::GlobalExplanation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __explanations,
            __class_label,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GlobalExplanation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "explanations" => Ok(__FieldTag::__explanations),
                            "classLabel" => Ok(__FieldTag::__class_label),
                            "class_label" => Ok(__FieldTag::__class_label),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::model::GlobalExplanation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GlobalExplanation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__explanations => {
                            if !fields.insert(__FieldTag::__explanations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for explanations",
                                ));
                            }
                            result.explanations = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::model::global_explanation::Explanation,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__class_label => {
                            if !fields.insert(__FieldTag::__class_label) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for class_label",
                                ));
                            }
                            result.class_label = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::model::global_explanation::Explanation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __feature_name,
            __attribution,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Explanation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "featureName" => Ok(__FieldTag::__feature_name),
                            "feature_name" => Ok(__FieldTag::__feature_name),
                            "attribution" => Ok(__FieldTag::__attribution),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::model::global_explanation::Explanation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Explanation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__feature_name => {
                            if !fields.insert(__FieldTag::__feature_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for feature_name",
                                ));
                            }
                            result.feature_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__attribution => {
                            if !fields.insert(__FieldTag::__attribution) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attribution",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.attribution = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::model::CategoryEncodingMethod {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CategoryEncodingMethod")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::model::CategoryEncodingMethod;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CategoryEncodingMethod")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::model::PcaSolverOptionEnums {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PcaSolverOptionEnums")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::model::PcaSolverOptionEnums;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PcaSolverOptionEnums")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::model::ModelRegistryOptionEnums {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ModelRegistryOptionEnums")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::model::ModelRegistryOptionEnums;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ModelRegistryOptionEnums")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::model::TrainingRun {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __training_options,
            __start_time,
            __results,
            __evaluation_metrics,
            __data_split_result,
            __model_level_global_explanation,
            __class_level_global_explanations,
            __vertex_ai_model_id,
            __vertex_ai_model_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TrainingRun")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "trainingOptions" => Ok(__FieldTag::__training_options),
                            "training_options" => Ok(__FieldTag::__training_options),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "results" => Ok(__FieldTag::__results),
                            "evaluationMetrics" => Ok(__FieldTag::__evaluation_metrics),
                            "evaluation_metrics" => Ok(__FieldTag::__evaluation_metrics),
                            "dataSplitResult" => Ok(__FieldTag::__data_split_result),
                            "data_split_result" => Ok(__FieldTag::__data_split_result),
                            "modelLevelGlobalExplanation" => {
                                Ok(__FieldTag::__model_level_global_explanation)
                            }
                            "model_level_global_explanation" => {
                                Ok(__FieldTag::__model_level_global_explanation)
                            }
                            "classLevelGlobalExplanations" => {
                                Ok(__FieldTag::__class_level_global_explanations)
                            }
                            "class_level_global_explanations" => {
                                Ok(__FieldTag::__class_level_global_explanations)
                            }
                            "vertexAiModelId" => Ok(__FieldTag::__vertex_ai_model_id),
                            "vertex_ai_model_id" => Ok(__FieldTag::__vertex_ai_model_id),
                            "vertexAiModelVersion" => Ok(__FieldTag::__vertex_ai_model_version),
                            "vertex_ai_model_version" => Ok(__FieldTag::__vertex_ai_model_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::model::TrainingRun;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TrainingRun")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__training_options => {
                            if !fields.insert(__FieldTag::__training_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for training_options",
                                ));
                            }
                            result.training_options = map.next_value::<std::option::Option<
                                crate::model::model::training_run::TrainingOptions,
                            >>()?;
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__results => {
                            if !fields.insert(__FieldTag::__results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for results",
                                ));
                            }
                            result.results = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::model::training_run::IterationResult,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__evaluation_metrics => {
                            if !fields.insert(__FieldTag::__evaluation_metrics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for evaluation_metrics",
                                ));
                            }
                            result.evaluation_metrics = map.next_value::<std::option::Option<crate::model::model::EvaluationMetrics>>()?
                                ;
                        }
                        __FieldTag::__data_split_result => {
                            if !fields.insert(__FieldTag::__data_split_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_split_result",
                                ));
                            }
                            result.data_split_result = map.next_value::<std::option::Option<crate::model::model::DataSplitResult>>()?
                                ;
                        }
                        __FieldTag::__model_level_global_explanation => {
                            if !fields.insert(__FieldTag::__model_level_global_explanation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model_level_global_explanation",
                                ));
                            }
                            result.model_level_global_explanation = map.next_value::<std::option::Option<crate::model::model::GlobalExplanation>>()?
                                ;
                        }
                        __FieldTag::__class_level_global_explanations => {
                            if !fields.insert(__FieldTag::__class_level_global_explanations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for class_level_global_explanations",
                                ));
                            }
                            result.class_level_global_explanations = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::model::GlobalExplanation>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vertex_ai_model_id => {
                            if !fields.insert(__FieldTag::__vertex_ai_model_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vertex_ai_model_id",
                                ));
                            }
                            result.vertex_ai_model_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vertex_ai_model_version => {
                            if !fields.insert(__FieldTag::__vertex_ai_model_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vertex_ai_model_version",
                                ));
                            }
                            result.vertex_ai_model_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::model::training_run::TrainingOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __max_iterations,
            __loss_type,
            __learn_rate,
            __l1_regularization,
            __l2_regularization,
            __min_relative_progress,
            __warm_start,
            __early_stop,
            __input_label_columns,
            __data_split_method,
            __data_split_eval_fraction,
            __data_split_column,
            __learn_rate_strategy,
            __initial_learn_rate,
            __label_class_weights,
            __user_column,
            __item_column,
            __distance_type,
            __num_clusters,
            __model_uri,
            __optimization_strategy,
            __hidden_units,
            __batch_size,
            __dropout,
            __max_tree_depth,
            __subsample,
            __min_split_loss,
            __booster_type,
            __num_parallel_tree,
            __dart_normalize_type,
            __tree_method,
            __min_tree_child_weight,
            __colsample_bytree,
            __colsample_bylevel,
            __colsample_bynode,
            __num_factors,
            __feedback_type,
            __wals_alpha,
            __kmeans_initialization_method,
            __kmeans_initialization_column,
            __time_series_timestamp_column,
            __time_series_data_column,
            __auto_arima,
            __non_seasonal_order,
            __data_frequency,
            __calculate_p_values,
            __include_drift,
            __holiday_region,
            __holiday_regions,
            __time_series_id_column,
            __time_series_id_columns,
            __forecast_limit_lower_bound,
            __forecast_limit_upper_bound,
            __horizon,
            __auto_arima_max_order,
            __auto_arima_min_order,
            __num_trials,
            __max_parallel_trials,
            __hparam_tuning_objectives,
            __decompose_time_series,
            __clean_spikes_and_dips,
            __adjust_step_changes,
            __enable_global_explain,
            __sampled_shapley_num_paths,
            __integrated_gradients_num_steps,
            __category_encoding_method,
            __tf_version,
            __color_space,
            __instance_weight_column,
            __trend_smoothing_window_size,
            __time_series_length_fraction,
            __min_time_series_length,
            __max_time_series_length,
            __xgboost_version,
            __approx_global_feature_contrib,
            __fit_intercept,
            __num_principal_components,
            __pca_explained_variance_ratio,
            __scale_features,
            __pca_solver,
            __auto_class_weights,
            __activation_fn,
            __optimizer,
            __budget_hours,
            __standardize_features,
            __l1_reg_activation,
            __model_registry,
            __vertex_ai_model_version_aliases,
            __dimension_id_columns,
            __contribution_metric,
            __is_test_column,
            __min_apriori_support,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TrainingOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "maxIterations" => Ok(__FieldTag::__max_iterations),
                            "max_iterations" => Ok(__FieldTag::__max_iterations),
                            "lossType" => Ok(__FieldTag::__loss_type),
                            "loss_type" => Ok(__FieldTag::__loss_type),
                            "learnRate" => Ok(__FieldTag::__learn_rate),
                            "learn_rate" => Ok(__FieldTag::__learn_rate),
                            "l1Regularization" => Ok(__FieldTag::__l1_regularization),
                            "l1_regularization" => Ok(__FieldTag::__l1_regularization),
                            "l2Regularization" => Ok(__FieldTag::__l2_regularization),
                            "l2_regularization" => Ok(__FieldTag::__l2_regularization),
                            "minRelativeProgress" => Ok(__FieldTag::__min_relative_progress),
                            "min_relative_progress" => Ok(__FieldTag::__min_relative_progress),
                            "warmStart" => Ok(__FieldTag::__warm_start),
                            "warm_start" => Ok(__FieldTag::__warm_start),
                            "earlyStop" => Ok(__FieldTag::__early_stop),
                            "early_stop" => Ok(__FieldTag::__early_stop),
                            "inputLabelColumns" => Ok(__FieldTag::__input_label_columns),
                            "input_label_columns" => Ok(__FieldTag::__input_label_columns),
                            "dataSplitMethod" => Ok(__FieldTag::__data_split_method),
                            "data_split_method" => Ok(__FieldTag::__data_split_method),
                            "dataSplitEvalFraction" => Ok(__FieldTag::__data_split_eval_fraction),
                            "data_split_eval_fraction" => {
                                Ok(__FieldTag::__data_split_eval_fraction)
                            }
                            "dataSplitColumn" => Ok(__FieldTag::__data_split_column),
                            "data_split_column" => Ok(__FieldTag::__data_split_column),
                            "learnRateStrategy" => Ok(__FieldTag::__learn_rate_strategy),
                            "learn_rate_strategy" => Ok(__FieldTag::__learn_rate_strategy),
                            "initialLearnRate" => Ok(__FieldTag::__initial_learn_rate),
                            "initial_learn_rate" => Ok(__FieldTag::__initial_learn_rate),
                            "labelClassWeights" => Ok(__FieldTag::__label_class_weights),
                            "label_class_weights" => Ok(__FieldTag::__label_class_weights),
                            "userColumn" => Ok(__FieldTag::__user_column),
                            "user_column" => Ok(__FieldTag::__user_column),
                            "itemColumn" => Ok(__FieldTag::__item_column),
                            "item_column" => Ok(__FieldTag::__item_column),
                            "distanceType" => Ok(__FieldTag::__distance_type),
                            "distance_type" => Ok(__FieldTag::__distance_type),
                            "numClusters" => Ok(__FieldTag::__num_clusters),
                            "num_clusters" => Ok(__FieldTag::__num_clusters),
                            "modelUri" => Ok(__FieldTag::__model_uri),
                            "model_uri" => Ok(__FieldTag::__model_uri),
                            "optimizationStrategy" => Ok(__FieldTag::__optimization_strategy),
                            "optimization_strategy" => Ok(__FieldTag::__optimization_strategy),
                            "hiddenUnits" => Ok(__FieldTag::__hidden_units),
                            "hidden_units" => Ok(__FieldTag::__hidden_units),
                            "batchSize" => Ok(__FieldTag::__batch_size),
                            "batch_size" => Ok(__FieldTag::__batch_size),
                            "dropout" => Ok(__FieldTag::__dropout),
                            "maxTreeDepth" => Ok(__FieldTag::__max_tree_depth),
                            "max_tree_depth" => Ok(__FieldTag::__max_tree_depth),
                            "subsample" => Ok(__FieldTag::__subsample),
                            "minSplitLoss" => Ok(__FieldTag::__min_split_loss),
                            "min_split_loss" => Ok(__FieldTag::__min_split_loss),
                            "boosterType" => Ok(__FieldTag::__booster_type),
                            "booster_type" => Ok(__FieldTag::__booster_type),
                            "numParallelTree" => Ok(__FieldTag::__num_parallel_tree),
                            "num_parallel_tree" => Ok(__FieldTag::__num_parallel_tree),
                            "dartNormalizeType" => Ok(__FieldTag::__dart_normalize_type),
                            "dart_normalize_type" => Ok(__FieldTag::__dart_normalize_type),
                            "treeMethod" => Ok(__FieldTag::__tree_method),
                            "tree_method" => Ok(__FieldTag::__tree_method),
                            "minTreeChildWeight" => Ok(__FieldTag::__min_tree_child_weight),
                            "min_tree_child_weight" => Ok(__FieldTag::__min_tree_child_weight),
                            "colsampleBytree" => Ok(__FieldTag::__colsample_bytree),
                            "colsample_bytree" => Ok(__FieldTag::__colsample_bytree),
                            "colsampleBylevel" => Ok(__FieldTag::__colsample_bylevel),
                            "colsample_bylevel" => Ok(__FieldTag::__colsample_bylevel),
                            "colsampleBynode" => Ok(__FieldTag::__colsample_bynode),
                            "colsample_bynode" => Ok(__FieldTag::__colsample_bynode),
                            "numFactors" => Ok(__FieldTag::__num_factors),
                            "num_factors" => Ok(__FieldTag::__num_factors),
                            "feedbackType" => Ok(__FieldTag::__feedback_type),
                            "feedback_type" => Ok(__FieldTag::__feedback_type),
                            "walsAlpha" => Ok(__FieldTag::__wals_alpha),
                            "wals_alpha" => Ok(__FieldTag::__wals_alpha),
                            "kmeansInitializationMethod" => {
                                Ok(__FieldTag::__kmeans_initialization_method)
                            }
                            "kmeans_initialization_method" => {
                                Ok(__FieldTag::__kmeans_initialization_method)
                            }
                            "kmeansInitializationColumn" => {
                                Ok(__FieldTag::__kmeans_initialization_column)
                            }
                            "kmeans_initialization_column" => {
                                Ok(__FieldTag::__kmeans_initialization_column)
                            }
                            "timeSeriesTimestampColumn" => {
                                Ok(__FieldTag::__time_series_timestamp_column)
                            }
                            "time_series_timestamp_column" => {
                                Ok(__FieldTag::__time_series_timestamp_column)
                            }
                            "timeSeriesDataColumn" => Ok(__FieldTag::__time_series_data_column),
                            "time_series_data_column" => Ok(__FieldTag::__time_series_data_column),
                            "autoArima" => Ok(__FieldTag::__auto_arima),
                            "auto_arima" => Ok(__FieldTag::__auto_arima),
                            "nonSeasonalOrder" => Ok(__FieldTag::__non_seasonal_order),
                            "non_seasonal_order" => Ok(__FieldTag::__non_seasonal_order),
                            "dataFrequency" => Ok(__FieldTag::__data_frequency),
                            "data_frequency" => Ok(__FieldTag::__data_frequency),
                            "calculatePValues" => Ok(__FieldTag::__calculate_p_values),
                            "calculate_p_values" => Ok(__FieldTag::__calculate_p_values),
                            "includeDrift" => Ok(__FieldTag::__include_drift),
                            "include_drift" => Ok(__FieldTag::__include_drift),
                            "holidayRegion" => Ok(__FieldTag::__holiday_region),
                            "holiday_region" => Ok(__FieldTag::__holiday_region),
                            "holidayRegions" => Ok(__FieldTag::__holiday_regions),
                            "holiday_regions" => Ok(__FieldTag::__holiday_regions),
                            "timeSeriesIdColumn" => Ok(__FieldTag::__time_series_id_column),
                            "time_series_id_column" => Ok(__FieldTag::__time_series_id_column),
                            "timeSeriesIdColumns" => Ok(__FieldTag::__time_series_id_columns),
                            "time_series_id_columns" => Ok(__FieldTag::__time_series_id_columns),
                            "forecastLimitLowerBound" => {
                                Ok(__FieldTag::__forecast_limit_lower_bound)
                            }
                            "forecast_limit_lower_bound" => {
                                Ok(__FieldTag::__forecast_limit_lower_bound)
                            }
                            "forecastLimitUpperBound" => {
                                Ok(__FieldTag::__forecast_limit_upper_bound)
                            }
                            "forecast_limit_upper_bound" => {
                                Ok(__FieldTag::__forecast_limit_upper_bound)
                            }
                            "horizon" => Ok(__FieldTag::__horizon),
                            "autoArimaMaxOrder" => Ok(__FieldTag::__auto_arima_max_order),
                            "auto_arima_max_order" => Ok(__FieldTag::__auto_arima_max_order),
                            "autoArimaMinOrder" => Ok(__FieldTag::__auto_arima_min_order),
                            "auto_arima_min_order" => Ok(__FieldTag::__auto_arima_min_order),
                            "numTrials" => Ok(__FieldTag::__num_trials),
                            "num_trials" => Ok(__FieldTag::__num_trials),
                            "maxParallelTrials" => Ok(__FieldTag::__max_parallel_trials),
                            "max_parallel_trials" => Ok(__FieldTag::__max_parallel_trials),
                            "hparamTuningObjectives" => Ok(__FieldTag::__hparam_tuning_objectives),
                            "hparam_tuning_objectives" => {
                                Ok(__FieldTag::__hparam_tuning_objectives)
                            }
                            "decomposeTimeSeries" => Ok(__FieldTag::__decompose_time_series),
                            "decompose_time_series" => Ok(__FieldTag::__decompose_time_series),
                            "cleanSpikesAndDips" => Ok(__FieldTag::__clean_spikes_and_dips),
                            "clean_spikes_and_dips" => Ok(__FieldTag::__clean_spikes_and_dips),
                            "adjustStepChanges" => Ok(__FieldTag::__adjust_step_changes),
                            "adjust_step_changes" => Ok(__FieldTag::__adjust_step_changes),
                            "enableGlobalExplain" => Ok(__FieldTag::__enable_global_explain),
                            "enable_global_explain" => Ok(__FieldTag::__enable_global_explain),
                            "sampledShapleyNumPaths" => Ok(__FieldTag::__sampled_shapley_num_paths),
                            "sampled_shapley_num_paths" => {
                                Ok(__FieldTag::__sampled_shapley_num_paths)
                            }
                            "integratedGradientsNumSteps" => {
                                Ok(__FieldTag::__integrated_gradients_num_steps)
                            }
                            "integrated_gradients_num_steps" => {
                                Ok(__FieldTag::__integrated_gradients_num_steps)
                            }
                            "categoryEncodingMethod" => Ok(__FieldTag::__category_encoding_method),
                            "category_encoding_method" => {
                                Ok(__FieldTag::__category_encoding_method)
                            }
                            "tfVersion" => Ok(__FieldTag::__tf_version),
                            "tf_version" => Ok(__FieldTag::__tf_version),
                            "colorSpace" => Ok(__FieldTag::__color_space),
                            "color_space" => Ok(__FieldTag::__color_space),
                            "instanceWeightColumn" => Ok(__FieldTag::__instance_weight_column),
                            "instance_weight_column" => Ok(__FieldTag::__instance_weight_column),
                            "trendSmoothingWindowSize" => {
                                Ok(__FieldTag::__trend_smoothing_window_size)
                            }
                            "trend_smoothing_window_size" => {
                                Ok(__FieldTag::__trend_smoothing_window_size)
                            }
                            "timeSeriesLengthFraction" => {
                                Ok(__FieldTag::__time_series_length_fraction)
                            }
                            "time_series_length_fraction" => {
                                Ok(__FieldTag::__time_series_length_fraction)
                            }
                            "minTimeSeriesLength" => Ok(__FieldTag::__min_time_series_length),
                            "min_time_series_length" => Ok(__FieldTag::__min_time_series_length),
                            "maxTimeSeriesLength" => Ok(__FieldTag::__max_time_series_length),
                            "max_time_series_length" => Ok(__FieldTag::__max_time_series_length),
                            "xgboostVersion" => Ok(__FieldTag::__xgboost_version),
                            "xgboost_version" => Ok(__FieldTag::__xgboost_version),
                            "approxGlobalFeatureContrib" => {
                                Ok(__FieldTag::__approx_global_feature_contrib)
                            }
                            "approx_global_feature_contrib" => {
                                Ok(__FieldTag::__approx_global_feature_contrib)
                            }
                            "fitIntercept" => Ok(__FieldTag::__fit_intercept),
                            "fit_intercept" => Ok(__FieldTag::__fit_intercept),
                            "numPrincipalComponents" => Ok(__FieldTag::__num_principal_components),
                            "num_principal_components" => {
                                Ok(__FieldTag::__num_principal_components)
                            }
                            "pcaExplainedVarianceRatio" => {
                                Ok(__FieldTag::__pca_explained_variance_ratio)
                            }
                            "pca_explained_variance_ratio" => {
                                Ok(__FieldTag::__pca_explained_variance_ratio)
                            }
                            "scaleFeatures" => Ok(__FieldTag::__scale_features),
                            "scale_features" => Ok(__FieldTag::__scale_features),
                            "pcaSolver" => Ok(__FieldTag::__pca_solver),
                            "pca_solver" => Ok(__FieldTag::__pca_solver),
                            "autoClassWeights" => Ok(__FieldTag::__auto_class_weights),
                            "auto_class_weights" => Ok(__FieldTag::__auto_class_weights),
                            "activationFn" => Ok(__FieldTag::__activation_fn),
                            "activation_fn" => Ok(__FieldTag::__activation_fn),
                            "optimizer" => Ok(__FieldTag::__optimizer),
                            "budgetHours" => Ok(__FieldTag::__budget_hours),
                            "budget_hours" => Ok(__FieldTag::__budget_hours),
                            "standardizeFeatures" => Ok(__FieldTag::__standardize_features),
                            "standardize_features" => Ok(__FieldTag::__standardize_features),
                            "l1RegActivation" => Ok(__FieldTag::__l1_reg_activation),
                            "l1_reg_activation" => Ok(__FieldTag::__l1_reg_activation),
                            "modelRegistry" => Ok(__FieldTag::__model_registry),
                            "model_registry" => Ok(__FieldTag::__model_registry),
                            "vertexAiModelVersionAliases" => {
                                Ok(__FieldTag::__vertex_ai_model_version_aliases)
                            }
                            "vertex_ai_model_version_aliases" => {
                                Ok(__FieldTag::__vertex_ai_model_version_aliases)
                            }
                            "dimensionIdColumns" => Ok(__FieldTag::__dimension_id_columns),
                            "dimension_id_columns" => Ok(__FieldTag::__dimension_id_columns),
                            "contributionMetric" => Ok(__FieldTag::__contribution_metric),
                            "contribution_metric" => Ok(__FieldTag::__contribution_metric),
                            "isTestColumn" => Ok(__FieldTag::__is_test_column),
                            "is_test_column" => Ok(__FieldTag::__is_test_column),
                            "minAprioriSupport" => Ok(__FieldTag::__min_apriori_support),
                            "min_apriori_support" => Ok(__FieldTag::__min_apriori_support),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::model::training_run::TrainingOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TrainingOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__max_iterations => {
                            if !fields.insert(__FieldTag::__max_iterations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_iterations",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_iterations =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__loss_type => {
                            if !fields.insert(__FieldTag::__loss_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for loss_type",
                                ));
                            }
                            result.loss_type = map
                                .next_value::<std::option::Option<crate::model::model::LossType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__learn_rate => {
                            if !fields.insert(__FieldTag::__learn_rate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for learn_rate",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.learn_rate = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__l1_regularization => {
                            if !fields.insert(__FieldTag::__l1_regularization) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for l1_regularization",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.l1_regularization = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__l2_regularization => {
                            if !fields.insert(__FieldTag::__l2_regularization) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for l2_regularization",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.l2_regularization = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__min_relative_progress => {
                            if !fields.insert(__FieldTag::__min_relative_progress) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_relative_progress",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.min_relative_progress = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__warm_start => {
                            if !fields.insert(__FieldTag::__warm_start) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for warm_start",
                                ));
                            }
                            result.warm_start =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__early_stop => {
                            if !fields.insert(__FieldTag::__early_stop) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for early_stop",
                                ));
                            }
                            result.early_stop =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__input_label_columns => {
                            if !fields.insert(__FieldTag::__input_label_columns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input_label_columns",
                                ));
                            }
                            result.input_label_columns = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__data_split_method => {
                            if !fields.insert(__FieldTag::__data_split_method) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_split_method",
                                ));
                            }
                            result.data_split_method = map.next_value::<std::option::Option<crate::model::model::DataSplitMethod>>()?.unwrap_or_default();
                        }
                        __FieldTag::__data_split_eval_fraction => {
                            if !fields.insert(__FieldTag::__data_split_eval_fraction) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_split_eval_fraction",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.data_split_eval_fraction =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__data_split_column => {
                            if !fields.insert(__FieldTag::__data_split_column) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_split_column",
                                ));
                            }
                            result.data_split_column = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__learn_rate_strategy => {
                            if !fields.insert(__FieldTag::__learn_rate_strategy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for learn_rate_strategy",
                                ));
                            }
                            result.learn_rate_strategy = map.next_value::<std::option::Option<crate::model::model::LearnRateStrategy>>()?.unwrap_or_default();
                        }
                        __FieldTag::__initial_learn_rate => {
                            if !fields.insert(__FieldTag::__initial_learn_rate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for initial_learn_rate",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.initial_learn_rate =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__label_class_weights => {
                            if !fields.insert(__FieldTag::__label_class_weights) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for label_class_weights",
                                ));
                            }
                            struct __With(
                                std::option::Option<
                                    std::collections::HashMap<std::string::String, f64>,
                                >,
                            );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                serde_with::Same,
                                                wkt::internal::F64,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.label_class_weights =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__user_column => {
                            if !fields.insert(__FieldTag::__user_column) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_column",
                                ));
                            }
                            result.user_column = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__item_column => {
                            if !fields.insert(__FieldTag::__item_column) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for item_column",
                                ));
                            }
                            result.item_column = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__distance_type => {
                            if !fields.insert(__FieldTag::__distance_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for distance_type",
                                ));
                            }
                            result.distance_type = map.next_value::<std::option::Option<crate::model::model::DistanceType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__num_clusters => {
                            if !fields.insert(__FieldTag::__num_clusters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for num_clusters",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.num_clusters = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__model_uri => {
                            if !fields.insert(__FieldTag::__model_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model_uri",
                                ));
                            }
                            result.model_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__optimization_strategy => {
                            if !fields.insert(__FieldTag::__optimization_strategy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optimization_strategy",
                                ));
                            }
                            result.optimization_strategy = map.next_value::<std::option::Option<crate::model::model::OptimizationStrategy>>()?.unwrap_or_default();
                        }
                        __FieldTag::__hidden_units => {
                            if !fields.insert(__FieldTag::__hidden_units) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hidden_units",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i64>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I64>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.hidden_units = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__batch_size => {
                            if !fields.insert(__FieldTag::__batch_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for batch_size",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.batch_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__dropout => {
                            if !fields.insert(__FieldTag::__dropout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dropout",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.dropout = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__max_tree_depth => {
                            if !fields.insert(__FieldTag::__max_tree_depth) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_tree_depth",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_tree_depth =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__subsample => {
                            if !fields.insert(__FieldTag::__subsample) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subsample",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.subsample = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__min_split_loss => {
                            if !fields.insert(__FieldTag::__min_split_loss) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_split_loss",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.min_split_loss = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__booster_type => {
                            if !fields.insert(__FieldTag::__booster_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for booster_type",
                                ));
                            }
                            result.booster_type = map
                                .next_value::<std::option::Option<
                                    crate::model::model::boosted_tree_option_enums::BoosterType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__num_parallel_tree => {
                            if !fields.insert(__FieldTag::__num_parallel_tree) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for num_parallel_tree",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.num_parallel_tree = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__dart_normalize_type => {
                            if !fields.insert(__FieldTag::__dart_normalize_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dart_normalize_type",
                                ));
                            }
                            result.dart_normalize_type = map.next_value::<std::option::Option<crate::model::model::boosted_tree_option_enums::DartNormalizeType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__tree_method => {
                            if !fields.insert(__FieldTag::__tree_method) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tree_method",
                                ));
                            }
                            result.tree_method = map
                                .next_value::<std::option::Option<
                                    crate::model::model::boosted_tree_option_enums::TreeMethod,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__min_tree_child_weight => {
                            if !fields.insert(__FieldTag::__min_tree_child_weight) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_tree_child_weight",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.min_tree_child_weight = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__colsample_bytree => {
                            if !fields.insert(__FieldTag::__colsample_bytree) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for colsample_bytree",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.colsample_bytree = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__colsample_bylevel => {
                            if !fields.insert(__FieldTag::__colsample_bylevel) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for colsample_bylevel",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.colsample_bylevel = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__colsample_bynode => {
                            if !fields.insert(__FieldTag::__colsample_bynode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for colsample_bynode",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.colsample_bynode = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__num_factors => {
                            if !fields.insert(__FieldTag::__num_factors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for num_factors",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.num_factors = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__feedback_type => {
                            if !fields.insert(__FieldTag::__feedback_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for feedback_type",
                                ));
                            }
                            result.feedback_type = map.next_value::<std::option::Option<crate::model::model::FeedbackType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__wals_alpha => {
                            if !fields.insert(__FieldTag::__wals_alpha) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for wals_alpha",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.wals_alpha = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__kmeans_initialization_method => {
                            if !fields.insert(__FieldTag::__kmeans_initialization_method) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kmeans_initialization_method",
                                ));
                            }
                            result.kmeans_initialization_method = map
                                .next_value::<std::option::Option<
                                    crate::model::model::kmeans_enums::KmeansInitializationMethod,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kmeans_initialization_column => {
                            if !fields.insert(__FieldTag::__kmeans_initialization_column) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kmeans_initialization_column",
                                ));
                            }
                            result.kmeans_initialization_column = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__time_series_timestamp_column => {
                            if !fields.insert(__FieldTag::__time_series_timestamp_column) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_series_timestamp_column",
                                ));
                            }
                            result.time_series_timestamp_column = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__time_series_data_column => {
                            if !fields.insert(__FieldTag::__time_series_data_column) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_series_data_column",
                                ));
                            }
                            result.time_series_data_column = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__auto_arima => {
                            if !fields.insert(__FieldTag::__auto_arima) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auto_arima",
                                ));
                            }
                            result.auto_arima =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__non_seasonal_order => {
                            if !fields.insert(__FieldTag::__non_seasonal_order) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for non_seasonal_order",
                                ));
                            }
                            result.non_seasonal_order = map
                                .next_value::<std::option::Option<crate::model::model::ArimaOrder>>(
                                )?;
                        }
                        __FieldTag::__data_frequency => {
                            if !fields.insert(__FieldTag::__data_frequency) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_frequency",
                                ));
                            }
                            result.data_frequency = map.next_value::<std::option::Option<crate::model::model::DataFrequency>>()?.unwrap_or_default();
                        }
                        __FieldTag::__calculate_p_values => {
                            if !fields.insert(__FieldTag::__calculate_p_values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for calculate_p_values",
                                ));
                            }
                            result.calculate_p_values =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__include_drift => {
                            if !fields.insert(__FieldTag::__include_drift) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for include_drift",
                                ));
                            }
                            result.include_drift =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__holiday_region => {
                            if !fields.insert(__FieldTag::__holiday_region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for holiday_region",
                                ));
                            }
                            result.holiday_region = map.next_value::<std::option::Option<crate::model::model::HolidayRegion>>()?.unwrap_or_default();
                        }
                        __FieldTag::__holiday_regions => {
                            if !fields.insert(__FieldTag::__holiday_regions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for holiday_regions",
                                ));
                            }
                            result.holiday_regions = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::model::HolidayRegion>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__time_series_id_column => {
                            if !fields.insert(__FieldTag::__time_series_id_column) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_series_id_column",
                                ));
                            }
                            result.time_series_id_column = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__time_series_id_columns => {
                            if !fields.insert(__FieldTag::__time_series_id_columns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_series_id_columns",
                                ));
                            }
                            result.time_series_id_columns = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__forecast_limit_lower_bound => {
                            if !fields.insert(__FieldTag::__forecast_limit_lower_bound) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for forecast_limit_lower_bound",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.forecast_limit_lower_bound =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__forecast_limit_upper_bound => {
                            if !fields.insert(__FieldTag::__forecast_limit_upper_bound) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for forecast_limit_upper_bound",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.forecast_limit_upper_bound =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__horizon => {
                            if !fields.insert(__FieldTag::__horizon) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for horizon",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.horizon = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__auto_arima_max_order => {
                            if !fields.insert(__FieldTag::__auto_arima_max_order) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auto_arima_max_order",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.auto_arima_max_order =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__auto_arima_min_order => {
                            if !fields.insert(__FieldTag::__auto_arima_min_order) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auto_arima_min_order",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.auto_arima_min_order =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__num_trials => {
                            if !fields.insert(__FieldTag::__num_trials) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for num_trials",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.num_trials = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_parallel_trials => {
                            if !fields.insert(__FieldTag::__max_parallel_trials) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_parallel_trials",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_parallel_trials =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__hparam_tuning_objectives => {
                            if !fields.insert(__FieldTag::__hparam_tuning_objectives) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hparam_tuning_objectives",
                                ));
                            }
                            result.hparam_tuning_objectives = map.next_value::<std::option::Option<std::vec::Vec<crate::model::model::hparam_tuning_enums::HparamTuningObjective>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__decompose_time_series => {
                            if !fields.insert(__FieldTag::__decompose_time_series) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for decompose_time_series",
                                ));
                            }
                            result.decompose_time_series =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__clean_spikes_and_dips => {
                            if !fields.insert(__FieldTag::__clean_spikes_and_dips) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for clean_spikes_and_dips",
                                ));
                            }
                            result.clean_spikes_and_dips =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__adjust_step_changes => {
                            if !fields.insert(__FieldTag::__adjust_step_changes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for adjust_step_changes",
                                ));
                            }
                            result.adjust_step_changes =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__enable_global_explain => {
                            if !fields.insert(__FieldTag::__enable_global_explain) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_global_explain",
                                ));
                            }
                            result.enable_global_explain =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__sampled_shapley_num_paths => {
                            if !fields.insert(__FieldTag::__sampled_shapley_num_paths) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sampled_shapley_num_paths",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.sampled_shapley_num_paths =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__integrated_gradients_num_steps => {
                            if !fields.insert(__FieldTag::__integrated_gradients_num_steps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for integrated_gradients_num_steps",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.integrated_gradients_num_steps =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__category_encoding_method => {
                            if !fields.insert(__FieldTag::__category_encoding_method) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for category_encoding_method",
                                ));
                            }
                            result.category_encoding_method = map
                                .next_value::<std::option::Option<
                                    crate::model::model::category_encoding_method::EncodingMethod,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tf_version => {
                            if !fields.insert(__FieldTag::__tf_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tf_version",
                                ));
                            }
                            result.tf_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__color_space => {
                            if !fields.insert(__FieldTag::__color_space) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for color_space",
                                ));
                            }
                            result.color_space = map
                                .next_value::<std::option::Option<crate::model::model::ColorSpace>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance_weight_column => {
                            if !fields.insert(__FieldTag::__instance_weight_column) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_weight_column",
                                ));
                            }
                            result.instance_weight_column = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__trend_smoothing_window_size => {
                            if !fields.insert(__FieldTag::__trend_smoothing_window_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trend_smoothing_window_size",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.trend_smoothing_window_size =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__time_series_length_fraction => {
                            if !fields.insert(__FieldTag::__time_series_length_fraction) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_series_length_fraction",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.time_series_length_fraction =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__min_time_series_length => {
                            if !fields.insert(__FieldTag::__min_time_series_length) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_time_series_length",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.min_time_series_length =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_time_series_length => {
                            if !fields.insert(__FieldTag::__max_time_series_length) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_time_series_length",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_time_series_length =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__xgboost_version => {
                            if !fields.insert(__FieldTag::__xgboost_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for xgboost_version",
                                ));
                            }
                            result.xgboost_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__approx_global_feature_contrib => {
                            if !fields.insert(__FieldTag::__approx_global_feature_contrib) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for approx_global_feature_contrib",
                                ));
                            }
                            result.approx_global_feature_contrib =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__fit_intercept => {
                            if !fields.insert(__FieldTag::__fit_intercept) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fit_intercept",
                                ));
                            }
                            result.fit_intercept =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__num_principal_components => {
                            if !fields.insert(__FieldTag::__num_principal_components) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for num_principal_components",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.num_principal_components =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__pca_explained_variance_ratio => {
                            if !fields.insert(__FieldTag::__pca_explained_variance_ratio) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pca_explained_variance_ratio",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.pca_explained_variance_ratio =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__scale_features => {
                            if !fields.insert(__FieldTag::__scale_features) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scale_features",
                                ));
                            }
                            result.scale_features =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__pca_solver => {
                            if !fields.insert(__FieldTag::__pca_solver) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pca_solver",
                                ));
                            }
                            result.pca_solver = map
                                .next_value::<std::option::Option<
                                    crate::model::model::pca_solver_option_enums::PcaSolver,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__auto_class_weights => {
                            if !fields.insert(__FieldTag::__auto_class_weights) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auto_class_weights",
                                ));
                            }
                            result.auto_class_weights =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__activation_fn => {
                            if !fields.insert(__FieldTag::__activation_fn) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for activation_fn",
                                ));
                            }
                            result.activation_fn = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__optimizer => {
                            if !fields.insert(__FieldTag::__optimizer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optimizer",
                                ));
                            }
                            result.optimizer = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__budget_hours => {
                            if !fields.insert(__FieldTag::__budget_hours) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for budget_hours",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.budget_hours = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__standardize_features => {
                            if !fields.insert(__FieldTag::__standardize_features) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for standardize_features",
                                ));
                            }
                            result.standardize_features =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__l1_reg_activation => {
                            if !fields.insert(__FieldTag::__l1_reg_activation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for l1_reg_activation",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.l1_reg_activation =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__model_registry => {
                            if !fields.insert(__FieldTag::__model_registry) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model_registry",
                                ));
                            }
                            result.model_registry = map
                                .next_value::<std::option::Option<
                                    crate::model::model::model_registry_option_enums::ModelRegistry,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vertex_ai_model_version_aliases => {
                            if !fields.insert(__FieldTag::__vertex_ai_model_version_aliases) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vertex_ai_model_version_aliases",
                                ));
                            }
                            result.vertex_ai_model_version_aliases = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__dimension_id_columns => {
                            if !fields.insert(__FieldTag::__dimension_id_columns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dimension_id_columns",
                                ));
                            }
                            result.dimension_id_columns = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__contribution_metric => {
                            if !fields.insert(__FieldTag::__contribution_metric) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for contribution_metric",
                                ));
                            }
                            result.contribution_metric =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__is_test_column => {
                            if !fields.insert(__FieldTag::__is_test_column) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_test_column",
                                ));
                            }
                            result.is_test_column =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__min_apriori_support => {
                            if !fields.insert(__FieldTag::__min_apriori_support) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_apriori_support",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.min_apriori_support = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::model::training_run::IterationResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __index,
            __duration_ms,
            __training_loss,
            __eval_loss,
            __learn_rate,
            __cluster_infos,
            __arima_result,
            __principal_component_infos,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IterationResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "index" => Ok(__FieldTag::__index),
                            "durationMs" => Ok(__FieldTag::__duration_ms),
                            "duration_ms" => Ok(__FieldTag::__duration_ms),
                            "trainingLoss" => Ok(__FieldTag::__training_loss),
                            "training_loss" => Ok(__FieldTag::__training_loss),
                            "evalLoss" => Ok(__FieldTag::__eval_loss),
                            "eval_loss" => Ok(__FieldTag::__eval_loss),
                            "learnRate" => Ok(__FieldTag::__learn_rate),
                            "learn_rate" => Ok(__FieldTag::__learn_rate),
                            "clusterInfos" => Ok(__FieldTag::__cluster_infos),
                            "cluster_infos" => Ok(__FieldTag::__cluster_infos),
                            "arimaResult" => Ok(__FieldTag::__arima_result),
                            "arima_result" => Ok(__FieldTag::__arima_result),
                            "principalComponentInfos" => {
                                Ok(__FieldTag::__principal_component_infos)
                            }
                            "principal_component_infos" => {
                                Ok(__FieldTag::__principal_component_infos)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::model::training_run::IterationResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IterationResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__index => {
                            if !fields.insert(__FieldTag::__index) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for index",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int32Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.index = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__duration_ms => {
                            if !fields.insert(__FieldTag::__duration_ms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for duration_ms",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.duration_ms = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__training_loss => {
                            if !fields.insert(__FieldTag::__training_loss) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for training_loss",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.training_loss = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__eval_loss => {
                            if !fields.insert(__FieldTag::__eval_loss) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for eval_loss",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.eval_loss = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__learn_rate => {
                            if !fields.insert(__FieldTag::__learn_rate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for learn_rate",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.learn_rate = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__cluster_infos => {
                            if !fields.insert(__FieldTag::__cluster_infos) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_infos",
                                ));
                            }
                            result.cluster_infos = map.next_value::<std::option::Option<std::vec::Vec<crate::model::model::training_run::iteration_result::ClusterInfo>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__arima_result => {
                            if !fields.insert(__FieldTag::__arima_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for arima_result",
                                ));
                            }
                            result.arima_result = map.next_value::<std::option::Option<
                                crate::model::model::training_run::iteration_result::ArimaResult,
                            >>()?;
                        }
                        __FieldTag::__principal_component_infos => {
                            if !fields.insert(__FieldTag::__principal_component_infos) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for principal_component_infos",
                                ));
                            }
                            result.principal_component_infos = map.next_value::<std::option::Option<std::vec::Vec<crate::model::model::training_run::iteration_result::PrincipalComponentInfo>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de>
    for super::model::training_run::iteration_result::ClusterInfo
{
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __centroid_id,
            __cluster_radius,
            __cluster_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ClusterInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "centroidId" => Ok(__FieldTag::__centroid_id),
                            "centroid_id" => Ok(__FieldTag::__centroid_id),
                            "clusterRadius" => Ok(__FieldTag::__cluster_radius),
                            "cluster_radius" => Ok(__FieldTag::__cluster_radius),
                            "clusterSize" => Ok(__FieldTag::__cluster_size),
                            "cluster_size" => Ok(__FieldTag::__cluster_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::model::training_run::iteration_result::ClusterInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ClusterInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__centroid_id => {
                            if !fields.insert(__FieldTag::__centroid_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for centroid_id",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.centroid_id = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__cluster_radius => {
                            if !fields.insert(__FieldTag::__cluster_radius) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_radius",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cluster_radius = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__cluster_size => {
                            if !fields.insert(__FieldTag::__cluster_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_size",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cluster_size = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de>
    for super::model::training_run::iteration_result::ArimaResult
{
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __arima_model_info,
            __seasonal_periods,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ArimaResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "arimaModelInfo" => Ok(__FieldTag::__arima_model_info),
                            "arima_model_info" => Ok(__FieldTag::__arima_model_info),
                            "seasonalPeriods" => Ok(__FieldTag::__seasonal_periods),
                            "seasonal_periods" => Ok(__FieldTag::__seasonal_periods),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::model::training_run::iteration_result::ArimaResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ArimaResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__arima_model_info => {
                            if !fields.insert(__FieldTag::__arima_model_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for arima_model_info",
                                ));
                            }
                            result.arima_model_info = map.next_value::<std::option::Option<std::vec::Vec<crate::model::model::training_run::iteration_result::arima_result::ArimaModelInfo>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__seasonal_periods => {
                            if !fields.insert(__FieldTag::__seasonal_periods) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for seasonal_periods",
                                ));
                            }
                            result.seasonal_periods = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::model::seasonal_period::SeasonalPeriodType,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de>
    for super::model::training_run::iteration_result::arima_result::ArimaCoefficients
{
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __auto_regressive_coefficients,
            __moving_average_coefficients,
            __intercept_coefficient,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ArimaCoefficients")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "autoRegressiveCoefficients" => {
                                Ok(__FieldTag::__auto_regressive_coefficients)
                            }
                            "auto_regressive_coefficients" => {
                                Ok(__FieldTag::__auto_regressive_coefficients)
                            }
                            "movingAverageCoefficients" => {
                                Ok(__FieldTag::__moving_average_coefficients)
                            }
                            "moving_average_coefficients" => {
                                Ok(__FieldTag::__moving_average_coefficients)
                            }
                            "interceptCoefficient" => Ok(__FieldTag::__intercept_coefficient),
                            "intercept_coefficient" => Ok(__FieldTag::__intercept_coefficient),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value =
                super::model::training_run::iteration_result::arima_result::ArimaCoefficients;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ArimaCoefficients")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__auto_regressive_coefficients => {
                            if !fields.insert(__FieldTag::__auto_regressive_coefficients) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auto_regressive_coefficients",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<f64>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::F64>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.auto_regressive_coefficients =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__moving_average_coefficients => {
                            if !fields.insert(__FieldTag::__moving_average_coefficients) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for moving_average_coefficients",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<f64>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::F64>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.moving_average_coefficients =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__intercept_coefficient => {
                            if !fields.insert(__FieldTag::__intercept_coefficient) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for intercept_coefficient",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.intercept_coefficient = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de>
    for super::model::training_run::iteration_result::arima_result::ArimaModelInfo
{
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __non_seasonal_order,
            __arima_coefficients,
            __arima_fitting_metrics,
            __has_drift,
            __time_series_id,
            __time_series_ids,
            __seasonal_periods,
            __has_holiday_effect,
            __has_spikes_and_dips,
            __has_step_changes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ArimaModelInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "nonSeasonalOrder" => Ok(__FieldTag::__non_seasonal_order),
                            "non_seasonal_order" => Ok(__FieldTag::__non_seasonal_order),
                            "arimaCoefficients" => Ok(__FieldTag::__arima_coefficients),
                            "arima_coefficients" => Ok(__FieldTag::__arima_coefficients),
                            "arimaFittingMetrics" => Ok(__FieldTag::__arima_fitting_metrics),
                            "arima_fitting_metrics" => Ok(__FieldTag::__arima_fitting_metrics),
                            "hasDrift" => Ok(__FieldTag::__has_drift),
                            "has_drift" => Ok(__FieldTag::__has_drift),
                            "timeSeriesId" => Ok(__FieldTag::__time_series_id),
                            "time_series_id" => Ok(__FieldTag::__time_series_id),
                            "timeSeriesIds" => Ok(__FieldTag::__time_series_ids),
                            "time_series_ids" => Ok(__FieldTag::__time_series_ids),
                            "seasonalPeriods" => Ok(__FieldTag::__seasonal_periods),
                            "seasonal_periods" => Ok(__FieldTag::__seasonal_periods),
                            "hasHolidayEffect" => Ok(__FieldTag::__has_holiday_effect),
                            "has_holiday_effect" => Ok(__FieldTag::__has_holiday_effect),
                            "hasSpikesAndDips" => Ok(__FieldTag::__has_spikes_and_dips),
                            "has_spikes_and_dips" => Ok(__FieldTag::__has_spikes_and_dips),
                            "hasStepChanges" => Ok(__FieldTag::__has_step_changes),
                            "has_step_changes" => Ok(__FieldTag::__has_step_changes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::model::training_run::iteration_result::arima_result::ArimaModelInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ArimaModelInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__non_seasonal_order => {
                            if !fields.insert(__FieldTag::__non_seasonal_order) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for non_seasonal_order",
                                ));
                            }
                            result.non_seasonal_order = map
                                .next_value::<std::option::Option<crate::model::model::ArimaOrder>>(
                                )?;
                        }
                        __FieldTag::__arima_coefficients => {
                            if !fields.insert(__FieldTag::__arima_coefficients) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for arima_coefficients",
                                ));
                            }
                            result.arima_coefficients = map.next_value::<std::option::Option<crate::model::model::training_run::iteration_result::arima_result::ArimaCoefficients>>()?
                                ;
                        }
                        __FieldTag::__arima_fitting_metrics => {
                            if !fields.insert(__FieldTag::__arima_fitting_metrics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for arima_fitting_metrics",
                                ));
                            }
                            result.arima_fitting_metrics = map.next_value::<std::option::Option<crate::model::model::ArimaFittingMetrics>>()?
                                ;
                        }
                        __FieldTag::__has_drift => {
                            if !fields.insert(__FieldTag::__has_drift) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for has_drift",
                                ));
                            }
                            result.has_drift =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__time_series_id => {
                            if !fields.insert(__FieldTag::__time_series_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_series_id",
                                ));
                            }
                            result.time_series_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__time_series_ids => {
                            if !fields.insert(__FieldTag::__time_series_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_series_ids",
                                ));
                            }
                            result.time_series_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__seasonal_periods => {
                            if !fields.insert(__FieldTag::__seasonal_periods) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for seasonal_periods",
                                ));
                            }
                            result.seasonal_periods = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::model::seasonal_period::SeasonalPeriodType,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__has_holiday_effect => {
                            if !fields.insert(__FieldTag::__has_holiday_effect) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for has_holiday_effect",
                                ));
                            }
                            result.has_holiday_effect =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__has_spikes_and_dips => {
                            if !fields.insert(__FieldTag::__has_spikes_and_dips) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for has_spikes_and_dips",
                                ));
                            }
                            result.has_spikes_and_dips =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__has_step_changes => {
                            if !fields.insert(__FieldTag::__has_step_changes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for has_step_changes",
                                ));
                            }
                            result.has_step_changes =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de>
    for super::model::training_run::iteration_result::PrincipalComponentInfo
{
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __principal_component_id,
            __explained_variance,
            __explained_variance_ratio,
            __cumulative_explained_variance_ratio,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PrincipalComponentInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "principalComponentId" => Ok(__FieldTag::__principal_component_id),
                            "principal_component_id" => Ok(__FieldTag::__principal_component_id),
                            "explainedVariance" => Ok(__FieldTag::__explained_variance),
                            "explained_variance" => Ok(__FieldTag::__explained_variance),
                            "explainedVarianceRatio" => Ok(__FieldTag::__explained_variance_ratio),
                            "explained_variance_ratio" => {
                                Ok(__FieldTag::__explained_variance_ratio)
                            }
                            "cumulativeExplainedVarianceRatio" => {
                                Ok(__FieldTag::__cumulative_explained_variance_ratio)
                            }
                            "cumulative_explained_variance_ratio" => {
                                Ok(__FieldTag::__cumulative_explained_variance_ratio)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::model::training_run::iteration_result::PrincipalComponentInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PrincipalComponentInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__principal_component_id => {
                            if !fields.insert(__FieldTag::__principal_component_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for principal_component_id",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.principal_component_id = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__explained_variance => {
                            if !fields.insert(__FieldTag::__explained_variance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for explained_variance",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.explained_variance = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__explained_variance_ratio => {
                            if !fields.insert(__FieldTag::__explained_variance_ratio) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for explained_variance_ratio",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.explained_variance_ratio = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__cumulative_explained_variance_ratio => {
                            if !fields.insert(__FieldTag::__cumulative_explained_variance_ratio) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cumulative_explained_variance_ratio",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cumulative_explained_variance_ratio =
                                map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::model::DoubleHparamSearchSpace {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __range,
            __candidates,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DoubleHparamSearchSpace")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "range" => Ok(__FieldTag::__range),
                            "candidates" => Ok(__FieldTag::__candidates),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::model::DoubleHparamSearchSpace;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DoubleHparamSearchSpace")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__range => {
                            if !fields.insert(__FieldTag::__range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for range",
                                ));
                            }
                            if result.search_space.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `search_space`, a oneof with full ID .google.cloud.bigquery.v2.Model.DoubleHparamSearchSpace.range, latest field was range",
                                ));
                            }
                            result.search_space = std::option::Option::Some(
                                crate::model::model::double_hparam_search_space::SearchSpace::Range(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::model::double_hparam_search_space::DoubleRange>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__candidates => {
                            if !fields.insert(__FieldTag::__candidates) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for candidates",
                                ));
                            }
                            if result.search_space.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `search_space`, a oneof with full ID .google.cloud.bigquery.v2.Model.DoubleHparamSearchSpace.candidates, latest field was candidates",
                                ));
                            }
                            result.search_space = std::option::Option::Some(
                                crate::model::model::double_hparam_search_space::SearchSpace::Candidates(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::model::double_hparam_search_space::DoubleCandidates>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::model::double_hparam_search_space::DoubleRange {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __min,
            __max,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DoubleRange")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "min" => Ok(__FieldTag::__min),
                            "max" => Ok(__FieldTag::__max),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::model::double_hparam_search_space::DoubleRange;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DoubleRange")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__min => {
                            if !fields.insert(__FieldTag::__min) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.min = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__max => {
                            if !fields.insert(__FieldTag::__max) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de>
    for super::model::double_hparam_search_space::DoubleCandidates
{
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __candidates,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DoubleCandidates")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "candidates" => Ok(__FieldTag::__candidates),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::model::double_hparam_search_space::DoubleCandidates;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DoubleCandidates")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__candidates => {
                            if !fields.insert(__FieldTag::__candidates) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for candidates",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<wkt::DoubleValue>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::F64>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.candidates = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::model::IntHparamSearchSpace {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __range,
            __candidates,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IntHparamSearchSpace")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "range" => Ok(__FieldTag::__range),
                            "candidates" => Ok(__FieldTag::__candidates),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::model::IntHparamSearchSpace;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IntHparamSearchSpace")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__range => {
                            if !fields.insert(__FieldTag::__range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for range",
                                ));
                            }
                            if result.search_space.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `search_space`, a oneof with full ID .google.cloud.bigquery.v2.Model.IntHparamSearchSpace.range, latest field was range",
                                ));
                            }
                            result.search_space = std::option::Option::Some(
                                crate::model::model::int_hparam_search_space::SearchSpace::Range(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::model::int_hparam_search_space::IntRange,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__candidates => {
                            if !fields.insert(__FieldTag::__candidates) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for candidates",
                                ));
                            }
                            if result.search_space.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `search_space`, a oneof with full ID .google.cloud.bigquery.v2.Model.IntHparamSearchSpace.candidates, latest field was candidates",
                                ));
                            }
                            result.search_space = std::option::Option::Some(
                                crate::model::model::int_hparam_search_space::SearchSpace::Candidates(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::model::int_hparam_search_space::IntCandidates>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::model::int_hparam_search_space::IntRange {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __min,
            __max,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IntRange")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "min" => Ok(__FieldTag::__min),
                            "max" => Ok(__FieldTag::__max),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::model::int_hparam_search_space::IntRange;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IntRange")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__min => {
                            if !fields.insert(__FieldTag::__min) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.min = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__max => {
                            if !fields.insert(__FieldTag::__max) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::model::int_hparam_search_space::IntCandidates {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __candidates,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IntCandidates")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "candidates" => Ok(__FieldTag::__candidates),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::model::int_hparam_search_space::IntCandidates;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IntCandidates")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__candidates => {
                            if !fields.insert(__FieldTag::__candidates) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for candidates",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<wkt::Int64Value>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I64>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.candidates = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::model::StringHparamSearchSpace {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __candidates,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StringHparamSearchSpace")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "candidates" => Ok(__FieldTag::__candidates),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::model::StringHparamSearchSpace;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StringHparamSearchSpace")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__candidates => {
                            if !fields.insert(__FieldTag::__candidates) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for candidates",
                                ));
                            }
                            result.candidates = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::model::IntArrayHparamSearchSpace {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __candidates,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IntArrayHparamSearchSpace")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "candidates" => Ok(__FieldTag::__candidates),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::model::IntArrayHparamSearchSpace;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IntArrayHparamSearchSpace")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__candidates => {
                            if !fields.insert(__FieldTag::__candidates) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for candidates",
                                ));
                            }
                            result.candidates = map.next_value::<std::option::Option<std::vec::Vec<crate::model::model::int_array_hparam_search_space::IntArray>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::model::int_array_hparam_search_space::IntArray {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __elements,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IntArray")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "elements" => Ok(__FieldTag::__elements),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::model::int_array_hparam_search_space::IntArray;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IntArray")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__elements => {
                            if !fields.insert(__FieldTag::__elements) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for elements",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i64>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I64>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.elements = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::model::HparamSearchSpaces {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __learn_rate,
            __l1_reg,
            __l2_reg,
            __num_clusters,
            __num_factors,
            __hidden_units,
            __batch_size,
            __dropout,
            __max_tree_depth,
            __subsample,
            __min_split_loss,
            __wals_alpha,
            __booster_type,
            __num_parallel_tree,
            __dart_normalize_type,
            __tree_method,
            __min_tree_child_weight,
            __colsample_bytree,
            __colsample_bylevel,
            __colsample_bynode,
            __activation_fn,
            __optimizer,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HparamSearchSpaces")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "learnRate" => Ok(__FieldTag::__learn_rate),
                            "learn_rate" => Ok(__FieldTag::__learn_rate),
                            "l1Reg" => Ok(__FieldTag::__l1_reg),
                            "l1_reg" => Ok(__FieldTag::__l1_reg),
                            "l2Reg" => Ok(__FieldTag::__l2_reg),
                            "l2_reg" => Ok(__FieldTag::__l2_reg),
                            "numClusters" => Ok(__FieldTag::__num_clusters),
                            "num_clusters" => Ok(__FieldTag::__num_clusters),
                            "numFactors" => Ok(__FieldTag::__num_factors),
                            "num_factors" => Ok(__FieldTag::__num_factors),
                            "hiddenUnits" => Ok(__FieldTag::__hidden_units),
                            "hidden_units" => Ok(__FieldTag::__hidden_units),
                            "batchSize" => Ok(__FieldTag::__batch_size),
                            "batch_size" => Ok(__FieldTag::__batch_size),
                            "dropout" => Ok(__FieldTag::__dropout),
                            "maxTreeDepth" => Ok(__FieldTag::__max_tree_depth),
                            "max_tree_depth" => Ok(__FieldTag::__max_tree_depth),
                            "subsample" => Ok(__FieldTag::__subsample),
                            "minSplitLoss" => Ok(__FieldTag::__min_split_loss),
                            "min_split_loss" => Ok(__FieldTag::__min_split_loss),
                            "walsAlpha" => Ok(__FieldTag::__wals_alpha),
                            "wals_alpha" => Ok(__FieldTag::__wals_alpha),
                            "boosterType" => Ok(__FieldTag::__booster_type),
                            "booster_type" => Ok(__FieldTag::__booster_type),
                            "numParallelTree" => Ok(__FieldTag::__num_parallel_tree),
                            "num_parallel_tree" => Ok(__FieldTag::__num_parallel_tree),
                            "dartNormalizeType" => Ok(__FieldTag::__dart_normalize_type),
                            "dart_normalize_type" => Ok(__FieldTag::__dart_normalize_type),
                            "treeMethod" => Ok(__FieldTag::__tree_method),
                            "tree_method" => Ok(__FieldTag::__tree_method),
                            "minTreeChildWeight" => Ok(__FieldTag::__min_tree_child_weight),
                            "min_tree_child_weight" => Ok(__FieldTag::__min_tree_child_weight),
                            "colsampleBytree" => Ok(__FieldTag::__colsample_bytree),
                            "colsample_bytree" => Ok(__FieldTag::__colsample_bytree),
                            "colsampleBylevel" => Ok(__FieldTag::__colsample_bylevel),
                            "colsample_bylevel" => Ok(__FieldTag::__colsample_bylevel),
                            "colsampleBynode" => Ok(__FieldTag::__colsample_bynode),
                            "colsample_bynode" => Ok(__FieldTag::__colsample_bynode),
                            "activationFn" => Ok(__FieldTag::__activation_fn),
                            "activation_fn" => Ok(__FieldTag::__activation_fn),
                            "optimizer" => Ok(__FieldTag::__optimizer),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::model::HparamSearchSpaces;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HparamSearchSpaces")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__learn_rate => {
                            if !fields.insert(__FieldTag::__learn_rate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for learn_rate",
                                ));
                            }
                            result.learn_rate =
                                map.next_value::<std::option::Option<
                                    crate::model::model::DoubleHparamSearchSpace,
                                >>()?;
                        }
                        __FieldTag::__l1_reg => {
                            if !fields.insert(__FieldTag::__l1_reg) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for l1_reg",
                                ));
                            }
                            result.l1_reg =
                                map.next_value::<std::option::Option<
                                    crate::model::model::DoubleHparamSearchSpace,
                                >>()?;
                        }
                        __FieldTag::__l2_reg => {
                            if !fields.insert(__FieldTag::__l2_reg) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for l2_reg",
                                ));
                            }
                            result.l2_reg =
                                map.next_value::<std::option::Option<
                                    crate::model::model::DoubleHparamSearchSpace,
                                >>()?;
                        }
                        __FieldTag::__num_clusters => {
                            if !fields.insert(__FieldTag::__num_clusters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for num_clusters",
                                ));
                            }
                            result.num_clusters = map.next_value::<std::option::Option<crate::model::model::IntHparamSearchSpace>>()?
                                ;
                        }
                        __FieldTag::__num_factors => {
                            if !fields.insert(__FieldTag::__num_factors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for num_factors",
                                ));
                            }
                            result.num_factors = map.next_value::<std::option::Option<crate::model::model::IntHparamSearchSpace>>()?
                                ;
                        }
                        __FieldTag::__hidden_units => {
                            if !fields.insert(__FieldTag::__hidden_units) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hidden_units",
                                ));
                            }
                            result.hidden_units = map.next_value::<std::option::Option<
                                crate::model::model::IntArrayHparamSearchSpace,
                            >>()?;
                        }
                        __FieldTag::__batch_size => {
                            if !fields.insert(__FieldTag::__batch_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for batch_size",
                                ));
                            }
                            result.batch_size = map.next_value::<std::option::Option<crate::model::model::IntHparamSearchSpace>>()?
                                ;
                        }
                        __FieldTag::__dropout => {
                            if !fields.insert(__FieldTag::__dropout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dropout",
                                ));
                            }
                            result.dropout =
                                map.next_value::<std::option::Option<
                                    crate::model::model::DoubleHparamSearchSpace,
                                >>()?;
                        }
                        __FieldTag::__max_tree_depth => {
                            if !fields.insert(__FieldTag::__max_tree_depth) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_tree_depth",
                                ));
                            }
                            result.max_tree_depth = map.next_value::<std::option::Option<crate::model::model::IntHparamSearchSpace>>()?
                                ;
                        }
                        __FieldTag::__subsample => {
                            if !fields.insert(__FieldTag::__subsample) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subsample",
                                ));
                            }
                            result.subsample =
                                map.next_value::<std::option::Option<
                                    crate::model::model::DoubleHparamSearchSpace,
                                >>()?;
                        }
                        __FieldTag::__min_split_loss => {
                            if !fields.insert(__FieldTag::__min_split_loss) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_split_loss",
                                ));
                            }
                            result.min_split_loss =
                                map.next_value::<std::option::Option<
                                    crate::model::model::DoubleHparamSearchSpace,
                                >>()?;
                        }
                        __FieldTag::__wals_alpha => {
                            if !fields.insert(__FieldTag::__wals_alpha) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for wals_alpha",
                                ));
                            }
                            result.wals_alpha =
                                map.next_value::<std::option::Option<
                                    crate::model::model::DoubleHparamSearchSpace,
                                >>()?;
                        }
                        __FieldTag::__booster_type => {
                            if !fields.insert(__FieldTag::__booster_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for booster_type",
                                ));
                            }
                            result.booster_type =
                                map.next_value::<std::option::Option<
                                    crate::model::model::StringHparamSearchSpace,
                                >>()?;
                        }
                        __FieldTag::__num_parallel_tree => {
                            if !fields.insert(__FieldTag::__num_parallel_tree) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for num_parallel_tree",
                                ));
                            }
                            result.num_parallel_tree = map.next_value::<std::option::Option<crate::model::model::IntHparamSearchSpace>>()?
                                ;
                        }
                        __FieldTag::__dart_normalize_type => {
                            if !fields.insert(__FieldTag::__dart_normalize_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dart_normalize_type",
                                ));
                            }
                            result.dart_normalize_type =
                                map.next_value::<std::option::Option<
                                    crate::model::model::StringHparamSearchSpace,
                                >>()?;
                        }
                        __FieldTag::__tree_method => {
                            if !fields.insert(__FieldTag::__tree_method) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tree_method",
                                ));
                            }
                            result.tree_method =
                                map.next_value::<std::option::Option<
                                    crate::model::model::StringHparamSearchSpace,
                                >>()?;
                        }
                        __FieldTag::__min_tree_child_weight => {
                            if !fields.insert(__FieldTag::__min_tree_child_weight) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_tree_child_weight",
                                ));
                            }
                            result.min_tree_child_weight = map.next_value::<std::option::Option<crate::model::model::IntHparamSearchSpace>>()?
                                ;
                        }
                        __FieldTag::__colsample_bytree => {
                            if !fields.insert(__FieldTag::__colsample_bytree) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for colsample_bytree",
                                ));
                            }
                            result.colsample_bytree =
                                map.next_value::<std::option::Option<
                                    crate::model::model::DoubleHparamSearchSpace,
                                >>()?;
                        }
                        __FieldTag::__colsample_bylevel => {
                            if !fields.insert(__FieldTag::__colsample_bylevel) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for colsample_bylevel",
                                ));
                            }
                            result.colsample_bylevel =
                                map.next_value::<std::option::Option<
                                    crate::model::model::DoubleHparamSearchSpace,
                                >>()?;
                        }
                        __FieldTag::__colsample_bynode => {
                            if !fields.insert(__FieldTag::__colsample_bynode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for colsample_bynode",
                                ));
                            }
                            result.colsample_bynode =
                                map.next_value::<std::option::Option<
                                    crate::model::model::DoubleHparamSearchSpace,
                                >>()?;
                        }
                        __FieldTag::__activation_fn => {
                            if !fields.insert(__FieldTag::__activation_fn) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for activation_fn",
                                ));
                            }
                            result.activation_fn =
                                map.next_value::<std::option::Option<
                                    crate::model::model::StringHparamSearchSpace,
                                >>()?;
                        }
                        __FieldTag::__optimizer => {
                            if !fields.insert(__FieldTag::__optimizer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optimizer",
                                ));
                            }
                            result.optimizer =
                                map.next_value::<std::option::Option<
                                    crate::model::model::StringHparamSearchSpace,
                                >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::model::HparamTuningTrial {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __trial_id,
            __start_time_ms,
            __end_time_ms,
            __hparams,
            __evaluation_metrics,
            __status,
            __error_message,
            __training_loss,
            __eval_loss,
            __hparam_tuning_evaluation_metrics,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HparamTuningTrial")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "trialId" => Ok(__FieldTag::__trial_id),
                            "trial_id" => Ok(__FieldTag::__trial_id),
                            "startTimeMs" => Ok(__FieldTag::__start_time_ms),
                            "start_time_ms" => Ok(__FieldTag::__start_time_ms),
                            "endTimeMs" => Ok(__FieldTag::__end_time_ms),
                            "end_time_ms" => Ok(__FieldTag::__end_time_ms),
                            "hparams" => Ok(__FieldTag::__hparams),
                            "evaluationMetrics" => Ok(__FieldTag::__evaluation_metrics),
                            "evaluation_metrics" => Ok(__FieldTag::__evaluation_metrics),
                            "status" => Ok(__FieldTag::__status),
                            "errorMessage" => Ok(__FieldTag::__error_message),
                            "error_message" => Ok(__FieldTag::__error_message),
                            "trainingLoss" => Ok(__FieldTag::__training_loss),
                            "training_loss" => Ok(__FieldTag::__training_loss),
                            "evalLoss" => Ok(__FieldTag::__eval_loss),
                            "eval_loss" => Ok(__FieldTag::__eval_loss),
                            "hparamTuningEvaluationMetrics" => {
                                Ok(__FieldTag::__hparam_tuning_evaluation_metrics)
                            }
                            "hparam_tuning_evaluation_metrics" => {
                                Ok(__FieldTag::__hparam_tuning_evaluation_metrics)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::model::HparamTuningTrial;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HparamTuningTrial")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__trial_id => {
                            if !fields.insert(__FieldTag::__trial_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trial_id",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.trial_id = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__start_time_ms => {
                            if !fields.insert(__FieldTag::__start_time_ms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time_ms",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.start_time_ms =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__end_time_ms => {
                            if !fields.insert(__FieldTag::__end_time_ms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time_ms",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.end_time_ms = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__hparams => {
                            if !fields.insert(__FieldTag::__hparams) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hparams",
                                ));
                            }
                            result.hparams = map.next_value::<std::option::Option<
                                crate::model::model::training_run::TrainingOptions,
                            >>()?;
                        }
                        __FieldTag::__evaluation_metrics => {
                            if !fields.insert(__FieldTag::__evaluation_metrics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for evaluation_metrics",
                                ));
                            }
                            result.evaluation_metrics = map.next_value::<std::option::Option<crate::model::model::EvaluationMetrics>>()?
                                ;
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status = map
                                .next_value::<std::option::Option<
                                    crate::model::model::hparam_tuning_trial::TrialStatus,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__error_message => {
                            if !fields.insert(__FieldTag::__error_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_message",
                                ));
                            }
                            result.error_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__training_loss => {
                            if !fields.insert(__FieldTag::__training_loss) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for training_loss",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.training_loss = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__eval_loss => {
                            if !fields.insert(__FieldTag::__eval_loss) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for eval_loss",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.eval_loss = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__hparam_tuning_evaluation_metrics => {
                            if !fields.insert(__FieldTag::__hparam_tuning_evaluation_metrics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hparam_tuning_evaluation_metrics",
                                ));
                            }
                            result.hparam_tuning_evaluation_metrics = map.next_value::<std::option::Option<crate::model::model::EvaluationMetrics>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetModelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __model_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetModelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "modelId" => Ok(__FieldTag::__model_id),
                            "model_id" => Ok(__FieldTag::__model_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetModelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetModelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__model_id => {
                            if !fields.insert(__FieldTag::__model_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model_id",
                                ));
                            }
                            result.model_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::PatchModelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __model_id,
            __model,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PatchModelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "modelId" => Ok(__FieldTag::__model_id),
                            "model_id" => Ok(__FieldTag::__model_id),
                            "model" => Ok(__FieldTag::__model),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::PatchModelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PatchModelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__model_id => {
                            if !fields.insert(__FieldTag::__model_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model_id",
                                ));
                            }
                            result.model_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__model => {
                            if !fields.insert(__FieldTag::__model) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model",
                                ));
                            }
                            result.model =
                                map.next_value::<std::option::Option<crate::model::Model>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeleteModelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __model_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteModelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "modelId" => Ok(__FieldTag::__model_id),
                            "model_id" => Ok(__FieldTag::__model_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeleteModelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteModelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__model_id => {
                            if !fields.insert(__FieldTag::__model_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model_id",
                                ));
                            }
                            result.model_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListModelsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __max_results,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListModelsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "maxResults" => Ok(__FieldTag::__max_results),
                            "max_results" => Ok(__FieldTag::__max_results),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListModelsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListModelsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__max_results => {
                            if !fields.insert(__FieldTag::__max_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_results",
                                ));
                            }
                            struct __With(std::option::Option<wkt::UInt32Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_results = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListModelsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __models,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListModelsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "models" => Ok(__FieldTag::__models),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListModelsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListModelsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__models => {
                            if !fields.insert(__FieldTag::__models) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for models",
                                ));
                            }
                            result.models = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Model>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ModelReference {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __model_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ModelReference")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "modelId" => Ok(__FieldTag::__model_id),
                            "model_id" => Ok(__FieldTag::__model_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ModelReference;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ModelReference")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__model_id => {
                            if !fields.insert(__FieldTag::__model_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model_id",
                                ));
                            }
                            result.model_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::PartitioningDefinition {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __partitioned_column,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PartitioningDefinition")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "partitionedColumn" => Ok(__FieldTag::__partitioned_column),
                            "partitioned_column" => Ok(__FieldTag::__partitioned_column),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::PartitioningDefinition;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PartitioningDefinition")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__partitioned_column => {
                            if !fields.insert(__FieldTag::__partitioned_column) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for partitioned_column",
                                ));
                            }
                            result.partitioned_column =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::PartitionedColumn>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::PartitionedColumn {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __field,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PartitionedColumn")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "field" => Ok(__FieldTag::__field),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::PartitionedColumn;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PartitionedColumn")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__field => {
                            if !fields.insert(__FieldTag::__field) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field",
                                ));
                            }
                            result.field =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AggregationThresholdPolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __threshold,
            __privacy_unit_columns,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AggregationThresholdPolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "threshold" => Ok(__FieldTag::__threshold),
                            "privacyUnitColumns" => Ok(__FieldTag::__privacy_unit_columns),
                            "privacy_unit_columns" => Ok(__FieldTag::__privacy_unit_columns),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AggregationThresholdPolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AggregationThresholdPolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__threshold => {
                            if !fields.insert(__FieldTag::__threshold) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for threshold",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.threshold = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__privacy_unit_columns => {
                            if !fields.insert(__FieldTag::__privacy_unit_columns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for privacy_unit_columns",
                                ));
                            }
                            result.privacy_unit_columns = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DifferentialPrivacyPolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __max_epsilon_per_query,
            __delta_per_query,
            __max_groups_contributed,
            __privacy_unit_column,
            __epsilon_budget,
            __delta_budget,
            __epsilon_budget_remaining,
            __delta_budget_remaining,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DifferentialPrivacyPolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "maxEpsilonPerQuery" => Ok(__FieldTag::__max_epsilon_per_query),
                            "max_epsilon_per_query" => Ok(__FieldTag::__max_epsilon_per_query),
                            "deltaPerQuery" => Ok(__FieldTag::__delta_per_query),
                            "delta_per_query" => Ok(__FieldTag::__delta_per_query),
                            "maxGroupsContributed" => Ok(__FieldTag::__max_groups_contributed),
                            "max_groups_contributed" => Ok(__FieldTag::__max_groups_contributed),
                            "privacyUnitColumn" => Ok(__FieldTag::__privacy_unit_column),
                            "privacy_unit_column" => Ok(__FieldTag::__privacy_unit_column),
                            "epsilonBudget" => Ok(__FieldTag::__epsilon_budget),
                            "epsilon_budget" => Ok(__FieldTag::__epsilon_budget),
                            "deltaBudget" => Ok(__FieldTag::__delta_budget),
                            "delta_budget" => Ok(__FieldTag::__delta_budget),
                            "epsilonBudgetRemaining" => Ok(__FieldTag::__epsilon_budget_remaining),
                            "epsilon_budget_remaining" => {
                                Ok(__FieldTag::__epsilon_budget_remaining)
                            }
                            "deltaBudgetRemaining" => Ok(__FieldTag::__delta_budget_remaining),
                            "delta_budget_remaining" => Ok(__FieldTag::__delta_budget_remaining),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DifferentialPrivacyPolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DifferentialPrivacyPolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__max_epsilon_per_query => {
                            if !fields.insert(__FieldTag::__max_epsilon_per_query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_epsilon_per_query",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_epsilon_per_query = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__delta_per_query => {
                            if !fields.insert(__FieldTag::__delta_per_query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delta_per_query",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.delta_per_query = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__max_groups_contributed => {
                            if !fields.insert(__FieldTag::__max_groups_contributed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_groups_contributed",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_groups_contributed = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__privacy_unit_column => {
                            if !fields.insert(__FieldTag::__privacy_unit_column) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for privacy_unit_column",
                                ));
                            }
                            result.privacy_unit_column =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__epsilon_budget => {
                            if !fields.insert(__FieldTag::__epsilon_budget) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for epsilon_budget",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.epsilon_budget = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__delta_budget => {
                            if !fields.insert(__FieldTag::__delta_budget) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delta_budget",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.delta_budget = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__epsilon_budget_remaining => {
                            if !fields.insert(__FieldTag::__epsilon_budget_remaining) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for epsilon_budget_remaining",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.epsilon_budget_remaining = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__delta_budget_remaining => {
                            if !fields.insert(__FieldTag::__delta_budget_remaining) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delta_budget_remaining",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.delta_budget_remaining = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::JoinRestrictionPolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __join_condition,
            __join_allowed_columns,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for JoinRestrictionPolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "joinCondition" => Ok(__FieldTag::__join_condition),
                            "join_condition" => Ok(__FieldTag::__join_condition),
                            "joinAllowedColumns" => Ok(__FieldTag::__join_allowed_columns),
                            "join_allowed_columns" => Ok(__FieldTag::__join_allowed_columns),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::JoinRestrictionPolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct JoinRestrictionPolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__join_condition => {
                            if !fields.insert(__FieldTag::__join_condition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for join_condition",
                                ));
                            }
                            result.join_condition = map.next_value::<std::option::Option<
                                crate::model::join_restriction_policy::JoinCondition,
                            >>()?;
                        }
                        __FieldTag::__join_allowed_columns => {
                            if !fields.insert(__FieldTag::__join_allowed_columns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for join_allowed_columns",
                                ));
                            }
                            result.join_allowed_columns = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::PrivacyPolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __aggregation_threshold_policy,
            __differential_privacy_policy,
            __join_restriction_policy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PrivacyPolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "aggregationThresholdPolicy" => {
                                Ok(__FieldTag::__aggregation_threshold_policy)
                            }
                            "aggregation_threshold_policy" => {
                                Ok(__FieldTag::__aggregation_threshold_policy)
                            }
                            "differentialPrivacyPolicy" => {
                                Ok(__FieldTag::__differential_privacy_policy)
                            }
                            "differential_privacy_policy" => {
                                Ok(__FieldTag::__differential_privacy_policy)
                            }
                            "joinRestrictionPolicy" => Ok(__FieldTag::__join_restriction_policy),
                            "join_restriction_policy" => Ok(__FieldTag::__join_restriction_policy),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::PrivacyPolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PrivacyPolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__aggregation_threshold_policy => {
                            if !fields.insert(__FieldTag::__aggregation_threshold_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aggregation_threshold_policy",
                                ));
                            }
                            if result.privacy_policy.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `privacy_policy`, a oneof with full ID .google.cloud.bigquery.v2.PrivacyPolicy.aggregation_threshold_policy, latest field was aggregationThresholdPolicy",
                                ));
                            }
                            result.privacy_policy = std::option::Option::Some(
                                crate::model::privacy_policy::PrivacyPolicy::AggregationThresholdPolicy(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::AggregationThresholdPolicy>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__differential_privacy_policy => {
                            if !fields.insert(__FieldTag::__differential_privacy_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for differential_privacy_policy",
                                ));
                            }
                            if result.privacy_policy.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `privacy_policy`, a oneof with full ID .google.cloud.bigquery.v2.PrivacyPolicy.differential_privacy_policy, latest field was differentialPrivacyPolicy",
                                ));
                            }
                            result.privacy_policy = std::option::Option::Some(
                                crate::model::privacy_policy::PrivacyPolicy::DifferentialPrivacyPolicy(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::DifferentialPrivacyPolicy>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__join_restriction_policy => {
                            if !fields.insert(__FieldTag::__join_restriction_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for join_restriction_policy",
                                ));
                            }
                            result.join_restriction_policy = map.next_value::<std::option::Option<crate::model::JoinRestrictionPolicy>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetServiceAccountRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetServiceAccountRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetServiceAccountRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetServiceAccountRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetServiceAccountResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __email,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetServiceAccountResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "email" => Ok(__FieldTag::__email),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetServiceAccountResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetServiceAccountResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__email => {
                            if !fields.insert(__FieldTag::__email) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for email",
                                ));
                            }
                            result.email = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::QueryParameterStructType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __type,
            __description,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QueryParameterStructType")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "type" => Ok(__FieldTag::__type),
                            "description" => Ok(__FieldTag::__description),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::QueryParameterStructType;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QueryParameterStructType")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<
                                std::boxed::Box<crate::model::QueryParameterType>,
                            >>()?;
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::QueryParameterType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __timestamp_precision,
            __array_type,
            __struct_types,
            __range_element_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QueryParameterType")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "timestampPrecision" => Ok(__FieldTag::__timestamp_precision),
                            "timestamp_precision" => Ok(__FieldTag::__timestamp_precision),
                            "arrayType" => Ok(__FieldTag::__array_type),
                            "array_type" => Ok(__FieldTag::__array_type),
                            "structTypes" => Ok(__FieldTag::__struct_types),
                            "struct_types" => Ok(__FieldTag::__struct_types),
                            "rangeElementType" => Ok(__FieldTag::__range_element_type),
                            "range_element_type" => Ok(__FieldTag::__range_element_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::QueryParameterType;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QueryParameterType")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__timestamp_precision => {
                            if !fields.insert(__FieldTag::__timestamp_precision) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timestamp_precision",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.timestamp_precision = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__array_type => {
                            if !fields.insert(__FieldTag::__array_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for array_type",
                                ));
                            }
                            result.array_type = map.next_value::<std::option::Option<
                                std::boxed::Box<crate::model::QueryParameterType>,
                            >>()?;
                        }
                        __FieldTag::__struct_types => {
                            if !fields.insert(__FieldTag::__struct_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for struct_types",
                                ));
                            }
                            result.struct_types = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::QueryParameterStructType>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__range_element_type => {
                            if !fields.insert(__FieldTag::__range_element_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for range_element_type",
                                ));
                            }
                            result.range_element_type = map.next_value::<std::option::Option<
                                std::boxed::Box<crate::model::QueryParameterType>,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RangeValue {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __start,
            __end,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RangeValue")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "start" => Ok(__FieldTag::__start),
                            "end" => Ok(__FieldTag::__end),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RangeValue;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RangeValue")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__start => {
                            if !fields.insert(__FieldTag::__start) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start",
                                ));
                            }
                            result.start = map.next_value::<std::option::Option<
                                std::boxed::Box<crate::model::QueryParameterValue>,
                            >>()?;
                        }
                        __FieldTag::__end => {
                            if !fields.insert(__FieldTag::__end) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end",
                                ));
                            }
                            result.end = map.next_value::<std::option::Option<
                                std::boxed::Box<crate::model::QueryParameterValue>,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::QueryParameterValue {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __value,
            __array_values,
            __struct_values,
            __range_value,
            __alt_struct_values,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QueryParameterValue")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "value" => Ok(__FieldTag::__value),
                            "arrayValues" => Ok(__FieldTag::__array_values),
                            "array_values" => Ok(__FieldTag::__array_values),
                            "structValues" => Ok(__FieldTag::__struct_values),
                            "struct_values" => Ok(__FieldTag::__struct_values),
                            "rangeValue" => Ok(__FieldTag::__range_value),
                            "range_value" => Ok(__FieldTag::__range_value),
                            "altStructValues" => Ok(__FieldTag::__alt_struct_values),
                            "alt_struct_values" => Ok(__FieldTag::__alt_struct_values),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::QueryParameterValue;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QueryParameterValue")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            result.value =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::__array_values => {
                            if !fields.insert(__FieldTag::__array_values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for array_values",
                                ));
                            }
                            result.array_values = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::QueryParameterValue>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__struct_values => {
                            if !fields.insert(__FieldTag::__struct_values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for struct_values",
                                ));
                            }
                            result.struct_values = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::QueryParameterValue,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__range_value => {
                            if !fields.insert(__FieldTag::__range_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for range_value",
                                ));
                            }
                            result.range_value = map.next_value::<std::option::Option<std::boxed::Box<crate::model::RangeValue>>>()?
                                ;
                        }
                        __FieldTag::__alt_struct_values => {
                            if !fields.insert(__FieldTag::__alt_struct_values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for alt_struct_values",
                                ));
                            }
                            result.alt_struct_values = map
                                .next_value::<std::option::Option<std::vec::Vec<wkt::Value>>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::QueryParameter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __parameter_type,
            __parameter_value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QueryParameter")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "parameterType" => Ok(__FieldTag::__parameter_type),
                            "parameter_type" => Ok(__FieldTag::__parameter_type),
                            "parameterValue" => Ok(__FieldTag::__parameter_value),
                            "parameter_value" => Ok(__FieldTag::__parameter_value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::QueryParameter;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QueryParameter")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parameter_type => {
                            if !fields.insert(__FieldTag::__parameter_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parameter_type",
                                ));
                            }
                            result.parameter_type = map.next_value::<std::option::Option<crate::model::QueryParameterType>>()?
                                ;
                        }
                        __FieldTag::__parameter_value => {
                            if !fields.insert(__FieldTag::__parameter_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parameter_value",
                                ));
                            }
                            result.parameter_value = map.next_value::<std::option::Option<crate::model::QueryParameterValue>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RangePartitioning {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __field,
            __range,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RangePartitioning")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "field" => Ok(__FieldTag::__field),
                            "range" => Ok(__FieldTag::__range),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RangePartitioning;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RangePartitioning")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__field => {
                            if !fields.insert(__FieldTag::__field) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field",
                                ));
                            }
                            result.field = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__range => {
                            if !fields.insert(__FieldTag::__range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for range",
                                ));
                            }
                            result.range = map.next_value::<std::option::Option<crate::model::range_partitioning::Range>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::range_partitioning::Range {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __start,
            __end,
            __interval,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Range")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "start" => Ok(__FieldTag::__start),
                            "end" => Ok(__FieldTag::__end),
                            "interval" => Ok(__FieldTag::__interval),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::range_partitioning::Range;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Range")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__start => {
                            if !fields.insert(__FieldTag::__start) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start",
                                ));
                            }
                            result.start = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__end => {
                            if !fields.insert(__FieldTag::__end) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end",
                                ));
                            }
                            result.end = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__interval => {
                            if !fields.insert(__FieldTag::__interval) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for interval",
                                ));
                            }
                            result.interval = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RestrictionConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RestrictionConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RestrictionConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RestrictionConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<
                                    crate::model::restriction_config::RestrictionType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Routine {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __etag,
            __routine_reference,
            __routine_type,
            __creation_time,
            __last_modified_time,
            __language,
            __arguments,
            __return_type,
            __return_table_type,
            __imported_libraries,
            __definition_body,
            __description,
            __determinism_level,
            __security_mode,
            __strict_mode,
            __remote_function_options,
            __spark_options,
            __data_governance_type,
            __python_options,
            __external_runtime_options,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Routine")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "etag" => Ok(__FieldTag::__etag),
                            "routineReference" => Ok(__FieldTag::__routine_reference),
                            "routine_reference" => Ok(__FieldTag::__routine_reference),
                            "routineType" => Ok(__FieldTag::__routine_type),
                            "routine_type" => Ok(__FieldTag::__routine_type),
                            "creationTime" => Ok(__FieldTag::__creation_time),
                            "creation_time" => Ok(__FieldTag::__creation_time),
                            "lastModifiedTime" => Ok(__FieldTag::__last_modified_time),
                            "last_modified_time" => Ok(__FieldTag::__last_modified_time),
                            "language" => Ok(__FieldTag::__language),
                            "arguments" => Ok(__FieldTag::__arguments),
                            "returnType" => Ok(__FieldTag::__return_type),
                            "return_type" => Ok(__FieldTag::__return_type),
                            "returnTableType" => Ok(__FieldTag::__return_table_type),
                            "return_table_type" => Ok(__FieldTag::__return_table_type),
                            "importedLibraries" => Ok(__FieldTag::__imported_libraries),
                            "imported_libraries" => Ok(__FieldTag::__imported_libraries),
                            "definitionBody" => Ok(__FieldTag::__definition_body),
                            "definition_body" => Ok(__FieldTag::__definition_body),
                            "description" => Ok(__FieldTag::__description),
                            "determinismLevel" => Ok(__FieldTag::__determinism_level),
                            "determinism_level" => Ok(__FieldTag::__determinism_level),
                            "securityMode" => Ok(__FieldTag::__security_mode),
                            "security_mode" => Ok(__FieldTag::__security_mode),
                            "strictMode" => Ok(__FieldTag::__strict_mode),
                            "strict_mode" => Ok(__FieldTag::__strict_mode),
                            "remoteFunctionOptions" => Ok(__FieldTag::__remote_function_options),
                            "remote_function_options" => Ok(__FieldTag::__remote_function_options),
                            "sparkOptions" => Ok(__FieldTag::__spark_options),
                            "spark_options" => Ok(__FieldTag::__spark_options),
                            "dataGovernanceType" => Ok(__FieldTag::__data_governance_type),
                            "data_governance_type" => Ok(__FieldTag::__data_governance_type),
                            "pythonOptions" => Ok(__FieldTag::__python_options),
                            "python_options" => Ok(__FieldTag::__python_options),
                            "externalRuntimeOptions" => Ok(__FieldTag::__external_runtime_options),
                            "external_runtime_options" => {
                                Ok(__FieldTag::__external_runtime_options)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Routine;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Routine")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__routine_reference => {
                            if !fields.insert(__FieldTag::__routine_reference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for routine_reference",
                                ));
                            }
                            result.routine_reference = map
                                .next_value::<std::option::Option<crate::model::RoutineReference>>(
                                )?;
                        }
                        __FieldTag::__routine_type => {
                            if !fields.insert(__FieldTag::__routine_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for routine_type",
                                ));
                            }
                            result.routine_type = map.next_value::<std::option::Option<crate::model::routine::RoutineType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__creation_time => {
                            if !fields.insert(__FieldTag::__creation_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for creation_time",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.creation_time =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__last_modified_time => {
                            if !fields.insert(__FieldTag::__last_modified_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_modified_time",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.last_modified_time =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__language => {
                            if !fields.insert(__FieldTag::__language) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language",
                                ));
                            }
                            result.language = map
                                .next_value::<std::option::Option<crate::model::routine::Language>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__arguments => {
                            if !fields.insert(__FieldTag::__arguments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for arguments",
                                ));
                            }
                            result.arguments =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::routine::Argument>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__return_type => {
                            if !fields.insert(__FieldTag::__return_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for return_type",
                                ));
                            }
                            result.return_type = map.next_value::<std::option::Option<crate::model::StandardSqlDataType>>()?
                                ;
                        }
                        __FieldTag::__return_table_type => {
                            if !fields.insert(__FieldTag::__return_table_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for return_table_type",
                                ));
                            }
                            result.return_table_type = map.next_value::<std::option::Option<crate::model::StandardSqlTableType>>()?
                                ;
                        }
                        __FieldTag::__imported_libraries => {
                            if !fields.insert(__FieldTag::__imported_libraries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for imported_libraries",
                                ));
                            }
                            result.imported_libraries = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__definition_body => {
                            if !fields.insert(__FieldTag::__definition_body) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for definition_body",
                                ));
                            }
                            result.definition_body = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__determinism_level => {
                            if !fields.insert(__FieldTag::__determinism_level) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for determinism_level",
                                ));
                            }
                            result.determinism_level = map.next_value::<std::option::Option<crate::model::routine::DeterminismLevel>>()?.unwrap_or_default();
                        }
                        __FieldTag::__security_mode => {
                            if !fields.insert(__FieldTag::__security_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for security_mode",
                                ));
                            }
                            result.security_mode = map.next_value::<std::option::Option<crate::model::routine::SecurityMode>>()?.unwrap_or_default();
                        }
                        __FieldTag::__strict_mode => {
                            if !fields.insert(__FieldTag::__strict_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for strict_mode",
                                ));
                            }
                            result.strict_mode =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__remote_function_options => {
                            if !fields.insert(__FieldTag::__remote_function_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for remote_function_options",
                                ));
                            }
                            result.remote_function_options =
                                map.next_value::<std::option::Option<
                                    crate::model::routine::RemoteFunctionOptions,
                                >>()?;
                        }
                        __FieldTag::__spark_options => {
                            if !fields.insert(__FieldTag::__spark_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for spark_options",
                                ));
                            }
                            result.spark_options = map
                                .next_value::<std::option::Option<crate::model::SparkOptions>>()?;
                        }
                        __FieldTag::__data_governance_type => {
                            if !fields.insert(__FieldTag::__data_governance_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_governance_type",
                                ));
                            }
                            result.data_governance_type = map.next_value::<std::option::Option<crate::model::routine::DataGovernanceType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__python_options => {
                            if !fields.insert(__FieldTag::__python_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for python_options",
                                ));
                            }
                            result.python_options = map
                                .next_value::<std::option::Option<crate::model::PythonOptions>>()?;
                        }
                        __FieldTag::__external_runtime_options => {
                            if !fields.insert(__FieldTag::__external_runtime_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_runtime_options",
                                ));
                            }
                            result.external_runtime_options = map.next_value::<std::option::Option<crate::model::ExternalRuntimeOptions>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::routine::Argument {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __argument_kind,
            __mode,
            __data_type,
            __is_aggregate,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Argument")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "argumentKind" => Ok(__FieldTag::__argument_kind),
                            "argument_kind" => Ok(__FieldTag::__argument_kind),
                            "mode" => Ok(__FieldTag::__mode),
                            "dataType" => Ok(__FieldTag::__data_type),
                            "data_type" => Ok(__FieldTag::__data_type),
                            "isAggregate" => Ok(__FieldTag::__is_aggregate),
                            "is_aggregate" => Ok(__FieldTag::__is_aggregate),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::routine::Argument;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Argument")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__argument_kind => {
                            if !fields.insert(__FieldTag::__argument_kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for argument_kind",
                                ));
                            }
                            result.argument_kind =
                                map.next_value::<std::option::Option<
                                    crate::model::routine::argument::ArgumentKind,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mode => {
                            if !fields.insert(__FieldTag::__mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mode",
                                ));
                            }
                            result.mode = map.next_value::<std::option::Option<crate::model::routine::argument::Mode>>()?.unwrap_or_default();
                        }
                        __FieldTag::__data_type => {
                            if !fields.insert(__FieldTag::__data_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_type",
                                ));
                            }
                            result.data_type = map.next_value::<std::option::Option<crate::model::StandardSqlDataType>>()?
                                ;
                        }
                        __FieldTag::__is_aggregate => {
                            if !fields.insert(__FieldTag::__is_aggregate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_aggregate",
                                ));
                            }
                            result.is_aggregate =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::routine::RemoteFunctionOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __endpoint,
            __connection,
            __user_defined_context,
            __max_batching_rows,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RemoteFunctionOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "endpoint" => Ok(__FieldTag::__endpoint),
                            "connection" => Ok(__FieldTag::__connection),
                            "userDefinedContext" => Ok(__FieldTag::__user_defined_context),
                            "user_defined_context" => Ok(__FieldTag::__user_defined_context),
                            "maxBatchingRows" => Ok(__FieldTag::__max_batching_rows),
                            "max_batching_rows" => Ok(__FieldTag::__max_batching_rows),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::routine::RemoteFunctionOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RemoteFunctionOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__endpoint => {
                            if !fields.insert(__FieldTag::__endpoint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for endpoint",
                                ));
                            }
                            result.endpoint = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__connection => {
                            if !fields.insert(__FieldTag::__connection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection",
                                ));
                            }
                            result.connection = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__user_defined_context => {
                            if !fields.insert(__FieldTag::__user_defined_context) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_defined_context",
                                ));
                            }
                            result.user_defined_context = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__max_batching_rows => {
                            if !fields.insert(__FieldTag::__max_batching_rows) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_batching_rows",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_batching_rows =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::PythonOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entry_point,
            __packages,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PythonOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entryPoint" => Ok(__FieldTag::__entry_point),
                            "entry_point" => Ok(__FieldTag::__entry_point),
                            "packages" => Ok(__FieldTag::__packages),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::PythonOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PythonOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entry_point => {
                            if !fields.insert(__FieldTag::__entry_point) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entry_point",
                                ));
                            }
                            result.entry_point = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__packages => {
                            if !fields.insert(__FieldTag::__packages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for packages",
                                ));
                            }
                            result.packages = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ExternalRuntimeOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __container_memory,
            __container_cpu,
            __runtime_connection,
            __max_batching_rows,
            __runtime_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExternalRuntimeOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "containerMemory" => Ok(__FieldTag::__container_memory),
                            "container_memory" => Ok(__FieldTag::__container_memory),
                            "containerCpu" => Ok(__FieldTag::__container_cpu),
                            "container_cpu" => Ok(__FieldTag::__container_cpu),
                            "runtimeConnection" => Ok(__FieldTag::__runtime_connection),
                            "runtime_connection" => Ok(__FieldTag::__runtime_connection),
                            "maxBatchingRows" => Ok(__FieldTag::__max_batching_rows),
                            "max_batching_rows" => Ok(__FieldTag::__max_batching_rows),
                            "runtimeVersion" => Ok(__FieldTag::__runtime_version),
                            "runtime_version" => Ok(__FieldTag::__runtime_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ExternalRuntimeOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExternalRuntimeOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__container_memory => {
                            if !fields.insert(__FieldTag::__container_memory) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for container_memory",
                                ));
                            }
                            result.container_memory = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__container_cpu => {
                            if !fields.insert(__FieldTag::__container_cpu) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for container_cpu",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.container_cpu =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__runtime_connection => {
                            if !fields.insert(__FieldTag::__runtime_connection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for runtime_connection",
                                ));
                            }
                            result.runtime_connection = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__max_batching_rows => {
                            if !fields.insert(__FieldTag::__max_batching_rows) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_batching_rows",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_batching_rows =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__runtime_version => {
                            if !fields.insert(__FieldTag::__runtime_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for runtime_version",
                                ));
                            }
                            result.runtime_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SparkOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __connection,
            __runtime_version,
            __container_image,
            __properties,
            __main_file_uri,
            __py_file_uris,
            __jar_uris,
            __file_uris,
            __archive_uris,
            __main_class,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SparkOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "connection" => Ok(__FieldTag::__connection),
                            "runtimeVersion" => Ok(__FieldTag::__runtime_version),
                            "runtime_version" => Ok(__FieldTag::__runtime_version),
                            "containerImage" => Ok(__FieldTag::__container_image),
                            "container_image" => Ok(__FieldTag::__container_image),
                            "properties" => Ok(__FieldTag::__properties),
                            "mainFileUri" => Ok(__FieldTag::__main_file_uri),
                            "main_file_uri" => Ok(__FieldTag::__main_file_uri),
                            "pyFileUris" => Ok(__FieldTag::__py_file_uris),
                            "py_file_uris" => Ok(__FieldTag::__py_file_uris),
                            "jarUris" => Ok(__FieldTag::__jar_uris),
                            "jar_uris" => Ok(__FieldTag::__jar_uris),
                            "fileUris" => Ok(__FieldTag::__file_uris),
                            "file_uris" => Ok(__FieldTag::__file_uris),
                            "archiveUris" => Ok(__FieldTag::__archive_uris),
                            "archive_uris" => Ok(__FieldTag::__archive_uris),
                            "mainClass" => Ok(__FieldTag::__main_class),
                            "main_class" => Ok(__FieldTag::__main_class),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SparkOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SparkOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__connection => {
                            if !fields.insert(__FieldTag::__connection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection",
                                ));
                            }
                            result.connection = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__runtime_version => {
                            if !fields.insert(__FieldTag::__runtime_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for runtime_version",
                                ));
                            }
                            result.runtime_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__container_image => {
                            if !fields.insert(__FieldTag::__container_image) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for container_image",
                                ));
                            }
                            result.container_image = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__properties => {
                            if !fields.insert(__FieldTag::__properties) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for properties",
                                ));
                            }
                            result.properties = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__main_file_uri => {
                            if !fields.insert(__FieldTag::__main_file_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for main_file_uri",
                                ));
                            }
                            result.main_file_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__py_file_uris => {
                            if !fields.insert(__FieldTag::__py_file_uris) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for py_file_uris",
                                ));
                            }
                            result.py_file_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__jar_uris => {
                            if !fields.insert(__FieldTag::__jar_uris) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for jar_uris",
                                ));
                            }
                            result.jar_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__file_uris => {
                            if !fields.insert(__FieldTag::__file_uris) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_uris",
                                ));
                            }
                            result.file_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__archive_uris => {
                            if !fields.insert(__FieldTag::__archive_uris) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for archive_uris",
                                ));
                            }
                            result.archive_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__main_class => {
                            if !fields.insert(__FieldTag::__main_class) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for main_class",
                                ));
                            }
                            result.main_class = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetRoutineRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __routine_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetRoutineRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "routineId" => Ok(__FieldTag::__routine_id),
                            "routine_id" => Ok(__FieldTag::__routine_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetRoutineRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetRoutineRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__routine_id => {
                            if !fields.insert(__FieldTag::__routine_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for routine_id",
                                ));
                            }
                            result.routine_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::InsertRoutineRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __routine,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InsertRoutineRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "routine" => Ok(__FieldTag::__routine),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::InsertRoutineRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InsertRoutineRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__routine => {
                            if !fields.insert(__FieldTag::__routine) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for routine",
                                ));
                            }
                            result.routine =
                                map.next_value::<std::option::Option<crate::model::Routine>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UpdateRoutineRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __routine_id,
            __routine,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateRoutineRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "routineId" => Ok(__FieldTag::__routine_id),
                            "routine_id" => Ok(__FieldTag::__routine_id),
                            "routine" => Ok(__FieldTag::__routine),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UpdateRoutineRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateRoutineRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__routine_id => {
                            if !fields.insert(__FieldTag::__routine_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for routine_id",
                                ));
                            }
                            result.routine_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__routine => {
                            if !fields.insert(__FieldTag::__routine) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for routine",
                                ));
                            }
                            result.routine =
                                map.next_value::<std::option::Option<crate::model::Routine>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::PatchRoutineRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __routine_id,
            __routine,
            __field_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PatchRoutineRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "routineId" => Ok(__FieldTag::__routine_id),
                            "routine_id" => Ok(__FieldTag::__routine_id),
                            "routine" => Ok(__FieldTag::__routine),
                            "fieldMask" => Ok(__FieldTag::__field_mask),
                            "field_mask" => Ok(__FieldTag::__field_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::PatchRoutineRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PatchRoutineRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__routine_id => {
                            if !fields.insert(__FieldTag::__routine_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for routine_id",
                                ));
                            }
                            result.routine_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__routine => {
                            if !fields.insert(__FieldTag::__routine) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for routine",
                                ));
                            }
                            result.routine =
                                map.next_value::<std::option::Option<crate::model::Routine>>()?;
                        }
                        __FieldTag::__field_mask => {
                            if !fields.insert(__FieldTag::__field_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field_mask",
                                ));
                            }
                            result.field_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeleteRoutineRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __routine_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteRoutineRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "routineId" => Ok(__FieldTag::__routine_id),
                            "routine_id" => Ok(__FieldTag::__routine_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeleteRoutineRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteRoutineRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__routine_id => {
                            if !fields.insert(__FieldTag::__routine_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for routine_id",
                                ));
                            }
                            result.routine_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListRoutinesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __max_results,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListRoutinesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "maxResults" => Ok(__FieldTag::__max_results),
                            "max_results" => Ok(__FieldTag::__max_results),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListRoutinesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListRoutinesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__max_results => {
                            if !fields.insert(__FieldTag::__max_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_results",
                                ));
                            }
                            struct __With(std::option::Option<wkt::UInt32Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_results = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListRoutinesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __routines,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListRoutinesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "routines" => Ok(__FieldTag::__routines),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListRoutinesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListRoutinesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__routines => {
                            if !fields.insert(__FieldTag::__routines) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for routines",
                                ));
                            }
                            result.routines = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Routine>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RoutineReference {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __routine_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RoutineReference")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "routineId" => Ok(__FieldTag::__routine_id),
                            "routine_id" => Ok(__FieldTag::__routine_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RoutineReference;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RoutineReference")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__routine_id => {
                            if !fields.insert(__FieldTag::__routine_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for routine_id",
                                ));
                            }
                            result.routine_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListRowAccessPoliciesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __table_id,
            __page_token,
            __page_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListRowAccessPoliciesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "tableId" => Ok(__FieldTag::__table_id),
                            "table_id" => Ok(__FieldTag::__table_id),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListRowAccessPoliciesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListRowAccessPoliciesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table_id => {
                            if !fields.insert(__FieldTag::__table_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_id",
                                ));
                            }
                            result.table_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListRowAccessPoliciesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __row_access_policies,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListRowAccessPoliciesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rowAccessPolicies" => Ok(__FieldTag::__row_access_policies),
                            "row_access_policies" => Ok(__FieldTag::__row_access_policies),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListRowAccessPoliciesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListRowAccessPoliciesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__row_access_policies => {
                            if !fields.insert(__FieldTag::__row_access_policies) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for row_access_policies",
                                ));
                            }
                            result.row_access_policies =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::RowAccessPolicy>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetRowAccessPolicyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __table_id,
            __policy_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetRowAccessPolicyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "tableId" => Ok(__FieldTag::__table_id),
                            "table_id" => Ok(__FieldTag::__table_id),
                            "policyId" => Ok(__FieldTag::__policy_id),
                            "policy_id" => Ok(__FieldTag::__policy_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetRowAccessPolicyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetRowAccessPolicyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table_id => {
                            if !fields.insert(__FieldTag::__table_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_id",
                                ));
                            }
                            result.table_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__policy_id => {
                            if !fields.insert(__FieldTag::__policy_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy_id",
                                ));
                            }
                            result.policy_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CreateRowAccessPolicyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __table_id,
            __row_access_policy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateRowAccessPolicyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "tableId" => Ok(__FieldTag::__table_id),
                            "table_id" => Ok(__FieldTag::__table_id),
                            "rowAccessPolicy" => Ok(__FieldTag::__row_access_policy),
                            "row_access_policy" => Ok(__FieldTag::__row_access_policy),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CreateRowAccessPolicyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateRowAccessPolicyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table_id => {
                            if !fields.insert(__FieldTag::__table_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_id",
                                ));
                            }
                            result.table_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__row_access_policy => {
                            if !fields.insert(__FieldTag::__row_access_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for row_access_policy",
                                ));
                            }
                            result.row_access_policy = map
                                .next_value::<std::option::Option<crate::model::RowAccessPolicy>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UpdateRowAccessPolicyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __table_id,
            __policy_id,
            __row_access_policy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateRowAccessPolicyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "tableId" => Ok(__FieldTag::__table_id),
                            "table_id" => Ok(__FieldTag::__table_id),
                            "policyId" => Ok(__FieldTag::__policy_id),
                            "policy_id" => Ok(__FieldTag::__policy_id),
                            "rowAccessPolicy" => Ok(__FieldTag::__row_access_policy),
                            "row_access_policy" => Ok(__FieldTag::__row_access_policy),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UpdateRowAccessPolicyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateRowAccessPolicyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table_id => {
                            if !fields.insert(__FieldTag::__table_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_id",
                                ));
                            }
                            result.table_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__policy_id => {
                            if !fields.insert(__FieldTag::__policy_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy_id",
                                ));
                            }
                            result.policy_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__row_access_policy => {
                            if !fields.insert(__FieldTag::__row_access_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for row_access_policy",
                                ));
                            }
                            result.row_access_policy = map
                                .next_value::<std::option::Option<crate::model::RowAccessPolicy>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeleteRowAccessPolicyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __table_id,
            __policy_id,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteRowAccessPolicyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "tableId" => Ok(__FieldTag::__table_id),
                            "table_id" => Ok(__FieldTag::__table_id),
                            "policyId" => Ok(__FieldTag::__policy_id),
                            "policy_id" => Ok(__FieldTag::__policy_id),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeleteRowAccessPolicyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteRowAccessPolicyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table_id => {
                            if !fields.insert(__FieldTag::__table_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_id",
                                ));
                            }
                            result.table_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__policy_id => {
                            if !fields.insert(__FieldTag::__policy_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy_id",
                                ));
                            }
                            result.policy_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::BatchDeleteRowAccessPoliciesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __table_id,
            __policy_ids,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchDeleteRowAccessPoliciesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "tableId" => Ok(__FieldTag::__table_id),
                            "table_id" => Ok(__FieldTag::__table_id),
                            "policyIds" => Ok(__FieldTag::__policy_ids),
                            "policy_ids" => Ok(__FieldTag::__policy_ids),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::BatchDeleteRowAccessPoliciesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchDeleteRowAccessPoliciesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table_id => {
                            if !fields.insert(__FieldTag::__table_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_id",
                                ));
                            }
                            result.table_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__policy_ids => {
                            if !fields.insert(__FieldTag::__policy_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy_ids",
                                ));
                            }
                            result.policy_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RowAccessPolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __etag,
            __row_access_policy_reference,
            __filter_predicate,
            __creation_time,
            __last_modified_time,
            __grantees,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RowAccessPolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "etag" => Ok(__FieldTag::__etag),
                            "rowAccessPolicyReference" => {
                                Ok(__FieldTag::__row_access_policy_reference)
                            }
                            "row_access_policy_reference" => {
                                Ok(__FieldTag::__row_access_policy_reference)
                            }
                            "filterPredicate" => Ok(__FieldTag::__filter_predicate),
                            "filter_predicate" => Ok(__FieldTag::__filter_predicate),
                            "creationTime" => Ok(__FieldTag::__creation_time),
                            "creation_time" => Ok(__FieldTag::__creation_time),
                            "lastModifiedTime" => Ok(__FieldTag::__last_modified_time),
                            "last_modified_time" => Ok(__FieldTag::__last_modified_time),
                            "grantees" => Ok(__FieldTag::__grantees),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RowAccessPolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RowAccessPolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__row_access_policy_reference => {
                            if !fields.insert(__FieldTag::__row_access_policy_reference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for row_access_policy_reference",
                                ));
                            }
                            result.row_access_policy_reference = map.next_value::<std::option::Option<crate::model::RowAccessPolicyReference>>()?
                                ;
                        }
                        __FieldTag::__filter_predicate => {
                            if !fields.insert(__FieldTag::__filter_predicate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter_predicate",
                                ));
                            }
                            result.filter_predicate = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__creation_time => {
                            if !fields.insert(__FieldTag::__creation_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for creation_time",
                                ));
                            }
                            result.creation_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__last_modified_time => {
                            if !fields.insert(__FieldTag::__last_modified_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_modified_time",
                                ));
                            }
                            result.last_modified_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__grantees => {
                            if !fields.insert(__FieldTag::__grantees) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for grantees",
                                ));
                            }
                            result.grantees = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RowAccessPolicyReference {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __table_id,
            __policy_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RowAccessPolicyReference")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "tableId" => Ok(__FieldTag::__table_id),
                            "table_id" => Ok(__FieldTag::__table_id),
                            "policyId" => Ok(__FieldTag::__policy_id),
                            "policy_id" => Ok(__FieldTag::__policy_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RowAccessPolicyReference;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RowAccessPolicyReference")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table_id => {
                            if !fields.insert(__FieldTag::__table_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_id",
                                ));
                            }
                            result.table_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__policy_id => {
                            if !fields.insert(__FieldTag::__policy_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy_id",
                                ));
                            }
                            result.policy_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SessionInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __session_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SessionInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sessionId" => Ok(__FieldTag::__session_id),
                            "session_id" => Ok(__FieldTag::__session_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SessionInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SessionInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__session_id => {
                            if !fields.insert(__FieldTag::__session_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for session_id",
                                ));
                            }
                            result.session_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::StandardSqlDataType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type_kind,
            __array_element_type,
            __struct_type,
            __range_element_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StandardSqlDataType")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "typeKind" => Ok(__FieldTag::__type_kind),
                            "type_kind" => Ok(__FieldTag::__type_kind),
                            "arrayElementType" => Ok(__FieldTag::__array_element_type),
                            "array_element_type" => Ok(__FieldTag::__array_element_type),
                            "structType" => Ok(__FieldTag::__struct_type),
                            "struct_type" => Ok(__FieldTag::__struct_type),
                            "rangeElementType" => Ok(__FieldTag::__range_element_type),
                            "range_element_type" => Ok(__FieldTag::__range_element_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::StandardSqlDataType;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StandardSqlDataType")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type_kind => {
                            if !fields.insert(__FieldTag::__type_kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type_kind",
                                ));
                            }
                            result.type_kind =
                                map.next_value::<std::option::Option<
                                    crate::model::standard_sql_data_type::TypeKind,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__array_element_type => {
                            if !fields.insert(__FieldTag::__array_element_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for array_element_type",
                                ));
                            }
                            if result.sub_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `sub_type`, a oneof with full ID .google.cloud.bigquery.v2.StandardSqlDataType.array_element_type, latest field was arrayElementType",
                                ));
                            }
                            result.sub_type = std::option::Option::Some(
                                crate::model::standard_sql_data_type::SubType::ArrayElementType(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::StandardSqlDataType>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__struct_type => {
                            if !fields.insert(__FieldTag::__struct_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for struct_type",
                                ));
                            }
                            if result.sub_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `sub_type`, a oneof with full ID .google.cloud.bigquery.v2.StandardSqlDataType.struct_type, latest field was structType",
                                ));
                            }
                            result.sub_type = std::option::Option::Some(
                                crate::model::standard_sql_data_type::SubType::StructType(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::StandardSqlStructType>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__range_element_type => {
                            if !fields.insert(__FieldTag::__range_element_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for range_element_type",
                                ));
                            }
                            if result.sub_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `sub_type`, a oneof with full ID .google.cloud.bigquery.v2.StandardSqlDataType.range_element_type, latest field was rangeElementType",
                                ));
                            }
                            result.sub_type = std::option::Option::Some(
                                crate::model::standard_sql_data_type::SubType::RangeElementType(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::StandardSqlDataType>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::StandardSqlField {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StandardSqlField")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "type" => Ok(__FieldTag::__type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::StandardSqlField;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StandardSqlField")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<
                                std::boxed::Box<crate::model::StandardSqlDataType>,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::StandardSqlStructType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __fields,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StandardSqlStructType")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fields" => Ok(__FieldTag::__fields),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::StandardSqlStructType;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StandardSqlStructType")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__fields => {
                            if !fields.insert(__FieldTag::__fields) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fields",
                                ));
                            }
                            result.fields =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::StandardSqlField>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::StandardSqlTableType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __columns,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StandardSqlTableType")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "columns" => Ok(__FieldTag::__columns),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::StandardSqlTableType;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StandardSqlTableType")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__columns => {
                            if !fields.insert(__FieldTag::__columns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for columns",
                                ));
                            }
                            result.columns =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::StandardSqlField>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SystemVariables {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __types,
            __values,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SystemVariables")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "types" => Ok(__FieldTag::__types),
                            "values" => Ok(__FieldTag::__values),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SystemVariables;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SystemVariables")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__types => {
                            if !fields.insert(__FieldTag::__types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for types",
                                ));
                            }
                            result.types = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::StandardSqlDataType,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__values => {
                            if !fields.insert(__FieldTag::__values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for values",
                                ));
                            }
                            result.values = map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::TableReplicationInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source_table,
            __replication_interval_ms,
            __replicated_source_last_refresh_time,
            __replication_status,
            __replication_error,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TableReplicationInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sourceTable" => Ok(__FieldTag::__source_table),
                            "source_table" => Ok(__FieldTag::__source_table),
                            "replicationIntervalMs" => Ok(__FieldTag::__replication_interval_ms),
                            "replication_interval_ms" => Ok(__FieldTag::__replication_interval_ms),
                            "replicatedSourceLastRefreshTime" => {
                                Ok(__FieldTag::__replicated_source_last_refresh_time)
                            }
                            "replicated_source_last_refresh_time" => {
                                Ok(__FieldTag::__replicated_source_last_refresh_time)
                            }
                            "replicationStatus" => Ok(__FieldTag::__replication_status),
                            "replication_status" => Ok(__FieldTag::__replication_status),
                            "replicationError" => Ok(__FieldTag::__replication_error),
                            "replication_error" => Ok(__FieldTag::__replication_error),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::TableReplicationInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TableReplicationInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source_table => {
                            if !fields.insert(__FieldTag::__source_table) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_table",
                                ));
                            }
                            result.source_table = map
                                .next_value::<std::option::Option<crate::model::TableReference>>(
                                )?;
                        }
                        __FieldTag::__replication_interval_ms => {
                            if !fields.insert(__FieldTag::__replication_interval_ms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for replication_interval_ms",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.replication_interval_ms =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__replicated_source_last_refresh_time => {
                            if !fields.insert(__FieldTag::__replicated_source_last_refresh_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for replicated_source_last_refresh_time",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.replicated_source_last_refresh_time =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__replication_status => {
                            if !fields.insert(__FieldTag::__replication_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for replication_status",
                                ));
                            }
                            result.replication_status = map
                                .next_value::<std::option::Option<
                                    crate::model::table_replication_info::ReplicationStatus,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__replication_error => {
                            if !fields.insert(__FieldTag::__replication_error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for replication_error",
                                ));
                            }
                            result.replication_error =
                                map.next_value::<std::option::Option<crate::model::ErrorProto>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ViewDefinition {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __query,
            __user_defined_function_resources,
            __use_legacy_sql,
            __use_explicit_column_names,
            __privacy_policy,
            __foreign_definitions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ViewDefinition")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "query" => Ok(__FieldTag::__query),
                            "userDefinedFunctionResources" => {
                                Ok(__FieldTag::__user_defined_function_resources)
                            }
                            "user_defined_function_resources" => {
                                Ok(__FieldTag::__user_defined_function_resources)
                            }
                            "useLegacySql" => Ok(__FieldTag::__use_legacy_sql),
                            "use_legacy_sql" => Ok(__FieldTag::__use_legacy_sql),
                            "useExplicitColumnNames" => Ok(__FieldTag::__use_explicit_column_names),
                            "use_explicit_column_names" => {
                                Ok(__FieldTag::__use_explicit_column_names)
                            }
                            "privacyPolicy" => Ok(__FieldTag::__privacy_policy),
                            "privacy_policy" => Ok(__FieldTag::__privacy_policy),
                            "foreignDefinitions" => Ok(__FieldTag::__foreign_definitions),
                            "foreign_definitions" => Ok(__FieldTag::__foreign_definitions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ViewDefinition;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ViewDefinition")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__query => {
                            if !fields.insert(__FieldTag::__query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query",
                                ));
                            }
                            result.query = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__user_defined_function_resources => {
                            if !fields.insert(__FieldTag::__user_defined_function_resources) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_defined_function_resources",
                                ));
                            }
                            result.user_defined_function_resources = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::UserDefinedFunctionResource>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__use_legacy_sql => {
                            if !fields.insert(__FieldTag::__use_legacy_sql) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for use_legacy_sql",
                                ));
                            }
                            result.use_legacy_sql =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__use_explicit_column_names => {
                            if !fields.insert(__FieldTag::__use_explicit_column_names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for use_explicit_column_names",
                                ));
                            }
                            result.use_explicit_column_names = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__privacy_policy => {
                            if !fields.insert(__FieldTag::__privacy_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for privacy_policy",
                                ));
                            }
                            result.privacy_policy = map
                                .next_value::<std::option::Option<crate::model::PrivacyPolicy>>()?;
                        }
                        __FieldTag::__foreign_definitions => {
                            if !fields.insert(__FieldTag::__foreign_definitions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for foreign_definitions",
                                ));
                            }
                            result.foreign_definitions = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ForeignViewDefinition>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ForeignViewDefinition {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __query,
            __dialect,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ForeignViewDefinition")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "query" => Ok(__FieldTag::__query),
                            "dialect" => Ok(__FieldTag::__dialect),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ForeignViewDefinition;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ForeignViewDefinition")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__query => {
                            if !fields.insert(__FieldTag::__query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query",
                                ));
                            }
                            result.query = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dialect => {
                            if !fields.insert(__FieldTag::__dialect) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dialect",
                                ));
                            }
                            result.dialect = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MaterializedViewDefinition {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __query,
            __last_refresh_time,
            __enable_refresh,
            __refresh_interval_ms,
            __allow_non_incremental_definition,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MaterializedViewDefinition")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "query" => Ok(__FieldTag::__query),
                            "lastRefreshTime" => Ok(__FieldTag::__last_refresh_time),
                            "last_refresh_time" => Ok(__FieldTag::__last_refresh_time),
                            "enableRefresh" => Ok(__FieldTag::__enable_refresh),
                            "enable_refresh" => Ok(__FieldTag::__enable_refresh),
                            "refreshIntervalMs" => Ok(__FieldTag::__refresh_interval_ms),
                            "refresh_interval_ms" => Ok(__FieldTag::__refresh_interval_ms),
                            "allowNonIncrementalDefinition" => {
                                Ok(__FieldTag::__allow_non_incremental_definition)
                            }
                            "allow_non_incremental_definition" => {
                                Ok(__FieldTag::__allow_non_incremental_definition)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MaterializedViewDefinition;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MaterializedViewDefinition")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__query => {
                            if !fields.insert(__FieldTag::__query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query",
                                ));
                            }
                            result.query = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__last_refresh_time => {
                            if !fields.insert(__FieldTag::__last_refresh_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_refresh_time",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.last_refresh_time =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__enable_refresh => {
                            if !fields.insert(__FieldTag::__enable_refresh) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_refresh",
                                ));
                            }
                            result.enable_refresh =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__refresh_interval_ms => {
                            if !fields.insert(__FieldTag::__refresh_interval_ms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for refresh_interval_ms",
                                ));
                            }
                            struct __With(std::option::Option<wkt::UInt64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.refresh_interval_ms = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__allow_non_incremental_definition => {
                            if !fields.insert(__FieldTag::__allow_non_incremental_definition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_non_incremental_definition",
                                ));
                            }
                            result.allow_non_incremental_definition =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MaterializedViewStatus {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __refresh_watermark,
            __last_refresh_status,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MaterializedViewStatus")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "refreshWatermark" => Ok(__FieldTag::__refresh_watermark),
                            "refresh_watermark" => Ok(__FieldTag::__refresh_watermark),
                            "lastRefreshStatus" => Ok(__FieldTag::__last_refresh_status),
                            "last_refresh_status" => Ok(__FieldTag::__last_refresh_status),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MaterializedViewStatus;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MaterializedViewStatus")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__refresh_watermark => {
                            if !fields.insert(__FieldTag::__refresh_watermark) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for refresh_watermark",
                                ));
                            }
                            result.refresh_watermark =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__last_refresh_status => {
                            if !fields.insert(__FieldTag::__last_refresh_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_refresh_status",
                                ));
                            }
                            result.last_refresh_status =
                                map.next_value::<std::option::Option<crate::model::ErrorProto>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SnapshotDefinition {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __base_table_reference,
            __snapshot_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SnapshotDefinition")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "baseTableReference" => Ok(__FieldTag::__base_table_reference),
                            "base_table_reference" => Ok(__FieldTag::__base_table_reference),
                            "snapshotTime" => Ok(__FieldTag::__snapshot_time),
                            "snapshot_time" => Ok(__FieldTag::__snapshot_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SnapshotDefinition;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SnapshotDefinition")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__base_table_reference => {
                            if !fields.insert(__FieldTag::__base_table_reference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for base_table_reference",
                                ));
                            }
                            result.base_table_reference = map
                                .next_value::<std::option::Option<crate::model::TableReference>>(
                                )?;
                        }
                        __FieldTag::__snapshot_time => {
                            if !fields.insert(__FieldTag::__snapshot_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for snapshot_time",
                                ));
                            }
                            result.snapshot_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CloneDefinition {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __base_table_reference,
            __clone_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloneDefinition")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "baseTableReference" => Ok(__FieldTag::__base_table_reference),
                            "base_table_reference" => Ok(__FieldTag::__base_table_reference),
                            "cloneTime" => Ok(__FieldTag::__clone_time),
                            "clone_time" => Ok(__FieldTag::__clone_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CloneDefinition;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloneDefinition")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__base_table_reference => {
                            if !fields.insert(__FieldTag::__base_table_reference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for base_table_reference",
                                ));
                            }
                            result.base_table_reference = map
                                .next_value::<std::option::Option<crate::model::TableReference>>(
                                )?;
                        }
                        __FieldTag::__clone_time => {
                            if !fields.insert(__FieldTag::__clone_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for clone_time",
                                ));
                            }
                            result.clone_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Streamingbuffer {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __estimated_bytes,
            __estimated_rows,
            __oldest_entry_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Streamingbuffer")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "estimatedBytes" => Ok(__FieldTag::__estimated_bytes),
                            "estimated_bytes" => Ok(__FieldTag::__estimated_bytes),
                            "estimatedRows" => Ok(__FieldTag::__estimated_rows),
                            "estimated_rows" => Ok(__FieldTag::__estimated_rows),
                            "oldestEntryTime" => Ok(__FieldTag::__oldest_entry_time),
                            "oldest_entry_time" => Ok(__FieldTag::__oldest_entry_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Streamingbuffer;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Streamingbuffer")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__estimated_bytes => {
                            if !fields.insert(__FieldTag::__estimated_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for estimated_bytes",
                                ));
                            }
                            struct __With(std::option::Option<u64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.estimated_bytes =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__estimated_rows => {
                            if !fields.insert(__FieldTag::__estimated_rows) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for estimated_rows",
                                ));
                            }
                            struct __With(std::option::Option<u64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.estimated_rows =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__oldest_entry_time => {
                            if !fields.insert(__FieldTag::__oldest_entry_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oldest_entry_time",
                                ));
                            }
                            struct __With(std::option::Option<u64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.oldest_entry_time =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Table {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __etag,
            __id,
            __self_link,
            __table_reference,
            __friendly_name,
            __description,
            __labels,
            __schema,
            __time_partitioning,
            __range_partitioning,
            __clustering,
            __require_partition_filter,
            __partition_definition,
            __num_bytes,
            __num_physical_bytes,
            __num_long_term_bytes,
            __num_rows,
            __creation_time,
            __expiration_time,
            __last_modified_time,
            __type,
            __view,
            __materialized_view,
            __materialized_view_status,
            __external_data_configuration,
            __biglake_configuration,
            __managed_table_type,
            __location,
            __streaming_buffer,
            __encryption_configuration,
            __snapshot_definition,
            __default_collation,
            __default_rounding_mode,
            __clone_definition,
            __num_time_travel_physical_bytes,
            __num_total_logical_bytes,
            __num_active_logical_bytes,
            __num_long_term_logical_bytes,
            __num_current_physical_bytes,
            __num_total_physical_bytes,
            __num_active_physical_bytes,
            __num_long_term_physical_bytes,
            __num_partitions,
            __max_staleness,
            __restrictions,
            __table_constraints,
            __resource_tags,
            __table_replication_info,
            __replicas,
            __external_catalog_table_options,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Table")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "etag" => Ok(__FieldTag::__etag),
                            "id" => Ok(__FieldTag::__id),
                            "selfLink" => Ok(__FieldTag::__self_link),
                            "self_link" => Ok(__FieldTag::__self_link),
                            "tableReference" => Ok(__FieldTag::__table_reference),
                            "table_reference" => Ok(__FieldTag::__table_reference),
                            "friendlyName" => Ok(__FieldTag::__friendly_name),
                            "friendly_name" => Ok(__FieldTag::__friendly_name),
                            "description" => Ok(__FieldTag::__description),
                            "labels" => Ok(__FieldTag::__labels),
                            "schema" => Ok(__FieldTag::__schema),
                            "timePartitioning" => Ok(__FieldTag::__time_partitioning),
                            "time_partitioning" => Ok(__FieldTag::__time_partitioning),
                            "rangePartitioning" => Ok(__FieldTag::__range_partitioning),
                            "range_partitioning" => Ok(__FieldTag::__range_partitioning),
                            "clustering" => Ok(__FieldTag::__clustering),
                            "requirePartitionFilter" => Ok(__FieldTag::__require_partition_filter),
                            "require_partition_filter" => {
                                Ok(__FieldTag::__require_partition_filter)
                            }
                            "partitionDefinition" => Ok(__FieldTag::__partition_definition),
                            "partition_definition" => Ok(__FieldTag::__partition_definition),
                            "numBytes" => Ok(__FieldTag::__num_bytes),
                            "num_bytes" => Ok(__FieldTag::__num_bytes),
                            "numPhysicalBytes" => Ok(__FieldTag::__num_physical_bytes),
                            "num_physical_bytes" => Ok(__FieldTag::__num_physical_bytes),
                            "numLongTermBytes" => Ok(__FieldTag::__num_long_term_bytes),
                            "num_long_term_bytes" => Ok(__FieldTag::__num_long_term_bytes),
                            "numRows" => Ok(__FieldTag::__num_rows),
                            "num_rows" => Ok(__FieldTag::__num_rows),
                            "creationTime" => Ok(__FieldTag::__creation_time),
                            "creation_time" => Ok(__FieldTag::__creation_time),
                            "expirationTime" => Ok(__FieldTag::__expiration_time),
                            "expiration_time" => Ok(__FieldTag::__expiration_time),
                            "lastModifiedTime" => Ok(__FieldTag::__last_modified_time),
                            "last_modified_time" => Ok(__FieldTag::__last_modified_time),
                            "type" => Ok(__FieldTag::__type),
                            "view" => Ok(__FieldTag::__view),
                            "materializedView" => Ok(__FieldTag::__materialized_view),
                            "materialized_view" => Ok(__FieldTag::__materialized_view),
                            "materializedViewStatus" => Ok(__FieldTag::__materialized_view_status),
                            "materialized_view_status" => {
                                Ok(__FieldTag::__materialized_view_status)
                            }
                            "externalDataConfiguration" => {
                                Ok(__FieldTag::__external_data_configuration)
                            }
                            "external_data_configuration" => {
                                Ok(__FieldTag::__external_data_configuration)
                            }
                            "biglakeConfiguration" => Ok(__FieldTag::__biglake_configuration),
                            "biglake_configuration" => Ok(__FieldTag::__biglake_configuration),
                            "managedTableType" => Ok(__FieldTag::__managed_table_type),
                            "managed_table_type" => Ok(__FieldTag::__managed_table_type),
                            "location" => Ok(__FieldTag::__location),
                            "streamingBuffer" => Ok(__FieldTag::__streaming_buffer),
                            "streaming_buffer" => Ok(__FieldTag::__streaming_buffer),
                            "encryptionConfiguration" => Ok(__FieldTag::__encryption_configuration),
                            "encryption_configuration" => {
                                Ok(__FieldTag::__encryption_configuration)
                            }
                            "snapshotDefinition" => Ok(__FieldTag::__snapshot_definition),
                            "snapshot_definition" => Ok(__FieldTag::__snapshot_definition),
                            "defaultCollation" => Ok(__FieldTag::__default_collation),
                            "default_collation" => Ok(__FieldTag::__default_collation),
                            "defaultRoundingMode" => Ok(__FieldTag::__default_rounding_mode),
                            "default_rounding_mode" => Ok(__FieldTag::__default_rounding_mode),
                            "cloneDefinition" => Ok(__FieldTag::__clone_definition),
                            "clone_definition" => Ok(__FieldTag::__clone_definition),
                            "numTimeTravelPhysicalBytes" => {
                                Ok(__FieldTag::__num_time_travel_physical_bytes)
                            }
                            "num_time_travel_physical_bytes" => {
                                Ok(__FieldTag::__num_time_travel_physical_bytes)
                            }
                            "numTotalLogicalBytes" => Ok(__FieldTag::__num_total_logical_bytes),
                            "num_total_logical_bytes" => Ok(__FieldTag::__num_total_logical_bytes),
                            "numActiveLogicalBytes" => Ok(__FieldTag::__num_active_logical_bytes),
                            "num_active_logical_bytes" => {
                                Ok(__FieldTag::__num_active_logical_bytes)
                            }
                            "numLongTermLogicalBytes" => {
                                Ok(__FieldTag::__num_long_term_logical_bytes)
                            }
                            "num_long_term_logical_bytes" => {
                                Ok(__FieldTag::__num_long_term_logical_bytes)
                            }
                            "numCurrentPhysicalBytes" => {
                                Ok(__FieldTag::__num_current_physical_bytes)
                            }
                            "num_current_physical_bytes" => {
                                Ok(__FieldTag::__num_current_physical_bytes)
                            }
                            "numTotalPhysicalBytes" => Ok(__FieldTag::__num_total_physical_bytes),
                            "num_total_physical_bytes" => {
                                Ok(__FieldTag::__num_total_physical_bytes)
                            }
                            "numActivePhysicalBytes" => Ok(__FieldTag::__num_active_physical_bytes),
                            "num_active_physical_bytes" => {
                                Ok(__FieldTag::__num_active_physical_bytes)
                            }
                            "numLongTermPhysicalBytes" => {
                                Ok(__FieldTag::__num_long_term_physical_bytes)
                            }
                            "num_long_term_physical_bytes" => {
                                Ok(__FieldTag::__num_long_term_physical_bytes)
                            }
                            "numPartitions" => Ok(__FieldTag::__num_partitions),
                            "num_partitions" => Ok(__FieldTag::__num_partitions),
                            "maxStaleness" => Ok(__FieldTag::__max_staleness),
                            "max_staleness" => Ok(__FieldTag::__max_staleness),
                            "restrictions" => Ok(__FieldTag::__restrictions),
                            "tableConstraints" => Ok(__FieldTag::__table_constraints),
                            "table_constraints" => Ok(__FieldTag::__table_constraints),
                            "resourceTags" => Ok(__FieldTag::__resource_tags),
                            "resource_tags" => Ok(__FieldTag::__resource_tags),
                            "tableReplicationInfo" => Ok(__FieldTag::__table_replication_info),
                            "table_replication_info" => Ok(__FieldTag::__table_replication_info),
                            "replicas" => Ok(__FieldTag::__replicas),
                            "externalCatalogTableOptions" => {
                                Ok(__FieldTag::__external_catalog_table_options)
                            }
                            "external_catalog_table_options" => {
                                Ok(__FieldTag::__external_catalog_table_options)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Table;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Table")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__self_link => {
                            if !fields.insert(__FieldTag::__self_link) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for self_link",
                                ));
                            }
                            result.self_link = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table_reference => {
                            if !fields.insert(__FieldTag::__table_reference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_reference",
                                ));
                            }
                            result.table_reference = map
                                .next_value::<std::option::Option<crate::model::TableReference>>(
                                )?;
                        }
                        __FieldTag::__friendly_name => {
                            if !fields.insert(__FieldTag::__friendly_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for friendly_name",
                                ));
                            }
                            result.friendly_name =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__schema => {
                            if !fields.insert(__FieldTag::__schema) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schema",
                                ));
                            }
                            result.schema =
                                map.next_value::<std::option::Option<crate::model::TableSchema>>()?;
                        }
                        __FieldTag::__time_partitioning => {
                            if !fields.insert(__FieldTag::__time_partitioning) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_partitioning",
                                ));
                            }
                            result.time_partitioning = map
                                .next_value::<std::option::Option<crate::model::TimePartitioning>>(
                                )?;
                        }
                        __FieldTag::__range_partitioning => {
                            if !fields.insert(__FieldTag::__range_partitioning) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for range_partitioning",
                                ));
                            }
                            result.range_partitioning = map
                                .next_value::<std::option::Option<crate::model::RangePartitioning>>(
                                )?;
                        }
                        __FieldTag::__clustering => {
                            if !fields.insert(__FieldTag::__clustering) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for clustering",
                                ));
                            }
                            result.clustering =
                                map.next_value::<std::option::Option<crate::model::Clustering>>()?;
                        }
                        __FieldTag::__require_partition_filter => {
                            if !fields.insert(__FieldTag::__require_partition_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for require_partition_filter",
                                ));
                            }
                            result.require_partition_filter =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__partition_definition => {
                            if !fields.insert(__FieldTag::__partition_definition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for partition_definition",
                                ));
                            }
                            result.partition_definition = map.next_value::<std::option::Option<crate::model::PartitioningDefinition>>()?
                                ;
                        }
                        __FieldTag::__num_bytes => {
                            if !fields.insert(__FieldTag::__num_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for num_bytes",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.num_bytes = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__num_physical_bytes => {
                            if !fields.insert(__FieldTag::__num_physical_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for num_physical_bytes",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.num_physical_bytes = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__num_long_term_bytes => {
                            if !fields.insert(__FieldTag::__num_long_term_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for num_long_term_bytes",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.num_long_term_bytes = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__num_rows => {
                            if !fields.insert(__FieldTag::__num_rows) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for num_rows",
                                ));
                            }
                            struct __With(std::option::Option<wkt::UInt64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.num_rows = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__creation_time => {
                            if !fields.insert(__FieldTag::__creation_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for creation_time",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.creation_time =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__expiration_time => {
                            if !fields.insert(__FieldTag::__expiration_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expiration_time",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.expiration_time = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__last_modified_time => {
                            if !fields.insert(__FieldTag::__last_modified_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_modified_time",
                                ));
                            }
                            struct __With(std::option::Option<u64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.last_modified_time =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<crate::model::ViewDefinition>>(
                                )?;
                        }
                        __FieldTag::__materialized_view => {
                            if !fields.insert(__FieldTag::__materialized_view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for materialized_view",
                                ));
                            }
                            result.materialized_view = map.next_value::<std::option::Option<crate::model::MaterializedViewDefinition>>()?
                                ;
                        }
                        __FieldTag::__materialized_view_status => {
                            if !fields.insert(__FieldTag::__materialized_view_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for materialized_view_status",
                                ));
                            }
                            result.materialized_view_status = map.next_value::<std::option::Option<crate::model::MaterializedViewStatus>>()?
                                ;
                        }
                        __FieldTag::__external_data_configuration => {
                            if !fields.insert(__FieldTag::__external_data_configuration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_data_configuration",
                                ));
                            }
                            result.external_data_configuration = map.next_value::<std::option::Option<crate::model::ExternalDataConfiguration>>()?
                                ;
                        }
                        __FieldTag::__biglake_configuration => {
                            if !fields.insert(__FieldTag::__biglake_configuration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for biglake_configuration",
                                ));
                            }
                            result.biglake_configuration = map.next_value::<std::option::Option<crate::model::BigLakeConfiguration>>()?
                                ;
                        }
                        __FieldTag::__managed_table_type => {
                            if !fields.insert(__FieldTag::__managed_table_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for managed_table_type",
                                ));
                            }
                            result.managed_table_type = map
                                .next_value::<std::option::Option<crate::model::ManagedTableType>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__streaming_buffer => {
                            if !fields.insert(__FieldTag::__streaming_buffer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for streaming_buffer",
                                ));
                            }
                            result.streaming_buffer = map
                                .next_value::<std::option::Option<crate::model::Streamingbuffer>>(
                                )?;
                        }
                        __FieldTag::__encryption_configuration => {
                            if !fields.insert(__FieldTag::__encryption_configuration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption_configuration",
                                ));
                            }
                            result.encryption_configuration = map.next_value::<std::option::Option<crate::model::EncryptionConfiguration>>()?
                                ;
                        }
                        __FieldTag::__snapshot_definition => {
                            if !fields.insert(__FieldTag::__snapshot_definition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for snapshot_definition",
                                ));
                            }
                            result.snapshot_definition = map.next_value::<std::option::Option<crate::model::SnapshotDefinition>>()?
                                ;
                        }
                        __FieldTag::__default_collation => {
                            if !fields.insert(__FieldTag::__default_collation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_collation",
                                ));
                            }
                            result.default_collation =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::__default_rounding_mode => {
                            if !fields.insert(__FieldTag::__default_rounding_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_rounding_mode",
                                ));
                            }
                            result.default_rounding_mode =
                                map.next_value::<std::option::Option<
                                    crate::model::table_field_schema::RoundingMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__clone_definition => {
                            if !fields.insert(__FieldTag::__clone_definition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for clone_definition",
                                ));
                            }
                            result.clone_definition = map
                                .next_value::<std::option::Option<crate::model::CloneDefinition>>(
                                )?;
                        }
                        __FieldTag::__num_time_travel_physical_bytes => {
                            if !fields.insert(__FieldTag::__num_time_travel_physical_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for num_time_travel_physical_bytes",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.num_time_travel_physical_bytes = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__num_total_logical_bytes => {
                            if !fields.insert(__FieldTag::__num_total_logical_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for num_total_logical_bytes",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.num_total_logical_bytes = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__num_active_logical_bytes => {
                            if !fields.insert(__FieldTag::__num_active_logical_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for num_active_logical_bytes",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.num_active_logical_bytes = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__num_long_term_logical_bytes => {
                            if !fields.insert(__FieldTag::__num_long_term_logical_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for num_long_term_logical_bytes",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.num_long_term_logical_bytes = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__num_current_physical_bytes => {
                            if !fields.insert(__FieldTag::__num_current_physical_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for num_current_physical_bytes",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.num_current_physical_bytes = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__num_total_physical_bytes => {
                            if !fields.insert(__FieldTag::__num_total_physical_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for num_total_physical_bytes",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.num_total_physical_bytes = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__num_active_physical_bytes => {
                            if !fields.insert(__FieldTag::__num_active_physical_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for num_active_physical_bytes",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.num_active_physical_bytes = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__num_long_term_physical_bytes => {
                            if !fields.insert(__FieldTag::__num_long_term_physical_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for num_long_term_physical_bytes",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.num_long_term_physical_bytes = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__num_partitions => {
                            if !fields.insert(__FieldTag::__num_partitions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for num_partitions",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.num_partitions = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__max_staleness => {
                            if !fields.insert(__FieldTag::__max_staleness) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_staleness",
                                ));
                            }
                            result.max_staleness = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__restrictions => {
                            if !fields.insert(__FieldTag::__restrictions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for restrictions",
                                ));
                            }
                            result.restrictions = map
                                .next_value::<std::option::Option<crate::model::RestrictionConfig>>(
                                )?;
                        }
                        __FieldTag::__table_constraints => {
                            if !fields.insert(__FieldTag::__table_constraints) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_constraints",
                                ));
                            }
                            result.table_constraints = map
                                .next_value::<std::option::Option<crate::model::TableConstraints>>(
                                )?;
                        }
                        __FieldTag::__resource_tags => {
                            if !fields.insert(__FieldTag::__resource_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_tags",
                                ));
                            }
                            result.resource_tags = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table_replication_info => {
                            if !fields.insert(__FieldTag::__table_replication_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_replication_info",
                                ));
                            }
                            result.table_replication_info = map.next_value::<std::option::Option<crate::model::TableReplicationInfo>>()?
                                ;
                        }
                        __FieldTag::__replicas => {
                            if !fields.insert(__FieldTag::__replicas) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for replicas",
                                ));
                            }
                            result.replicas =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::TableReference>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__external_catalog_table_options => {
                            if !fields.insert(__FieldTag::__external_catalog_table_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_catalog_table_options",
                                ));
                            }
                            result.external_catalog_table_options = map.next_value::<std::option::Option<crate::model::ExternalCatalogTableOptions>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetTableRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __table_id,
            __selected_fields,
            __view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetTableRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "tableId" => Ok(__FieldTag::__table_id),
                            "table_id" => Ok(__FieldTag::__table_id),
                            "selectedFields" => Ok(__FieldTag::__selected_fields),
                            "selected_fields" => Ok(__FieldTag::__selected_fields),
                            "view" => Ok(__FieldTag::__view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetTableRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetTableRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table_id => {
                            if !fields.insert(__FieldTag::__table_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_id",
                                ));
                            }
                            result.table_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__selected_fields => {
                            if !fields.insert(__FieldTag::__selected_fields) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for selected_fields",
                                ));
                            }
                            result.selected_fields = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<
                                    crate::model::get_table_request::TableMetadataView,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::InsertTableRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __table,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InsertTableRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "table" => Ok(__FieldTag::__table),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::InsertTableRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InsertTableRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table => {
                            if !fields.insert(__FieldTag::__table) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table",
                                ));
                            }
                            result.table =
                                map.next_value::<std::option::Option<crate::model::Table>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UpdateOrPatchTableRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __table_id,
            __table,
            __autodetect_schema,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateOrPatchTableRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "tableId" => Ok(__FieldTag::__table_id),
                            "table_id" => Ok(__FieldTag::__table_id),
                            "table" => Ok(__FieldTag::__table),
                            "autodetectSchema" => Ok(__FieldTag::__autodetect_schema),
                            "autodetect_schema" => Ok(__FieldTag::__autodetect_schema),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UpdateOrPatchTableRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateOrPatchTableRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table_id => {
                            if !fields.insert(__FieldTag::__table_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_id",
                                ));
                            }
                            result.table_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table => {
                            if !fields.insert(__FieldTag::__table) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table",
                                ));
                            }
                            result.table =
                                map.next_value::<std::option::Option<crate::model::Table>>()?;
                        }
                        __FieldTag::__autodetect_schema => {
                            if !fields.insert(__FieldTag::__autodetect_schema) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autodetect_schema",
                                ));
                            }
                            result.autodetect_schema = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeleteTableRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __table_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteTableRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "tableId" => Ok(__FieldTag::__table_id),
                            "table_id" => Ok(__FieldTag::__table_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeleteTableRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteTableRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table_id => {
                            if !fields.insert(__FieldTag::__table_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_id",
                                ));
                            }
                            result.table_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListTablesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __max_results,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTablesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "maxResults" => Ok(__FieldTag::__max_results),
                            "max_results" => Ok(__FieldTag::__max_results),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListTablesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTablesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__max_results => {
                            if !fields.insert(__FieldTag::__max_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_results",
                                ));
                            }
                            struct __With(std::option::Option<wkt::UInt32Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_results = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListFormatView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __use_legacy_sql,
            __privacy_policy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListFormatView")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "useLegacySql" => Ok(__FieldTag::__use_legacy_sql),
                            "use_legacy_sql" => Ok(__FieldTag::__use_legacy_sql),
                            "privacyPolicy" => Ok(__FieldTag::__privacy_policy),
                            "privacy_policy" => Ok(__FieldTag::__privacy_policy),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListFormatView;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListFormatView")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__use_legacy_sql => {
                            if !fields.insert(__FieldTag::__use_legacy_sql) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for use_legacy_sql",
                                ));
                            }
                            result.use_legacy_sql =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__privacy_policy => {
                            if !fields.insert(__FieldTag::__privacy_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for privacy_policy",
                                ));
                            }
                            result.privacy_policy = map
                                .next_value::<std::option::Option<crate::model::PrivacyPolicy>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListFormatTable {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __id,
            __table_reference,
            __friendly_name,
            __type,
            __time_partitioning,
            __range_partitioning,
            __clustering,
            __labels,
            __view,
            __creation_time,
            __expiration_time,
            __require_partition_filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListFormatTable")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "id" => Ok(__FieldTag::__id),
                            "tableReference" => Ok(__FieldTag::__table_reference),
                            "table_reference" => Ok(__FieldTag::__table_reference),
                            "friendlyName" => Ok(__FieldTag::__friendly_name),
                            "friendly_name" => Ok(__FieldTag::__friendly_name),
                            "type" => Ok(__FieldTag::__type),
                            "timePartitioning" => Ok(__FieldTag::__time_partitioning),
                            "time_partitioning" => Ok(__FieldTag::__time_partitioning),
                            "rangePartitioning" => Ok(__FieldTag::__range_partitioning),
                            "range_partitioning" => Ok(__FieldTag::__range_partitioning),
                            "clustering" => Ok(__FieldTag::__clustering),
                            "labels" => Ok(__FieldTag::__labels),
                            "view" => Ok(__FieldTag::__view),
                            "creationTime" => Ok(__FieldTag::__creation_time),
                            "creation_time" => Ok(__FieldTag::__creation_time),
                            "expirationTime" => Ok(__FieldTag::__expiration_time),
                            "expiration_time" => Ok(__FieldTag::__expiration_time),
                            "requirePartitionFilter" => Ok(__FieldTag::__require_partition_filter),
                            "require_partition_filter" => {
                                Ok(__FieldTag::__require_partition_filter)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListFormatTable;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListFormatTable")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table_reference => {
                            if !fields.insert(__FieldTag::__table_reference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_reference",
                                ));
                            }
                            result.table_reference = map
                                .next_value::<std::option::Option<crate::model::TableReference>>(
                                )?;
                        }
                        __FieldTag::__friendly_name => {
                            if !fields.insert(__FieldTag::__friendly_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for friendly_name",
                                ));
                            }
                            result.friendly_name =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__time_partitioning => {
                            if !fields.insert(__FieldTag::__time_partitioning) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_partitioning",
                                ));
                            }
                            result.time_partitioning = map
                                .next_value::<std::option::Option<crate::model::TimePartitioning>>(
                                )?;
                        }
                        __FieldTag::__range_partitioning => {
                            if !fields.insert(__FieldTag::__range_partitioning) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for range_partitioning",
                                ));
                            }
                            result.range_partitioning = map
                                .next_value::<std::option::Option<crate::model::RangePartitioning>>(
                                )?;
                        }
                        __FieldTag::__clustering => {
                            if !fields.insert(__FieldTag::__clustering) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for clustering",
                                ));
                            }
                            result.clustering =
                                map.next_value::<std::option::Option<crate::model::Clustering>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<crate::model::ListFormatView>>(
                                )?;
                        }
                        __FieldTag::__creation_time => {
                            if !fields.insert(__FieldTag::__creation_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for creation_time",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.creation_time =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__expiration_time => {
                            if !fields.insert(__FieldTag::__expiration_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expiration_time",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.expiration_time =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__require_partition_filter => {
                            if !fields.insert(__FieldTag::__require_partition_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for require_partition_filter",
                                ));
                            }
                            result.require_partition_filter =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::TableList {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __etag,
            __next_page_token,
            __tables,
            __total_items,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TableList")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "etag" => Ok(__FieldTag::__etag),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "tables" => Ok(__FieldTag::__tables),
                            "totalItems" => Ok(__FieldTag::__total_items),
                            "total_items" => Ok(__FieldTag::__total_items),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::TableList;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TableList")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tables => {
                            if !fields.insert(__FieldTag::__tables) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tables",
                                ));
                            }
                            result.tables =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ListFormatTable>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__total_items => {
                            if !fields.insert(__FieldTag::__total_items) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_items",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int32Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_items = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::PrimaryKey {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __columns,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PrimaryKey")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "columns" => Ok(__FieldTag::__columns),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::PrimaryKey;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PrimaryKey")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__columns => {
                            if !fields.insert(__FieldTag::__columns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for columns",
                                ));
                            }
                            result.columns = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ColumnReference {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __referencing_column,
            __referenced_column,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ColumnReference")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "referencingColumn" => Ok(__FieldTag::__referencing_column),
                            "referencing_column" => Ok(__FieldTag::__referencing_column),
                            "referencedColumn" => Ok(__FieldTag::__referenced_column),
                            "referenced_column" => Ok(__FieldTag::__referenced_column),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ColumnReference;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ColumnReference")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__referencing_column => {
                            if !fields.insert(__FieldTag::__referencing_column) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for referencing_column",
                                ));
                            }
                            result.referencing_column = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__referenced_column => {
                            if !fields.insert(__FieldTag::__referenced_column) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for referenced_column",
                                ));
                            }
                            result.referenced_column = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ForeignKey {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __referenced_table,
            __column_references,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ForeignKey")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "referencedTable" => Ok(__FieldTag::__referenced_table),
                            "referenced_table" => Ok(__FieldTag::__referenced_table),
                            "columnReferences" => Ok(__FieldTag::__column_references),
                            "column_references" => Ok(__FieldTag::__column_references),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ForeignKey;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ForeignKey")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__referenced_table => {
                            if !fields.insert(__FieldTag::__referenced_table) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for referenced_table",
                                ));
                            }
                            result.referenced_table = map
                                .next_value::<std::option::Option<crate::model::TableReference>>(
                                )?;
                        }
                        __FieldTag::__column_references => {
                            if !fields.insert(__FieldTag::__column_references) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for column_references",
                                ));
                            }
                            result.column_references =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ColumnReference>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::TableConstraints {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __primary_key,
            __foreign_keys,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TableConstraints")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "primaryKey" => Ok(__FieldTag::__primary_key),
                            "primary_key" => Ok(__FieldTag::__primary_key),
                            "foreignKeys" => Ok(__FieldTag::__foreign_keys),
                            "foreign_keys" => Ok(__FieldTag::__foreign_keys),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::TableConstraints;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TableConstraints")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__primary_key => {
                            if !fields.insert(__FieldTag::__primary_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for primary_key",
                                ));
                            }
                            result.primary_key =
                                map.next_value::<std::option::Option<crate::model::PrimaryKey>>()?;
                        }
                        __FieldTag::__foreign_keys => {
                            if !fields.insert(__FieldTag::__foreign_keys) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for foreign_keys",
                                ));
                            }
                            result.foreign_keys = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ForeignKey>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::TableReference {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __table_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TableReference")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "tableId" => Ok(__FieldTag::__table_id),
                            "table_id" => Ok(__FieldTag::__table_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::TableReference;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TableReference")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table_id => {
                            if !fields.insert(__FieldTag::__table_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_id",
                                ));
                            }
                            result.table_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::TableSchema {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __fields,
            __foreign_type_info,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TableSchema")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fields" => Ok(__FieldTag::__fields),
                            "foreignTypeInfo" => Ok(__FieldTag::__foreign_type_info),
                            "foreign_type_info" => Ok(__FieldTag::__foreign_type_info),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::TableSchema;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TableSchema")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__fields => {
                            if !fields.insert(__FieldTag::__fields) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fields",
                                ));
                            }
                            result.fields =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::TableFieldSchema>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__foreign_type_info => {
                            if !fields.insert(__FieldTag::__foreign_type_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for foreign_type_info",
                                ));
                            }
                            result.foreign_type_info = map
                                .next_value::<std::option::Option<crate::model::ForeignTypeInfo>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ForeignTypeInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type_system,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ForeignTypeInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "typeSystem" => Ok(__FieldTag::__type_system),
                            "type_system" => Ok(__FieldTag::__type_system),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ForeignTypeInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ForeignTypeInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type_system => {
                            if !fields.insert(__FieldTag::__type_system) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type_system",
                                ));
                            }
                            result.type_system =
                                map.next_value::<std::option::Option<
                                    crate::model::foreign_type_info::TypeSystem,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DataPolicyOption {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataPolicyOption")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DataPolicyOption;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataPolicyOption")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::TableFieldSchema {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __type,
            __mode,
            __fields,
            __description,
            __policy_tags,
            __data_policies,
            __max_length,
            __precision,
            __scale,
            __rounding_mode,
            __collation,
            __default_value_expression,
            __range_element_type,
            __foreign_type_definition,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TableFieldSchema")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "type" => Ok(__FieldTag::__type),
                            "mode" => Ok(__FieldTag::__mode),
                            "fields" => Ok(__FieldTag::__fields),
                            "description" => Ok(__FieldTag::__description),
                            "policyTags" => Ok(__FieldTag::__policy_tags),
                            "policy_tags" => Ok(__FieldTag::__policy_tags),
                            "dataPolicies" => Ok(__FieldTag::__data_policies),
                            "data_policies" => Ok(__FieldTag::__data_policies),
                            "maxLength" => Ok(__FieldTag::__max_length),
                            "max_length" => Ok(__FieldTag::__max_length),
                            "precision" => Ok(__FieldTag::__precision),
                            "scale" => Ok(__FieldTag::__scale),
                            "roundingMode" => Ok(__FieldTag::__rounding_mode),
                            "rounding_mode" => Ok(__FieldTag::__rounding_mode),
                            "collation" => Ok(__FieldTag::__collation),
                            "defaultValueExpression" => Ok(__FieldTag::__default_value_expression),
                            "default_value_expression" => {
                                Ok(__FieldTag::__default_value_expression)
                            }
                            "rangeElementType" => Ok(__FieldTag::__range_element_type),
                            "range_element_type" => Ok(__FieldTag::__range_element_type),
                            "foreignTypeDefinition" => Ok(__FieldTag::__foreign_type_definition),
                            "foreign_type_definition" => Ok(__FieldTag::__foreign_type_definition),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::TableFieldSchema;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TableFieldSchema")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mode => {
                            if !fields.insert(__FieldTag::__mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mode",
                                ));
                            }
                            result.mode = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__fields => {
                            if !fields.insert(__FieldTag::__fields) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fields",
                                ));
                            }
                            result.fields =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::TableFieldSchema>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::__policy_tags => {
                            if !fields.insert(__FieldTag::__policy_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy_tags",
                                ));
                            }
                            result.policy_tags = map.next_value::<std::option::Option<
                                crate::model::table_field_schema::PolicyTagList,
                            >>()?;
                        }
                        __FieldTag::__data_policies => {
                            if !fields.insert(__FieldTag::__data_policies) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_policies",
                                ));
                            }
                            result.data_policies =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::DataPolicyOption>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__max_length => {
                            if !fields.insert(__FieldTag::__max_length) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_length",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_length = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__precision => {
                            if !fields.insert(__FieldTag::__precision) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for precision",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.precision = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__scale => {
                            if !fields.insert(__FieldTag::__scale) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scale",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.scale = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__rounding_mode => {
                            if !fields.insert(__FieldTag::__rounding_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rounding_mode",
                                ));
                            }
                            result.rounding_mode =
                                map.next_value::<std::option::Option<
                                    crate::model::table_field_schema::RoundingMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__collation => {
                            if !fields.insert(__FieldTag::__collation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for collation",
                                ));
                            }
                            result.collation =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::__default_value_expression => {
                            if !fields.insert(__FieldTag::__default_value_expression) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_value_expression",
                                ));
                            }
                            result.default_value_expression =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::__range_element_type => {
                            if !fields.insert(__FieldTag::__range_element_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for range_element_type",
                                ));
                            }
                            result.range_element_type = map.next_value::<std::option::Option<
                                crate::model::table_field_schema::FieldElementType,
                            >>()?;
                        }
                        __FieldTag::__foreign_type_definition => {
                            if !fields.insert(__FieldTag::__foreign_type_definition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for foreign_type_definition",
                                ));
                            }
                            result.foreign_type_definition = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::table_field_schema::PolicyTagList {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __names,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PolicyTagList")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "names" => Ok(__FieldTag::__names),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::table_field_schema::PolicyTagList;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PolicyTagList")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__names => {
                            if !fields.insert(__FieldTag::__names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for names",
                                ));
                            }
                            result.names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::table_field_schema::FieldElementType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FieldElementType")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::table_field_schema::FieldElementType;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FieldElementType")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::TimePartitioning {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __expiration_ms,
            __field,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TimePartitioning")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "expirationMs" => Ok(__FieldTag::__expiration_ms),
                            "expiration_ms" => Ok(__FieldTag::__expiration_ms),
                            "field" => Ok(__FieldTag::__field),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::TimePartitioning;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TimePartitioning")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__expiration_ms => {
                            if !fields.insert(__FieldTag::__expiration_ms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expiration_ms",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.expiration_ms = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__field => {
                            if !fields.insert(__FieldTag::__field) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field",
                                ));
                            }
                            result.field =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UserDefinedFunctionResource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __resource_uri,
            __inline_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UserDefinedFunctionResource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resourceUri" => Ok(__FieldTag::__resource_uri),
                            "resource_uri" => Ok(__FieldTag::__resource_uri),
                            "inlineCode" => Ok(__FieldTag::__inline_code),
                            "inline_code" => Ok(__FieldTag::__inline_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UserDefinedFunctionResource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UserDefinedFunctionResource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__resource_uri => {
                            if !fields.insert(__FieldTag::__resource_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_uri",
                                ));
                            }
                            result.resource_uri =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::__inline_code => {
                            if !fields.insert(__FieldTag::__inline_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inline_code",
                                ));
                            }
                            result.inline_code =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}
