// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

impl std::fmt::Debug for super::BigLakeConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BigLakeConfiguration");
        debug_struct.field("connection_id", &self.connection_id);
        debug_struct.field("storage_uri", &self.storage_uri);
        debug_struct.field("file_format", &self.file_format);
        debug_struct.field("table_format", &self.table_format);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Clustering {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Clustering");
        debug_struct.field("fields", &self.fields);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DataFormatOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DataFormatOptions");
        debug_struct.field("use_int64_timestamp", &self.use_int64_timestamp);
        debug_struct.field("timestamp_output_format", &self.timestamp_output_format);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DatasetAccessEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DatasetAccessEntry");
        debug_struct.field("dataset", &self.dataset);
        debug_struct.field("target_types", &self.target_types);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Access {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Access");
        debug_struct.field("role", &self.role);
        debug_struct.field("user_by_email", &self.user_by_email);
        debug_struct.field("group_by_email", &self.group_by_email);
        debug_struct.field("domain", &self.domain);
        debug_struct.field("special_group", &self.special_group);
        debug_struct.field("iam_member", &self.iam_member);
        debug_struct.field("view", &self.view);
        debug_struct.field("routine", &self.routine);
        debug_struct.field("dataset", &self.dataset);
        debug_struct.field("condition", &self.condition);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Dataset {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Dataset");
        debug_struct.field("kind", &self.kind);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("id", &self.id);
        debug_struct.field("self_link", &self.self_link);
        debug_struct.field("dataset_reference", &self.dataset_reference);
        debug_struct.field("friendly_name", &self.friendly_name);
        debug_struct.field("description", &self.description);
        debug_struct.field("default_table_expiration_ms", &self.default_table_expiration_ms);
        debug_struct.field("default_partition_expiration_ms", &self.default_partition_expiration_ms);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("access", &self.access);
        debug_struct.field("creation_time", &self.creation_time);
        debug_struct.field("last_modified_time", &self.last_modified_time);
        debug_struct.field("location", &self.location);
        debug_struct.field("default_encryption_configuration", &self.default_encryption_configuration);
        debug_struct.field("satisfies_pzs", &self.satisfies_pzs);
        debug_struct.field("satisfies_pzi", &self.satisfies_pzi);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("linked_dataset_source", &self.linked_dataset_source);
        debug_struct.field("linked_dataset_metadata", &self.linked_dataset_metadata);
        debug_struct.field("external_dataset_reference", &self.external_dataset_reference);
        debug_struct.field("external_catalog_dataset_options", &self.external_catalog_dataset_options);
        debug_struct.field("is_case_insensitive", &self.is_case_insensitive);
        debug_struct.field("default_collation", &self.default_collation);
        debug_struct.field("default_rounding_mode", &self.default_rounding_mode);
        debug_struct.field("max_time_travel_hours", &self.max_time_travel_hours);
        debug_struct.field("tags", &self.tags);
        debug_struct.field("storage_billing_model", &self.storage_billing_model);
        debug_struct.field("restrictions", &self.restrictions);
        debug_struct.field("resource_tags", &self.resource_tags);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}



impl std::fmt::Debug for super::GcpTag {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GcpTag");
        debug_struct.field("tag_key", &self.tag_key);
        debug_struct.field("tag_value", &self.tag_value);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::LinkedDatasetSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LinkedDatasetSource");
        debug_struct.field("source_dataset", &self.source_dataset);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::LinkedDatasetMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LinkedDatasetMetadata");
        debug_struct.field("link_state", &self.link_state);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetDatasetRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetDatasetRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("dataset_id", &self.dataset_id);
        debug_struct.field("dataset_view", &self.dataset_view);
        debug_struct.field("access_policy_version", &self.access_policy_version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::InsertDatasetRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InsertDatasetRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("dataset", &self.dataset);
        debug_struct.field("access_policy_version", &self.access_policy_version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateOrPatchDatasetRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateOrPatchDatasetRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("dataset_id", &self.dataset_id);
        debug_struct.field("dataset", &self.dataset);
        debug_struct.field("update_mode", &self.update_mode);
        debug_struct.field("access_policy_version", &self.access_policy_version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteDatasetRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteDatasetRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("dataset_id", &self.dataset_id);
        debug_struct.field("delete_contents", &self.delete_contents);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListDatasetsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListDatasetsRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("max_results", &self.max_results);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("all", &self.all);
        debug_struct.field("filter", &self.filter);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListFormatDataset {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListFormatDataset");
        debug_struct.field("kind", &self.kind);
        debug_struct.field("id", &self.id);
        debug_struct.field("dataset_reference", &self.dataset_reference);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("friendly_name", &self.friendly_name);
        debug_struct.field("location", &self.location);
        debug_struct.field("external_dataset_reference", &self.external_dataset_reference);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DatasetList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DatasetList");
        debug_struct.field("kind", &self.kind);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("datasets", &self.datasets);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UndeleteDatasetRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UndeleteDatasetRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("dataset_id", &self.dataset_id);
        debug_struct.field("deletion_time", &self.deletion_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DatasetReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DatasetReference");
        debug_struct.field("dataset_id", &self.dataset_id);
        debug_struct.field("project_id", &self.project_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::EncryptionConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EncryptionConfiguration");
        debug_struct.field("kms_key_name", &self.kms_key_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ErrorProto {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ErrorProto");
        debug_struct.field("reason", &self.reason);
        debug_struct.field("location", &self.location);
        debug_struct.field("debug_info", &self.debug_info);
        debug_struct.field("message", &self.message);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ExternalCatalogDatasetOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExternalCatalogDatasetOptions");
        debug_struct.field("parameters", &self.parameters);
        debug_struct.field("default_storage_location_uri", &self.default_storage_location_uri);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ExternalCatalogTableOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExternalCatalogTableOptions");
        debug_struct.field("parameters", &self.parameters);
        debug_struct.field("storage_descriptor", &self.storage_descriptor);
        debug_struct.field("connection_id", &self.connection_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::StorageDescriptor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StorageDescriptor");
        debug_struct.field("location_uri", &self.location_uri);
        debug_struct.field("input_format", &self.input_format);
        debug_struct.field("output_format", &self.output_format);
        debug_struct.field("serde_info", &self.serde_info);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SerDeInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SerDeInfo");
        debug_struct.field("name", &self.name);
        debug_struct.field("serialization_library", &self.serialization_library);
        debug_struct.field("parameters", &self.parameters);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AvroOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AvroOptions");
        debug_struct.field("use_avro_logical_types", &self.use_avro_logical_types);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ParquetOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ParquetOptions");
        debug_struct.field("enum_as_string", &self.enum_as_string);
        debug_struct.field("enable_list_inference", &self.enable_list_inference);
        debug_struct.field("map_target_type", &self.map_target_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CsvOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CsvOptions");
        debug_struct.field("field_delimiter", &self.field_delimiter);
        debug_struct.field("skip_leading_rows", &self.skip_leading_rows);
        debug_struct.field("quote", &self.quote);
        debug_struct.field("allow_quoted_newlines", &self.allow_quoted_newlines);
        debug_struct.field("allow_jagged_rows", &self.allow_jagged_rows);
        debug_struct.field("encoding", &self.encoding);
        debug_struct.field("preserve_ascii_control_characters", &self.preserve_ascii_control_characters);
        debug_struct.field("null_marker", &self.null_marker);
        debug_struct.field("null_markers", &self.null_markers);
        debug_struct.field("source_column_match", &self.source_column_match);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::JsonOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("JsonOptions");
        debug_struct.field("encoding", &self.encoding);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BigtableProtoConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BigtableProtoConfig");
        debug_struct.field("schema_bundle_id", &self.schema_bundle_id);
        debug_struct.field("proto_message_name", &self.proto_message_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BigtableColumn {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BigtableColumn");
        debug_struct.field("qualifier_encoded", &self.qualifier_encoded);
        debug_struct.field("qualifier_string", &self.qualifier_string);
        debug_struct.field("field_name", &self.field_name);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("encoding", &self.encoding);
        debug_struct.field("only_read_latest", &self.only_read_latest);
        debug_struct.field("proto_config", &self.proto_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BigtableColumnFamily {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BigtableColumnFamily");
        debug_struct.field("family_id", &self.family_id);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("encoding", &self.encoding);
        debug_struct.field("columns", &self.columns);
        debug_struct.field("only_read_latest", &self.only_read_latest);
        debug_struct.field("proto_config", &self.proto_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BigtableOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BigtableOptions");
        debug_struct.field("column_families", &self.column_families);
        debug_struct.field("ignore_unspecified_column_families", &self.ignore_unspecified_column_families);
        debug_struct.field("read_rowkey_as_string", &self.read_rowkey_as_string);
        debug_struct.field("output_column_families_as_json", &self.output_column_families_as_json);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GoogleSheetsOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GoogleSheetsOptions");
        debug_struct.field("skip_leading_rows", &self.skip_leading_rows);
        debug_struct.field("range", &self.range);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ExternalDataConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExternalDataConfiguration");
        debug_struct.field("source_uris", &self.source_uris);
        debug_struct.field("file_set_spec_type", &self.file_set_spec_type);
        debug_struct.field("schema", &self.schema);
        debug_struct.field("source_format", &self.source_format);
        debug_struct.field("max_bad_records", &self.max_bad_records);
        debug_struct.field("autodetect", &self.autodetect);
        debug_struct.field("ignore_unknown_values", &self.ignore_unknown_values);
        debug_struct.field("compression", &self.compression);
        debug_struct.field("csv_options", &self.csv_options);
        debug_struct.field("json_options", &self.json_options);
        debug_struct.field("bigtable_options", &self.bigtable_options);
        debug_struct.field("google_sheets_options", &self.google_sheets_options);
        debug_struct.field("hive_partitioning_options", &self.hive_partitioning_options);
        debug_struct.field("connection_id", &self.connection_id);
        debug_struct.field("decimal_target_types", &self.decimal_target_types);
        debug_struct.field("avro_options", &self.avro_options);
        debug_struct.field("json_extension", &self.json_extension);
        debug_struct.field("parquet_options", &self.parquet_options);
        debug_struct.field("object_metadata", &self.object_metadata);
        debug_struct.field("reference_file_schema_uri", &self.reference_file_schema_uri);
        debug_struct.field("metadata_cache_mode", &self.metadata_cache_mode);
        debug_struct.field("time_zone", &self.time_zone);
        debug_struct.field("date_format", &self.date_format);
        debug_struct.field("datetime_format", &self.datetime_format);
        debug_struct.field("time_format", &self.time_format);
        debug_struct.field("timestamp_format", &self.timestamp_format);
        debug_struct.field("timestamp_target_precision", &self.timestamp_target_precision);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ExternalDatasetReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExternalDatasetReference");
        debug_struct.field("external_source", &self.external_source);
        debug_struct.field("connection", &self.connection);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::HivePartitioningOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("HivePartitioningOptions");
        debug_struct.field("mode", &self.mode);
        debug_struct.field("source_uri_prefix", &self.source_uri_prefix);
        debug_struct.field("require_partition_filter", &self.require_partition_filter);
        debug_struct.field("fields", &self.fields);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Job {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Job");
        debug_struct.field("kind", &self.kind);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("id", &self.id);
        debug_struct.field("self_link", &self.self_link);
        debug_struct.field("user_email", &self.user_email);
        debug_struct.field("configuration", &self.configuration);
        debug_struct.field("job_reference", &self.job_reference);
        debug_struct.field("statistics", &self.statistics);
        debug_struct.field("status", &self.status);
        debug_struct.field("principal_subject", &self.principal_subject);
        debug_struct.field("job_creation_reason", &self.job_creation_reason);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CancelJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CancelJobRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("job_id", &self.job_id);
        debug_struct.field("location", &self.location);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::JobCancelResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("JobCancelResponse");
        debug_struct.field("kind", &self.kind);
        debug_struct.field("job", &self.job);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetJobRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("job_id", &self.job_id);
        debug_struct.field("location", &self.location);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::InsertJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InsertJobRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("job", &self.job);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteJobRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("job_id", &self.job_id);
        debug_struct.field("location", &self.location);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListJobsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListJobsRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("all_users", &self.all_users);
        debug_struct.field("max_results", &self.max_results);
        debug_struct.field("min_creation_time", &self.min_creation_time);
        debug_struct.field("max_creation_time", &self.max_creation_time);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("projection", &self.projection);
        debug_struct.field("state_filter", &self.state_filter);
        debug_struct.field("parent_job_id", &self.parent_job_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListFormatJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListFormatJob");
        debug_struct.field("id", &self.id);
        debug_struct.field("kind", &self.kind);
        debug_struct.field("job_reference", &self.job_reference);
        debug_struct.field("state", &self.state);
        debug_struct.field("error_result", &self.error_result);
        debug_struct.field("statistics", &self.statistics);
        debug_struct.field("configuration", &self.configuration);
        debug_struct.field("status", &self.status);
        debug_struct.field("user_email", &self.user_email);
        debug_struct.field("principal_subject", &self.principal_subject);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::JobList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("JobList");
        debug_struct.field("etag", &self.etag);
        debug_struct.field("kind", &self.kind);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("jobs", &self.jobs);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetQueryResultsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetQueryResultsRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("job_id", &self.job_id);
        debug_struct.field("start_index", &self.start_index);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("max_results", &self.max_results);
        debug_struct.field("timeout_ms", &self.timeout_ms);
        debug_struct.field("location", &self.location);
        debug_struct.field("format_options", &self.format_options);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetQueryResultsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetQueryResultsResponse");
        debug_struct.field("kind", &self.kind);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("schema", &self.schema);
        debug_struct.field("job_reference", &self.job_reference);
        debug_struct.field("total_rows", &self.total_rows);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("rows", &self.rows);
        debug_struct.field("total_bytes_processed", &self.total_bytes_processed);
        debug_struct.field("job_complete", &self.job_complete);
        debug_struct.field("errors", &self.errors);
        debug_struct.field("cache_hit", &self.cache_hit);
        debug_struct.field("num_dml_affected_rows", &self.num_dml_affected_rows);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::PostQueryRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PostQueryRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("query_request", &self.query_request);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::QueryRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("QueryRequest");
        debug_struct.field("kind", &self.kind);
        debug_struct.field("query", &self.query);
        debug_struct.field("max_results", &self.max_results);
        debug_struct.field("default_dataset", &self.default_dataset);
        debug_struct.field("timeout_ms", &self.timeout_ms);
        debug_struct.field("job_timeout_ms", &self.job_timeout_ms);
        debug_struct.field("max_slots", &self.max_slots);
        debug_struct.field("destination_encryption_configuration", &self.destination_encryption_configuration);
        debug_struct.field("dry_run", &self.dry_run);
        debug_struct.field("use_query_cache", &self.use_query_cache);
        debug_struct.field("use_legacy_sql", &self.use_legacy_sql);
        debug_struct.field("parameter_mode", &self.parameter_mode);
        debug_struct.field("query_parameters", &self.query_parameters);
        debug_struct.field("location", &self.location);
        debug_struct.field("format_options", &self.format_options);
        debug_struct.field("connection_properties", &self.connection_properties);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("maximum_bytes_billed", &self.maximum_bytes_billed);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("create_session", &self.create_session);
        debug_struct.field("job_creation_mode", &self.job_creation_mode);
        debug_struct.field("reservation", &self.reservation);
        debug_struct.field("write_incremental_results", &self.write_incremental_results);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}


impl std::fmt::Debug for super::QueryResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("QueryResponse");
        debug_struct.field("kind", &self.kind);
        debug_struct.field("schema", &self.schema);
        debug_struct.field("job_reference", &self.job_reference);
        debug_struct.field("job_creation_reason", &self.job_creation_reason);
        debug_struct.field("query_id", &self.query_id);
        debug_struct.field("location", &self.location);
        debug_struct.field("total_rows", &self.total_rows);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("rows", &self.rows);
        debug_struct.field("total_bytes_processed", &self.total_bytes_processed);
        debug_struct.field("total_bytes_billed", &self.total_bytes_billed);
        debug_struct.field("total_slot_ms", &self.total_slot_ms);
        debug_struct.field("job_complete", &self.job_complete);
        debug_struct.field("errors", &self.errors);
        debug_struct.field("cache_hit", &self.cache_hit);
        debug_struct.field("num_dml_affected_rows", &self.num_dml_affected_rows);
        debug_struct.field("session_info", &self.session_info);
        debug_struct.field("dml_stats", &self.dml_stats);
        debug_struct.field("creation_time", &self.creation_time);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_time", &self.end_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DestinationTableProperties {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DestinationTableProperties");
        debug_struct.field("friendly_name", &self.friendly_name);
        debug_struct.field("description", &self.description);
        debug_struct.field("labels", &self.labels);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ConnectionProperty {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConnectionProperty");
        debug_struct.field("key", &self.key);
        debug_struct.field("value", &self.value);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::JobConfigurationQuery {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("JobConfigurationQuery");
        debug_struct.field("query", &self.query);
        debug_struct.field("destination_table", &self.destination_table);
        debug_struct.field("external_table_definitions", &self.external_table_definitions);
        debug_struct.field("user_defined_function_resources", &self.user_defined_function_resources);
        debug_struct.field("create_disposition", &self.create_disposition);
        debug_struct.field("write_disposition", &self.write_disposition);
        debug_struct.field("default_dataset", &self.default_dataset);
        debug_struct.field("priority", &self.priority);
        debug_struct.field("allow_large_results", &self.allow_large_results);
        debug_struct.field("use_query_cache", &self.use_query_cache);
        debug_struct.field("flatten_results", &self.flatten_results);
        debug_struct.field("maximum_bytes_billed", &self.maximum_bytes_billed);
        debug_struct.field("use_legacy_sql", &self.use_legacy_sql);
        debug_struct.field("parameter_mode", &self.parameter_mode);
        debug_struct.field("query_parameters", &self.query_parameters);
        debug_struct.field("system_variables", &self.system_variables);
        debug_struct.field("schema_update_options", &self.schema_update_options);
        debug_struct.field("time_partitioning", &self.time_partitioning);
        debug_struct.field("range_partitioning", &self.range_partitioning);
        debug_struct.field("clustering", &self.clustering);
        debug_struct.field("destination_encryption_configuration", &self.destination_encryption_configuration);
        debug_struct.field("script_options", &self.script_options);
        debug_struct.field("connection_properties", &self.connection_properties);
        debug_struct.field("create_session", &self.create_session);
        debug_struct.field("continuous", &self.continuous);
        debug_struct.field("write_incremental_results", &self.write_incremental_results);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ScriptOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ScriptOptions");
        debug_struct.field("statement_timeout_ms", &self.statement_timeout_ms);
        debug_struct.field("statement_byte_budget", &self.statement_byte_budget);
        debug_struct.field("key_result_statement", &self.key_result_statement);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::JobConfigurationLoad {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("JobConfigurationLoad");
        debug_struct.field("source_uris", &self.source_uris);
        debug_struct.field("file_set_spec_type", &self.file_set_spec_type);
        debug_struct.field("schema", &self.schema);
        debug_struct.field("destination_table", &self.destination_table);
        debug_struct.field("destination_table_properties", &self.destination_table_properties);
        debug_struct.field("create_disposition", &self.create_disposition);
        debug_struct.field("write_disposition", &self.write_disposition);
        debug_struct.field("null_marker", &self.null_marker);
        debug_struct.field("field_delimiter", &self.field_delimiter);
        debug_struct.field("skip_leading_rows", &self.skip_leading_rows);
        debug_struct.field("encoding", &self.encoding);
        debug_struct.field("quote", &self.quote);
        debug_struct.field("max_bad_records", &self.max_bad_records);
        debug_struct.field("allow_quoted_newlines", &self.allow_quoted_newlines);
        debug_struct.field("source_format", &self.source_format);
        debug_struct.field("allow_jagged_rows", &self.allow_jagged_rows);
        debug_struct.field("ignore_unknown_values", &self.ignore_unknown_values);
        debug_struct.field("projection_fields", &self.projection_fields);
        debug_struct.field("autodetect", &self.autodetect);
        debug_struct.field("schema_update_options", &self.schema_update_options);
        debug_struct.field("time_partitioning", &self.time_partitioning);
        debug_struct.field("range_partitioning", &self.range_partitioning);
        debug_struct.field("clustering", &self.clustering);
        debug_struct.field("destination_encryption_configuration", &self.destination_encryption_configuration);
        debug_struct.field("use_avro_logical_types", &self.use_avro_logical_types);
        debug_struct.field("reference_file_schema_uri", &self.reference_file_schema_uri);
        debug_struct.field("hive_partitioning_options", &self.hive_partitioning_options);
        debug_struct.field("decimal_target_types", &self.decimal_target_types);
        debug_struct.field("json_extension", &self.json_extension);
        debug_struct.field("parquet_options", &self.parquet_options);
        debug_struct.field("preserve_ascii_control_characters", &self.preserve_ascii_control_characters);
        debug_struct.field("connection_properties", &self.connection_properties);
        debug_struct.field("create_session", &self.create_session);
        debug_struct.field("column_name_character_map", &self.column_name_character_map);
        debug_struct.field("copy_files_only", &self.copy_files_only);
        debug_struct.field("time_zone", &self.time_zone);
        debug_struct.field("null_markers", &self.null_markers);
        debug_struct.field("date_format", &self.date_format);
        debug_struct.field("datetime_format", &self.datetime_format);
        debug_struct.field("time_format", &self.time_format);
        debug_struct.field("timestamp_format", &self.timestamp_format);
        debug_struct.field("source_column_match", &self.source_column_match);
        debug_struct.field("timestamp_target_precision", &self.timestamp_target_precision);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::JobConfigurationTableCopy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("JobConfigurationTableCopy");
        debug_struct.field("source_table", &self.source_table);
        debug_struct.field("source_tables", &self.source_tables);
        debug_struct.field("destination_table", &self.destination_table);
        debug_struct.field("create_disposition", &self.create_disposition);
        debug_struct.field("write_disposition", &self.write_disposition);
        debug_struct.field("destination_encryption_configuration", &self.destination_encryption_configuration);
        debug_struct.field("operation_type", &self.operation_type);
        debug_struct.field("destination_expiration_time", &self.destination_expiration_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::JobConfigurationExtract {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("JobConfigurationExtract");
        debug_struct.field("destination_uris", &self.destination_uris);
        debug_struct.field("print_header", &self.print_header);
        debug_struct.field("field_delimiter", &self.field_delimiter);
        debug_struct.field("destination_format", &self.destination_format);
        debug_struct.field("compression", &self.compression);
        debug_struct.field("use_avro_logical_types", &self.use_avro_logical_types);
        debug_struct.field("model_extract_options", &self.model_extract_options);
        debug_struct.field("source", &self.source);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::job_configuration_extract::ModelExtractOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ModelExtractOptions");
        debug_struct.field("trial_id", &self.trial_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::JobConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("JobConfiguration");
        debug_struct.field("job_type", &self.job_type);
        debug_struct.field("query", &self.query);
        debug_struct.field("load", &self.load);
        debug_struct.field("copy", &self.copy);
        debug_struct.field("extract", &self.extract);
        debug_struct.field("dry_run", &self.dry_run);
        debug_struct.field("job_timeout_ms", &self.job_timeout_ms);
        debug_struct.field("max_slots", &self.max_slots);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("reservation", &self.reservation);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::JobCreationReason {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("JobCreationReason");
        debug_struct.field("code", &self.code);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::JobReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("JobReference");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("job_id", &self.job_id);
        debug_struct.field("location", &self.location);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ExplainQueryStep {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExplainQueryStep");
        debug_struct.field("kind", &self.kind);
        debug_struct.field("substeps", &self.substeps);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ExplainQueryStage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExplainQueryStage");
        debug_struct.field("name", &self.name);
        debug_struct.field("id", &self.id);
        debug_struct.field("start_ms", &self.start_ms);
        debug_struct.field("end_ms", &self.end_ms);
        debug_struct.field("input_stages", &self.input_stages);
        debug_struct.field("wait_ratio_avg", &self.wait_ratio_avg);
        debug_struct.field("wait_ms_avg", &self.wait_ms_avg);
        debug_struct.field("wait_ratio_max", &self.wait_ratio_max);
        debug_struct.field("wait_ms_max", &self.wait_ms_max);
        debug_struct.field("read_ratio_avg", &self.read_ratio_avg);
        debug_struct.field("read_ms_avg", &self.read_ms_avg);
        debug_struct.field("read_ratio_max", &self.read_ratio_max);
        debug_struct.field("read_ms_max", &self.read_ms_max);
        debug_struct.field("compute_ratio_avg", &self.compute_ratio_avg);
        debug_struct.field("compute_ms_avg", &self.compute_ms_avg);
        debug_struct.field("compute_ratio_max", &self.compute_ratio_max);
        debug_struct.field("compute_ms_max", &self.compute_ms_max);
        debug_struct.field("write_ratio_avg", &self.write_ratio_avg);
        debug_struct.field("write_ms_avg", &self.write_ms_avg);
        debug_struct.field("write_ratio_max", &self.write_ratio_max);
        debug_struct.field("write_ms_max", &self.write_ms_max);
        debug_struct.field("shuffle_output_bytes", &self.shuffle_output_bytes);
        debug_struct.field("shuffle_output_bytes_spilled", &self.shuffle_output_bytes_spilled);
        debug_struct.field("records_read", &self.records_read);
        debug_struct.field("records_written", &self.records_written);
        debug_struct.field("parallel_inputs", &self.parallel_inputs);
        debug_struct.field("completed_parallel_inputs", &self.completed_parallel_inputs);
        debug_struct.field("status", &self.status);
        debug_struct.field("steps", &self.steps);
        debug_struct.field("slot_ms", &self.slot_ms);
        debug_struct.field("compute_mode", &self.compute_mode);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::QueryTimelineSample {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("QueryTimelineSample");
        debug_struct.field("elapsed_ms", &self.elapsed_ms);
        debug_struct.field("total_slot_ms", &self.total_slot_ms);
        debug_struct.field("pending_units", &self.pending_units);
        debug_struct.field("completed_units", &self.completed_units);
        debug_struct.field("active_units", &self.active_units);
        debug_struct.field("shuffle_ram_usage_ratio", &self.shuffle_ram_usage_ratio);
        debug_struct.field("estimated_runnable_units", &self.estimated_runnable_units);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ExternalServiceCost {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExternalServiceCost");
        debug_struct.field("external_service", &self.external_service);
        debug_struct.field("bytes_processed", &self.bytes_processed);
        debug_struct.field("bytes_billed", &self.bytes_billed);
        debug_struct.field("slot_ms", &self.slot_ms);
        debug_struct.field("reserved_slot_count", &self.reserved_slot_count);
        debug_struct.field("billing_method", &self.billing_method);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ExportDataStatistics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExportDataStatistics");
        debug_struct.field("file_count", &self.file_count);
        debug_struct.field("row_count", &self.row_count);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BiEngineReason {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BiEngineReason");
        debug_struct.field("code", &self.code);
        debug_struct.field("message", &self.message);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BiEngineStatistics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BiEngineStatistics");
        debug_struct.field("bi_engine_mode", &self.bi_engine_mode);
        debug_struct.field("acceleration_mode", &self.acceleration_mode);
        debug_struct.field("bi_engine_reasons", &self.bi_engine_reasons);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::IndexUnusedReason {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IndexUnusedReason");
        debug_struct.field("code", &self.code);
        debug_struct.field("message", &self.message);
        debug_struct.field("base_table", &self.base_table);
        debug_struct.field("index_name", &self.index_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::IndexPruningStats {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IndexPruningStats");
        debug_struct.field("base_table", &self.base_table);
        debug_struct.field("index_id", &self.index_id);
        debug_struct.field("pre_index_pruning_parallel_input_count", &self.pre_index_pruning_parallel_input_count);
        debug_struct.field("post_index_pruning_parallel_input_count", &self.post_index_pruning_parallel_input_count);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::StoredColumnsUsage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StoredColumnsUsage");
        debug_struct.field("is_query_accelerated", &self.is_query_accelerated);
        debug_struct.field("base_table", &self.base_table);
        debug_struct.field("stored_columns_unused_reasons", &self.stored_columns_unused_reasons);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::stored_columns_usage::StoredColumnsUnusedReason {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StoredColumnsUnusedReason");
        debug_struct.field("code", &self.code);
        debug_struct.field("message", &self.message);
        debug_struct.field("uncovered_columns", &self.uncovered_columns);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SearchStatistics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SearchStatistics");
        debug_struct.field("index_usage_mode", &self.index_usage_mode);
        debug_struct.field("index_unused_reasons", &self.index_unused_reasons);
        debug_struct.field("index_pruning_stats", &self.index_pruning_stats);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::VectorSearchStatistics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VectorSearchStatistics");
        debug_struct.field("index_usage_mode", &self.index_usage_mode);
        debug_struct.field("index_unused_reasons", &self.index_unused_reasons);
        debug_struct.field("stored_columns_usages", &self.stored_columns_usages);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::QueryInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("QueryInfo");
        debug_struct.field("optimization_details", &self.optimization_details);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::LoadQueryStatistics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LoadQueryStatistics");
        debug_struct.field("input_files", &self.input_files);
        debug_struct.field("input_file_bytes", &self.input_file_bytes);
        debug_struct.field("output_rows", &self.output_rows);
        debug_struct.field("output_bytes", &self.output_bytes);
        debug_struct.field("bad_records", &self.bad_records);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::IncrementalResultStats {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IncrementalResultStats");
        debug_struct.field("disabled_reason", &self.disabled_reason);
        debug_struct.field("result_set_last_replace_time", &self.result_set_last_replace_time);
        debug_struct.field("result_set_last_modify_time", &self.result_set_last_modify_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::JobStatistics2 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("JobStatistics2");
        debug_struct.field("query_plan", &self.query_plan);
        debug_struct.field("estimated_bytes_processed", &self.estimated_bytes_processed);
        debug_struct.field("timeline", &self.timeline);
        debug_struct.field("total_partitions_processed", &self.total_partitions_processed);
        debug_struct.field("total_bytes_processed", &self.total_bytes_processed);
        debug_struct.field("total_bytes_processed_accuracy", &self.total_bytes_processed_accuracy);
        debug_struct.field("total_bytes_billed", &self.total_bytes_billed);
        debug_struct.field("billing_tier", &self.billing_tier);
        debug_struct.field("total_slot_ms", &self.total_slot_ms);
        debug_struct.field("total_services_sku_slot_ms", &self.total_services_sku_slot_ms);
        debug_struct.field("cache_hit", &self.cache_hit);
        debug_struct.field("referenced_tables", &self.referenced_tables);
        debug_struct.field("referenced_routines", &self.referenced_routines);
        debug_struct.field("schema", &self.schema);
        debug_struct.field("num_dml_affected_rows", &self.num_dml_affected_rows);
        debug_struct.field("dml_stats", &self.dml_stats);
        debug_struct.field("undeclared_query_parameters", &self.undeclared_query_parameters);
        debug_struct.field("statement_type", &self.statement_type);
        debug_struct.field("ddl_operation_performed", &self.ddl_operation_performed);
        debug_struct.field("ddl_target_table", &self.ddl_target_table);
        debug_struct.field("ddl_destination_table", &self.ddl_destination_table);
        debug_struct.field("ddl_target_row_access_policy", &self.ddl_target_row_access_policy);
        debug_struct.field("ddl_affected_row_access_policy_count", &self.ddl_affected_row_access_policy_count);
        debug_struct.field("ddl_target_routine", &self.ddl_target_routine);
        debug_struct.field("ddl_target_dataset", &self.ddl_target_dataset);
        debug_struct.field("ml_statistics", &self.ml_statistics);
        debug_struct.field("export_data_statistics", &self.export_data_statistics);
        debug_struct.field("external_service_costs", &self.external_service_costs);
        debug_struct.field("bi_engine_statistics", &self.bi_engine_statistics);
        debug_struct.field("load_query_statistics", &self.load_query_statistics);
        debug_struct.field("dcl_target_table", &self.dcl_target_table);
        debug_struct.field("dcl_target_view", &self.dcl_target_view);
        debug_struct.field("dcl_target_dataset", &self.dcl_target_dataset);
        debug_struct.field("search_statistics", &self.search_statistics);
        debug_struct.field("vector_search_statistics", &self.vector_search_statistics);
        debug_struct.field("performance_insights", &self.performance_insights);
        debug_struct.field("query_info", &self.query_info);
        debug_struct.field("spark_statistics", &self.spark_statistics);
        debug_struct.field("transferred_bytes", &self.transferred_bytes);
        debug_struct.field("materialized_view_statistics", &self.materialized_view_statistics);
        debug_struct.field("metadata_cache_statistics", &self.metadata_cache_statistics);
        debug_struct.field("incremental_result_stats", &self.incremental_result_stats);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::JobStatistics3 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("JobStatistics3");
        debug_struct.field("input_files", &self.input_files);
        debug_struct.field("input_file_bytes", &self.input_file_bytes);
        debug_struct.field("output_rows", &self.output_rows);
        debug_struct.field("output_bytes", &self.output_bytes);
        debug_struct.field("bad_records", &self.bad_records);
        debug_struct.field("timeline", &self.timeline);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::JobStatistics4 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("JobStatistics4");
        debug_struct.field("destination_uri_file_counts", &self.destination_uri_file_counts);
        debug_struct.field("input_bytes", &self.input_bytes);
        debug_struct.field("timeline", &self.timeline);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CopyJobStatistics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CopyJobStatistics");
        debug_struct.field("copied_rows", &self.copied_rows);
        debug_struct.field("copied_logical_bytes", &self.copied_logical_bytes);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::MlStatistics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MlStatistics");
        debug_struct.field("max_iterations", &self.max_iterations);
        debug_struct.field("iteration_results", &self.iteration_results);
        debug_struct.field("model_type", &self.model_type);
        debug_struct.field("training_type", &self.training_type);
        debug_struct.field("hparam_trials", &self.hparam_trials);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ScriptStatistics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ScriptStatistics");
        debug_struct.field("evaluation_kind", &self.evaluation_kind);
        debug_struct.field("stack_frames", &self.stack_frames);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::script_statistics::ScriptStackFrame {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ScriptStackFrame");
        debug_struct.field("start_line", &self.start_line);
        debug_struct.field("start_column", &self.start_column);
        debug_struct.field("end_line", &self.end_line);
        debug_struct.field("end_column", &self.end_column);
        debug_struct.field("procedure_id", &self.procedure_id);
        debug_struct.field("text", &self.text);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RowLevelSecurityStatistics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RowLevelSecurityStatistics");
        debug_struct.field("row_level_security_applied", &self.row_level_security_applied);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DataMaskingStatistics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DataMaskingStatistics");
        debug_struct.field("data_masking_applied", &self.data_masking_applied);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::JobStatistics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("JobStatistics");
        debug_struct.field("creation_time", &self.creation_time);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("total_bytes_processed", &self.total_bytes_processed);
        debug_struct.field("completion_ratio", &self.completion_ratio);
        debug_struct.field("quota_deferments", &self.quota_deferments);
        debug_struct.field("query", &self.query);
        debug_struct.field("load", &self.load);
        debug_struct.field("extract", &self.extract);
        debug_struct.field("copy", &self.copy);
        debug_struct.field("total_slot_ms", &self.total_slot_ms);
        debug_struct.field("reservation_id", &self.reservation_id);
        debug_struct.field("num_child_jobs", &self.num_child_jobs);
        debug_struct.field("parent_job_id", &self.parent_job_id);
        debug_struct.field("script_statistics", &self.script_statistics);
        debug_struct.field("row_level_security_statistics", &self.row_level_security_statistics);
        debug_struct.field("data_masking_statistics", &self.data_masking_statistics);
        debug_struct.field("transaction_info", &self.transaction_info);
        debug_struct.field("session_info", &self.session_info);
        debug_struct.field("final_execution_duration_ms", &self.final_execution_duration_ms);
        debug_struct.field("edition", &self.edition);
        debug_struct.field("reservation_group_path", &self.reservation_group_path);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::job_statistics::TransactionInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TransactionInfo");
        debug_struct.field("transaction_id", &self.transaction_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DmlStats {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DmlStats");
        debug_struct.field("inserted_row_count", &self.inserted_row_count);
        debug_struct.field("deleted_row_count", &self.deleted_row_count);
        debug_struct.field("updated_row_count", &self.updated_row_count);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::PerformanceInsights {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PerformanceInsights");
        debug_struct.field("avg_previous_execution_ms", &self.avg_previous_execution_ms);
        debug_struct.field("stage_performance_standalone_insights", &self.stage_performance_standalone_insights);
        debug_struct.field("stage_performance_change_insights", &self.stage_performance_change_insights);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::StagePerformanceChangeInsight {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StagePerformanceChangeInsight");
        debug_struct.field("stage_id", &self.stage_id);
        debug_struct.field("input_data_change", &self.input_data_change);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::InputDataChange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InputDataChange");
        debug_struct.field("records_read_diff_percentage", &self.records_read_diff_percentage);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::StagePerformanceStandaloneInsight {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StagePerformanceStandaloneInsight");
        debug_struct.field("stage_id", &self.stage_id);
        debug_struct.field("slot_contention", &self.slot_contention);
        debug_struct.field("insufficient_shuffle_quota", &self.insufficient_shuffle_quota);
        debug_struct.field("bi_engine_reasons", &self.bi_engine_reasons);
        debug_struct.field("high_cardinality_joins", &self.high_cardinality_joins);
        debug_struct.field("partition_skew", &self.partition_skew);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::HighCardinalityJoin {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("HighCardinalityJoin");
        debug_struct.field("left_rows", &self.left_rows);
        debug_struct.field("right_rows", &self.right_rows);
        debug_struct.field("output_rows", &self.output_rows);
        debug_struct.field("step_index", &self.step_index);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::PartitionSkew {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PartitionSkew");
        debug_struct.field("skew_sources", &self.skew_sources);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::partition_skew::SkewSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SkewSource");
        debug_struct.field("stage_id", &self.stage_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SparkStatistics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SparkStatistics");
        debug_struct.field("spark_job_id", &self.spark_job_id);
        debug_struct.field("spark_job_location", &self.spark_job_location);
        debug_struct.field("endpoints", &self.endpoints);
        debug_struct.field("logging_info", &self.logging_info);
        debug_struct.field("kms_key_name", &self.kms_key_name);
        debug_struct.field("gcs_staging_bucket", &self.gcs_staging_bucket);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::spark_statistics::LoggingInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LoggingInfo");
        debug_struct.field("resource_type", &self.resource_type);
        debug_struct.field("project_id", &self.project_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}


impl std::fmt::Debug for super::MaterializedViewStatistics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MaterializedViewStatistics");
        debug_struct.field("materialized_view", &self.materialized_view);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::MaterializedView {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MaterializedView");
        debug_struct.field("table_reference", &self.table_reference);
        debug_struct.field("chosen", &self.chosen);
        debug_struct.field("estimated_bytes_saved", &self.estimated_bytes_saved);
        debug_struct.field("rejected_reason", &self.rejected_reason);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::PruningStats {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PruningStats");
        debug_struct.field("post_cmeta_pruning_partition_count", &self.post_cmeta_pruning_partition_count);
        debug_struct.field("pre_cmeta_pruning_parallel_input_count", &self.pre_cmeta_pruning_parallel_input_count);
        debug_struct.field("post_cmeta_pruning_parallel_input_count", &self.post_cmeta_pruning_parallel_input_count);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::TableMetadataCacheUsage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TableMetadataCacheUsage");
        debug_struct.field("table_reference", &self.table_reference);
        debug_struct.field("unused_reason", &self.unused_reason);
        debug_struct.field("explanation", &self.explanation);
        debug_struct.field("staleness", &self.staleness);
        debug_struct.field("table_type", &self.table_type);
        debug_struct.field("pruning_stats", &self.pruning_stats);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::MetadataCacheStatistics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MetadataCacheStatistics");
        debug_struct.field("table_metadata_cache_usage", &self.table_metadata_cache_usage);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::JobStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("JobStatus");
        debug_struct.field("error_result", &self.error_result);
        debug_struct.field("errors", &self.errors);
        debug_struct.field("state", &self.state);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::LocationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LocationMetadata");
        debug_struct.field("legacy_location_id", &self.legacy_location_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RemoteModelInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RemoteModelInfo");
        debug_struct.field("connection", &self.connection);
        debug_struct.field("max_batching_rows", &self.max_batching_rows);
        debug_struct.field("remote_model_version", &self.remote_model_version);
        debug_struct.field("speech_recognizer", &self.speech_recognizer);
        debug_struct.field("remote_service", &self.remote_service);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::TransformColumn {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TransformColumn");
        debug_struct.field("name", &self.name);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("transform_sql", &self.transform_sql);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Model {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Model");
        debug_struct.field("etag", &self.etag);
        debug_struct.field("model_reference", &self.model_reference);
        debug_struct.field("creation_time", &self.creation_time);
        debug_struct.field("last_modified_time", &self.last_modified_time);
        debug_struct.field("description", &self.description);
        debug_struct.field("friendly_name", &self.friendly_name);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("expiration_time", &self.expiration_time);
        debug_struct.field("location", &self.location);
        debug_struct.field("encryption_configuration", &self.encryption_configuration);
        debug_struct.field("model_type", &self.model_type);
        debug_struct.field("training_runs", &self.training_runs);
        debug_struct.field("feature_columns", &self.feature_columns);
        debug_struct.field("label_columns", &self.label_columns);
        debug_struct.field("transform_columns", &self.transform_columns);
        debug_struct.field("hparam_search_spaces", &self.hparam_search_spaces);
        debug_struct.field("default_trial_id", &self.default_trial_id);
        debug_struct.field("hparam_trials", &self.hparam_trials);
        debug_struct.field("optimal_trial_ids", &self.optimal_trial_ids);
        debug_struct.field("remote_model_info", &self.remote_model_info);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::model::SeasonalPeriod {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SeasonalPeriod");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::model::KmeansEnums {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("KmeansEnums");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::model::BoostedTreeOptionEnums {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BoostedTreeOptionEnums");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::model::HparamTuningEnums {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("HparamTuningEnums");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::model::RegressionMetrics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RegressionMetrics");
        debug_struct.field("mean_absolute_error", &self.mean_absolute_error);
        debug_struct.field("mean_squared_error", &self.mean_squared_error);
        debug_struct.field("mean_squared_log_error", &self.mean_squared_log_error);
        debug_struct.field("median_absolute_error", &self.median_absolute_error);
        debug_struct.field("r_squared", &self.r_squared);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::model::AggregateClassificationMetrics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AggregateClassificationMetrics");
        debug_struct.field("precision", &self.precision);
        debug_struct.field("recall", &self.recall);
        debug_struct.field("accuracy", &self.accuracy);
        debug_struct.field("threshold", &self.threshold);
        debug_struct.field("f1_score", &self.f1_score);
        debug_struct.field("log_loss", &self.log_loss);
        debug_struct.field("roc_auc", &self.roc_auc);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::model::BinaryClassificationMetrics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BinaryClassificationMetrics");
        debug_struct.field("aggregate_classification_metrics", &self.aggregate_classification_metrics);
        debug_struct.field("binary_confusion_matrix_list", &self.binary_confusion_matrix_list);
        debug_struct.field("positive_label", &self.positive_label);
        debug_struct.field("negative_label", &self.negative_label);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::model::binary_classification_metrics::BinaryConfusionMatrix {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BinaryConfusionMatrix");
        debug_struct.field("positive_class_threshold", &self.positive_class_threshold);
        debug_struct.field("true_positives", &self.true_positives);
        debug_struct.field("false_positives", &self.false_positives);
        debug_struct.field("true_negatives", &self.true_negatives);
        debug_struct.field("false_negatives", &self.false_negatives);
        debug_struct.field("precision", &self.precision);
        debug_struct.field("recall", &self.recall);
        debug_struct.field("f1_score", &self.f1_score);
        debug_struct.field("accuracy", &self.accuracy);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::model::MultiClassClassificationMetrics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MultiClassClassificationMetrics");
        debug_struct.field("aggregate_classification_metrics", &self.aggregate_classification_metrics);
        debug_struct.field("confusion_matrix_list", &self.confusion_matrix_list);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::model::multi_class_classification_metrics::ConfusionMatrix {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConfusionMatrix");
        debug_struct.field("confidence_threshold", &self.confidence_threshold);
        debug_struct.field("rows", &self.rows);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::model::multi_class_classification_metrics::confusion_matrix::Entry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Entry");
        debug_struct.field("predicted_label", &self.predicted_label);
        debug_struct.field("item_count", &self.item_count);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::model::multi_class_classification_metrics::confusion_matrix::Row {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Row");
        debug_struct.field("actual_label", &self.actual_label);
        debug_struct.field("entries", &self.entries);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::model::ClusteringMetrics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ClusteringMetrics");
        debug_struct.field("davies_bouldin_index", &self.davies_bouldin_index);
        debug_struct.field("mean_squared_distance", &self.mean_squared_distance);
        debug_struct.field("clusters", &self.clusters);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::model::clustering_metrics::Cluster {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Cluster");
        debug_struct.field("centroid_id", &self.centroid_id);
        debug_struct.field("feature_values", &self.feature_values);
        debug_struct.field("count", &self.count);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::model::clustering_metrics::cluster::FeatureValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FeatureValue");
        debug_struct.field("feature_column", &self.feature_column);
        debug_struct.field("value", &self.value);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::model::clustering_metrics::cluster::feature_value::CategoricalValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CategoricalValue");
        debug_struct.field("category_counts", &self.category_counts);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::model::clustering_metrics::cluster::feature_value::categorical_value::CategoryCount {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CategoryCount");
        debug_struct.field("category", &self.category);
        debug_struct.field("count", &self.count);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::model::RankingMetrics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RankingMetrics");
        debug_struct.field("mean_average_precision", &self.mean_average_precision);
        debug_struct.field("mean_squared_error", &self.mean_squared_error);
        debug_struct.field("normalized_discounted_cumulative_gain", &self.normalized_discounted_cumulative_gain);
        debug_struct.field("average_rank", &self.average_rank);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::model::ArimaForecastingMetrics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ArimaForecastingMetrics");
        debug_struct.field("arima_single_model_forecasting_metrics", &self.arima_single_model_forecasting_metrics);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::model::arima_forecasting_metrics::ArimaSingleModelForecastingMetrics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ArimaSingleModelForecastingMetrics");
        debug_struct.field("non_seasonal_order", &self.non_seasonal_order);
        debug_struct.field("arima_fitting_metrics", &self.arima_fitting_metrics);
        debug_struct.field("has_drift", &self.has_drift);
        debug_struct.field("time_series_id", &self.time_series_id);
        debug_struct.field("time_series_ids", &self.time_series_ids);
        debug_struct.field("seasonal_periods", &self.seasonal_periods);
        debug_struct.field("has_holiday_effect", &self.has_holiday_effect);
        debug_struct.field("has_spikes_and_dips", &self.has_spikes_and_dips);
        debug_struct.field("has_step_changes", &self.has_step_changes);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::model::DimensionalityReductionMetrics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DimensionalityReductionMetrics");
        debug_struct.field("total_explained_variance_ratio", &self.total_explained_variance_ratio);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::model::EvaluationMetrics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EvaluationMetrics");
        debug_struct.field("metrics", &self.metrics);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::model::DataSplitResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DataSplitResult");
        debug_struct.field("training_table", &self.training_table);
        debug_struct.field("evaluation_table", &self.evaluation_table);
        debug_struct.field("test_table", &self.test_table);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::model::ArimaOrder {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ArimaOrder");
        debug_struct.field("p", &self.p);
        debug_struct.field("d", &self.d);
        debug_struct.field("q", &self.q);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::model::ArimaFittingMetrics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ArimaFittingMetrics");
        debug_struct.field("log_likelihood", &self.log_likelihood);
        debug_struct.field("aic", &self.aic);
        debug_struct.field("variance", &self.variance);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::model::GlobalExplanation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GlobalExplanation");
        debug_struct.field("explanations", &self.explanations);
        debug_struct.field("class_label", &self.class_label);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::model::global_explanation::Explanation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Explanation");
        debug_struct.field("feature_name", &self.feature_name);
        debug_struct.field("attribution", &self.attribution);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::model::CategoryEncodingMethod {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CategoryEncodingMethod");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::model::PcaSolverOptionEnums {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PcaSolverOptionEnums");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::model::ModelRegistryOptionEnums {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ModelRegistryOptionEnums");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::model::TrainingRun {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TrainingRun");
        debug_struct.field("training_options", &self.training_options);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("results", &self.results);
        debug_struct.field("evaluation_metrics", &self.evaluation_metrics);
        debug_struct.field("data_split_result", &self.data_split_result);
        debug_struct.field("model_level_global_explanation", &self.model_level_global_explanation);
        debug_struct.field("class_level_global_explanations", &self.class_level_global_explanations);
        debug_struct.field("vertex_ai_model_id", &self.vertex_ai_model_id);
        debug_struct.field("vertex_ai_model_version", &self.vertex_ai_model_version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::model::training_run::TrainingOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TrainingOptions");
        debug_struct.field("max_iterations", &self.max_iterations);
        debug_struct.field("loss_type", &self.loss_type);
        debug_struct.field("learn_rate", &self.learn_rate);
        debug_struct.field("l1_regularization", &self.l1_regularization);
        debug_struct.field("l2_regularization", &self.l2_regularization);
        debug_struct.field("min_relative_progress", &self.min_relative_progress);
        debug_struct.field("warm_start", &self.warm_start);
        debug_struct.field("early_stop", &self.early_stop);
        debug_struct.field("input_label_columns", &self.input_label_columns);
        debug_struct.field("data_split_method", &self.data_split_method);
        debug_struct.field("data_split_eval_fraction", &self.data_split_eval_fraction);
        debug_struct.field("data_split_column", &self.data_split_column);
        debug_struct.field("learn_rate_strategy", &self.learn_rate_strategy);
        debug_struct.field("initial_learn_rate", &self.initial_learn_rate);
        debug_struct.field("label_class_weights", &self.label_class_weights);
        debug_struct.field("user_column", &self.user_column);
        debug_struct.field("item_column", &self.item_column);
        debug_struct.field("distance_type", &self.distance_type);
        debug_struct.field("num_clusters", &self.num_clusters);
        debug_struct.field("model_uri", &self.model_uri);
        debug_struct.field("optimization_strategy", &self.optimization_strategy);
        debug_struct.field("hidden_units", &self.hidden_units);
        debug_struct.field("batch_size", &self.batch_size);
        debug_struct.field("dropout", &self.dropout);
        debug_struct.field("max_tree_depth", &self.max_tree_depth);
        debug_struct.field("subsample", &self.subsample);
        debug_struct.field("min_split_loss", &self.min_split_loss);
        debug_struct.field("booster_type", &self.booster_type);
        debug_struct.field("num_parallel_tree", &self.num_parallel_tree);
        debug_struct.field("dart_normalize_type", &self.dart_normalize_type);
        debug_struct.field("tree_method", &self.tree_method);
        debug_struct.field("min_tree_child_weight", &self.min_tree_child_weight);
        debug_struct.field("colsample_bytree", &self.colsample_bytree);
        debug_struct.field("colsample_bylevel", &self.colsample_bylevel);
        debug_struct.field("colsample_bynode", &self.colsample_bynode);
        debug_struct.field("num_factors", &self.num_factors);
        debug_struct.field("feedback_type", &self.feedback_type);
        debug_struct.field("wals_alpha", &self.wals_alpha);
        debug_struct.field("kmeans_initialization_method", &self.kmeans_initialization_method);
        debug_struct.field("kmeans_initialization_column", &self.kmeans_initialization_column);
        debug_struct.field("time_series_timestamp_column", &self.time_series_timestamp_column);
        debug_struct.field("time_series_data_column", &self.time_series_data_column);
        debug_struct.field("auto_arima", &self.auto_arima);
        debug_struct.field("non_seasonal_order", &self.non_seasonal_order);
        debug_struct.field("data_frequency", &self.data_frequency);
        debug_struct.field("calculate_p_values", &self.calculate_p_values);
        debug_struct.field("include_drift", &self.include_drift);
        debug_struct.field("holiday_region", &self.holiday_region);
        debug_struct.field("holiday_regions", &self.holiday_regions);
        debug_struct.field("time_series_id_column", &self.time_series_id_column);
        debug_struct.field("time_series_id_columns", &self.time_series_id_columns);
        debug_struct.field("forecast_limit_lower_bound", &self.forecast_limit_lower_bound);
        debug_struct.field("forecast_limit_upper_bound", &self.forecast_limit_upper_bound);
        debug_struct.field("horizon", &self.horizon);
        debug_struct.field("auto_arima_max_order", &self.auto_arima_max_order);
        debug_struct.field("auto_arima_min_order", &self.auto_arima_min_order);
        debug_struct.field("num_trials", &self.num_trials);
        debug_struct.field("max_parallel_trials", &self.max_parallel_trials);
        debug_struct.field("hparam_tuning_objectives", &self.hparam_tuning_objectives);
        debug_struct.field("decompose_time_series", &self.decompose_time_series);
        debug_struct.field("clean_spikes_and_dips", &self.clean_spikes_and_dips);
        debug_struct.field("adjust_step_changes", &self.adjust_step_changes);
        debug_struct.field("enable_global_explain", &self.enable_global_explain);
        debug_struct.field("sampled_shapley_num_paths", &self.sampled_shapley_num_paths);
        debug_struct.field("integrated_gradients_num_steps", &self.integrated_gradients_num_steps);
        debug_struct.field("category_encoding_method", &self.category_encoding_method);
        debug_struct.field("tf_version", &self.tf_version);
        debug_struct.field("color_space", &self.color_space);
        debug_struct.field("instance_weight_column", &self.instance_weight_column);
        debug_struct.field("trend_smoothing_window_size", &self.trend_smoothing_window_size);
        debug_struct.field("time_series_length_fraction", &self.time_series_length_fraction);
        debug_struct.field("min_time_series_length", &self.min_time_series_length);
        debug_struct.field("max_time_series_length", &self.max_time_series_length);
        debug_struct.field("xgboost_version", &self.xgboost_version);
        debug_struct.field("approx_global_feature_contrib", &self.approx_global_feature_contrib);
        debug_struct.field("fit_intercept", &self.fit_intercept);
        debug_struct.field("num_principal_components", &self.num_principal_components);
        debug_struct.field("pca_explained_variance_ratio", &self.pca_explained_variance_ratio);
        debug_struct.field("scale_features", &self.scale_features);
        debug_struct.field("pca_solver", &self.pca_solver);
        debug_struct.field("auto_class_weights", &self.auto_class_weights);
        debug_struct.field("activation_fn", &self.activation_fn);
        debug_struct.field("optimizer", &self.optimizer);
        debug_struct.field("budget_hours", &self.budget_hours);
        debug_struct.field("standardize_features", &self.standardize_features);
        debug_struct.field("l1_reg_activation", &self.l1_reg_activation);
        debug_struct.field("model_registry", &self.model_registry);
        debug_struct.field("vertex_ai_model_version_aliases", &self.vertex_ai_model_version_aliases);
        debug_struct.field("dimension_id_columns", &self.dimension_id_columns);
        debug_struct.field("contribution_metric", &self.contribution_metric);
        debug_struct.field("is_test_column", &self.is_test_column);
        debug_struct.field("min_apriori_support", &self.min_apriori_support);
        debug_struct.field("endpoint_idle_ttl", &self.endpoint_idle_ttl);
        debug_struct.field("machine_type", &self.machine_type);
        debug_struct.field("min_replica_count", &self.min_replica_count);
        debug_struct.field("max_replica_count", &self.max_replica_count);
        debug_struct.field("reservation_affinity_type", &self.reservation_affinity_type);
        debug_struct.field("reservation_affinity_key", &self.reservation_affinity_key);
        debug_struct.field("reservation_affinity_values", &self.reservation_affinity_values);
        debug_struct.field("external_model_id", &self.external_model_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}


impl std::fmt::Debug for super::model::training_run::IterationResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IterationResult");
        debug_struct.field("index", &self.index);
        debug_struct.field("duration_ms", &self.duration_ms);
        debug_struct.field("training_loss", &self.training_loss);
        debug_struct.field("eval_loss", &self.eval_loss);
        debug_struct.field("learn_rate", &self.learn_rate);
        debug_struct.field("cluster_infos", &self.cluster_infos);
        debug_struct.field("arima_result", &self.arima_result);
        debug_struct.field("principal_component_infos", &self.principal_component_infos);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::model::training_run::iteration_result::ClusterInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ClusterInfo");
        debug_struct.field("centroid_id", &self.centroid_id);
        debug_struct.field("cluster_radius", &self.cluster_radius);
        debug_struct.field("cluster_size", &self.cluster_size);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::model::training_run::iteration_result::ArimaResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ArimaResult");
        debug_struct.field("arima_model_info", &self.arima_model_info);
        debug_struct.field("seasonal_periods", &self.seasonal_periods);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::model::training_run::iteration_result::arima_result::ArimaCoefficients {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ArimaCoefficients");
        debug_struct.field("auto_regressive_coefficients", &self.auto_regressive_coefficients);
        debug_struct.field("moving_average_coefficients", &self.moving_average_coefficients);
        debug_struct.field("intercept_coefficient", &self.intercept_coefficient);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::model::training_run::iteration_result::arima_result::ArimaModelInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ArimaModelInfo");
        debug_struct.field("non_seasonal_order", &self.non_seasonal_order);
        debug_struct.field("arima_coefficients", &self.arima_coefficients);
        debug_struct.field("arima_fitting_metrics", &self.arima_fitting_metrics);
        debug_struct.field("has_drift", &self.has_drift);
        debug_struct.field("time_series_id", &self.time_series_id);
        debug_struct.field("time_series_ids", &self.time_series_ids);
        debug_struct.field("seasonal_periods", &self.seasonal_periods);
        debug_struct.field("has_holiday_effect", &self.has_holiday_effect);
        debug_struct.field("has_spikes_and_dips", &self.has_spikes_and_dips);
        debug_struct.field("has_step_changes", &self.has_step_changes);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::model::training_run::iteration_result::PrincipalComponentInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PrincipalComponentInfo");
        debug_struct.field("principal_component_id", &self.principal_component_id);
        debug_struct.field("explained_variance", &self.explained_variance);
        debug_struct.field("explained_variance_ratio", &self.explained_variance_ratio);
        debug_struct.field("cumulative_explained_variance_ratio", &self.cumulative_explained_variance_ratio);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::model::DoubleHparamSearchSpace {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DoubleHparamSearchSpace");
        debug_struct.field("search_space", &self.search_space);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::model::double_hparam_search_space::DoubleRange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DoubleRange");
        debug_struct.field("min", &self.min);
        debug_struct.field("max", &self.max);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::model::double_hparam_search_space::DoubleCandidates {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DoubleCandidates");
        debug_struct.field("candidates", &self.candidates);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::model::IntHparamSearchSpace {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IntHparamSearchSpace");
        debug_struct.field("search_space", &self.search_space);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::model::int_hparam_search_space::IntRange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IntRange");
        debug_struct.field("min", &self.min);
        debug_struct.field("max", &self.max);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::model::int_hparam_search_space::IntCandidates {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IntCandidates");
        debug_struct.field("candidates", &self.candidates);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::model::StringHparamSearchSpace {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StringHparamSearchSpace");
        debug_struct.field("candidates", &self.candidates);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::model::IntArrayHparamSearchSpace {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IntArrayHparamSearchSpace");
        debug_struct.field("candidates", &self.candidates);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::model::int_array_hparam_search_space::IntArray {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IntArray");
        debug_struct.field("elements", &self.elements);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::model::HparamSearchSpaces {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("HparamSearchSpaces");
        debug_struct.field("learn_rate", &self.learn_rate);
        debug_struct.field("l1_reg", &self.l1_reg);
        debug_struct.field("l2_reg", &self.l2_reg);
        debug_struct.field("num_clusters", &self.num_clusters);
        debug_struct.field("num_factors", &self.num_factors);
        debug_struct.field("hidden_units", &self.hidden_units);
        debug_struct.field("batch_size", &self.batch_size);
        debug_struct.field("dropout", &self.dropout);
        debug_struct.field("max_tree_depth", &self.max_tree_depth);
        debug_struct.field("subsample", &self.subsample);
        debug_struct.field("min_split_loss", &self.min_split_loss);
        debug_struct.field("wals_alpha", &self.wals_alpha);
        debug_struct.field("booster_type", &self.booster_type);
        debug_struct.field("num_parallel_tree", &self.num_parallel_tree);
        debug_struct.field("dart_normalize_type", &self.dart_normalize_type);
        debug_struct.field("tree_method", &self.tree_method);
        debug_struct.field("min_tree_child_weight", &self.min_tree_child_weight);
        debug_struct.field("colsample_bytree", &self.colsample_bytree);
        debug_struct.field("colsample_bylevel", &self.colsample_bylevel);
        debug_struct.field("colsample_bynode", &self.colsample_bynode);
        debug_struct.field("activation_fn", &self.activation_fn);
        debug_struct.field("optimizer", &self.optimizer);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::model::HparamTuningTrial {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("HparamTuningTrial");
        debug_struct.field("trial_id", &self.trial_id);
        debug_struct.field("start_time_ms", &self.start_time_ms);
        debug_struct.field("end_time_ms", &self.end_time_ms);
        debug_struct.field("hparams", &self.hparams);
        debug_struct.field("evaluation_metrics", &self.evaluation_metrics);
        debug_struct.field("status", &self.status);
        debug_struct.field("error_message", &self.error_message);
        debug_struct.field("training_loss", &self.training_loss);
        debug_struct.field("eval_loss", &self.eval_loss);
        debug_struct.field("hparam_tuning_evaluation_metrics", &self.hparam_tuning_evaluation_metrics);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}


impl std::fmt::Debug for super::GetModelRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetModelRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("dataset_id", &self.dataset_id);
        debug_struct.field("model_id", &self.model_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::PatchModelRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PatchModelRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("dataset_id", &self.dataset_id);
        debug_struct.field("model_id", &self.model_id);
        debug_struct.field("model", &self.model);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteModelRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteModelRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("dataset_id", &self.dataset_id);
        debug_struct.field("model_id", &self.model_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListModelsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListModelsRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("dataset_id", &self.dataset_id);
        debug_struct.field("max_results", &self.max_results);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListModelsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListModelsResponse");
        debug_struct.field("models", &self.models);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ModelReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ModelReference");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("dataset_id", &self.dataset_id);
        debug_struct.field("model_id", &self.model_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::PartitioningDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PartitioningDefinition");
        debug_struct.field("partitioned_column", &self.partitioned_column);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::PartitionedColumn {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PartitionedColumn");
        debug_struct.field("field", &self.field);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AggregationThresholdPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AggregationThresholdPolicy");
        debug_struct.field("threshold", &self.threshold);
        debug_struct.field("privacy_unit_columns", &self.privacy_unit_columns);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DifferentialPrivacyPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DifferentialPrivacyPolicy");
        debug_struct.field("max_epsilon_per_query", &self.max_epsilon_per_query);
        debug_struct.field("delta_per_query", &self.delta_per_query);
        debug_struct.field("max_groups_contributed", &self.max_groups_contributed);
        debug_struct.field("privacy_unit_column", &self.privacy_unit_column);
        debug_struct.field("epsilon_budget", &self.epsilon_budget);
        debug_struct.field("delta_budget", &self.delta_budget);
        debug_struct.field("epsilon_budget_remaining", &self.epsilon_budget_remaining);
        debug_struct.field("delta_budget_remaining", &self.delta_budget_remaining);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::JoinRestrictionPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("JoinRestrictionPolicy");
        debug_struct.field("join_condition", &self.join_condition);
        debug_struct.field("join_allowed_columns", &self.join_allowed_columns);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::PrivacyPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PrivacyPolicy");
        debug_struct.field("join_restriction_policy", &self.join_restriction_policy);
        debug_struct.field("privacy_policy", &self.privacy_policy);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetServiceAccountRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetServiceAccountRequest");
        debug_struct.field("project_id", &self.project_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetServiceAccountResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetServiceAccountResponse");
        debug_struct.field("kind", &self.kind);
        debug_struct.field("email", &self.email);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::QueryParameterStructType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("QueryParameterStructType");
        debug_struct.field("name", &self.name);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("description", &self.description);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::QueryParameterType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("QueryParameterType");
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("timestamp_precision", &self.timestamp_precision);
        debug_struct.field("array_type", &self.array_type);
        debug_struct.field("struct_types", &self.struct_types);
        debug_struct.field("range_element_type", &self.range_element_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RangeValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RangeValue");
        debug_struct.field("start", &self.start);
        debug_struct.field("end", &self.end);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::QueryParameterValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("QueryParameterValue");
        debug_struct.field("value", &self.value);
        debug_struct.field("array_values", &self.array_values);
        debug_struct.field("struct_values", &self.struct_values);
        debug_struct.field("range_value", &self.range_value);
        debug_struct.field("alt_struct_values", &self.alt_struct_values);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::QueryParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("QueryParameter");
        debug_struct.field("name", &self.name);
        debug_struct.field("parameter_type", &self.parameter_type);
        debug_struct.field("parameter_value", &self.parameter_value);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RangePartitioning {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RangePartitioning");
        debug_struct.field("field", &self.field);
        debug_struct.field("range", &self.range);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::range_partitioning::Range {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Range");
        debug_struct.field("start", &self.start);
        debug_struct.field("end", &self.end);
        debug_struct.field("interval", &self.interval);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RestrictionConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RestrictionConfig");
        debug_struct.field("r#type", &self.r#type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Routine {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Routine");
        debug_struct.field("etag", &self.etag);
        debug_struct.field("routine_reference", &self.routine_reference);
        debug_struct.field("routine_type", &self.routine_type);
        debug_struct.field("creation_time", &self.creation_time);
        debug_struct.field("last_modified_time", &self.last_modified_time);
        debug_struct.field("language", &self.language);
        debug_struct.field("arguments", &self.arguments);
        debug_struct.field("return_type", &self.return_type);
        debug_struct.field("return_table_type", &self.return_table_type);
        debug_struct.field("imported_libraries", &self.imported_libraries);
        debug_struct.field("definition_body", &self.definition_body);
        debug_struct.field("description", &self.description);
        debug_struct.field("determinism_level", &self.determinism_level);
        debug_struct.field("security_mode", &self.security_mode);
        debug_struct.field("strict_mode", &self.strict_mode);
        debug_struct.field("remote_function_options", &self.remote_function_options);
        debug_struct.field("spark_options", &self.spark_options);
        debug_struct.field("data_governance_type", &self.data_governance_type);
        debug_struct.field("python_options", &self.python_options);
        debug_struct.field("external_runtime_options", &self.external_runtime_options);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::routine::Argument {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Argument");
        debug_struct.field("name", &self.name);
        debug_struct.field("argument_kind", &self.argument_kind);
        debug_struct.field("mode", &self.mode);
        debug_struct.field("data_type", &self.data_type);
        debug_struct.field("is_aggregate", &self.is_aggregate);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::routine::RemoteFunctionOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RemoteFunctionOptions");
        debug_struct.field("endpoint", &self.endpoint);
        debug_struct.field("connection", &self.connection);
        debug_struct.field("user_defined_context", &self.user_defined_context);
        debug_struct.field("max_batching_rows", &self.max_batching_rows);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::PythonOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PythonOptions");
        debug_struct.field("entry_point", &self.entry_point);
        debug_struct.field("packages", &self.packages);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ExternalRuntimeOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExternalRuntimeOptions");
        debug_struct.field("container_memory", &self.container_memory);
        debug_struct.field("container_cpu", &self.container_cpu);
        debug_struct.field("runtime_connection", &self.runtime_connection);
        debug_struct.field("max_batching_rows", &self.max_batching_rows);
        debug_struct.field("runtime_version", &self.runtime_version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SparkOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SparkOptions");
        debug_struct.field("connection", &self.connection);
        debug_struct.field("runtime_version", &self.runtime_version);
        debug_struct.field("container_image", &self.container_image);
        debug_struct.field("properties", &self.properties);
        debug_struct.field("main_file_uri", &self.main_file_uri);
        debug_struct.field("py_file_uris", &self.py_file_uris);
        debug_struct.field("jar_uris", &self.jar_uris);
        debug_struct.field("file_uris", &self.file_uris);
        debug_struct.field("archive_uris", &self.archive_uris);
        debug_struct.field("main_class", &self.main_class);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetRoutineRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetRoutineRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("dataset_id", &self.dataset_id);
        debug_struct.field("routine_id", &self.routine_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::InsertRoutineRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InsertRoutineRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("dataset_id", &self.dataset_id);
        debug_struct.field("routine", &self.routine);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateRoutineRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateRoutineRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("dataset_id", &self.dataset_id);
        debug_struct.field("routine_id", &self.routine_id);
        debug_struct.field("routine", &self.routine);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteRoutineRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteRoutineRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("dataset_id", &self.dataset_id);
        debug_struct.field("routine_id", &self.routine_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListRoutinesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListRoutinesRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("dataset_id", &self.dataset_id);
        debug_struct.field("max_results", &self.max_results);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListRoutinesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListRoutinesResponse");
        debug_struct.field("routines", &self.routines);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RoutineReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RoutineReference");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("dataset_id", &self.dataset_id);
        debug_struct.field("routine_id", &self.routine_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListRowAccessPoliciesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListRowAccessPoliciesRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("dataset_id", &self.dataset_id);
        debug_struct.field("table_id", &self.table_id);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("page_size", &self.page_size);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListRowAccessPoliciesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListRowAccessPoliciesResponse");
        debug_struct.field("row_access_policies", &self.row_access_policies);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetRowAccessPolicyRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetRowAccessPolicyRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("dataset_id", &self.dataset_id);
        debug_struct.field("table_id", &self.table_id);
        debug_struct.field("policy_id", &self.policy_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateRowAccessPolicyRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateRowAccessPolicyRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("dataset_id", &self.dataset_id);
        debug_struct.field("table_id", &self.table_id);
        debug_struct.field("row_access_policy", &self.row_access_policy);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateRowAccessPolicyRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateRowAccessPolicyRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("dataset_id", &self.dataset_id);
        debug_struct.field("table_id", &self.table_id);
        debug_struct.field("policy_id", &self.policy_id);
        debug_struct.field("row_access_policy", &self.row_access_policy);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteRowAccessPolicyRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteRowAccessPolicyRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("dataset_id", &self.dataset_id);
        debug_struct.field("table_id", &self.table_id);
        debug_struct.field("policy_id", &self.policy_id);
        debug_struct.field("force", &self.force);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BatchDeleteRowAccessPoliciesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchDeleteRowAccessPoliciesRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("dataset_id", &self.dataset_id);
        debug_struct.field("table_id", &self.table_id);
        debug_struct.field("policy_ids", &self.policy_ids);
        debug_struct.field("force", &self.force);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RowAccessPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RowAccessPolicy");
        debug_struct.field("etag", &self.etag);
        debug_struct.field("row_access_policy_reference", &self.row_access_policy_reference);
        debug_struct.field("filter_predicate", &self.filter_predicate);
        debug_struct.field("creation_time", &self.creation_time);
        debug_struct.field("last_modified_time", &self.last_modified_time);
        debug_struct.field("grantees", &self.grantees);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RowAccessPolicyReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RowAccessPolicyReference");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("dataset_id", &self.dataset_id);
        debug_struct.field("table_id", &self.table_id);
        debug_struct.field("policy_id", &self.policy_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SessionInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SessionInfo");
        debug_struct.field("session_id", &self.session_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::StandardSqlDataType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StandardSqlDataType");
        debug_struct.field("type_kind", &self.type_kind);
        debug_struct.field("sub_type", &self.sub_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::StandardSqlField {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StandardSqlField");
        debug_struct.field("name", &self.name);
        debug_struct.field("r#type", &self.r#type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::StandardSqlStructType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StandardSqlStructType");
        debug_struct.field("fields", &self.fields);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::StandardSqlTableType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StandardSqlTableType");
        debug_struct.field("columns", &self.columns);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SystemVariables {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SystemVariables");
        debug_struct.field("types", &self.types);
        debug_struct.field("values", &self.values);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::TableReplicationInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TableReplicationInfo");
        debug_struct.field("source_table", &self.source_table);
        debug_struct.field("replication_interval_ms", &self.replication_interval_ms);
        debug_struct.field("replicated_source_last_refresh_time", &self.replicated_source_last_refresh_time);
        debug_struct.field("replication_status", &self.replication_status);
        debug_struct.field("replication_error", &self.replication_error);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ViewDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ViewDefinition");
        debug_struct.field("query", &self.query);
        debug_struct.field("user_defined_function_resources", &self.user_defined_function_resources);
        debug_struct.field("use_legacy_sql", &self.use_legacy_sql);
        debug_struct.field("use_explicit_column_names", &self.use_explicit_column_names);
        debug_struct.field("privacy_policy", &self.privacy_policy);
        debug_struct.field("foreign_definitions", &self.foreign_definitions);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ForeignViewDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ForeignViewDefinition");
        debug_struct.field("query", &self.query);
        debug_struct.field("dialect", &self.dialect);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::MaterializedViewDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MaterializedViewDefinition");
        debug_struct.field("query", &self.query);
        debug_struct.field("last_refresh_time", &self.last_refresh_time);
        debug_struct.field("enable_refresh", &self.enable_refresh);
        debug_struct.field("refresh_interval_ms", &self.refresh_interval_ms);
        debug_struct.field("allow_non_incremental_definition", &self.allow_non_incremental_definition);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::MaterializedViewStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MaterializedViewStatus");
        debug_struct.field("refresh_watermark", &self.refresh_watermark);
        debug_struct.field("last_refresh_status", &self.last_refresh_status);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SnapshotDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SnapshotDefinition");
        debug_struct.field("base_table_reference", &self.base_table_reference);
        debug_struct.field("snapshot_time", &self.snapshot_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CloneDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloneDefinition");
        debug_struct.field("base_table_reference", &self.base_table_reference);
        debug_struct.field("clone_time", &self.clone_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Streamingbuffer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Streamingbuffer");
        debug_struct.field("estimated_bytes", &self.estimated_bytes);
        debug_struct.field("estimated_rows", &self.estimated_rows);
        debug_struct.field("oldest_entry_time", &self.oldest_entry_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Table {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Table");
        debug_struct.field("kind", &self.kind);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("id", &self.id);
        debug_struct.field("self_link", &self.self_link);
        debug_struct.field("table_reference", &self.table_reference);
        debug_struct.field("friendly_name", &self.friendly_name);
        debug_struct.field("description", &self.description);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("schema", &self.schema);
        debug_struct.field("time_partitioning", &self.time_partitioning);
        debug_struct.field("range_partitioning", &self.range_partitioning);
        debug_struct.field("clustering", &self.clustering);
        debug_struct.field("require_partition_filter", &self.require_partition_filter);
        debug_struct.field("partition_definition", &self.partition_definition);
        debug_struct.field("num_bytes", &self.num_bytes);
        debug_struct.field("num_physical_bytes", &self.num_physical_bytes);
        debug_struct.field("num_long_term_bytes", &self.num_long_term_bytes);
        debug_struct.field("num_rows", &self.num_rows);
        debug_struct.field("creation_time", &self.creation_time);
        debug_struct.field("expiration_time", &self.expiration_time);
        debug_struct.field("last_modified_time", &self.last_modified_time);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("view", &self.view);
        debug_struct.field("materialized_view", &self.materialized_view);
        debug_struct.field("materialized_view_status", &self.materialized_view_status);
        debug_struct.field("external_data_configuration", &self.external_data_configuration);
        debug_struct.field("biglake_configuration", &self.biglake_configuration);
        debug_struct.field("managed_table_type", &self.managed_table_type);
        debug_struct.field("location", &self.location);
        debug_struct.field("streaming_buffer", &self.streaming_buffer);
        debug_struct.field("encryption_configuration", &self.encryption_configuration);
        debug_struct.field("snapshot_definition", &self.snapshot_definition);
        debug_struct.field("default_collation", &self.default_collation);
        debug_struct.field("default_rounding_mode", &self.default_rounding_mode);
        debug_struct.field("clone_definition", &self.clone_definition);
        debug_struct.field("num_time_travel_physical_bytes", &self.num_time_travel_physical_bytes);
        debug_struct.field("num_total_logical_bytes", &self.num_total_logical_bytes);
        debug_struct.field("num_active_logical_bytes", &self.num_active_logical_bytes);
        debug_struct.field("num_long_term_logical_bytes", &self.num_long_term_logical_bytes);
        debug_struct.field("num_current_physical_bytes", &self.num_current_physical_bytes);
        debug_struct.field("num_total_physical_bytes", &self.num_total_physical_bytes);
        debug_struct.field("num_active_physical_bytes", &self.num_active_physical_bytes);
        debug_struct.field("num_long_term_physical_bytes", &self.num_long_term_physical_bytes);
        debug_struct.field("num_partitions", &self.num_partitions);
        debug_struct.field("max_staleness", &self.max_staleness);
        debug_struct.field("restrictions", &self.restrictions);
        debug_struct.field("table_constraints", &self.table_constraints);
        debug_struct.field("resource_tags", &self.resource_tags);
        debug_struct.field("table_replication_info", &self.table_replication_info);
        debug_struct.field("replicas", &self.replicas);
        debug_struct.field("external_catalog_table_options", &self.external_catalog_table_options);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetTableRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetTableRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("dataset_id", &self.dataset_id);
        debug_struct.field("table_id", &self.table_id);
        debug_struct.field("selected_fields", &self.selected_fields);
        debug_struct.field("view", &self.view);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::InsertTableRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InsertTableRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("dataset_id", &self.dataset_id);
        debug_struct.field("table", &self.table);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateOrPatchTableRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateOrPatchTableRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("dataset_id", &self.dataset_id);
        debug_struct.field("table_id", &self.table_id);
        debug_struct.field("table", &self.table);
        debug_struct.field("autodetect_schema", &self.autodetect_schema);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteTableRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteTableRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("dataset_id", &self.dataset_id);
        debug_struct.field("table_id", &self.table_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListTablesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListTablesRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("dataset_id", &self.dataset_id);
        debug_struct.field("max_results", &self.max_results);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListFormatView {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListFormatView");
        debug_struct.field("use_legacy_sql", &self.use_legacy_sql);
        debug_struct.field("privacy_policy", &self.privacy_policy);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListFormatTable {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListFormatTable");
        debug_struct.field("kind", &self.kind);
        debug_struct.field("id", &self.id);
        debug_struct.field("table_reference", &self.table_reference);
        debug_struct.field("friendly_name", &self.friendly_name);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("time_partitioning", &self.time_partitioning);
        debug_struct.field("range_partitioning", &self.range_partitioning);
        debug_struct.field("clustering", &self.clustering);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("view", &self.view);
        debug_struct.field("creation_time", &self.creation_time);
        debug_struct.field("expiration_time", &self.expiration_time);
        debug_struct.field("require_partition_filter", &self.require_partition_filter);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::TableList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TableList");
        debug_struct.field("kind", &self.kind);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("tables", &self.tables);
        debug_struct.field("total_items", &self.total_items);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::PrimaryKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PrimaryKey");
        debug_struct.field("columns", &self.columns);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ColumnReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ColumnReference");
        debug_struct.field("referencing_column", &self.referencing_column);
        debug_struct.field("referenced_column", &self.referenced_column);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ForeignKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ForeignKey");
        debug_struct.field("name", &self.name);
        debug_struct.field("referenced_table", &self.referenced_table);
        debug_struct.field("column_references", &self.column_references);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::TableConstraints {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TableConstraints");
        debug_struct.field("primary_key", &self.primary_key);
        debug_struct.field("foreign_keys", &self.foreign_keys);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::TableReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TableReference");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("dataset_id", &self.dataset_id);
        debug_struct.field("table_id", &self.table_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::TableSchema {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TableSchema");
        debug_struct.field("fields", &self.fields);
        debug_struct.field("foreign_type_info", &self.foreign_type_info);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ForeignTypeInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ForeignTypeInfo");
        debug_struct.field("type_system", &self.type_system);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DataPolicyOption {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DataPolicyOption");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::TableFieldSchema {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TableFieldSchema");
        debug_struct.field("name", &self.name);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("mode", &self.mode);
        debug_struct.field("fields", &self.fields);
        debug_struct.field("description", &self.description);
        debug_struct.field("policy_tags", &self.policy_tags);
        debug_struct.field("data_policies", &self.data_policies);
        debug_struct.field("max_length", &self.max_length);
        debug_struct.field("precision", &self.precision);
        debug_struct.field("scale", &self.scale);
        debug_struct.field("timestamp_precision", &self.timestamp_precision);
        debug_struct.field("rounding_mode", &self.rounding_mode);
        debug_struct.field("collation", &self.collation);
        debug_struct.field("default_value_expression", &self.default_value_expression);
        debug_struct.field("range_element_type", &self.range_element_type);
        debug_struct.field("foreign_type_definition", &self.foreign_type_definition);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::table_field_schema::PolicyTagList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PolicyTagList");
        debug_struct.field("names", &self.names);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::table_field_schema::FieldElementType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FieldElementType");
        debug_struct.field("r#type", &self.r#type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::TimePartitioning {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TimePartitioning");
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("expiration_ms", &self.expiration_ms);
        debug_struct.field("field", &self.field);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UserDefinedFunctionResource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UserDefinedFunctionResource");
        debug_struct.field("resource_uri", &self.resource_uri);
        debug_struct.field("inline_code", &self.inline_code);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}
