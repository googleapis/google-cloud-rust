// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.
use crate::Result;

/// Implements a [DatasetService](super::stub::DatasetService) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct DatasetService<T>
where
    T: super::stub::DatasetService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> DatasetService<T>
where
    T: super::stub::DatasetService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> super::stub::DatasetService for DatasetService<T>
where
    T: super::stub::DatasetService + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_dataset(
        &self,
        req: crate::model::GetDatasetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Dataset>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DatasetService",
            "::get_dataset"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_dataset",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_dataset(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_dataset(
        &self,
        req: crate::model::GetDatasetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Dataset>> {
        self.inner.get_dataset(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn insert_dataset(
        &self,
        req: crate::model::InsertDatasetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Dataset>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DatasetService",
            "::insert_dataset"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "insert_dataset",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .insert_dataset(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn insert_dataset(
        &self,
        req: crate::model::InsertDatasetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Dataset>> {
        self.inner.insert_dataset(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn patch_dataset(
        &self,
        req: crate::model::UpdateOrPatchDatasetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Dataset>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DatasetService",
            "::patch_dataset"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "patch_dataset",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .patch_dataset(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn patch_dataset(
        &self,
        req: crate::model::UpdateOrPatchDatasetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Dataset>> {
        self.inner.patch_dataset(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_dataset(
        &self,
        req: crate::model::UpdateOrPatchDatasetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Dataset>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DatasetService",
            "::update_dataset"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_dataset",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_dataset(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_dataset(
        &self,
        req: crate::model::UpdateOrPatchDatasetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Dataset>> {
        self.inner.update_dataset(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_dataset(
        &self,
        req: crate::model::DeleteDatasetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DatasetService",
            "::delete_dataset"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_dataset",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_dataset(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_dataset(
        &self,
        req: crate::model::DeleteDatasetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_dataset(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_datasets(
        &self,
        req: crate::model::ListDatasetsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DatasetList>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DatasetService",
            "::list_datasets"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_datasets",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_datasets(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_datasets(
        &self,
        req: crate::model::ListDatasetsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DatasetList>> {
        self.inner.list_datasets(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn undelete_dataset(
        &self,
        req: crate::model::UndeleteDatasetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Dataset>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DatasetService",
            "::undelete_dataset"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "undelete_dataset",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .undelete_dataset(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn undelete_dataset(
        &self,
        req: crate::model::UndeleteDatasetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Dataset>> {
        self.inner.undelete_dataset(req, options).await
    }
}

/// Implements a [JobService](super::stub::JobService) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct JobService<T>
where
    T: super::stub::JobService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> JobService<T>
where
    T: super::stub::JobService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> super::stub::JobService for JobService<T>
where
    T: super::stub::JobService + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_job(
        &self,
        req: crate::model::CancelJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::JobCancelResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::cancel_job"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_job",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_job(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_job(
        &self,
        req: crate::model::CancelJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::JobCancelResponse>> {
        self.inner.cancel_job(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_job(
        &self,
        req: crate::model::GetJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Job>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::get_job"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_job",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_job(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_job(
        &self,
        req: crate::model::GetJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Job>> {
        self.inner.get_job(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn insert_job(
        &self,
        req: crate::model::InsertJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Job>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::insert_job"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "insert_job",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .insert_job(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn insert_job(
        &self,
        req: crate::model::InsertJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Job>> {
        self.inner.insert_job(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_job(
        &self,
        req: crate::model::DeleteJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::delete_job"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_job",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_job(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_job(
        &self,
        req: crate::model::DeleteJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_job(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_jobs(
        &self,
        req: crate::model::ListJobsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::JobList>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::list_jobs"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_jobs",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_jobs(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_jobs(
        &self,
        req: crate::model::ListJobsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::JobList>> {
        self.inner.list_jobs(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_query_results(
        &self,
        req: crate::model::GetQueryResultsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GetQueryResultsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::get_query_results"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_query_results",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_query_results(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_query_results(
        &self,
        req: crate::model::GetQueryResultsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GetQueryResultsResponse>> {
        self.inner.get_query_results(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn query(
        &self,
        req: crate::model::PostQueryRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::QueryResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobService",
            "::query"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "query",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .query(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn query(
        &self,
        req: crate::model::PostQueryRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::QueryResponse>> {
        self.inner.query(req, options).await
    }
}

/// Implements a [ModelService](super::stub::ModelService) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct ModelService<T>
where
    T: super::stub::ModelService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> ModelService<T>
where
    T: super::stub::ModelService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> super::stub::ModelService for ModelService<T>
where
    T: super::stub::ModelService + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_model(
        &self,
        req: crate::model::GetModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Model>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ModelService",
            "::get_model"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_model",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_model(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_model(
        &self,
        req: crate::model::GetModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Model>> {
        self.inner.get_model(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_models(
        &self,
        req: crate::model::ListModelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListModelsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ModelService",
            "::list_models"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_models",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_models(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_models(
        &self,
        req: crate::model::ListModelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListModelsResponse>> {
        self.inner.list_models(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn patch_model(
        &self,
        req: crate::model::PatchModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Model>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ModelService",
            "::patch_model"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "patch_model",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .patch_model(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn patch_model(
        &self,
        req: crate::model::PatchModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Model>> {
        self.inner.patch_model(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_model(
        &self,
        req: crate::model::DeleteModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ModelService",
            "::delete_model"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_model",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_model(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_model(
        &self,
        req: crate::model::DeleteModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_model(req, options).await
    }
}

/// Implements a [ProjectService](super::stub::ProjectService) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct ProjectService<T>
where
    T: super::stub::ProjectService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> ProjectService<T>
where
    T: super::stub::ProjectService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> super::stub::ProjectService for ProjectService<T>
where
    T: super::stub::ProjectService + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_service_account(
        &self,
        req: crate::model::GetServiceAccountRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GetServiceAccountResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ProjectService",
            "::get_service_account"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_service_account",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_service_account(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_service_account(
        &self,
        req: crate::model::GetServiceAccountRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GetServiceAccountResponse>> {
        self.inner.get_service_account(req, options).await
    }
}

/// Implements a [RoutineService](super::stub::RoutineService) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct RoutineService<T>
where
    T: super::stub::RoutineService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> RoutineService<T>
where
    T: super::stub::RoutineService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> super::stub::RoutineService for RoutineService<T>
where
    T: super::stub::RoutineService + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_routine(
        &self,
        req: crate::model::GetRoutineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Routine>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "RoutineService",
            "::get_routine"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_routine",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_routine(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_routine(
        &self,
        req: crate::model::GetRoutineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Routine>> {
        self.inner.get_routine(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn insert_routine(
        &self,
        req: crate::model::InsertRoutineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Routine>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "RoutineService",
            "::insert_routine"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "insert_routine",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .insert_routine(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn insert_routine(
        &self,
        req: crate::model::InsertRoutineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Routine>> {
        self.inner.insert_routine(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_routine(
        &self,
        req: crate::model::UpdateRoutineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Routine>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "RoutineService",
            "::update_routine"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_routine",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_routine(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_routine(
        &self,
        req: crate::model::UpdateRoutineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Routine>> {
        self.inner.update_routine(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_routine(
        &self,
        req: crate::model::DeleteRoutineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "RoutineService",
            "::delete_routine"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_routine",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_routine(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_routine(
        &self,
        req: crate::model::DeleteRoutineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_routine(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_routines(
        &self,
        req: crate::model::ListRoutinesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListRoutinesResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "RoutineService",
            "::list_routines"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_routines",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_routines(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_routines(
        &self,
        req: crate::model::ListRoutinesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListRoutinesResponse>> {
        self.inner.list_routines(req, options).await
    }
}

/// Implements a [RowAccessPolicyService](super::stub::RowAccessPolicyService) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct RowAccessPolicyService<T>
where
    T: super::stub::RowAccessPolicyService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> RowAccessPolicyService<T>
where
    T: super::stub::RowAccessPolicyService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> super::stub::RowAccessPolicyService for RowAccessPolicyService<T>
where
    T: super::stub::RowAccessPolicyService + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_row_access_policies(
        &self,
        req: crate::model::ListRowAccessPoliciesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListRowAccessPoliciesResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "RowAccessPolicyService",
            "::list_row_access_policies"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_row_access_policies",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_row_access_policies(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_row_access_policies(
        &self,
        req: crate::model::ListRowAccessPoliciesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListRowAccessPoliciesResponse>> {
        self.inner.list_row_access_policies(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_row_access_policy(
        &self,
        req: crate::model::GetRowAccessPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RowAccessPolicy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "RowAccessPolicyService",
            "::get_row_access_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_row_access_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_row_access_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_row_access_policy(
        &self,
        req: crate::model::GetRowAccessPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RowAccessPolicy>> {
        self.inner.get_row_access_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_row_access_policy(
        &self,
        req: crate::model::CreateRowAccessPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RowAccessPolicy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "RowAccessPolicyService",
            "::create_row_access_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_row_access_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_row_access_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_row_access_policy(
        &self,
        req: crate::model::CreateRowAccessPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RowAccessPolicy>> {
        self.inner.create_row_access_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_row_access_policy(
        &self,
        req: crate::model::UpdateRowAccessPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RowAccessPolicy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "RowAccessPolicyService",
            "::update_row_access_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_row_access_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_row_access_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_row_access_policy(
        &self,
        req: crate::model::UpdateRowAccessPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RowAccessPolicy>> {
        self.inner.update_row_access_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_row_access_policy(
        &self,
        req: crate::model::DeleteRowAccessPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "RowAccessPolicyService",
            "::delete_row_access_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_row_access_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_row_access_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_row_access_policy(
        &self,
        req: crate::model::DeleteRowAccessPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_row_access_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn batch_delete_row_access_policies(
        &self,
        req: crate::model::BatchDeleteRowAccessPoliciesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "RowAccessPolicyService",
            "::batch_delete_row_access_policies"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "batch_delete_row_access_policies",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .batch_delete_row_access_policies(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn batch_delete_row_access_policies(
        &self,
        req: crate::model::BatchDeleteRowAccessPoliciesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner
            .batch_delete_row_access_policies(req, options)
            .await
    }
}

/// Implements a [TableService](super::stub::TableService) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct TableService<T>
where
    T: super::stub::TableService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> TableService<T>
where
    T: super::stub::TableService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> super::stub::TableService for TableService<T>
where
    T: super::stub::TableService + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_table(
        &self,
        req: crate::model::GetTableRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Table>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TableService",
            "::get_table"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_table",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_table(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_table(
        &self,
        req: crate::model::GetTableRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Table>> {
        self.inner.get_table(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn insert_table(
        &self,
        req: crate::model::InsertTableRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Table>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TableService",
            "::insert_table"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "insert_table",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .insert_table(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn insert_table(
        &self,
        req: crate::model::InsertTableRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Table>> {
        self.inner.insert_table(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn patch_table(
        &self,
        req: crate::model::UpdateOrPatchTableRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Table>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TableService",
            "::patch_table"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "patch_table",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .patch_table(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn patch_table(
        &self,
        req: crate::model::UpdateOrPatchTableRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Table>> {
        self.inner.patch_table(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_table(
        &self,
        req: crate::model::UpdateOrPatchTableRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Table>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TableService",
            "::update_table"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_table",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_table(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_table(
        &self,
        req: crate::model::UpdateOrPatchTableRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Table>> {
        self.inner.update_table(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_table(
        &self,
        req: crate::model::DeleteTableRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TableService",
            "::delete_table"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_table",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_table(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_table(
        &self,
        req: crate::model::DeleteTableRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_table(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_tables(
        &self,
        req: crate::model::ListTablesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TableList>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TableService",
            "::list_tables"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_tables",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_tables(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_tables(
        &self,
        req: crate::model::ListTablesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TableList>> {
        self.inner.list_tables(req, options).await
    }
}
