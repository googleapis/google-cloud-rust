// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate lazy_static;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Configuration for BigQuery tables for Apache Iceberg (formerly BigLake
/// managed tables.)
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BigLakeConfiguration {
    /// Optional. The connection specifying the credentials to be used to read and
    /// write to external storage, such as Cloud Storage. The connection_id can
    /// have the form `{project}.{location}.{connection_id}` or
    /// `projects/{project}/locations/{location}/connections/{connection_id}".
    pub connection_id: std::string::String,

    /// Optional. The fully qualified location prefix of the external folder where
    /// table data is stored. The '*' wildcard character is not allowed. The URI
    /// should be in the format `gs://bucket/path_to_table/`
    pub storage_uri: std::string::String,

    /// Optional. The file format the table data is stored in.
    pub file_format: crate::model::big_lake_configuration::FileFormat,

    /// Optional. The table format the metadata only snapshots are stored in.
    pub table_format: crate::model::big_lake_configuration::TableFormat,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigLakeConfiguration {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [connection_id][crate::model::BigLakeConfiguration::connection_id].
    pub fn set_connection_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.connection_id = v.into();
        self
    }

    /// Sets the value of [storage_uri][crate::model::BigLakeConfiguration::storage_uri].
    pub fn set_storage_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.storage_uri = v.into();
        self
    }

    /// Sets the value of [file_format][crate::model::BigLakeConfiguration::file_format].
    pub fn set_file_format<
        T: std::convert::Into<crate::model::big_lake_configuration::FileFormat>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.file_format = v.into();
        self
    }

    /// Sets the value of [table_format][crate::model::BigLakeConfiguration::table_format].
    pub fn set_table_format<
        T: std::convert::Into<crate::model::big_lake_configuration::TableFormat>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.table_format = v.into();
        self
    }
}

impl wkt::message::Message for BigLakeConfiguration {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.BigLakeConfiguration"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BigLakeConfiguration {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __connection_id,
            __storage_uri,
            __file_format,
            __table_format,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BigLakeConfiguration")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "connectionId" => Ok(__FieldTag::__connection_id),
                            "connection_id" => Ok(__FieldTag::__connection_id),
                            "storageUri" => Ok(__FieldTag::__storage_uri),
                            "storage_uri" => Ok(__FieldTag::__storage_uri),
                            "fileFormat" => Ok(__FieldTag::__file_format),
                            "file_format" => Ok(__FieldTag::__file_format),
                            "tableFormat" => Ok(__FieldTag::__table_format),
                            "table_format" => Ok(__FieldTag::__table_format),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BigLakeConfiguration;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BigLakeConfiguration")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__connection_id => {
                            if !fields.insert(__FieldTag::__connection_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection_id",
                                ));
                            }
                            result.connection_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__storage_uri => {
                            if !fields.insert(__FieldTag::__storage_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_uri",
                                ));
                            }
                            result.storage_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__file_format => {
                            if !fields.insert(__FieldTag::__file_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_format",
                                ));
                            }
                            result.file_format = map
                                .next_value::<std::option::Option<
                                    crate::model::big_lake_configuration::FileFormat,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table_format => {
                            if !fields.insert(__FieldTag::__table_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_format",
                                ));
                            }
                            result.table_format = map
                                .next_value::<std::option::Option<
                                    crate::model::big_lake_configuration::TableFormat,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BigLakeConfiguration {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.connection_id.is_empty() {
            state.serialize_entry("connectionId", &self.connection_id)?;
        }
        if !self.storage_uri.is_empty() {
            state.serialize_entry("storageUri", &self.storage_uri)?;
        }
        if !wkt::internal::is_default(&self.file_format) {
            state.serialize_entry("fileFormat", &self.file_format)?;
        }
        if !wkt::internal::is_default(&self.table_format) {
            state.serialize_entry("tableFormat", &self.table_format)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [BigLakeConfiguration].
pub mod big_lake_configuration {
    #[allow(unused_imports)]
    use super::*;

    /// Supported file formats for BigQuery tables for Apache Iceberg.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum FileFormat {
        /// Default Value.
        Unspecified,
        /// Apache Parquet format.
        Parquet,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [FileFormat::value] or
        /// [FileFormat::name].
        UnknownValue(file_format::UnknownValue),
    }

    #[doc(hidden)]
    pub mod file_format {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl FileFormat {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Parquet => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("FILE_FORMAT_UNSPECIFIED"),
                Self::Parquet => std::option::Option::Some("PARQUET"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for FileFormat {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for FileFormat {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for FileFormat {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Parquet,
                _ => Self::UnknownValue(file_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for FileFormat {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FILE_FORMAT_UNSPECIFIED" => Self::Unspecified,
                "PARQUET" => Self::Parquet,
                _ => Self::UnknownValue(file_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for FileFormat {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Parquet => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for FileFormat {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<FileFormat>::new(
                ".google.cloud.bigquery.v2.BigLakeConfiguration.FileFormat",
            ))
        }
    }

    /// Supported table formats for BigQuery tables for Apache Iceberg.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TableFormat {
        /// Default Value.
        Unspecified,
        /// Apache Iceberg format.
        Iceberg,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TableFormat::value] or
        /// [TableFormat::name].
        UnknownValue(table_format::UnknownValue),
    }

    #[doc(hidden)]
    pub mod table_format {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TableFormat {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Iceberg => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TABLE_FORMAT_UNSPECIFIED"),
                Self::Iceberg => std::option::Option::Some("ICEBERG"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TableFormat {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TableFormat {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TableFormat {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Iceberg,
                _ => Self::UnknownValue(table_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TableFormat {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TABLE_FORMAT_UNSPECIFIED" => Self::Unspecified,
                "ICEBERG" => Self::Iceberg,
                _ => Self::UnknownValue(table_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TableFormat {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Iceberg => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TableFormat {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TableFormat>::new(
                ".google.cloud.bigquery.v2.BigLakeConfiguration.TableFormat",
            ))
        }
    }
}

/// Configures table clustering.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Clustering {
    /// One or more fields on which data should be clustered. Only top-level,
    /// non-repeated, simple-type fields are supported. The ordering of the
    /// clustering fields should be prioritized from most to least important
    /// for filtering purposes.
    ///
    /// For additional information, see
    /// [Introduction to clustered
    /// tables](https://cloud.google.com/bigquery/docs/clustered-tables#limitations).
    pub fields: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Clustering {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [fields][crate::model::Clustering::fields].
    pub fn set_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.fields = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Clustering {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.Clustering"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Clustering {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __fields,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Clustering")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fields" => Ok(__FieldTag::__fields),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Clustering;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Clustering")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__fields => {
                            if !fields.insert(__FieldTag::__fields) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fields",
                                ));
                            }
                            result.fields = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Clustering {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.fields.is_empty() {
            state.serialize_entry("fields", &self.fields)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Grants all resources of particular types in a particular dataset read access
/// to the current dataset.
///
/// Similar to how individually authorized views work, updates to any resource
/// granted through its dataset (including creation of new resources) requires
/// read permission to referenced resources, plus write permission to the
/// authorizing dataset.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DatasetAccessEntry {
    /// The dataset this entry applies to
    pub dataset: std::option::Option<crate::model::DatasetReference>,

    /// Which resources in the dataset this entry applies to. Currently, only
    /// views are supported, but additional target types may be added in the
    /// future.
    pub target_types: std::vec::Vec<crate::model::dataset_access_entry::TargetType>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatasetAccessEntry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dataset][crate::model::DatasetAccessEntry::dataset].
    pub fn set_dataset<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DatasetReference>,
    {
        self.dataset = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dataset][crate::model::DatasetAccessEntry::dataset].
    pub fn set_or_clear_dataset<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DatasetReference>,
    {
        self.dataset = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target_types][crate::model::DatasetAccessEntry::target_types].
    pub fn set_target_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::dataset_access_entry::TargetType>,
    {
        use std::iter::Iterator;
        self.target_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DatasetAccessEntry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.DatasetAccessEntry"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DatasetAccessEntry {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dataset,
            __target_types,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DatasetAccessEntry")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dataset" => Ok(__FieldTag::__dataset),
                            "targetTypes" => Ok(__FieldTag::__target_types),
                            "target_types" => Ok(__FieldTag::__target_types),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DatasetAccessEntry;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DatasetAccessEntry")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dataset => {
                            if !fields.insert(__FieldTag::__dataset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset",
                                ));
                            }
                            result.dataset = map
                                .next_value::<std::option::Option<crate::model::DatasetReference>>(
                                )?;
                        }
                        __FieldTag::__target_types => {
                            if !fields.insert(__FieldTag::__target_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_types",
                                ));
                            }
                            result.target_types = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::dataset_access_entry::TargetType>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DatasetAccessEntry {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.dataset.is_some() {
            state.serialize_entry("dataset", &self.dataset)?;
        }
        if !self.target_types.is_empty() {
            state.serialize_entry("targetTypes", &self.target_types)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DatasetAccessEntry].
pub mod dataset_access_entry {
    #[allow(unused_imports)]
    use super::*;

    /// Indicates the type of resources in a dataset that the entry applies to.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TargetType {
        /// Do not use. You must set a target type explicitly.
        Unspecified,
        /// This entry applies to views in the dataset.
        Views,
        /// This entry applies to routines in the dataset.
        Routines,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TargetType::value] or
        /// [TargetType::name].
        UnknownValue(target_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod target_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TargetType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Views => std::option::Option::Some(1),
                Self::Routines => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TARGET_TYPE_UNSPECIFIED"),
                Self::Views => std::option::Option::Some("VIEWS"),
                Self::Routines => std::option::Option::Some("ROUTINES"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TargetType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TargetType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TargetType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Views,
                2 => Self::Routines,
                _ => Self::UnknownValue(target_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TargetType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TARGET_TYPE_UNSPECIFIED" => Self::Unspecified,
                "VIEWS" => Self::Views,
                "ROUTINES" => Self::Routines,
                _ => Self::UnknownValue(target_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TargetType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Views => serializer.serialize_i32(1),
                Self::Routines => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TargetType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TargetType>::new(
                ".google.cloud.bigquery.v2.DatasetAccessEntry.TargetType",
            ))
        }
    }
}

/// An object that defines dataset access for an entity.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Access {
    /// An IAM role ID that should be granted to the user, group,
    /// or domain specified in this access entry.
    /// The following legacy mappings will be applied:
    ///
    /// * `OWNER`: `roles/bigquery.dataOwner`
    /// * `WRITER`: `roles/bigquery.dataEditor`
    /// * `READER`: `roles/bigquery.dataViewer`
    ///
    /// This field will accept any of the above formats, but will return only
    /// the legacy format. For example, if you set this field to
    /// "roles/bigquery.dataOwner", it will be returned back as "OWNER".
    pub role: std::string::String,

    /// [Pick one] An email address of a user to grant access to. For example:
    /// fred@example.com. Maps to IAM policy member "user:EMAIL" or
    /// "serviceAccount:EMAIL".
    pub user_by_email: std::string::String,

    /// [Pick one] An email address of a Google Group to grant access to.
    /// Maps to IAM policy member "group:GROUP".
    pub group_by_email: std::string::String,

    /// [Pick one] A domain to grant access to. Any users signed in with the domain
    /// specified will be granted the specified access. Example: "example.com".
    /// Maps to IAM policy member "domain:DOMAIN".
    pub domain: std::string::String,

    /// [Pick one] A special group to grant access to. Possible values include:
    ///
    /// * projectOwners: Owners of the enclosing project.
    /// * projectReaders: Readers of the enclosing project.
    /// * projectWriters: Writers of the enclosing project.
    /// * allAuthenticatedUsers: All authenticated BigQuery users.
    ///
    /// Maps to similarly-named IAM members.
    pub special_group: std::string::String,

    /// [Pick one] Some other type of member that appears in the IAM Policy but
    /// isn't a user, group, domain, or special group.
    pub iam_member: std::string::String,

    /// [Pick one] A view from a different dataset to grant access to. Queries
    /// executed against that view will have read access to views/tables/routines
    /// in this dataset.
    /// The role field is not required when this field is set. If that view is
    /// updated by any user, access to the view needs to be granted again via an
    /// update operation.
    pub view: std::option::Option<crate::model::TableReference>,

    /// [Pick one] A routine from a different dataset to grant access to. Queries
    /// executed against that routine will have read access to
    /// views/tables/routines in this dataset. Only UDF is supported for now.
    /// The role field is not required when this field is set. If that routine is
    /// updated by any user, access to the routine needs to be granted again via
    /// an update operation.
    pub routine: std::option::Option<crate::model::RoutineReference>,

    /// [Pick one] A grant authorizing all resources of a particular type in a
    /// particular dataset access to this dataset. Only views are supported for
    /// now. The role field is not required when this field is set. If that dataset
    /// is deleted and re-created, its access needs to be granted again via an
    /// update operation.
    pub dataset: std::option::Option<crate::model::DatasetAccessEntry>,

    /// Optional. condition for the binding. If CEL expression in this field is
    /// true, this access binding will be considered
    pub condition: std::option::Option<gtype::model::Expr>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Access {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [role][crate::model::Access::role].
    pub fn set_role<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.role = v.into();
        self
    }

    /// Sets the value of [user_by_email][crate::model::Access::user_by_email].
    pub fn set_user_by_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_by_email = v.into();
        self
    }

    /// Sets the value of [group_by_email][crate::model::Access::group_by_email].
    pub fn set_group_by_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.group_by_email = v.into();
        self
    }

    /// Sets the value of [domain][crate::model::Access::domain].
    pub fn set_domain<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.domain = v.into();
        self
    }

    /// Sets the value of [special_group][crate::model::Access::special_group].
    pub fn set_special_group<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.special_group = v.into();
        self
    }

    /// Sets the value of [iam_member][crate::model::Access::iam_member].
    pub fn set_iam_member<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.iam_member = v.into();
        self
    }

    /// Sets the value of [view][crate::model::Access::view].
    pub fn set_view<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TableReference>,
    {
        self.view = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [view][crate::model::Access::view].
    pub fn set_or_clear_view<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TableReference>,
    {
        self.view = v.map(|x| x.into());
        self
    }

    /// Sets the value of [routine][crate::model::Access::routine].
    pub fn set_routine<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RoutineReference>,
    {
        self.routine = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [routine][crate::model::Access::routine].
    pub fn set_or_clear_routine<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RoutineReference>,
    {
        self.routine = v.map(|x| x.into());
        self
    }

    /// Sets the value of [dataset][crate::model::Access::dataset].
    pub fn set_dataset<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DatasetAccessEntry>,
    {
        self.dataset = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dataset][crate::model::Access::dataset].
    pub fn set_or_clear_dataset<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DatasetAccessEntry>,
    {
        self.dataset = v.map(|x| x.into());
        self
    }

    /// Sets the value of [condition][crate::model::Access::condition].
    pub fn set_condition<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::Expr>,
    {
        self.condition = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [condition][crate::model::Access::condition].
    pub fn set_or_clear_condition<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::Expr>,
    {
        self.condition = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Access {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.Access"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Access {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __role,
            __user_by_email,
            __group_by_email,
            __domain,
            __special_group,
            __iam_member,
            __view,
            __routine,
            __dataset,
            __condition,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Access")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "role" => Ok(__FieldTag::__role),
                            "userByEmail" => Ok(__FieldTag::__user_by_email),
                            "user_by_email" => Ok(__FieldTag::__user_by_email),
                            "groupByEmail" => Ok(__FieldTag::__group_by_email),
                            "group_by_email" => Ok(__FieldTag::__group_by_email),
                            "domain" => Ok(__FieldTag::__domain),
                            "specialGroup" => Ok(__FieldTag::__special_group),
                            "special_group" => Ok(__FieldTag::__special_group),
                            "iamMember" => Ok(__FieldTag::__iam_member),
                            "iam_member" => Ok(__FieldTag::__iam_member),
                            "view" => Ok(__FieldTag::__view),
                            "routine" => Ok(__FieldTag::__routine),
                            "dataset" => Ok(__FieldTag::__dataset),
                            "condition" => Ok(__FieldTag::__condition),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Access;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Access")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__role => {
                            if !fields.insert(__FieldTag::__role) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for role",
                                ));
                            }
                            result.role = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__user_by_email => {
                            if !fields.insert(__FieldTag::__user_by_email) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_by_email",
                                ));
                            }
                            result.user_by_email = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__group_by_email => {
                            if !fields.insert(__FieldTag::__group_by_email) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for group_by_email",
                                ));
                            }
                            result.group_by_email = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__domain => {
                            if !fields.insert(__FieldTag::__domain) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for domain",
                                ));
                            }
                            result.domain = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__special_group => {
                            if !fields.insert(__FieldTag::__special_group) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for special_group",
                                ));
                            }
                            result.special_group = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__iam_member => {
                            if !fields.insert(__FieldTag::__iam_member) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for iam_member",
                                ));
                            }
                            result.iam_member = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<crate::model::TableReference>>(
                                )?;
                        }
                        __FieldTag::__routine => {
                            if !fields.insert(__FieldTag::__routine) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for routine",
                                ));
                            }
                            result.routine = map
                                .next_value::<std::option::Option<crate::model::RoutineReference>>(
                                )?;
                        }
                        __FieldTag::__dataset => {
                            if !fields.insert(__FieldTag::__dataset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset",
                                ));
                            }
                            result.dataset = map.next_value::<std::option::Option<crate::model::DatasetAccessEntry>>()?
                                ;
                        }
                        __FieldTag::__condition => {
                            if !fields.insert(__FieldTag::__condition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for condition",
                                ));
                            }
                            result.condition =
                                map.next_value::<std::option::Option<gtype::model::Expr>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Access {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.role.is_empty() {
            state.serialize_entry("role", &self.role)?;
        }
        if !self.user_by_email.is_empty() {
            state.serialize_entry("userByEmail", &self.user_by_email)?;
        }
        if !self.group_by_email.is_empty() {
            state.serialize_entry("groupByEmail", &self.group_by_email)?;
        }
        if !self.domain.is_empty() {
            state.serialize_entry("domain", &self.domain)?;
        }
        if !self.special_group.is_empty() {
            state.serialize_entry("specialGroup", &self.special_group)?;
        }
        if !self.iam_member.is_empty() {
            state.serialize_entry("iamMember", &self.iam_member)?;
        }
        if self.view.is_some() {
            state.serialize_entry("view", &self.view)?;
        }
        if self.routine.is_some() {
            state.serialize_entry("routine", &self.routine)?;
        }
        if self.dataset.is_some() {
            state.serialize_entry("dataset", &self.dataset)?;
        }
        if self.condition.is_some() {
            state.serialize_entry("condition", &self.condition)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents a BigQuery dataset.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Dataset {
    /// Output only. The resource type.
    pub kind: std::string::String,

    /// Output only. A hash of the resource.
    pub etag: std::string::String,

    /// Output only. The fully-qualified unique name of the dataset in the format
    /// projectId:datasetId. The dataset name without the project name is given in
    /// the datasetId field. When creating a new dataset, leave this field blank,
    /// and instead specify the datasetId field.
    pub id: std::string::String,

    /// Output only. A URL that can be used to access the resource again. You can
    /// use this URL in Get or Update requests to the resource.
    pub self_link: std::string::String,

    /// Required. A reference that identifies the dataset.
    pub dataset_reference: std::option::Option<crate::model::DatasetReference>,

    /// Optional. A descriptive name for the dataset.
    pub friendly_name: std::option::Option<wkt::StringValue>,

    /// Optional. A user-friendly description of the dataset.
    pub description: std::option::Option<wkt::StringValue>,

    /// Optional. The default lifetime of all tables in the dataset, in
    /// milliseconds. The minimum lifetime value is 3600000 milliseconds (one
    /// hour). To clear an existing default expiration with a PATCH request, set to
    /// 0. Once this property is set, all newly-created tables in the dataset will
    /// have an expirationTime property set to the creation time plus the value in
    /// this property, and changing the value will only affect new tables, not
    /// existing ones. When the expirationTime for a given table is reached, that
    /// table will be deleted automatically.
    /// If a table's expirationTime is modified or removed before the table
    /// expires, or if you provide an explicit expirationTime when creating a
    /// table, that value takes precedence over the default expiration time
    /// indicated by this property.
    pub default_table_expiration_ms: std::option::Option<wkt::Int64Value>,

    /// This default partition expiration, expressed in milliseconds.
    ///
    /// When new time-partitioned tables are created in a dataset where this
    /// property is set, the table will inherit this value, propagated as the
    /// `TimePartitioning.expirationMs` property on the new table.  If you set
    /// `TimePartitioning.expirationMs` explicitly when creating a table,
    /// the `defaultPartitionExpirationMs` of the containing dataset is ignored.
    ///
    /// When creating a partitioned table, if `defaultPartitionExpirationMs`
    /// is set, the `defaultTableExpirationMs` value is ignored and the table
    /// will not be inherit a table expiration deadline.
    pub default_partition_expiration_ms: std::option::Option<wkt::Int64Value>,

    /// The labels associated with this dataset. You can use these
    /// to organize and group your datasets.
    /// You can set this property when inserting or updating a dataset.
    /// See [Creating and Updating Dataset
    /// Labels](https://cloud.google.com/bigquery/docs/creating-managing-labels#creating_and_updating_dataset_labels)
    /// for more information.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. An array of objects that define dataset access for one or more
    /// entities. You can set this property when inserting or updating a dataset in
    /// order to control who is allowed to access the data. If unspecified at
    /// dataset creation time, BigQuery adds default dataset access for the
    /// following entities: access.specialGroup: projectReaders; access.role:
    /// READER; access.specialGroup: projectWriters; access.role: WRITER;
    /// access.specialGroup: projectOwners; access.role: OWNER;
    /// access.userByEmail: [dataset creator email]; access.role: OWNER;
    /// If you patch a dataset, then this field is overwritten by the patched
    /// dataset's access field. To add entities, you must supply the entire
    /// existing access array in addition to any new entities that you want to add.
    pub access: std::vec::Vec<crate::model::Access>,

    /// Output only. The time when this dataset was created, in milliseconds since
    /// the epoch.
    pub creation_time: i64,

    /// Output only. The date when this dataset was last modified, in milliseconds
    /// since the epoch.
    pub last_modified_time: i64,

    /// The geographic location where the dataset should reside. See
    /// <https://cloud.google.com/bigquery/docs/locations> for supported
    /// locations.
    pub location: std::string::String,

    /// The default encryption key for all tables in the dataset.
    /// After this property is set, the encryption key of all newly-created tables
    /// in the dataset is set to this value unless the table creation request or
    /// query explicitly overrides the key.
    pub default_encryption_configuration:
        std::option::Option<crate::model::EncryptionConfiguration>,

    /// Output only. Reserved for future use.
    pub satisfies_pzs: std::option::Option<wkt::BoolValue>,

    /// Output only. Reserved for future use.
    pub satisfies_pzi: std::option::Option<wkt::BoolValue>,

    /// Output only. Same as `type` in `ListFormatDataset`.
    /// The type of the dataset, one of:
    ///
    /// * DEFAULT - only accessible by owner and authorized accounts,
    /// * PUBLIC - accessible by everyone,
    /// * LINKED - linked dataset,
    /// * EXTERNAL - dataset with definition in external metadata catalog.
    pub r#type: std::string::String,

    /// Optional. The source dataset reference when the dataset is of type LINKED.
    /// For all other dataset types it is not set. This field cannot be updated
    /// once it is set. Any attempt to update this field using Update and Patch API
    /// Operations will be ignored.
    pub linked_dataset_source: std::option::Option<crate::model::LinkedDatasetSource>,

    /// Output only. Metadata about the LinkedDataset. Filled out when the dataset
    /// type is LINKED.
    pub linked_dataset_metadata: std::option::Option<crate::model::LinkedDatasetMetadata>,

    /// Optional. Reference to a read-only external dataset defined in data
    /// catalogs outside of BigQuery. Filled out when the dataset type is EXTERNAL.
    pub external_dataset_reference: std::option::Option<crate::model::ExternalDatasetReference>,

    /// Optional. Options defining open source compatible datasets living in the
    /// BigQuery catalog. Contains metadata of open source database, schema or
    /// namespace represented by the current dataset.
    pub external_catalog_dataset_options:
        std::option::Option<crate::model::ExternalCatalogDatasetOptions>,

    /// Optional. TRUE if the dataset and its table names are case-insensitive,
    /// otherwise FALSE. By default, this is FALSE, which means the dataset and its
    /// table names are case-sensitive. This field does not affect routine
    /// references.
    pub is_case_insensitive: std::option::Option<wkt::BoolValue>,

    /// Optional. Defines the default collation specification of future tables
    /// created in the dataset. If a table is created in this dataset without
    /// table-level default collation, then the table inherits the dataset default
    /// collation, which is applied to the string fields that do not have explicit
    /// collation specified. A change to this field affects only tables created
    /// afterwards, and does not alter the existing tables.
    /// The following values are supported:
    ///
    /// * 'und:ci': undetermined locale, case insensitive.
    /// * '': empty string. Default to case-sensitive behavior.
    pub default_collation: std::option::Option<wkt::StringValue>,

    /// Optional. Defines the default rounding mode specification of new tables
    /// created within this dataset. During table creation, if this field is
    /// specified, the table within this dataset will inherit the default rounding
    /// mode of the dataset. Setting the default rounding mode on a table overrides
    /// this option. Existing tables in the dataset are unaffected.
    /// If columns are defined during that table creation,
    /// they will immediately inherit the table's default rounding mode,
    /// unless otherwise specified.
    pub default_rounding_mode: crate::model::table_field_schema::RoundingMode,

    /// Optional. Defines the time travel window in hours. The value can be from 48
    /// to 168 hours (2 to 7 days). The default value is 168 hours if this is not
    /// set.
    pub max_time_travel_hours: std::option::Option<wkt::Int64Value>,

    /// Output only. Tags for the dataset. To provide tags as inputs, use the
    /// `resourceTags` field.
    #[deprecated]
    pub tags: std::vec::Vec<crate::model::GcpTag>,

    /// Optional. Updates storage_billing_model for the dataset.
    pub storage_billing_model: crate::model::dataset::StorageBillingModel,

    /// Optional. Output only. Restriction config for all tables and dataset. If
    /// set, restrict certain accesses on the dataset and all its tables based on
    /// the config. See [Data
    /// egress](https://cloud.google.com/bigquery/docs/analytics-hub-introduction#data_egress)
    /// for more details.
    pub restrictions: std::option::Option<crate::model::RestrictionConfig>,

    /// Optional. The [tags](https://cloud.google.com/bigquery/docs/tags) attached
    /// to this dataset. Tag keys are globally unique. Tag key is expected to be in
    /// the namespaced format, for example "123456789012/environment" where
    /// 123456789012 is the ID of the parent organization or project resource for
    /// this tag key. Tag value is expected to be the short name, for example
    /// "Production". See [Tag
    /// definitions](https://cloud.google.com/iam/docs/tags-access-control#definitions)
    /// for more details.
    pub resource_tags: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Dataset {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::Dataset::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Dataset::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Dataset::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [self_link][crate::model::Dataset::self_link].
    pub fn set_self_link<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.self_link = v.into();
        self
    }

    /// Sets the value of [dataset_reference][crate::model::Dataset::dataset_reference].
    pub fn set_dataset_reference<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DatasetReference>,
    {
        self.dataset_reference = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dataset_reference][crate::model::Dataset::dataset_reference].
    pub fn set_or_clear_dataset_reference<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DatasetReference>,
    {
        self.dataset_reference = v.map(|x| x.into());
        self
    }

    /// Sets the value of [friendly_name][crate::model::Dataset::friendly_name].
    pub fn set_friendly_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.friendly_name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [friendly_name][crate::model::Dataset::friendly_name].
    pub fn set_or_clear_friendly_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.friendly_name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::Dataset::description].
    pub fn set_description<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.description = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [description][crate::model::Dataset::description].
    pub fn set_or_clear_description<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.description = v.map(|x| x.into());
        self
    }

    /// Sets the value of [default_table_expiration_ms][crate::model::Dataset::default_table_expiration_ms].
    pub fn set_default_table_expiration_ms<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.default_table_expiration_ms = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [default_table_expiration_ms][crate::model::Dataset::default_table_expiration_ms].
    pub fn set_or_clear_default_table_expiration_ms<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.default_table_expiration_ms = v.map(|x| x.into());
        self
    }

    /// Sets the value of [default_partition_expiration_ms][crate::model::Dataset::default_partition_expiration_ms].
    pub fn set_default_partition_expiration_ms<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.default_partition_expiration_ms = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [default_partition_expiration_ms][crate::model::Dataset::default_partition_expiration_ms].
    pub fn set_or_clear_default_partition_expiration_ms<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.default_partition_expiration_ms = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Dataset::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [access][crate::model::Dataset::access].
    pub fn set_access<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Access>,
    {
        use std::iter::Iterator;
        self.access = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [creation_time][crate::model::Dataset::creation_time].
    pub fn set_creation_time<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.creation_time = v.into();
        self
    }

    /// Sets the value of [last_modified_time][crate::model::Dataset::last_modified_time].
    pub fn set_last_modified_time<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.last_modified_time = v.into();
        self
    }

    /// Sets the value of [location][crate::model::Dataset::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [default_encryption_configuration][crate::model::Dataset::default_encryption_configuration].
    pub fn set_default_encryption_configuration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionConfiguration>,
    {
        self.default_encryption_configuration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [default_encryption_configuration][crate::model::Dataset::default_encryption_configuration].
    pub fn set_or_clear_default_encryption_configuration<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionConfiguration>,
    {
        self.default_encryption_configuration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Dataset::satisfies_pzs].
    pub fn set_satisfies_pzs<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.satisfies_pzs = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [satisfies_pzs][crate::model::Dataset::satisfies_pzs].
    pub fn set_or_clear_satisfies_pzs<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.satisfies_pzs = v.map(|x| x.into());
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::Dataset::satisfies_pzi].
    pub fn set_satisfies_pzi<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.satisfies_pzi = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [satisfies_pzi][crate::model::Dataset::satisfies_pzi].
    pub fn set_or_clear_satisfies_pzi<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.satisfies_pzi = v.map(|x| x.into());
        self
    }

    /// Sets the value of [r#type][crate::model::Dataset::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [linked_dataset_source][crate::model::Dataset::linked_dataset_source].
    pub fn set_linked_dataset_source<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LinkedDatasetSource>,
    {
        self.linked_dataset_source = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [linked_dataset_source][crate::model::Dataset::linked_dataset_source].
    pub fn set_or_clear_linked_dataset_source<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LinkedDatasetSource>,
    {
        self.linked_dataset_source = v.map(|x| x.into());
        self
    }

    /// Sets the value of [linked_dataset_metadata][crate::model::Dataset::linked_dataset_metadata].
    pub fn set_linked_dataset_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LinkedDatasetMetadata>,
    {
        self.linked_dataset_metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [linked_dataset_metadata][crate::model::Dataset::linked_dataset_metadata].
    pub fn set_or_clear_linked_dataset_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LinkedDatasetMetadata>,
    {
        self.linked_dataset_metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [external_dataset_reference][crate::model::Dataset::external_dataset_reference].
    pub fn set_external_dataset_reference<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ExternalDatasetReference>,
    {
        self.external_dataset_reference = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [external_dataset_reference][crate::model::Dataset::external_dataset_reference].
    pub fn set_or_clear_external_dataset_reference<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ExternalDatasetReference>,
    {
        self.external_dataset_reference = v.map(|x| x.into());
        self
    }

    /// Sets the value of [external_catalog_dataset_options][crate::model::Dataset::external_catalog_dataset_options].
    pub fn set_external_catalog_dataset_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ExternalCatalogDatasetOptions>,
    {
        self.external_catalog_dataset_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [external_catalog_dataset_options][crate::model::Dataset::external_catalog_dataset_options].
    pub fn set_or_clear_external_catalog_dataset_options<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::ExternalCatalogDatasetOptions>,
    {
        self.external_catalog_dataset_options = v.map(|x| x.into());
        self
    }

    /// Sets the value of [is_case_insensitive][crate::model::Dataset::is_case_insensitive].
    pub fn set_is_case_insensitive<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.is_case_insensitive = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [is_case_insensitive][crate::model::Dataset::is_case_insensitive].
    pub fn set_or_clear_is_case_insensitive<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.is_case_insensitive = v.map(|x| x.into());
        self
    }

    /// Sets the value of [default_collation][crate::model::Dataset::default_collation].
    pub fn set_default_collation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.default_collation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [default_collation][crate::model::Dataset::default_collation].
    pub fn set_or_clear_default_collation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.default_collation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [default_rounding_mode][crate::model::Dataset::default_rounding_mode].
    pub fn set_default_rounding_mode<
        T: std::convert::Into<crate::model::table_field_schema::RoundingMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.default_rounding_mode = v.into();
        self
    }

    /// Sets the value of [max_time_travel_hours][crate::model::Dataset::max_time_travel_hours].
    pub fn set_max_time_travel_hours<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.max_time_travel_hours = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [max_time_travel_hours][crate::model::Dataset::max_time_travel_hours].
    pub fn set_or_clear_max_time_travel_hours<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.max_time_travel_hours = v.map(|x| x.into());
        self
    }

    /// Sets the value of [tags][crate::model::Dataset::tags].
    #[deprecated]
    pub fn set_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::GcpTag>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [storage_billing_model][crate::model::Dataset::storage_billing_model].
    pub fn set_storage_billing_model<
        T: std::convert::Into<crate::model::dataset::StorageBillingModel>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.storage_billing_model = v.into();
        self
    }

    /// Sets the value of [restrictions][crate::model::Dataset::restrictions].
    pub fn set_restrictions<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RestrictionConfig>,
    {
        self.restrictions = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [restrictions][crate::model::Dataset::restrictions].
    pub fn set_or_clear_restrictions<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RestrictionConfig>,
    {
        self.restrictions = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resource_tags][crate::model::Dataset::resource_tags].
    pub fn set_resource_tags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_tags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Dataset {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.Dataset"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Dataset {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __etag,
            __id,
            __self_link,
            __dataset_reference,
            __friendly_name,
            __description,
            __default_table_expiration_ms,
            __default_partition_expiration_ms,
            __labels,
            __access,
            __creation_time,
            __last_modified_time,
            __location,
            __default_encryption_configuration,
            __satisfies_pzs,
            __satisfies_pzi,
            __type,
            __linked_dataset_source,
            __linked_dataset_metadata,
            __external_dataset_reference,
            __external_catalog_dataset_options,
            __is_case_insensitive,
            __default_collation,
            __default_rounding_mode,
            __max_time_travel_hours,
            __tags,
            __storage_billing_model,
            __restrictions,
            __resource_tags,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Dataset")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "etag" => Ok(__FieldTag::__etag),
                            "id" => Ok(__FieldTag::__id),
                            "selfLink" => Ok(__FieldTag::__self_link),
                            "self_link" => Ok(__FieldTag::__self_link),
                            "datasetReference" => Ok(__FieldTag::__dataset_reference),
                            "dataset_reference" => Ok(__FieldTag::__dataset_reference),
                            "friendlyName" => Ok(__FieldTag::__friendly_name),
                            "friendly_name" => Ok(__FieldTag::__friendly_name),
                            "description" => Ok(__FieldTag::__description),
                            "defaultTableExpirationMs" => {
                                Ok(__FieldTag::__default_table_expiration_ms)
                            }
                            "default_table_expiration_ms" => {
                                Ok(__FieldTag::__default_table_expiration_ms)
                            }
                            "defaultPartitionExpirationMs" => {
                                Ok(__FieldTag::__default_partition_expiration_ms)
                            }
                            "default_partition_expiration_ms" => {
                                Ok(__FieldTag::__default_partition_expiration_ms)
                            }
                            "labels" => Ok(__FieldTag::__labels),
                            "access" => Ok(__FieldTag::__access),
                            "creationTime" => Ok(__FieldTag::__creation_time),
                            "creation_time" => Ok(__FieldTag::__creation_time),
                            "lastModifiedTime" => Ok(__FieldTag::__last_modified_time),
                            "last_modified_time" => Ok(__FieldTag::__last_modified_time),
                            "location" => Ok(__FieldTag::__location),
                            "defaultEncryptionConfiguration" => {
                                Ok(__FieldTag::__default_encryption_configuration)
                            }
                            "default_encryption_configuration" => {
                                Ok(__FieldTag::__default_encryption_configuration)
                            }
                            "satisfiesPzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfies_pzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfiesPzi" => Ok(__FieldTag::__satisfies_pzi),
                            "satisfies_pzi" => Ok(__FieldTag::__satisfies_pzi),
                            "type" => Ok(__FieldTag::__type),
                            "linkedDatasetSource" => Ok(__FieldTag::__linked_dataset_source),
                            "linked_dataset_source" => Ok(__FieldTag::__linked_dataset_source),
                            "linkedDatasetMetadata" => Ok(__FieldTag::__linked_dataset_metadata),
                            "linked_dataset_metadata" => Ok(__FieldTag::__linked_dataset_metadata),
                            "externalDatasetReference" => {
                                Ok(__FieldTag::__external_dataset_reference)
                            }
                            "external_dataset_reference" => {
                                Ok(__FieldTag::__external_dataset_reference)
                            }
                            "externalCatalogDatasetOptions" => {
                                Ok(__FieldTag::__external_catalog_dataset_options)
                            }
                            "external_catalog_dataset_options" => {
                                Ok(__FieldTag::__external_catalog_dataset_options)
                            }
                            "isCaseInsensitive" => Ok(__FieldTag::__is_case_insensitive),
                            "is_case_insensitive" => Ok(__FieldTag::__is_case_insensitive),
                            "defaultCollation" => Ok(__FieldTag::__default_collation),
                            "default_collation" => Ok(__FieldTag::__default_collation),
                            "defaultRoundingMode" => Ok(__FieldTag::__default_rounding_mode),
                            "default_rounding_mode" => Ok(__FieldTag::__default_rounding_mode),
                            "maxTimeTravelHours" => Ok(__FieldTag::__max_time_travel_hours),
                            "max_time_travel_hours" => Ok(__FieldTag::__max_time_travel_hours),
                            "tags" => Ok(__FieldTag::__tags),
                            "storageBillingModel" => Ok(__FieldTag::__storage_billing_model),
                            "storage_billing_model" => Ok(__FieldTag::__storage_billing_model),
                            "restrictions" => Ok(__FieldTag::__restrictions),
                            "resourceTags" => Ok(__FieldTag::__resource_tags),
                            "resource_tags" => Ok(__FieldTag::__resource_tags),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Dataset;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Dataset")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__self_link => {
                            if !fields.insert(__FieldTag::__self_link) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for self_link",
                                ));
                            }
                            result.self_link = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_reference => {
                            if !fields.insert(__FieldTag::__dataset_reference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_reference",
                                ));
                            }
                            result.dataset_reference = map
                                .next_value::<std::option::Option<crate::model::DatasetReference>>(
                                )?;
                        }
                        __FieldTag::__friendly_name => {
                            if !fields.insert(__FieldTag::__friendly_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for friendly_name",
                                ));
                            }
                            result.friendly_name =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::__default_table_expiration_ms => {
                            if !fields.insert(__FieldTag::__default_table_expiration_ms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_table_expiration_ms",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.default_table_expiration_ms = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__default_partition_expiration_ms => {
                            if !fields.insert(__FieldTag::__default_partition_expiration_ms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_partition_expiration_ms",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.default_partition_expiration_ms = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__access => {
                            if !fields.insert(__FieldTag::__access) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for access",
                                ));
                            }
                            result.access = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Access>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__creation_time => {
                            if !fields.insert(__FieldTag::__creation_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for creation_time",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.creation_time =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__last_modified_time => {
                            if !fields.insert(__FieldTag::__last_modified_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_modified_time",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.last_modified_time =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__default_encryption_configuration => {
                            if !fields.insert(__FieldTag::__default_encryption_configuration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_encryption_configuration",
                                ));
                            }
                            result.default_encryption_configuration = map.next_value::<std::option::Option<crate::model::EncryptionConfiguration>>()?
                                ;
                        }
                        __FieldTag::__satisfies_pzs => {
                            if !fields.insert(__FieldTag::__satisfies_pzs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzs",
                                ));
                            }
                            result.satisfies_pzs =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__satisfies_pzi => {
                            if !fields.insert(__FieldTag::__satisfies_pzi) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzi",
                                ));
                            }
                            result.satisfies_pzi =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__linked_dataset_source => {
                            if !fields.insert(__FieldTag::__linked_dataset_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for linked_dataset_source",
                                ));
                            }
                            result.linked_dataset_source = map.next_value::<std::option::Option<crate::model::LinkedDatasetSource>>()?
                                ;
                        }
                        __FieldTag::__linked_dataset_metadata => {
                            if !fields.insert(__FieldTag::__linked_dataset_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for linked_dataset_metadata",
                                ));
                            }
                            result.linked_dataset_metadata = map.next_value::<std::option::Option<crate::model::LinkedDatasetMetadata>>()?
                                ;
                        }
                        __FieldTag::__external_dataset_reference => {
                            if !fields.insert(__FieldTag::__external_dataset_reference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_dataset_reference",
                                ));
                            }
                            result.external_dataset_reference = map.next_value::<std::option::Option<crate::model::ExternalDatasetReference>>()?
                                ;
                        }
                        __FieldTag::__external_catalog_dataset_options => {
                            if !fields.insert(__FieldTag::__external_catalog_dataset_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_catalog_dataset_options",
                                ));
                            }
                            result.external_catalog_dataset_options =
                                map.next_value::<std::option::Option<
                                    crate::model::ExternalCatalogDatasetOptions,
                                >>()?;
                        }
                        __FieldTag::__is_case_insensitive => {
                            if !fields.insert(__FieldTag::__is_case_insensitive) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_case_insensitive",
                                ));
                            }
                            result.is_case_insensitive =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__default_collation => {
                            if !fields.insert(__FieldTag::__default_collation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_collation",
                                ));
                            }
                            result.default_collation =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::__default_rounding_mode => {
                            if !fields.insert(__FieldTag::__default_rounding_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_rounding_mode",
                                ));
                            }
                            result.default_rounding_mode =
                                map.next_value::<std::option::Option<
                                    crate::model::table_field_schema::RoundingMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__max_time_travel_hours => {
                            if !fields.insert(__FieldTag::__max_time_travel_hours) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_time_travel_hours",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_time_travel_hours = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__tags => {
                            if !fields.insert(__FieldTag::__tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tags",
                                ));
                            }
                            result.tags = map.next_value::<std::option::Option<std::vec::Vec<crate::model::GcpTag>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__storage_billing_model => {
                            if !fields.insert(__FieldTag::__storage_billing_model) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_billing_model",
                                ));
                            }
                            result.storage_billing_model = map.next_value::<std::option::Option<crate::model::dataset::StorageBillingModel>>()?.unwrap_or_default();
                        }
                        __FieldTag::__restrictions => {
                            if !fields.insert(__FieldTag::__restrictions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for restrictions",
                                ));
                            }
                            result.restrictions = map
                                .next_value::<std::option::Option<crate::model::RestrictionConfig>>(
                                )?;
                        }
                        __FieldTag::__resource_tags => {
                            if !fields.insert(__FieldTag::__resource_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_tags",
                                ));
                            }
                            result.resource_tags = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Dataset {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.self_link.is_empty() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.dataset_reference.is_some() {
            state.serialize_entry("datasetReference", &self.dataset_reference)?;
        }
        if self.friendly_name.is_some() {
            state.serialize_entry("friendlyName", &self.friendly_name)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.default_table_expiration_ms.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "defaultTableExpirationMs",
                &__With(&self.default_table_expiration_ms),
            )?;
        }
        if self.default_partition_expiration_ms.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "defaultPartitionExpirationMs",
                &__With(&self.default_partition_expiration_ms),
            )?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.access.is_empty() {
            state.serialize_entry("access", &self.access)?;
        }
        if !wkt::internal::is_default(&self.creation_time) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("creationTime", &__With(&self.creation_time))?;
        }
        if !wkt::internal::is_default(&self.last_modified_time) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("lastModifiedTime", &__With(&self.last_modified_time))?;
        }
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if self.default_encryption_configuration.is_some() {
            state.serialize_entry(
                "defaultEncryptionConfiguration",
                &self.default_encryption_configuration,
            )?;
        }
        if self.satisfies_pzs.is_some() {
            state.serialize_entry("satisfiesPzs", &self.satisfies_pzs)?;
        }
        if self.satisfies_pzi.is_some() {
            state.serialize_entry("satisfiesPzi", &self.satisfies_pzi)?;
        }
        if !self.r#type.is_empty() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if self.linked_dataset_source.is_some() {
            state.serialize_entry("linkedDatasetSource", &self.linked_dataset_source)?;
        }
        if self.linked_dataset_metadata.is_some() {
            state.serialize_entry("linkedDatasetMetadata", &self.linked_dataset_metadata)?;
        }
        if self.external_dataset_reference.is_some() {
            state.serialize_entry("externalDatasetReference", &self.external_dataset_reference)?;
        }
        if self.external_catalog_dataset_options.is_some() {
            state.serialize_entry(
                "externalCatalogDatasetOptions",
                &self.external_catalog_dataset_options,
            )?;
        }
        if self.is_case_insensitive.is_some() {
            state.serialize_entry("isCaseInsensitive", &self.is_case_insensitive)?;
        }
        if self.default_collation.is_some() {
            state.serialize_entry("defaultCollation", &self.default_collation)?;
        }
        if !wkt::internal::is_default(&self.default_rounding_mode) {
            state.serialize_entry("defaultRoundingMode", &self.default_rounding_mode)?;
        }
        if self.max_time_travel_hours.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("maxTimeTravelHours", &__With(&self.max_time_travel_hours))?;
        }
        if !self.tags.is_empty() {
            state.serialize_entry("tags", &self.tags)?;
        }
        if !wkt::internal::is_default(&self.storage_billing_model) {
            state.serialize_entry("storageBillingModel", &self.storage_billing_model)?;
        }
        if self.restrictions.is_some() {
            state.serialize_entry("restrictions", &self.restrictions)?;
        }
        if !self.resource_tags.is_empty() {
            state.serialize_entry("resourceTags", &self.resource_tags)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Dataset].
pub mod dataset {
    #[allow(unused_imports)]
    use super::*;

    /// Indicates the billing model that will be applied to the dataset.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum StorageBillingModel {
        /// Value not set.
        Unspecified,
        /// Billing for logical bytes.
        Logical,
        /// Billing for physical bytes.
        Physical,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [StorageBillingModel::value] or
        /// [StorageBillingModel::name].
        UnknownValue(storage_billing_model::UnknownValue),
    }

    #[doc(hidden)]
    pub mod storage_billing_model {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl StorageBillingModel {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Logical => std::option::Option::Some(1),
                Self::Physical => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STORAGE_BILLING_MODEL_UNSPECIFIED"),
                Self::Logical => std::option::Option::Some("LOGICAL"),
                Self::Physical => std::option::Option::Some("PHYSICAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for StorageBillingModel {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for StorageBillingModel {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for StorageBillingModel {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Logical,
                2 => Self::Physical,
                _ => Self::UnknownValue(storage_billing_model::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for StorageBillingModel {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STORAGE_BILLING_MODEL_UNSPECIFIED" => Self::Unspecified,
                "LOGICAL" => Self::Logical,
                "PHYSICAL" => Self::Physical,
                _ => Self::UnknownValue(storage_billing_model::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for StorageBillingModel {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Logical => serializer.serialize_i32(1),
                Self::Physical => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for StorageBillingModel {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<StorageBillingModel>::new(
                ".google.cloud.bigquery.v2.Dataset.StorageBillingModel",
            ))
        }
    }
}

/// A global tag managed by Resource Manager.
/// <https://cloud.google.com/iam/docs/tags-access-control#definitions>
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GcpTag {
    /// Required. The namespaced friendly name of the tag key, e.g.
    /// "12345/environment" where 12345 is org id.
    pub tag_key: std::string::String,

    /// Required. The friendly short name of the tag value, e.g. "production".
    pub tag_value: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcpTag {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tag_key][crate::model::GcpTag::tag_key].
    pub fn set_tag_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tag_key = v.into();
        self
    }

    /// Sets the value of [tag_value][crate::model::GcpTag::tag_value].
    pub fn set_tag_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tag_value = v.into();
        self
    }
}

impl wkt::message::Message for GcpTag {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.GcpTag"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GcpTag {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __tag_key,
            __tag_value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GcpTag")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "tagKey" => Ok(__FieldTag::__tag_key),
                            "tag_key" => Ok(__FieldTag::__tag_key),
                            "tagValue" => Ok(__FieldTag::__tag_value),
                            "tag_value" => Ok(__FieldTag::__tag_value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GcpTag;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GcpTag")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__tag_key => {
                            if !fields.insert(__FieldTag::__tag_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tag_key",
                                ));
                            }
                            result.tag_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tag_value => {
                            if !fields.insert(__FieldTag::__tag_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tag_value",
                                ));
                            }
                            result.tag_value = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GcpTag {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.tag_key.is_empty() {
            state.serialize_entry("tagKey", &self.tag_key)?;
        }
        if !self.tag_value.is_empty() {
            state.serialize_entry("tagValue", &self.tag_value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A dataset source type which refers to another BigQuery dataset.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LinkedDatasetSource {
    /// The source dataset reference contains project numbers and not project ids.
    pub source_dataset: std::option::Option<crate::model::DatasetReference>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LinkedDatasetSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_dataset][crate::model::LinkedDatasetSource::source_dataset].
    pub fn set_source_dataset<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DatasetReference>,
    {
        self.source_dataset = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_dataset][crate::model::LinkedDatasetSource::source_dataset].
    pub fn set_or_clear_source_dataset<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DatasetReference>,
    {
        self.source_dataset = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for LinkedDatasetSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.LinkedDatasetSource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LinkedDatasetSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source_dataset,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LinkedDatasetSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sourceDataset" => Ok(__FieldTag::__source_dataset),
                            "source_dataset" => Ok(__FieldTag::__source_dataset),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LinkedDatasetSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LinkedDatasetSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source_dataset => {
                            if !fields.insert(__FieldTag::__source_dataset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_dataset",
                                ));
                            }
                            result.source_dataset = map
                                .next_value::<std::option::Option<crate::model::DatasetReference>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LinkedDatasetSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.source_dataset.is_some() {
            state.serialize_entry("sourceDataset", &self.source_dataset)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata about the Linked Dataset.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LinkedDatasetMetadata {
    /// Output only. Specifies whether Linked Dataset is currently in a linked
    /// state or not.
    pub link_state: crate::model::linked_dataset_metadata::LinkState,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LinkedDatasetMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [link_state][crate::model::LinkedDatasetMetadata::link_state].
    pub fn set_link_state<
        T: std::convert::Into<crate::model::linked_dataset_metadata::LinkState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.link_state = v.into();
        self
    }
}

impl wkt::message::Message for LinkedDatasetMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.LinkedDatasetMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LinkedDatasetMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __link_state,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LinkedDatasetMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "linkState" => Ok(__FieldTag::__link_state),
                            "link_state" => Ok(__FieldTag::__link_state),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LinkedDatasetMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LinkedDatasetMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__link_state => {
                            if !fields.insert(__FieldTag::__link_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for link_state",
                                ));
                            }
                            result.link_state = map
                                .next_value::<std::option::Option<
                                    crate::model::linked_dataset_metadata::LinkState,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LinkedDatasetMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.link_state) {
            state.serialize_entry("linkState", &self.link_state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [LinkedDatasetMetadata].
pub mod linked_dataset_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Specifies whether Linked Dataset is currently in a linked state or not.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LinkState {
        /// The default value.
        /// Default to the LINKED state.
        Unspecified,
        /// Normal Linked Dataset state. Data is queryable via the Linked Dataset.
        Linked,
        /// Data publisher or owner has unlinked this Linked Dataset. It means you
        /// can no longer query or see the data in the Linked Dataset.
        Unlinked,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [LinkState::value] or
        /// [LinkState::name].
        UnknownValue(link_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod link_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl LinkState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Linked => std::option::Option::Some(1),
                Self::Unlinked => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("LINK_STATE_UNSPECIFIED"),
                Self::Linked => std::option::Option::Some("LINKED"),
                Self::Unlinked => std::option::Option::Some("UNLINKED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for LinkState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for LinkState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for LinkState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Linked,
                2 => Self::Unlinked,
                _ => Self::UnknownValue(link_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for LinkState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LINK_STATE_UNSPECIFIED" => Self::Unspecified,
                "LINKED" => Self::Linked,
                "UNLINKED" => Self::Unlinked,
                _ => Self::UnknownValue(link_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for LinkState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Linked => serializer.serialize_i32(1),
                Self::Unlinked => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for LinkState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<LinkState>::new(
                ".google.cloud.bigquery.v2.LinkedDatasetMetadata.LinkState",
            ))
        }
    }
}

/// Request format for getting information about a dataset.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetDatasetRequest {
    /// Required. Project ID of the requested dataset
    pub project_id: std::string::String,

    /// Required. Dataset ID of the requested dataset
    pub dataset_id: std::string::String,

    /// Optional. Specifies the view that determines which dataset information is
    /// returned. By default, metadata and ACL information are returned.
    pub dataset_view: crate::model::get_dataset_request::DatasetView,

    /// Optional. The version of the access policy schema to fetch.
    /// Valid values are 0, 1, and 3. Requests specifying an invalid value will be
    /// rejected.
    ///
    /// Requests for conditional access policy binding in datasets must specify
    /// version 3. Dataset with no conditional role bindings in access policy may
    /// specify any valid value or leave the field unset.
    ///
    /// This field will be mapped to [IAM Policy version]
    /// (<https://cloud.google.com/iam/docs/policies#versions>) and will be used to
    /// fetch policy from IAM.
    ///
    /// If unset or if 0 or 1 value is used for dataset with conditional bindings,
    /// access entry with condition will have role string appended by
    /// 'withcond' string followed by a hash value. For example :
    /// {
    /// "access": [
    /// {
    /// "role":
    /// "roles/bigquery.dataViewer_with_conditionalbinding_7a34awqsda",
    /// "userByEmail": "user@example.com",
    /// }
    /// ]
    /// }
    /// Please refer <https://cloud.google.com/iam/docs/troubleshooting-withcond> for
    /// more details.
    pub access_policy_version: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDatasetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::GetDatasetRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::GetDatasetRequest::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [dataset_view][crate::model::GetDatasetRequest::dataset_view].
    pub fn set_dataset_view<
        T: std::convert::Into<crate::model::get_dataset_request::DatasetView>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dataset_view = v.into();
        self
    }

    /// Sets the value of [access_policy_version][crate::model::GetDatasetRequest::access_policy_version].
    pub fn set_access_policy_version<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.access_policy_version = v.into();
        self
    }
}

impl wkt::message::Message for GetDatasetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.GetDatasetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetDatasetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __dataset_view,
            __access_policy_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetDatasetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "datasetView" => Ok(__FieldTag::__dataset_view),
                            "dataset_view" => Ok(__FieldTag::__dataset_view),
                            "accessPolicyVersion" => Ok(__FieldTag::__access_policy_version),
                            "access_policy_version" => Ok(__FieldTag::__access_policy_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetDatasetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetDatasetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_view => {
                            if !fields.insert(__FieldTag::__dataset_view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_view",
                                ));
                            }
                            result.dataset_view =
                                map.next_value::<std::option::Option<
                                    crate::model::get_dataset_request::DatasetView,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__access_policy_version => {
                            if !fields.insert(__FieldTag::__access_policy_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for access_policy_version",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.access_policy_version =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetDatasetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.dataset_id.is_empty() {
            state.serialize_entry("datasetId", &self.dataset_id)?;
        }
        if !wkt::internal::is_default(&self.dataset_view) {
            state.serialize_entry("datasetView", &self.dataset_view)?;
        }
        if !wkt::internal::is_default(&self.access_policy_version) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("accessPolicyVersion", &__With(&self.access_policy_version))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [GetDatasetRequest].
pub mod get_dataset_request {
    #[allow(unused_imports)]
    use super::*;

    /// DatasetView specifies which dataset information is returned.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DatasetView {
        /// The default value.
        /// Default to the FULL view.
        Unspecified,
        /// View metadata information for the dataset, such as friendlyName,
        /// description, labels, etc.
        Metadata,
        /// View ACL information for the dataset, which defines dataset access
        /// for one or more entities.
        Acl,
        /// View both dataset metadata and ACL information.
        Full,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DatasetView::value] or
        /// [DatasetView::name].
        UnknownValue(dataset_view::UnknownValue),
    }

    #[doc(hidden)]
    pub mod dataset_view {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DatasetView {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Metadata => std::option::Option::Some(1),
                Self::Acl => std::option::Option::Some(2),
                Self::Full => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DATASET_VIEW_UNSPECIFIED"),
                Self::Metadata => std::option::Option::Some("METADATA"),
                Self::Acl => std::option::Option::Some("ACL"),
                Self::Full => std::option::Option::Some("FULL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DatasetView {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DatasetView {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DatasetView {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Metadata,
                2 => Self::Acl,
                3 => Self::Full,
                _ => Self::UnknownValue(dataset_view::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DatasetView {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DATASET_VIEW_UNSPECIFIED" => Self::Unspecified,
                "METADATA" => Self::Metadata,
                "ACL" => Self::Acl,
                "FULL" => Self::Full,
                _ => Self::UnknownValue(dataset_view::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DatasetView {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Metadata => serializer.serialize_i32(1),
                Self::Acl => serializer.serialize_i32(2),
                Self::Full => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DatasetView {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DatasetView>::new(
                ".google.cloud.bigquery.v2.GetDatasetRequest.DatasetView",
            ))
        }
    }
}

/// Request format for inserting a dataset.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InsertDatasetRequest {
    /// Required. Project ID of the new dataset
    pub project_id: std::string::String,

    /// Required. Datasets resource to use for the new dataset
    pub dataset: std::option::Option<crate::model::Dataset>,

    /// Optional. The version of the provided access policy schema.
    /// Valid values are 0, 1, and 3. Requests specifying an invalid value will be
    /// rejected.
    ///
    /// This version refers to the schema version of the access policy and not the
    /// version of access policy. This field's value can be equal or more
    /// than the access policy schema provided in the request.
    /// For example,
    ///
    /// * Requests with conditional access policy binding in datasets must
    ///   specify
    ///   version 3.
    /// * But dataset with no conditional role bindings in access policy
    ///   may specify any valid value or leave the field unset.
    ///   If unset or if 0 or 1 value is used for dataset with conditional
    ///   bindings, request will be rejected.
    ///
    /// This field will be mapped to IAM Policy version
    /// (<https://cloud.google.com/iam/docs/policies#versions>) and will be used to
    /// set policy in IAM.
    pub access_policy_version: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InsertDatasetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::InsertDatasetRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset][crate::model::InsertDatasetRequest::dataset].
    pub fn set_dataset<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Dataset>,
    {
        self.dataset = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dataset][crate::model::InsertDatasetRequest::dataset].
    pub fn set_or_clear_dataset<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Dataset>,
    {
        self.dataset = v.map(|x| x.into());
        self
    }

    /// Sets the value of [access_policy_version][crate::model::InsertDatasetRequest::access_policy_version].
    pub fn set_access_policy_version<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.access_policy_version = v.into();
        self
    }
}

impl wkt::message::Message for InsertDatasetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.InsertDatasetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InsertDatasetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset,
            __access_policy_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InsertDatasetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "dataset" => Ok(__FieldTag::__dataset),
                            "accessPolicyVersion" => Ok(__FieldTag::__access_policy_version),
                            "access_policy_version" => Ok(__FieldTag::__access_policy_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InsertDatasetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InsertDatasetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset => {
                            if !fields.insert(__FieldTag::__dataset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset",
                                ));
                            }
                            result.dataset =
                                map.next_value::<std::option::Option<crate::model::Dataset>>()?;
                        }
                        __FieldTag::__access_policy_version => {
                            if !fields.insert(__FieldTag::__access_policy_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for access_policy_version",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.access_policy_version =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InsertDatasetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if self.dataset.is_some() {
            state.serialize_entry("dataset", &self.dataset)?;
        }
        if !wkt::internal::is_default(&self.access_policy_version) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("accessPolicyVersion", &__With(&self.access_policy_version))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for updating or patching a dataset.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateOrPatchDatasetRequest {
    /// Required. Project ID of the dataset being updated
    pub project_id: std::string::String,

    /// Required. Dataset ID of the dataset being updated
    pub dataset_id: std::string::String,

    /// Required. Datasets resource which will replace or patch the specified
    /// dataset.
    pub dataset: std::option::Option<crate::model::Dataset>,

    /// Optional. Specifies the fields of dataset that update/patch operation is
    /// targeting By default, both metadata and ACL fields are updated.
    pub update_mode: crate::model::update_or_patch_dataset_request::UpdateMode,

    /// Optional. The version of the provided access policy schema.
    /// Valid values are 0, 1, and 3. Requests specifying an invalid value will be
    /// rejected.
    ///
    /// This version refers to the schema version of the access policy and not the
    /// version of access policy. This field's value can be equal or more
    /// than the access policy schema provided in the request.
    /// For example,
    ///
    /// * Operations updating conditional access policy binding in datasets must
    ///   specify
    ///   version 3. Some of the operations are :
    ///   - Adding a new access policy entry with condition.
    ///   - Removing an access policy entry with condition.
    ///   - Updating an access policy entry with condition.
    /// * But dataset with no conditional role bindings in access policy
    ///   may specify any valid value or leave the field unset.
    ///   If unset or if 0 or 1 value is used for dataset with conditional
    ///   bindings, request will be rejected.
    ///
    /// This field will be mapped to IAM Policy version
    /// (<https://cloud.google.com/iam/docs/policies#versions>) and will be used to
    /// set policy in IAM.
    pub access_policy_version: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateOrPatchDatasetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::UpdateOrPatchDatasetRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::UpdateOrPatchDatasetRequest::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [dataset][crate::model::UpdateOrPatchDatasetRequest::dataset].
    pub fn set_dataset<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Dataset>,
    {
        self.dataset = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dataset][crate::model::UpdateOrPatchDatasetRequest::dataset].
    pub fn set_or_clear_dataset<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Dataset>,
    {
        self.dataset = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mode][crate::model::UpdateOrPatchDatasetRequest::update_mode].
    pub fn set_update_mode<
        T: std::convert::Into<crate::model::update_or_patch_dataset_request::UpdateMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.update_mode = v.into();
        self
    }

    /// Sets the value of [access_policy_version][crate::model::UpdateOrPatchDatasetRequest::access_policy_version].
    pub fn set_access_policy_version<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.access_policy_version = v.into();
        self
    }
}

impl wkt::message::Message for UpdateOrPatchDatasetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.UpdateOrPatchDatasetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateOrPatchDatasetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __dataset,
            __update_mode,
            __access_policy_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateOrPatchDatasetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "dataset" => Ok(__FieldTag::__dataset),
                            "updateMode" => Ok(__FieldTag::__update_mode),
                            "update_mode" => Ok(__FieldTag::__update_mode),
                            "accessPolicyVersion" => Ok(__FieldTag::__access_policy_version),
                            "access_policy_version" => Ok(__FieldTag::__access_policy_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateOrPatchDatasetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateOrPatchDatasetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset => {
                            if !fields.insert(__FieldTag::__dataset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset",
                                ));
                            }
                            result.dataset =
                                map.next_value::<std::option::Option<crate::model::Dataset>>()?;
                        }
                        __FieldTag::__update_mode => {
                            if !fields.insert(__FieldTag::__update_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mode",
                                ));
                            }
                            result.update_mode = map
                                .next_value::<std::option::Option<
                                    crate::model::update_or_patch_dataset_request::UpdateMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__access_policy_version => {
                            if !fields.insert(__FieldTag::__access_policy_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for access_policy_version",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.access_policy_version =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateOrPatchDatasetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.dataset_id.is_empty() {
            state.serialize_entry("datasetId", &self.dataset_id)?;
        }
        if self.dataset.is_some() {
            state.serialize_entry("dataset", &self.dataset)?;
        }
        if !wkt::internal::is_default(&self.update_mode) {
            state.serialize_entry("updateMode", &self.update_mode)?;
        }
        if !wkt::internal::is_default(&self.access_policy_version) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("accessPolicyVersion", &__With(&self.access_policy_version))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [UpdateOrPatchDatasetRequest].
pub mod update_or_patch_dataset_request {
    #[allow(unused_imports)]
    use super::*;

    /// UpdateMode specifies which dataset fields is updated.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum UpdateMode {
        /// The default value.
        /// Default to the UPDATE_FULL.
        Unspecified,
        /// Includes metadata information for the dataset, such as friendlyName,
        /// description, labels, etc.
        UpdateMetadata,
        /// Includes ACL information for the dataset, which defines dataset access
        /// for one or more entities.
        UpdateAcl,
        /// Includes both dataset metadata and ACL information.
        UpdateFull,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [UpdateMode::value] or
        /// [UpdateMode::name].
        UnknownValue(update_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod update_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl UpdateMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::UpdateMetadata => std::option::Option::Some(1),
                Self::UpdateAcl => std::option::Option::Some(2),
                Self::UpdateFull => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("UPDATE_MODE_UNSPECIFIED"),
                Self::UpdateMetadata => std::option::Option::Some("UPDATE_METADATA"),
                Self::UpdateAcl => std::option::Option::Some("UPDATE_ACL"),
                Self::UpdateFull => std::option::Option::Some("UPDATE_FULL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for UpdateMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for UpdateMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for UpdateMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::UpdateMetadata,
                2 => Self::UpdateAcl,
                3 => Self::UpdateFull,
                _ => Self::UnknownValue(update_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for UpdateMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UPDATE_MODE_UNSPECIFIED" => Self::Unspecified,
                "UPDATE_METADATA" => Self::UpdateMetadata,
                "UPDATE_ACL" => Self::UpdateAcl,
                "UPDATE_FULL" => Self::UpdateFull,
                _ => Self::UnknownValue(update_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for UpdateMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::UpdateMetadata => serializer.serialize_i32(1),
                Self::UpdateAcl => serializer.serialize_i32(2),
                Self::UpdateFull => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for UpdateMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<UpdateMode>::new(
                ".google.cloud.bigquery.v2.UpdateOrPatchDatasetRequest.UpdateMode",
            ))
        }
    }
}

/// Request format for deleting a dataset.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteDatasetRequest {
    /// Required. Project ID of the dataset being deleted
    pub project_id: std::string::String,

    /// Required. Dataset ID of dataset being deleted
    pub dataset_id: std::string::String,

    /// If True, delete all the tables in the dataset.
    /// If False and the dataset contains tables, the request will fail.
    /// Default is False
    pub delete_contents: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteDatasetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::DeleteDatasetRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::DeleteDatasetRequest::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [delete_contents][crate::model::DeleteDatasetRequest::delete_contents].
    pub fn set_delete_contents<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.delete_contents = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDatasetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.DeleteDatasetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteDatasetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __delete_contents,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteDatasetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "deleteContents" => Ok(__FieldTag::__delete_contents),
                            "delete_contents" => Ok(__FieldTag::__delete_contents),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteDatasetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteDatasetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__delete_contents => {
                            if !fields.insert(__FieldTag::__delete_contents) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delete_contents",
                                ));
                            }
                            result.delete_contents = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteDatasetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.dataset_id.is_empty() {
            state.serialize_entry("datasetId", &self.dataset_id)?;
        }
        if !wkt::internal::is_default(&self.delete_contents) {
            state.serialize_entry("deleteContents", &self.delete_contents)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDatasetsRequest {
    /// Required. Project ID of the datasets to be listed
    pub project_id: std::string::String,

    /// The maximum number of results to return in a single response page.
    /// Leverage the page tokens to iterate through the entire collection.
    pub max_results: std::option::Option<wkt::UInt32Value>,

    /// Page token, returned by a previous call, to request the next page of
    /// results
    pub page_token: std::string::String,

    /// Whether to list all datasets, including hidden ones
    pub all: bool,

    /// An expression for filtering the results of the request by label.
    /// The syntax is `labels.<name>[:<value>]`.
    /// Multiple filters can be AND-ed together by connecting with a space.
    /// Example: `labels.department:receiving labels.active`.
    /// See [Filtering datasets using
    /// labels](https://cloud.google.com/bigquery/docs/filtering-labels#filtering_datasets_using_labels)
    /// for details.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDatasetsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::ListDatasetsRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [max_results][crate::model::ListDatasetsRequest::max_results].
    pub fn set_max_results<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::UInt32Value>,
    {
        self.max_results = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [max_results][crate::model::ListDatasetsRequest::max_results].
    pub fn set_or_clear_max_results<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::UInt32Value>,
    {
        self.max_results = v.map(|x| x.into());
        self
    }

    /// Sets the value of [page_token][crate::model::ListDatasetsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [all][crate::model::ListDatasetsRequest::all].
    pub fn set_all<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.all = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDatasetsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListDatasetsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ListDatasetsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDatasetsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __max_results,
            __page_token,
            __all,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDatasetsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "maxResults" => Ok(__FieldTag::__max_results),
                            "max_results" => Ok(__FieldTag::__max_results),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "all" => Ok(__FieldTag::__all),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDatasetsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDatasetsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__max_results => {
                            if !fields.insert(__FieldTag::__max_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_results",
                                ));
                            }
                            struct __With(std::option::Option<wkt::UInt32Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_results = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__all => {
                            if !fields.insert(__FieldTag::__all) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for all",
                                ));
                            }
                            result.all = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDatasetsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if self.max_results.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::UInt32Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("maxResults", &__With(&self.max_results))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.all) {
            state.serialize_entry("all", &self.all)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A dataset resource with only a subset of fields, to be returned in a list of
/// datasets.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListFormatDataset {
    /// The resource type.
    /// This property always returns the value "bigquery#dataset"
    pub kind: std::string::String,

    /// The fully-qualified, unique, opaque ID of the dataset.
    pub id: std::string::String,

    /// The dataset reference.
    /// Use this property to access specific parts of the dataset's ID, such as
    /// project ID or dataset ID.
    pub dataset_reference: std::option::Option<crate::model::DatasetReference>,

    /// The labels associated with this dataset.
    /// You can use these to organize and group your datasets.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// An alternate name for the dataset.  The friendly name is purely
    /// decorative in nature.
    pub friendly_name: std::option::Option<wkt::StringValue>,

    /// The geographic location where the dataset resides.
    pub location: std::string::String,

    /// Output only. Reference to a read-only external dataset defined in data
    /// catalogs outside of BigQuery. Filled out when the dataset type is EXTERNAL.
    pub external_dataset_reference: std::option::Option<crate::model::ExternalDatasetReference>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListFormatDataset {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::ListFormatDataset::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [id][crate::model::ListFormatDataset::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [dataset_reference][crate::model::ListFormatDataset::dataset_reference].
    pub fn set_dataset_reference<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DatasetReference>,
    {
        self.dataset_reference = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dataset_reference][crate::model::ListFormatDataset::dataset_reference].
    pub fn set_or_clear_dataset_reference<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DatasetReference>,
    {
        self.dataset_reference = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::ListFormatDataset::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [friendly_name][crate::model::ListFormatDataset::friendly_name].
    pub fn set_friendly_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.friendly_name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [friendly_name][crate::model::ListFormatDataset::friendly_name].
    pub fn set_or_clear_friendly_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.friendly_name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [location][crate::model::ListFormatDataset::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [external_dataset_reference][crate::model::ListFormatDataset::external_dataset_reference].
    pub fn set_external_dataset_reference<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ExternalDatasetReference>,
    {
        self.external_dataset_reference = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [external_dataset_reference][crate::model::ListFormatDataset::external_dataset_reference].
    pub fn set_or_clear_external_dataset_reference<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ExternalDatasetReference>,
    {
        self.external_dataset_reference = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ListFormatDataset {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ListFormatDataset"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListFormatDataset {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __id,
            __dataset_reference,
            __labels,
            __friendly_name,
            __location,
            __external_dataset_reference,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListFormatDataset")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "id" => Ok(__FieldTag::__id),
                            "datasetReference" => Ok(__FieldTag::__dataset_reference),
                            "dataset_reference" => Ok(__FieldTag::__dataset_reference),
                            "labels" => Ok(__FieldTag::__labels),
                            "friendlyName" => Ok(__FieldTag::__friendly_name),
                            "friendly_name" => Ok(__FieldTag::__friendly_name),
                            "location" => Ok(__FieldTag::__location),
                            "externalDatasetReference" => {
                                Ok(__FieldTag::__external_dataset_reference)
                            }
                            "external_dataset_reference" => {
                                Ok(__FieldTag::__external_dataset_reference)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListFormatDataset;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListFormatDataset")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_reference => {
                            if !fields.insert(__FieldTag::__dataset_reference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_reference",
                                ));
                            }
                            result.dataset_reference = map
                                .next_value::<std::option::Option<crate::model::DatasetReference>>(
                                )?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__friendly_name => {
                            if !fields.insert(__FieldTag::__friendly_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for friendly_name",
                                ));
                            }
                            result.friendly_name =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__external_dataset_reference => {
                            if !fields.insert(__FieldTag::__external_dataset_reference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_dataset_reference",
                                ));
                            }
                            result.external_dataset_reference = map.next_value::<std::option::Option<crate::model::ExternalDatasetReference>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListFormatDataset {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if self.dataset_reference.is_some() {
            state.serialize_entry("datasetReference", &self.dataset_reference)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.friendly_name.is_some() {
            state.serialize_entry("friendlyName", &self.friendly_name)?;
        }
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if self.external_dataset_reference.is_some() {
            state.serialize_entry("externalDatasetReference", &self.external_dataset_reference)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response format for a page of results when listing datasets.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DatasetList {
    /// Output only. The resource type.
    /// This property always returns the value "bigquery#datasetList"
    pub kind: std::string::String,

    /// Output only. A hash value of the results page. You can use this property to
    /// determine if the page has changed since the last request.
    pub etag: std::string::String,

    /// A token that can be used to request the next results page. This property is
    /// omitted on the final results page.
    pub next_page_token: std::string::String,

    /// An array of the dataset resources in the project.
    /// Each resource contains basic information.
    /// For full information about a particular dataset resource, use the Datasets:
    /// get method. This property is omitted when there are no datasets in the
    /// project.
    pub datasets: std::vec::Vec<crate::model::ListFormatDataset>,

    /// A list of skipped locations that were unreachable. For more information
    /// about BigQuery locations, see:
    /// <https://cloud.google.com/bigquery/docs/locations>. Example: "europe-west5"
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatasetList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::DatasetList::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DatasetList::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [next_page_token][crate::model::DatasetList::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [datasets][crate::model::DatasetList::datasets].
    pub fn set_datasets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ListFormatDataset>,
    {
        use std::iter::Iterator;
        self.datasets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::DatasetList::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DatasetList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.DatasetList"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DatasetList {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __etag,
            __next_page_token,
            __datasets,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DatasetList")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "etag" => Ok(__FieldTag::__etag),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "datasets" => Ok(__FieldTag::__datasets),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DatasetList;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DatasetList")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__datasets => {
                            if !fields.insert(__FieldTag::__datasets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for datasets",
                                ));
                            }
                            result.datasets =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ListFormatDataset>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DatasetList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.datasets.is_empty() {
            state.serialize_entry("datasets", &self.datasets)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request format for undeleting a dataset.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UndeleteDatasetRequest {
    /// Required. Project ID of the dataset to be undeleted
    pub project_id: std::string::String,

    /// Required. Dataset ID of dataset being deleted
    pub dataset_id: std::string::String,

    /// Optional. The exact time when the dataset was deleted. If not specified,
    /// the most recently deleted version is undeleted. Undeleting a dataset
    /// using deletion time is not supported.
    pub deletion_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UndeleteDatasetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::UndeleteDatasetRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::UndeleteDatasetRequest::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [deletion_time][crate::model::UndeleteDatasetRequest::deletion_time].
    pub fn set_deletion_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.deletion_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deletion_time][crate::model::UndeleteDatasetRequest::deletion_time].
    pub fn set_or_clear_deletion_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.deletion_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UndeleteDatasetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.UndeleteDatasetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UndeleteDatasetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __deletion_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UndeleteDatasetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "deletionTime" => Ok(__FieldTag::__deletion_time),
                            "deletion_time" => Ok(__FieldTag::__deletion_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UndeleteDatasetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UndeleteDatasetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__deletion_time => {
                            if !fields.insert(__FieldTag::__deletion_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deletion_time",
                                ));
                            }
                            result.deletion_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UndeleteDatasetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.dataset_id.is_empty() {
            state.serialize_entry("datasetId", &self.dataset_id)?;
        }
        if self.deletion_time.is_some() {
            state.serialize_entry("deletionTime", &self.deletion_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Identifier for a dataset.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DatasetReference {
    /// Required. A unique ID for this dataset, without the project name. The ID
    /// must contain only letters (a-z, A-Z), numbers (0-9), or underscores (_).
    /// The maximum length is 1,024 characters.
    pub dataset_id: std::string::String,

    /// Optional. The ID of the project containing this dataset.
    pub project_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatasetReference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dataset_id][crate::model::DatasetReference::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::DatasetReference::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }
}

impl wkt::message::Message for DatasetReference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.DatasetReference"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DatasetReference {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dataset_id,
            __project_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DatasetReference")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DatasetReference;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DatasetReference")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DatasetReference {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.dataset_id.is_empty() {
            state.serialize_entry("datasetId", &self.dataset_id)?;
        }
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Configuration for Cloud KMS encryption settings.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EncryptionConfiguration {
    /// Optional. Describes the Cloud KMS encryption key that will be used to
    /// protect destination BigQuery table. The BigQuery Service Account associated
    /// with your project requires access to this encryption key.
    pub kms_key_name: std::option::Option<wkt::StringValue>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EncryptionConfiguration {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kms_key_name][crate::model::EncryptionConfiguration::kms_key_name].
    pub fn set_kms_key_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.kms_key_name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kms_key_name][crate::model::EncryptionConfiguration::kms_key_name].
    pub fn set_or_clear_kms_key_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.kms_key_name = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for EncryptionConfiguration {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.EncryptionConfiguration"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EncryptionConfiguration {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kms_key_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EncryptionConfiguration")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kmsKeyName" => Ok(__FieldTag::__kms_key_name),
                            "kms_key_name" => Ok(__FieldTag::__kms_key_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EncryptionConfiguration;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EncryptionConfiguration")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kms_key_name => {
                            if !fields.insert(__FieldTag::__kms_key_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key_name",
                                ));
                            }
                            result.kms_key_name =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EncryptionConfiguration {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.kms_key_name.is_some() {
            state.serialize_entry("kmsKeyName", &self.kms_key_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Error details.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ErrorProto {
    /// A short error code that summarizes the error.
    pub reason: std::string::String,

    /// Specifies where the error occurred, if present.
    pub location: std::string::String,

    /// Debugging information. This property is internal to Google and should not
    /// be used.
    pub debug_info: std::string::String,

    /// A human-readable description of the error.
    pub message: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ErrorProto {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [reason][crate::model::ErrorProto::reason].
    pub fn set_reason<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.reason = v.into();
        self
    }

    /// Sets the value of [location][crate::model::ErrorProto::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [debug_info][crate::model::ErrorProto::debug_info].
    pub fn set_debug_info<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.debug_info = v.into();
        self
    }

    /// Sets the value of [message][crate::model::ErrorProto::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }
}

impl wkt::message::Message for ErrorProto {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ErrorProto"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ErrorProto {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __reason,
            __location,
            __debug_info,
            __message,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ErrorProto")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "reason" => Ok(__FieldTag::__reason),
                            "location" => Ok(__FieldTag::__location),
                            "debugInfo" => Ok(__FieldTag::__debug_info),
                            "debug_info" => Ok(__FieldTag::__debug_info),
                            "message" => Ok(__FieldTag::__message),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ErrorProto;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ErrorProto")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__reason => {
                            if !fields.insert(__FieldTag::__reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reason",
                                ));
                            }
                            result.reason = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__debug_info => {
                            if !fields.insert(__FieldTag::__debug_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for debug_info",
                                ));
                            }
                            result.debug_info = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ErrorProto {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.reason.is_empty() {
            state.serialize_entry("reason", &self.reason)?;
        }
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !self.debug_info.is_empty() {
            state.serialize_entry("debugInfo", &self.debug_info)?;
        }
        if !self.message.is_empty() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Options defining open source compatible datasets living in the BigQuery
/// catalog. Contains metadata of open source database, schema,
/// or namespace represented by the current dataset.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ExternalCatalogDatasetOptions {
    /// Optional. A map of key value pairs defining the parameters and properties
    /// of the open source schema. Maximum size of 2MiB.
    pub parameters: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. The storage location URI for all tables in the dataset.
    /// Equivalent to hive metastore's database locationUri. Maximum length of 1024
    /// characters.
    pub default_storage_location_uri: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExternalCatalogDatasetOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parameters][crate::model::ExternalCatalogDatasetOptions::parameters].
    pub fn set_parameters<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.parameters = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [default_storage_location_uri][crate::model::ExternalCatalogDatasetOptions::default_storage_location_uri].
    pub fn set_default_storage_location_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.default_storage_location_uri = v.into();
        self
    }
}

impl wkt::message::Message for ExternalCatalogDatasetOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ExternalCatalogDatasetOptions"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExternalCatalogDatasetOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parameters,
            __default_storage_location_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExternalCatalogDatasetOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parameters" => Ok(__FieldTag::__parameters),
                            "defaultStorageLocationUri" => {
                                Ok(__FieldTag::__default_storage_location_uri)
                            }
                            "default_storage_location_uri" => {
                                Ok(__FieldTag::__default_storage_location_uri)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExternalCatalogDatasetOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExternalCatalogDatasetOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parameters => {
                            if !fields.insert(__FieldTag::__parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parameters",
                                ));
                            }
                            result.parameters = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__default_storage_location_uri => {
                            if !fields.insert(__FieldTag::__default_storage_location_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_storage_location_uri",
                                ));
                            }
                            result.default_storage_location_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExternalCatalogDatasetOptions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parameters.is_empty() {
            state.serialize_entry("parameters", &self.parameters)?;
        }
        if !self.default_storage_location_uri.is_empty() {
            state.serialize_entry(
                "defaultStorageLocationUri",
                &self.default_storage_location_uri,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata about open source compatible table. The fields contained in
/// these options correspond to Hive metastore's table-level properties.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ExternalCatalogTableOptions {
    /// Optional. A map of the key-value pairs defining the parameters and
    /// properties of the open source table. Corresponds with Hive metastore table
    /// parameters. Maximum size of 4MiB.
    pub parameters: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. A storage descriptor containing information about the physical
    /// storage of this table.
    pub storage_descriptor: std::option::Option<crate::model::StorageDescriptor>,

    /// Optional. A connection ID that specifies the credentials to be used to read
    /// external storage, such as Azure Blob, Cloud Storage, or Amazon S3. This
    /// connection is needed to read the open source table from BigQuery. The
    /// connection_id format must be either
    /// `<project_id>.<location_id>.<connection_id>` or
    /// `projects/<project_id>/locations/<location_id>/connections/<connection_id>`.
    pub connection_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExternalCatalogTableOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parameters][crate::model::ExternalCatalogTableOptions::parameters].
    pub fn set_parameters<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.parameters = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [storage_descriptor][crate::model::ExternalCatalogTableOptions::storage_descriptor].
    pub fn set_storage_descriptor<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::StorageDescriptor>,
    {
        self.storage_descriptor = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [storage_descriptor][crate::model::ExternalCatalogTableOptions::storage_descriptor].
    pub fn set_or_clear_storage_descriptor<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::StorageDescriptor>,
    {
        self.storage_descriptor = v.map(|x| x.into());
        self
    }

    /// Sets the value of [connection_id][crate::model::ExternalCatalogTableOptions::connection_id].
    pub fn set_connection_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.connection_id = v.into();
        self
    }
}

impl wkt::message::Message for ExternalCatalogTableOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ExternalCatalogTableOptions"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExternalCatalogTableOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parameters,
            __storage_descriptor,
            __connection_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExternalCatalogTableOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parameters" => Ok(__FieldTag::__parameters),
                            "storageDescriptor" => Ok(__FieldTag::__storage_descriptor),
                            "storage_descriptor" => Ok(__FieldTag::__storage_descriptor),
                            "connectionId" => Ok(__FieldTag::__connection_id),
                            "connection_id" => Ok(__FieldTag::__connection_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExternalCatalogTableOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExternalCatalogTableOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parameters => {
                            if !fields.insert(__FieldTag::__parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parameters",
                                ));
                            }
                            result.parameters = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__storage_descriptor => {
                            if !fields.insert(__FieldTag::__storage_descriptor) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_descriptor",
                                ));
                            }
                            result.storage_descriptor = map
                                .next_value::<std::option::Option<crate::model::StorageDescriptor>>(
                                )?;
                        }
                        __FieldTag::__connection_id => {
                            if !fields.insert(__FieldTag::__connection_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection_id",
                                ));
                            }
                            result.connection_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExternalCatalogTableOptions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parameters.is_empty() {
            state.serialize_entry("parameters", &self.parameters)?;
        }
        if self.storage_descriptor.is_some() {
            state.serialize_entry("storageDescriptor", &self.storage_descriptor)?;
        }
        if !self.connection_id.is_empty() {
            state.serialize_entry("connectionId", &self.connection_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Contains information about how a table's data is stored and accessed by open
/// source query engines.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StorageDescriptor {
    /// Optional. The physical location of the table
    /// (e.g. `gs://spark-dataproc-data/pangea-data/case_sensitive/` or
    /// `gs://spark-dataproc-data/pangea-data/*`).
    /// The maximum length is 2056 bytes.
    pub location_uri: std::string::String,

    /// Optional. Specifies the fully qualified class name of the InputFormat
    /// (e.g. "org.apache.hadoop.hive.ql.io.orc.OrcInputFormat").
    /// The maximum length is 128 characters.
    pub input_format: std::string::String,

    /// Optional. Specifies the fully qualified class name of the OutputFormat
    /// (e.g. "org.apache.hadoop.hive.ql.io.orc.OrcOutputFormat").
    /// The maximum length is 128 characters.
    pub output_format: std::string::String,

    /// Optional. Serializer and deserializer information.
    pub serde_info: std::option::Option<crate::model::SerDeInfo>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StorageDescriptor {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location_uri][crate::model::StorageDescriptor::location_uri].
    pub fn set_location_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_uri = v.into();
        self
    }

    /// Sets the value of [input_format][crate::model::StorageDescriptor::input_format].
    pub fn set_input_format<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.input_format = v.into();
        self
    }

    /// Sets the value of [output_format][crate::model::StorageDescriptor::output_format].
    pub fn set_output_format<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.output_format = v.into();
        self
    }

    /// Sets the value of [serde_info][crate::model::StorageDescriptor::serde_info].
    pub fn set_serde_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SerDeInfo>,
    {
        self.serde_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [serde_info][crate::model::StorageDescriptor::serde_info].
    pub fn set_or_clear_serde_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SerDeInfo>,
    {
        self.serde_info = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for StorageDescriptor {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.StorageDescriptor"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StorageDescriptor {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __location_uri,
            __input_format,
            __output_format,
            __serde_info,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StorageDescriptor")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "locationUri" => Ok(__FieldTag::__location_uri),
                            "location_uri" => Ok(__FieldTag::__location_uri),
                            "inputFormat" => Ok(__FieldTag::__input_format),
                            "input_format" => Ok(__FieldTag::__input_format),
                            "outputFormat" => Ok(__FieldTag::__output_format),
                            "output_format" => Ok(__FieldTag::__output_format),
                            "serdeInfo" => Ok(__FieldTag::__serde_info),
                            "serde_info" => Ok(__FieldTag::__serde_info),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StorageDescriptor;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StorageDescriptor")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__location_uri => {
                            if !fields.insert(__FieldTag::__location_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location_uri",
                                ));
                            }
                            result.location_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__input_format => {
                            if !fields.insert(__FieldTag::__input_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input_format",
                                ));
                            }
                            result.input_format = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__output_format => {
                            if !fields.insert(__FieldTag::__output_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_format",
                                ));
                            }
                            result.output_format = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__serde_info => {
                            if !fields.insert(__FieldTag::__serde_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for serde_info",
                                ));
                            }
                            result.serde_info =
                                map.next_value::<std::option::Option<crate::model::SerDeInfo>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StorageDescriptor {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.location_uri.is_empty() {
            state.serialize_entry("locationUri", &self.location_uri)?;
        }
        if !self.input_format.is_empty() {
            state.serialize_entry("inputFormat", &self.input_format)?;
        }
        if !self.output_format.is_empty() {
            state.serialize_entry("outputFormat", &self.output_format)?;
        }
        if self.serde_info.is_some() {
            state.serialize_entry("serdeInfo", &self.serde_info)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Serializer and deserializer information.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SerDeInfo {
    /// Optional. Name of the SerDe.
    /// The maximum length is 256 characters.
    pub name: std::string::String,

    /// Required. Specifies a fully-qualified class name of the serialization
    /// library that is responsible for the translation of data between table
    /// representation and the underlying low-level input and output format
    /// structures. The maximum length is 256 characters.
    pub serialization_library: std::string::String,

    /// Optional. Key-value pairs that define the initialization parameters for the
    /// serialization library.
    /// Maximum size 10 Kib.
    pub parameters: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SerDeInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SerDeInfo::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [serialization_library][crate::model::SerDeInfo::serialization_library].
    pub fn set_serialization_library<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.serialization_library = v.into();
        self
    }

    /// Sets the value of [parameters][crate::model::SerDeInfo::parameters].
    pub fn set_parameters<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.parameters = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for SerDeInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.SerDeInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SerDeInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __serialization_library,
            __parameters,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SerDeInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "serializationLibrary" => Ok(__FieldTag::__serialization_library),
                            "serialization_library" => Ok(__FieldTag::__serialization_library),
                            "parameters" => Ok(__FieldTag::__parameters),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SerDeInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SerDeInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__serialization_library => {
                            if !fields.insert(__FieldTag::__serialization_library) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for serialization_library",
                                ));
                            }
                            result.serialization_library = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parameters => {
                            if !fields.insert(__FieldTag::__parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parameters",
                                ));
                            }
                            result.parameters = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SerDeInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.serialization_library.is_empty() {
            state.serialize_entry("serializationLibrary", &self.serialization_library)?;
        }
        if !self.parameters.is_empty() {
            state.serialize_entry("parameters", &self.parameters)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Options for external data sources.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AvroOptions {
    /// Optional. If sourceFormat is set to "AVRO", indicates whether to interpret
    /// logical types as the corresponding BigQuery data type (for example,
    /// TIMESTAMP), instead of using the raw type (for example, INTEGER).
    pub use_avro_logical_types: std::option::Option<wkt::BoolValue>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AvroOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [use_avro_logical_types][crate::model::AvroOptions::use_avro_logical_types].
    pub fn set_use_avro_logical_types<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.use_avro_logical_types = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [use_avro_logical_types][crate::model::AvroOptions::use_avro_logical_types].
    pub fn set_or_clear_use_avro_logical_types<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.use_avro_logical_types = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AvroOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.AvroOptions"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AvroOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __use_avro_logical_types,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AvroOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "useAvroLogicalTypes" => Ok(__FieldTag::__use_avro_logical_types),
                            "use_avro_logical_types" => Ok(__FieldTag::__use_avro_logical_types),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AvroOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AvroOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__use_avro_logical_types => {
                            if !fields.insert(__FieldTag::__use_avro_logical_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for use_avro_logical_types",
                                ));
                            }
                            result.use_avro_logical_types =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AvroOptions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.use_avro_logical_types.is_some() {
            state.serialize_entry("useAvroLogicalTypes", &self.use_avro_logical_types)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Parquet Options for load and make external tables.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ParquetOptions {
    /// Optional. Indicates whether to infer Parquet ENUM logical type as STRING
    /// instead of BYTES by default.
    pub enum_as_string: std::option::Option<wkt::BoolValue>,

    /// Optional. Indicates whether to use schema inference specifically for
    /// Parquet LIST logical type.
    pub enable_list_inference: std::option::Option<wkt::BoolValue>,

    /// Optional. Indicates how to represent a Parquet map if present.
    pub map_target_type: crate::model::MapTargetType,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ParquetOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enum_as_string][crate::model::ParquetOptions::enum_as_string].
    pub fn set_enum_as_string<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.enum_as_string = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enum_as_string][crate::model::ParquetOptions::enum_as_string].
    pub fn set_or_clear_enum_as_string<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.enum_as_string = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enable_list_inference][crate::model::ParquetOptions::enable_list_inference].
    pub fn set_enable_list_inference<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.enable_list_inference = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_list_inference][crate::model::ParquetOptions::enable_list_inference].
    pub fn set_or_clear_enable_list_inference<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.enable_list_inference = v.map(|x| x.into());
        self
    }

    /// Sets the value of [map_target_type][crate::model::ParquetOptions::map_target_type].
    pub fn set_map_target_type<T: std::convert::Into<crate::model::MapTargetType>>(
        mut self,
        v: T,
    ) -> Self {
        self.map_target_type = v.into();
        self
    }
}

impl wkt::message::Message for ParquetOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ParquetOptions"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ParquetOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enum_as_string,
            __enable_list_inference,
            __map_target_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ParquetOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enumAsString" => Ok(__FieldTag::__enum_as_string),
                            "enum_as_string" => Ok(__FieldTag::__enum_as_string),
                            "enableListInference" => Ok(__FieldTag::__enable_list_inference),
                            "enable_list_inference" => Ok(__FieldTag::__enable_list_inference),
                            "mapTargetType" => Ok(__FieldTag::__map_target_type),
                            "map_target_type" => Ok(__FieldTag::__map_target_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ParquetOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ParquetOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enum_as_string => {
                            if !fields.insert(__FieldTag::__enum_as_string) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enum_as_string",
                                ));
                            }
                            result.enum_as_string =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__enable_list_inference => {
                            if !fields.insert(__FieldTag::__enable_list_inference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_list_inference",
                                ));
                            }
                            result.enable_list_inference =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__map_target_type => {
                            if !fields.insert(__FieldTag::__map_target_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map_target_type",
                                ));
                            }
                            result.map_target_type = map
                                .next_value::<std::option::Option<crate::model::MapTargetType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ParquetOptions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.enum_as_string.is_some() {
            state.serialize_entry("enumAsString", &self.enum_as_string)?;
        }
        if self.enable_list_inference.is_some() {
            state.serialize_entry("enableListInference", &self.enable_list_inference)?;
        }
        if !wkt::internal::is_default(&self.map_target_type) {
            state.serialize_entry("mapTargetType", &self.map_target_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Information related to a CSV data source.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CsvOptions {
    /// Optional. The separator character for fields in a CSV file. The separator
    /// is interpreted as a single byte. For files encoded in ISO-8859-1, any
    /// single character can be used as a separator. For files encoded in UTF-8,
    /// characters represented in decimal range 1-127 (U+0001-U+007F) can be used
    /// without any modification. UTF-8 characters encoded with multiple bytes
    /// (i.e. U+0080 and above) will have only the first byte used for separating
    /// fields. The remaining bytes will be treated as a part of the field.
    /// BigQuery also supports the escape sequence "\t" (U+0009) to specify a tab
    /// separator. The default value is comma (",", U+002C).
    pub field_delimiter: std::string::String,

    /// Optional. The number of rows at the top of a CSV file that BigQuery will
    /// skip when reading the data. The default value is 0. This property is
    /// useful if you have header rows in the file that should be skipped.
    /// When autodetect is on, the behavior is the following:
    ///
    /// * skipLeadingRows unspecified - Autodetect tries to detect headers in the
    ///   first row. If they are not detected, the row is read as data. Otherwise
    ///   data is read starting from the second row.
    /// * skipLeadingRows is 0 - Instructs autodetect that there are no headers and
    ///   data should be read starting from the first row.
    /// * skipLeadingRows = N > 0 - Autodetect skips N-1 rows and tries to detect
    ///   headers in row N. If headers are not detected, row N is just skipped.
    ///   Otherwise row N is used to extract column names for the detected schema.
    pub skip_leading_rows: std::option::Option<wkt::Int64Value>,

    /// Optional. The value that is used to quote data sections in a CSV file.
    /// BigQuery converts the string to ISO-8859-1 encoding, and then uses the
    /// first byte of the encoded string to split the data in its raw, binary
    /// state.
    /// The default value is a double-quote (").
    /// If your data does not contain quoted sections,
    /// set the property value to an empty string.
    /// If your data contains quoted newline characters, you must also set the
    /// allowQuotedNewlines property to true.
    /// To include the specific quote character within a quoted value, precede it
    /// with an additional matching quote character. For example, if you want to
    /// escape the default character  ' " ', use ' "" '.
    pub quote: std::option::Option<wkt::StringValue>,

    /// Optional. Indicates if BigQuery should allow quoted data sections that
    /// contain newline characters in a CSV file. The default value is false.
    pub allow_quoted_newlines: std::option::Option<wkt::BoolValue>,

    /// Optional. Indicates if BigQuery should accept rows that are missing
    /// trailing optional columns. If true, BigQuery treats missing trailing
    /// columns as null values.
    /// If false, records with missing trailing columns are treated as bad records,
    /// and if there are too many bad records, an invalid error is returned in the
    /// job result. The default value is false.
    pub allow_jagged_rows: std::option::Option<wkt::BoolValue>,

    /// Optional. The character encoding of the data.
    /// The supported values are UTF-8, ISO-8859-1, UTF-16BE, UTF-16LE, UTF-32BE,
    /// and UTF-32LE.  The default value is UTF-8.
    /// BigQuery decodes the data after the raw, binary data has been split using
    /// the values of the quote and fieldDelimiter properties.
    pub encoding: std::string::String,

    /// Optional. Indicates if the embedded ASCII control characters (the first 32
    /// characters in the ASCII-table, from '\x00' to '\x1F') are preserved.
    pub preserve_ascii_control_characters: std::option::Option<wkt::BoolValue>,

    /// Optional. Specifies a string that represents a null value in a CSV file.
    /// For example, if you specify "\N", BigQuery interprets "\N" as a null value
    /// when querying a CSV file.
    /// The default value is the empty string. If you set this property to a custom
    /// value, BigQuery throws an error if an empty string is present for all data
    /// types except for STRING and BYTE. For STRING and BYTE columns, BigQuery
    /// interprets the empty string as an empty value.
    pub null_marker: std::option::Option<wkt::StringValue>,

    /// Optional. A list of strings represented as SQL NULL value in a CSV file.
    ///
    /// null_marker and null_markers can't be set at the same time.
    /// If null_marker is set, null_markers has to be not set.
    /// If null_markers is set, null_marker has to be not set.
    /// If both null_marker and null_markers are set at the same time, a user
    /// error would be thrown.
    /// Any strings listed in null_markers, including
    /// empty string would be interpreted as SQL NULL. This applies to all column
    /// types.
    pub null_markers: std::vec::Vec<std::string::String>,

    /// Optional. Controls the strategy used to match loaded columns to the schema.
    /// If not set, a sensible default is chosen based on how the schema is
    /// provided. If autodetect is used, then columns are matched by name.
    /// Otherwise, columns are matched by position. This is done to keep the
    /// behavior backward-compatible. Acceptable values are:
    /// POSITION - matches by position. This assumes that the columns are ordered
    /// the same way as the schema.
    /// NAME - matches by name. This reads the header row as column names and
    /// reorders columns to match the field names in the schema.
    pub source_column_match: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CsvOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [field_delimiter][crate::model::CsvOptions::field_delimiter].
    pub fn set_field_delimiter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.field_delimiter = v.into();
        self
    }

    /// Sets the value of [skip_leading_rows][crate::model::CsvOptions::skip_leading_rows].
    pub fn set_skip_leading_rows<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.skip_leading_rows = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [skip_leading_rows][crate::model::CsvOptions::skip_leading_rows].
    pub fn set_or_clear_skip_leading_rows<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.skip_leading_rows = v.map(|x| x.into());
        self
    }

    /// Sets the value of [quote][crate::model::CsvOptions::quote].
    pub fn set_quote<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.quote = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [quote][crate::model::CsvOptions::quote].
    pub fn set_or_clear_quote<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.quote = v.map(|x| x.into());
        self
    }

    /// Sets the value of [allow_quoted_newlines][crate::model::CsvOptions::allow_quoted_newlines].
    pub fn set_allow_quoted_newlines<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.allow_quoted_newlines = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [allow_quoted_newlines][crate::model::CsvOptions::allow_quoted_newlines].
    pub fn set_or_clear_allow_quoted_newlines<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.allow_quoted_newlines = v.map(|x| x.into());
        self
    }

    /// Sets the value of [allow_jagged_rows][crate::model::CsvOptions::allow_jagged_rows].
    pub fn set_allow_jagged_rows<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.allow_jagged_rows = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [allow_jagged_rows][crate::model::CsvOptions::allow_jagged_rows].
    pub fn set_or_clear_allow_jagged_rows<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.allow_jagged_rows = v.map(|x| x.into());
        self
    }

    /// Sets the value of [encoding][crate::model::CsvOptions::encoding].
    pub fn set_encoding<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.encoding = v.into();
        self
    }

    /// Sets the value of [preserve_ascii_control_characters][crate::model::CsvOptions::preserve_ascii_control_characters].
    pub fn set_preserve_ascii_control_characters<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.preserve_ascii_control_characters = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [preserve_ascii_control_characters][crate::model::CsvOptions::preserve_ascii_control_characters].
    pub fn set_or_clear_preserve_ascii_control_characters<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.preserve_ascii_control_characters = v.map(|x| x.into());
        self
    }

    /// Sets the value of [null_marker][crate::model::CsvOptions::null_marker].
    pub fn set_null_marker<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.null_marker = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [null_marker][crate::model::CsvOptions::null_marker].
    pub fn set_or_clear_null_marker<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.null_marker = v.map(|x| x.into());
        self
    }

    /// Sets the value of [null_markers][crate::model::CsvOptions::null_markers].
    pub fn set_null_markers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.null_markers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [source_column_match][crate::model::CsvOptions::source_column_match].
    pub fn set_source_column_match<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_column_match = v.into();
        self
    }
}

impl wkt::message::Message for CsvOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.CsvOptions"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CsvOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __field_delimiter,
            __skip_leading_rows,
            __quote,
            __allow_quoted_newlines,
            __allow_jagged_rows,
            __encoding,
            __preserve_ascii_control_characters,
            __null_marker,
            __null_markers,
            __source_column_match,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CsvOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fieldDelimiter" => Ok(__FieldTag::__field_delimiter),
                            "field_delimiter" => Ok(__FieldTag::__field_delimiter),
                            "skipLeadingRows" => Ok(__FieldTag::__skip_leading_rows),
                            "skip_leading_rows" => Ok(__FieldTag::__skip_leading_rows),
                            "quote" => Ok(__FieldTag::__quote),
                            "allowQuotedNewlines" => Ok(__FieldTag::__allow_quoted_newlines),
                            "allow_quoted_newlines" => Ok(__FieldTag::__allow_quoted_newlines),
                            "allowJaggedRows" => Ok(__FieldTag::__allow_jagged_rows),
                            "allow_jagged_rows" => Ok(__FieldTag::__allow_jagged_rows),
                            "encoding" => Ok(__FieldTag::__encoding),
                            "preserveAsciiControlCharacters" => {
                                Ok(__FieldTag::__preserve_ascii_control_characters)
                            }
                            "preserve_ascii_control_characters" => {
                                Ok(__FieldTag::__preserve_ascii_control_characters)
                            }
                            "nullMarker" => Ok(__FieldTag::__null_marker),
                            "null_marker" => Ok(__FieldTag::__null_marker),
                            "nullMarkers" => Ok(__FieldTag::__null_markers),
                            "null_markers" => Ok(__FieldTag::__null_markers),
                            "sourceColumnMatch" => Ok(__FieldTag::__source_column_match),
                            "source_column_match" => Ok(__FieldTag::__source_column_match),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CsvOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CsvOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__field_delimiter => {
                            if !fields.insert(__FieldTag::__field_delimiter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field_delimiter",
                                ));
                            }
                            result.field_delimiter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__skip_leading_rows => {
                            if !fields.insert(__FieldTag::__skip_leading_rows) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for skip_leading_rows",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.skip_leading_rows = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__quote => {
                            if !fields.insert(__FieldTag::__quote) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for quote",
                                ));
                            }
                            result.quote =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::__allow_quoted_newlines => {
                            if !fields.insert(__FieldTag::__allow_quoted_newlines) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_quoted_newlines",
                                ));
                            }
                            result.allow_quoted_newlines =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__allow_jagged_rows => {
                            if !fields.insert(__FieldTag::__allow_jagged_rows) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_jagged_rows",
                                ));
                            }
                            result.allow_jagged_rows =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__encoding => {
                            if !fields.insert(__FieldTag::__encoding) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encoding",
                                ));
                            }
                            result.encoding = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__preserve_ascii_control_characters => {
                            if !fields.insert(__FieldTag::__preserve_ascii_control_characters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for preserve_ascii_control_characters",
                                ));
                            }
                            result.preserve_ascii_control_characters =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__null_marker => {
                            if !fields.insert(__FieldTag::__null_marker) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for null_marker",
                                ));
                            }
                            result.null_marker =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::__null_markers => {
                            if !fields.insert(__FieldTag::__null_markers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for null_markers",
                                ));
                            }
                            result.null_markers = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__source_column_match => {
                            if !fields.insert(__FieldTag::__source_column_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_column_match",
                                ));
                            }
                            result.source_column_match = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CsvOptions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.field_delimiter.is_empty() {
            state.serialize_entry("fieldDelimiter", &self.field_delimiter)?;
        }
        if self.skip_leading_rows.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("skipLeadingRows", &__With(&self.skip_leading_rows))?;
        }
        if self.quote.is_some() {
            state.serialize_entry("quote", &self.quote)?;
        }
        if self.allow_quoted_newlines.is_some() {
            state.serialize_entry("allowQuotedNewlines", &self.allow_quoted_newlines)?;
        }
        if self.allow_jagged_rows.is_some() {
            state.serialize_entry("allowJaggedRows", &self.allow_jagged_rows)?;
        }
        if !self.encoding.is_empty() {
            state.serialize_entry("encoding", &self.encoding)?;
        }
        if self.preserve_ascii_control_characters.is_some() {
            state.serialize_entry(
                "preserveAsciiControlCharacters",
                &self.preserve_ascii_control_characters,
            )?;
        }
        if self.null_marker.is_some() {
            state.serialize_entry("nullMarker", &self.null_marker)?;
        }
        if !self.null_markers.is_empty() {
            state.serialize_entry("nullMarkers", &self.null_markers)?;
        }
        if !self.source_column_match.is_empty() {
            state.serialize_entry("sourceColumnMatch", &self.source_column_match)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Json Options for load and make external tables.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct JsonOptions {
    /// Optional. The character encoding of the data.
    /// The supported values are UTF-8, UTF-16BE, UTF-16LE, UTF-32BE,
    /// and UTF-32LE.  The default value is UTF-8.
    pub encoding: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl JsonOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [encoding][crate::model::JsonOptions::encoding].
    pub fn set_encoding<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.encoding = v.into();
        self
    }
}

impl wkt::message::Message for JsonOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.JsonOptions"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for JsonOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __encoding,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for JsonOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "encoding" => Ok(__FieldTag::__encoding),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = JsonOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct JsonOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__encoding => {
                            if !fields.insert(__FieldTag::__encoding) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encoding",
                                ));
                            }
                            result.encoding = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for JsonOptions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.encoding.is_empty() {
            state.serialize_entry("encoding", &self.encoding)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Information related to a Bigtable column.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BigtableColumn {
    /// [Required] Qualifier of the column.
    /// Columns in the parent column family that has this exact qualifier are
    /// exposed as `<family field name>.<column field name>` field.
    /// If the qualifier is valid UTF-8 string, it can be specified in the
    /// qualifier_string field.  Otherwise, a base-64 encoded value must be set to
    /// qualifier_encoded.
    /// The column field name is the same as the column qualifier. However, if the
    /// qualifier is not a valid BigQuery field identifier i.e. does not match
    /// [a-zA-Z][a-zA-Z0-9_]*, a valid identifier must be provided as field_name.
    pub qualifier_encoded: std::option::Option<wkt::BytesValue>,

    /// Qualifier string.
    pub qualifier_string: std::option::Option<wkt::StringValue>,

    /// Optional. If the qualifier is not a valid BigQuery field identifier i.e.
    /// does not match [a-zA-Z][a-zA-Z0-9_]*,  a valid identifier must be provided
    /// as the column field name and is used as field name in queries.
    pub field_name: std::string::String,

    /// Optional. The type to convert the value in cells of this column.
    /// The values are expected to be encoded using HBase Bytes.toBytes function
    /// when using the BINARY encoding value.
    /// Following BigQuery types are allowed (case-sensitive):
    ///
    /// * BYTES
    /// * STRING
    /// * INTEGER
    /// * FLOAT
    /// * BOOLEAN
    /// * JSON
    ///
    /// Default type is BYTES.
    /// 'type' can also be set at the column family level. However, the setting at
    /// this level takes precedence if 'type' is set at both levels.
    pub r#type: std::string::String,

    /// Optional. The encoding of the values when the type is not STRING.
    /// Acceptable encoding values are:
    /// TEXT - indicates values are alphanumeric text strings.
    /// BINARY - indicates values are encoded using HBase Bytes.toBytes family of
    /// functions.
    /// 'encoding' can also be set at the column family level. However, the setting
    /// at this level takes precedence if 'encoding' is set at both levels.
    pub encoding: std::string::String,

    /// Optional. If this is set, only the latest version of value in this column
    /// are exposed.
    /// 'onlyReadLatest' can also be set at the column family level. However, the
    /// setting at this level takes precedence if 'onlyReadLatest' is set at both
    /// levels.
    pub only_read_latest: std::option::Option<wkt::BoolValue>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigtableColumn {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [qualifier_encoded][crate::model::BigtableColumn::qualifier_encoded].
    pub fn set_qualifier_encoded<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BytesValue>,
    {
        self.qualifier_encoded = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [qualifier_encoded][crate::model::BigtableColumn::qualifier_encoded].
    pub fn set_or_clear_qualifier_encoded<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BytesValue>,
    {
        self.qualifier_encoded = v.map(|x| x.into());
        self
    }

    /// Sets the value of [qualifier_string][crate::model::BigtableColumn::qualifier_string].
    pub fn set_qualifier_string<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.qualifier_string = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [qualifier_string][crate::model::BigtableColumn::qualifier_string].
    pub fn set_or_clear_qualifier_string<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.qualifier_string = v.map(|x| x.into());
        self
    }

    /// Sets the value of [field_name][crate::model::BigtableColumn::field_name].
    pub fn set_field_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.field_name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::BigtableColumn::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [encoding][crate::model::BigtableColumn::encoding].
    pub fn set_encoding<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.encoding = v.into();
        self
    }

    /// Sets the value of [only_read_latest][crate::model::BigtableColumn::only_read_latest].
    pub fn set_only_read_latest<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.only_read_latest = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [only_read_latest][crate::model::BigtableColumn::only_read_latest].
    pub fn set_or_clear_only_read_latest<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.only_read_latest = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for BigtableColumn {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.BigtableColumn"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BigtableColumn {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __qualifier_encoded,
            __qualifier_string,
            __field_name,
            __type,
            __encoding,
            __only_read_latest,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BigtableColumn")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "qualifierEncoded" => Ok(__FieldTag::__qualifier_encoded),
                            "qualifier_encoded" => Ok(__FieldTag::__qualifier_encoded),
                            "qualifierString" => Ok(__FieldTag::__qualifier_string),
                            "qualifier_string" => Ok(__FieldTag::__qualifier_string),
                            "fieldName" => Ok(__FieldTag::__field_name),
                            "field_name" => Ok(__FieldTag::__field_name),
                            "type" => Ok(__FieldTag::__type),
                            "encoding" => Ok(__FieldTag::__encoding),
                            "onlyReadLatest" => Ok(__FieldTag::__only_read_latest),
                            "only_read_latest" => Ok(__FieldTag::__only_read_latest),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BigtableColumn;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BigtableColumn")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__qualifier_encoded => {
                            if !fields.insert(__FieldTag::__qualifier_encoded) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for qualifier_encoded",
                                ));
                            }
                            struct __With(std::option::Option<wkt::BytesValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.qualifier_encoded = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__qualifier_string => {
                            if !fields.insert(__FieldTag::__qualifier_string) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for qualifier_string",
                                ));
                            }
                            result.qualifier_string =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::__field_name => {
                            if !fields.insert(__FieldTag::__field_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field_name",
                                ));
                            }
                            result.field_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__encoding => {
                            if !fields.insert(__FieldTag::__encoding) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encoding",
                                ));
                            }
                            result.encoding = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__only_read_latest => {
                            if !fields.insert(__FieldTag::__only_read_latest) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for only_read_latest",
                                ));
                            }
                            result.only_read_latest =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BigtableColumn {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.qualifier_encoded.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::BytesValue>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<serde_with::base64::Base64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("qualifierEncoded", &__With(&self.qualifier_encoded))?;
        }
        if self.qualifier_string.is_some() {
            state.serialize_entry("qualifierString", &self.qualifier_string)?;
        }
        if !self.field_name.is_empty() {
            state.serialize_entry("fieldName", &self.field_name)?;
        }
        if !self.r#type.is_empty() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.encoding.is_empty() {
            state.serialize_entry("encoding", &self.encoding)?;
        }
        if self.only_read_latest.is_some() {
            state.serialize_entry("onlyReadLatest", &self.only_read_latest)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Information related to a Bigtable column family.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BigtableColumnFamily {
    /// Identifier of the column family.
    pub family_id: std::string::String,

    /// Optional. The type to convert the value in cells of this column family.
    /// The values are expected to be encoded using HBase Bytes.toBytes function
    /// when using the BINARY encoding value.
    /// Following BigQuery types are allowed (case-sensitive):
    ///
    /// * BYTES
    /// * STRING
    /// * INTEGER
    /// * FLOAT
    /// * BOOLEAN
    /// * JSON
    ///
    /// Default type is BYTES.
    /// This can be overridden for a specific column by listing that column in
    /// 'columns' and specifying a type for it.
    pub r#type: std::string::String,

    /// Optional. The encoding of the values when the type is not STRING.
    /// Acceptable encoding values are:
    /// TEXT - indicates values are alphanumeric text strings.
    /// BINARY - indicates values are encoded using HBase Bytes.toBytes family of
    /// functions.
    /// This can be overridden for a specific column by listing that column in
    /// 'columns' and specifying an encoding for it.
    pub encoding: std::string::String,

    /// Optional. Lists of columns that should be exposed as individual fields as
    /// opposed to a list of (column name, value) pairs.
    /// All columns whose qualifier matches a qualifier in this list can be
    /// accessed as `<family field name>.<column field name>`.
    /// Other columns can be accessed as a list through
    /// the `<family field name>.Column` field.
    pub columns: std::vec::Vec<crate::model::BigtableColumn>,

    /// Optional. If this is set only the latest version of value are exposed for
    /// all columns in this column family.
    /// This can be overridden for a specific column by listing that column in
    /// 'columns' and specifying a different setting
    /// for that column.
    pub only_read_latest: std::option::Option<wkt::BoolValue>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigtableColumnFamily {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [family_id][crate::model::BigtableColumnFamily::family_id].
    pub fn set_family_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.family_id = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::BigtableColumnFamily::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [encoding][crate::model::BigtableColumnFamily::encoding].
    pub fn set_encoding<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.encoding = v.into();
        self
    }

    /// Sets the value of [columns][crate::model::BigtableColumnFamily::columns].
    pub fn set_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BigtableColumn>,
    {
        use std::iter::Iterator;
        self.columns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [only_read_latest][crate::model::BigtableColumnFamily::only_read_latest].
    pub fn set_only_read_latest<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.only_read_latest = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [only_read_latest][crate::model::BigtableColumnFamily::only_read_latest].
    pub fn set_or_clear_only_read_latest<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.only_read_latest = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for BigtableColumnFamily {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.BigtableColumnFamily"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BigtableColumnFamily {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __family_id,
            __type,
            __encoding,
            __columns,
            __only_read_latest,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BigtableColumnFamily")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "familyId" => Ok(__FieldTag::__family_id),
                            "family_id" => Ok(__FieldTag::__family_id),
                            "type" => Ok(__FieldTag::__type),
                            "encoding" => Ok(__FieldTag::__encoding),
                            "columns" => Ok(__FieldTag::__columns),
                            "onlyReadLatest" => Ok(__FieldTag::__only_read_latest),
                            "only_read_latest" => Ok(__FieldTag::__only_read_latest),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BigtableColumnFamily;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BigtableColumnFamily")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__family_id => {
                            if !fields.insert(__FieldTag::__family_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for family_id",
                                ));
                            }
                            result.family_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__encoding => {
                            if !fields.insert(__FieldTag::__encoding) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encoding",
                                ));
                            }
                            result.encoding = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__columns => {
                            if !fields.insert(__FieldTag::__columns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for columns",
                                ));
                            }
                            result.columns =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::BigtableColumn>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__only_read_latest => {
                            if !fields.insert(__FieldTag::__only_read_latest) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for only_read_latest",
                                ));
                            }
                            result.only_read_latest =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BigtableColumnFamily {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.family_id.is_empty() {
            state.serialize_entry("familyId", &self.family_id)?;
        }
        if !self.r#type.is_empty() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.encoding.is_empty() {
            state.serialize_entry("encoding", &self.encoding)?;
        }
        if !self.columns.is_empty() {
            state.serialize_entry("columns", &self.columns)?;
        }
        if self.only_read_latest.is_some() {
            state.serialize_entry("onlyReadLatest", &self.only_read_latest)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Options specific to Google Cloud Bigtable data sources.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BigtableOptions {
    /// Optional. List of column families to expose in the table schema along with
    /// their types.
    /// This list restricts the column families that can be referenced in queries
    /// and specifies their value types.
    /// You can use this list to do type conversions - see the 'type' field for
    /// more details.
    /// If you leave this list empty, all column families are present in the table
    /// schema and their values are read as BYTES.
    /// During a query only the column families referenced in that query are read
    /// from Bigtable.
    pub column_families: std::vec::Vec<crate::model::BigtableColumnFamily>,

    /// Optional. If field is true, then the column families that are not
    /// specified in columnFamilies list are not exposed in the table schema.
    /// Otherwise, they are read with BYTES type values.
    /// The default value is false.
    pub ignore_unspecified_column_families: std::option::Option<wkt::BoolValue>,

    /// Optional. If field is true, then the rowkey column families will be read
    /// and converted to string. Otherwise they are read with BYTES type values and
    /// users need to manually cast them with CAST if necessary.
    /// The default value is false.
    pub read_rowkey_as_string: std::option::Option<wkt::BoolValue>,

    /// Optional. If field is true, then each column family will be read as a
    /// single JSON column. Otherwise they are read as a repeated cell structure
    /// containing timestamp/value tuples. The default value is false.
    pub output_column_families_as_json: std::option::Option<wkt::BoolValue>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigtableOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [column_families][crate::model::BigtableOptions::column_families].
    pub fn set_column_families<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BigtableColumnFamily>,
    {
        use std::iter::Iterator;
        self.column_families = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [ignore_unspecified_column_families][crate::model::BigtableOptions::ignore_unspecified_column_families].
    pub fn set_ignore_unspecified_column_families<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.ignore_unspecified_column_families = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ignore_unspecified_column_families][crate::model::BigtableOptions::ignore_unspecified_column_families].
    pub fn set_or_clear_ignore_unspecified_column_families<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.ignore_unspecified_column_families = v.map(|x| x.into());
        self
    }

    /// Sets the value of [read_rowkey_as_string][crate::model::BigtableOptions::read_rowkey_as_string].
    pub fn set_read_rowkey_as_string<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.read_rowkey_as_string = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [read_rowkey_as_string][crate::model::BigtableOptions::read_rowkey_as_string].
    pub fn set_or_clear_read_rowkey_as_string<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.read_rowkey_as_string = v.map(|x| x.into());
        self
    }

    /// Sets the value of [output_column_families_as_json][crate::model::BigtableOptions::output_column_families_as_json].
    pub fn set_output_column_families_as_json<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.output_column_families_as_json = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [output_column_families_as_json][crate::model::BigtableOptions::output_column_families_as_json].
    pub fn set_or_clear_output_column_families_as_json<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.output_column_families_as_json = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for BigtableOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.BigtableOptions"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BigtableOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __column_families,
            __ignore_unspecified_column_families,
            __read_rowkey_as_string,
            __output_column_families_as_json,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BigtableOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "columnFamilies" => Ok(__FieldTag::__column_families),
                            "column_families" => Ok(__FieldTag::__column_families),
                            "ignoreUnspecifiedColumnFamilies" => {
                                Ok(__FieldTag::__ignore_unspecified_column_families)
                            }
                            "ignore_unspecified_column_families" => {
                                Ok(__FieldTag::__ignore_unspecified_column_families)
                            }
                            "readRowkeyAsString" => Ok(__FieldTag::__read_rowkey_as_string),
                            "read_rowkey_as_string" => Ok(__FieldTag::__read_rowkey_as_string),
                            "outputColumnFamiliesAsJson" => {
                                Ok(__FieldTag::__output_column_families_as_json)
                            }
                            "output_column_families_as_json" => {
                                Ok(__FieldTag::__output_column_families_as_json)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BigtableOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BigtableOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__column_families => {
                            if !fields.insert(__FieldTag::__column_families) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for column_families",
                                ));
                            }
                            result.column_families = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::BigtableColumnFamily>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ignore_unspecified_column_families => {
                            if !fields.insert(__FieldTag::__ignore_unspecified_column_families) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ignore_unspecified_column_families",
                                ));
                            }
                            result.ignore_unspecified_column_families =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__read_rowkey_as_string => {
                            if !fields.insert(__FieldTag::__read_rowkey_as_string) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_rowkey_as_string",
                                ));
                            }
                            result.read_rowkey_as_string =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__output_column_families_as_json => {
                            if !fields.insert(__FieldTag::__output_column_families_as_json) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_column_families_as_json",
                                ));
                            }
                            result.output_column_families_as_json =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BigtableOptions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.column_families.is_empty() {
            state.serialize_entry("columnFamilies", &self.column_families)?;
        }
        if self.ignore_unspecified_column_families.is_some() {
            state.serialize_entry(
                "ignoreUnspecifiedColumnFamilies",
                &self.ignore_unspecified_column_families,
            )?;
        }
        if self.read_rowkey_as_string.is_some() {
            state.serialize_entry("readRowkeyAsString", &self.read_rowkey_as_string)?;
        }
        if self.output_column_families_as_json.is_some() {
            state.serialize_entry(
                "outputColumnFamiliesAsJson",
                &self.output_column_families_as_json,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Options specific to Google Sheets data sources.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GoogleSheetsOptions {
    /// Optional. The number of rows at the top of a sheet that BigQuery will skip
    /// when reading the data. The default value is 0. This property is useful if
    /// you have header rows that should be skipped. When autodetect is on,
    /// the behavior is the following:
    ///
    /// * skipLeadingRows unspecified - Autodetect tries to detect headers in the
    ///   first row. If they are not detected, the row is read as data. Otherwise
    ///   data is read starting from the second row.
    /// * skipLeadingRows is 0 - Instructs autodetect that there are no headers and
    ///   data should be read starting from the first row.
    /// * skipLeadingRows = N > 0 - Autodetect skips N-1 rows and tries to detect
    ///   headers in row N. If headers are not detected, row N is just skipped.
    ///   Otherwise row N is used to extract column names for the detected schema.
    pub skip_leading_rows: std::option::Option<wkt::Int64Value>,

    /// Optional. Range of a sheet to query from. Only used when non-empty.
    /// Typical format: sheet_name!top_left_cell_id:bottom_right_cell_id
    /// For example: sheet1!A1:B20
    pub range: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GoogleSheetsOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [skip_leading_rows][crate::model::GoogleSheetsOptions::skip_leading_rows].
    pub fn set_skip_leading_rows<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.skip_leading_rows = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [skip_leading_rows][crate::model::GoogleSheetsOptions::skip_leading_rows].
    pub fn set_or_clear_skip_leading_rows<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.skip_leading_rows = v.map(|x| x.into());
        self
    }

    /// Sets the value of [range][crate::model::GoogleSheetsOptions::range].
    pub fn set_range<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.range = v.into();
        self
    }
}

impl wkt::message::Message for GoogleSheetsOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.GoogleSheetsOptions"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GoogleSheetsOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __skip_leading_rows,
            __range,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GoogleSheetsOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "skipLeadingRows" => Ok(__FieldTag::__skip_leading_rows),
                            "skip_leading_rows" => Ok(__FieldTag::__skip_leading_rows),
                            "range" => Ok(__FieldTag::__range),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GoogleSheetsOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GoogleSheetsOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__skip_leading_rows => {
                            if !fields.insert(__FieldTag::__skip_leading_rows) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for skip_leading_rows",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.skip_leading_rows = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__range => {
                            if !fields.insert(__FieldTag::__range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for range",
                                ));
                            }
                            result.range = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GoogleSheetsOptions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.skip_leading_rows.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("skipLeadingRows", &__With(&self.skip_leading_rows))?;
        }
        if !self.range.is_empty() {
            state.serialize_entry("range", &self.range)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ExternalDataConfiguration {
    /// [Required] The fully-qualified URIs that point to your data in Google
    /// Cloud. For Google Cloud Storage URIs:
    /// Each URI can contain one '*' wildcard character and it must come after
    /// the 'bucket' name.
    /// Size limits related to load jobs apply to external data sources.
    /// For Google Cloud Bigtable URIs:
    /// Exactly one URI can be specified and it has be a fully specified and
    /// valid HTTPS URL for a Google Cloud Bigtable table.
    /// For Google Cloud Datastore backups, exactly one URI can be specified. Also,
    /// the '*' wildcard character is not allowed.
    pub source_uris: std::vec::Vec<std::string::String>,

    /// Optional. Specifies how source URIs are interpreted for constructing the
    /// file set to load.  By default source URIs are expanded against the
    /// underlying storage.  Other options include specifying manifest files. Only
    /// applicable to object storage systems.
    pub file_set_spec_type: crate::model::FileSetSpecType,

    /// Optional. The schema for the data.
    /// Schema is required for CSV and JSON formats if autodetect is not on.
    /// Schema is disallowed for Google Cloud Bigtable, Cloud Datastore backups,
    /// Avro, ORC and Parquet formats.
    pub schema: std::option::Option<crate::model::TableSchema>,

    /// [Required] The data format.
    /// For CSV files, specify "CSV".
    /// For Google sheets, specify "GOOGLE_SHEETS".
    /// For newline-delimited JSON, specify "NEWLINE_DELIMITED_JSON".
    /// For Avro files, specify "AVRO".
    /// For Google Cloud Datastore backups, specify "DATASTORE_BACKUP".
    /// For Apache Iceberg tables, specify "ICEBERG".
    /// For ORC files, specify "ORC".
    /// For Parquet files, specify "PARQUET".
    /// [Beta] For Google Cloud Bigtable, specify "BIGTABLE".
    pub source_format: std::string::String,

    /// Optional. The maximum number of bad records that BigQuery can ignore when
    /// reading data. If the number of bad records exceeds this value, an invalid
    /// error is returned in the job result. The default value is 0, which requires
    /// that all records are valid. This setting is ignored for Google Cloud
    /// Bigtable, Google Cloud Datastore backups, Avro, ORC and Parquet formats.
    pub max_bad_records: std::option::Option<wkt::Int32Value>,

    /// Try to detect schema and format options automatically.
    /// Any option specified explicitly will be honored.
    pub autodetect: std::option::Option<wkt::BoolValue>,

    /// Optional. Indicates if BigQuery should allow extra values that are not
    /// represented in the table schema.
    /// If true, the extra values are ignored.
    /// If false, records with extra columns are treated as bad records, and if
    /// there are too many bad records, an invalid error is returned in the job
    /// result.
    /// The default value is false.
    /// The sourceFormat property determines what BigQuery treats as an extra
    /// value:
    /// CSV: Trailing columns
    /// JSON: Named values that don't match any column names
    /// Google Cloud Bigtable: This setting is ignored.
    /// Google Cloud Datastore backups: This setting is ignored.
    /// Avro: This setting is ignored.
    /// ORC: This setting is ignored.
    /// Parquet: This setting is ignored.
    pub ignore_unknown_values: std::option::Option<wkt::BoolValue>,

    /// Optional. The compression type of the data source.
    /// Possible values include GZIP and NONE. The default value is NONE.
    /// This setting is ignored for Google Cloud Bigtable, Google Cloud Datastore
    /// backups, Avro, ORC and Parquet
    /// formats. An empty string is an invalid value.
    pub compression: std::string::String,

    /// Optional. Additional properties to set if sourceFormat is set to CSV.
    pub csv_options: std::option::Option<crate::model::CsvOptions>,

    /// Optional. Additional properties to set if sourceFormat is set to JSON.
    pub json_options: std::option::Option<crate::model::JsonOptions>,

    /// Optional. Additional options if sourceFormat is set to BIGTABLE.
    pub bigtable_options: std::option::Option<crate::model::BigtableOptions>,

    /// Optional. Additional options if sourceFormat is set to GOOGLE_SHEETS.
    pub google_sheets_options: std::option::Option<crate::model::GoogleSheetsOptions>,

    /// Optional. When set, configures hive partitioning support. Not all storage
    /// formats support hive partitioning -- requesting hive partitioning on an
    /// unsupported format will lead to an error, as will providing an invalid
    /// specification.
    pub hive_partitioning_options: std::option::Option<crate::model::HivePartitioningOptions>,

    /// Optional. The connection specifying the credentials to be used to read
    /// external storage, such as Azure Blob, Cloud Storage, or S3. The
    /// connection_id can have the form
    /// `{project_id}.{location_id};{connection_id}` or
    /// `projects/{project_id}/locations/{location_id}/connections/{connection_id}`.
    pub connection_id: std::string::String,

    /// Defines the list of possible SQL data types to which the source decimal
    /// values are converted. This list and the precision and the scale parameters
    /// of the decimal field determine the target type. In the order of NUMERIC,
    /// BIGNUMERIC, and STRING, a
    /// type is picked if it is in the specified list and if it supports the
    /// precision and the scale. STRING supports all precision and scale values.
    /// If none of the listed types supports the precision and the scale, the type
    /// supporting the widest range in the specified list is picked, and if a value
    /// exceeds the supported range when reading the data, an error will be thrown.
    ///
    /// Example: Suppose the value of this field is ["NUMERIC", "BIGNUMERIC"].
    /// If (precision,scale) is:
    ///
    /// * (38,9) -> NUMERIC;
    /// * (39,9) -> BIGNUMERIC (NUMERIC cannot hold 30 integer digits);
    /// * (38,10) -> BIGNUMERIC (NUMERIC cannot hold 10 fractional digits);
    /// * (76,38) -> BIGNUMERIC;
    /// * (77,38) -> BIGNUMERIC (error if value exceeds supported range).
    ///
    /// This field cannot contain duplicate types. The order of the types in this
    /// field is ignored. For example, ["BIGNUMERIC", "NUMERIC"] is the same as
    /// ["NUMERIC", "BIGNUMERIC"] and NUMERIC always takes precedence over
    /// BIGNUMERIC.
    ///
    /// Defaults to ["NUMERIC", "STRING"] for ORC and ["NUMERIC"] for the other
    /// file formats.
    pub decimal_target_types: std::vec::Vec<crate::model::DecimalTargetType>,

    /// Optional. Additional properties to set if sourceFormat is set to AVRO.
    pub avro_options: std::option::Option<crate::model::AvroOptions>,

    /// Optional. Load option to be used together with source_format
    /// newline-delimited JSON to indicate that a variant of JSON is being loaded.
    /// To load newline-delimited GeoJSON, specify GEOJSON (and source_format must
    /// be set to NEWLINE_DELIMITED_JSON).
    pub json_extension: crate::model::JsonExtension,

    /// Optional. Additional properties to set if sourceFormat is set to PARQUET.
    pub parquet_options: std::option::Option<crate::model::ParquetOptions>,

    /// Optional. ObjectMetadata is used to create Object Tables. Object Tables
    /// contain a listing of objects (with their metadata) found at the
    /// source_uris. If ObjectMetadata is set, source_format should be omitted.
    ///
    /// Currently SIMPLE is the only supported Object Metadata type.
    pub object_metadata:
        std::option::Option<crate::model::external_data_configuration::ObjectMetadata>,

    /// Optional. When creating an external table, the user can provide a reference
    /// file with the table schema. This is enabled for the following formats:
    /// AVRO, PARQUET, ORC.
    pub reference_file_schema_uri: std::option::Option<wkt::StringValue>,

    /// Optional. Metadata Cache Mode for the table. Set this to enable caching of
    /// metadata from external data source.
    pub metadata_cache_mode: crate::model::external_data_configuration::MetadataCacheMode,

    /// Optional. Time zone used when parsing timestamp values that do not have
    /// specific time zone information (e.g. 2024-04-20 12:34:56). The expected
    /// format is a IANA timezone string (e.g. America/Los_Angeles).
    pub time_zone: std::option::Option<std::string::String>,

    /// Optional. Format used to parse DATE values. Supports C-style and SQL-style
    /// values.
    pub date_format: std::option::Option<std::string::String>,

    /// Optional. Format used to parse DATETIME values. Supports C-style and
    /// SQL-style values.
    pub datetime_format: std::option::Option<std::string::String>,

    /// Optional. Format used to parse TIME values. Supports C-style and SQL-style
    /// values.
    pub time_format: std::option::Option<std::string::String>,

    /// Optional. Format used to parse TIMESTAMP values. Supports C-style and
    /// SQL-style values.
    pub timestamp_format: std::option::Option<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExternalDataConfiguration {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_uris][crate::model::ExternalDataConfiguration::source_uris].
    pub fn set_source_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.source_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [file_set_spec_type][crate::model::ExternalDataConfiguration::file_set_spec_type].
    pub fn set_file_set_spec_type<T: std::convert::Into<crate::model::FileSetSpecType>>(
        mut self,
        v: T,
    ) -> Self {
        self.file_set_spec_type = v.into();
        self
    }

    /// Sets the value of [schema][crate::model::ExternalDataConfiguration::schema].
    pub fn set_schema<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TableSchema>,
    {
        self.schema = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [schema][crate::model::ExternalDataConfiguration::schema].
    pub fn set_or_clear_schema<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TableSchema>,
    {
        self.schema = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_format][crate::model::ExternalDataConfiguration::source_format].
    pub fn set_source_format<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_format = v.into();
        self
    }

    /// Sets the value of [max_bad_records][crate::model::ExternalDataConfiguration::max_bad_records].
    pub fn set_max_bad_records<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int32Value>,
    {
        self.max_bad_records = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [max_bad_records][crate::model::ExternalDataConfiguration::max_bad_records].
    pub fn set_or_clear_max_bad_records<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int32Value>,
    {
        self.max_bad_records = v.map(|x| x.into());
        self
    }

    /// Sets the value of [autodetect][crate::model::ExternalDataConfiguration::autodetect].
    pub fn set_autodetect<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.autodetect = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [autodetect][crate::model::ExternalDataConfiguration::autodetect].
    pub fn set_or_clear_autodetect<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.autodetect = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ignore_unknown_values][crate::model::ExternalDataConfiguration::ignore_unknown_values].
    pub fn set_ignore_unknown_values<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.ignore_unknown_values = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ignore_unknown_values][crate::model::ExternalDataConfiguration::ignore_unknown_values].
    pub fn set_or_clear_ignore_unknown_values<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.ignore_unknown_values = v.map(|x| x.into());
        self
    }

    /// Sets the value of [compression][crate::model::ExternalDataConfiguration::compression].
    pub fn set_compression<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.compression = v.into();
        self
    }

    /// Sets the value of [csv_options][crate::model::ExternalDataConfiguration::csv_options].
    pub fn set_csv_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CsvOptions>,
    {
        self.csv_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [csv_options][crate::model::ExternalDataConfiguration::csv_options].
    pub fn set_or_clear_csv_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CsvOptions>,
    {
        self.csv_options = v.map(|x| x.into());
        self
    }

    /// Sets the value of [json_options][crate::model::ExternalDataConfiguration::json_options].
    pub fn set_json_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::JsonOptions>,
    {
        self.json_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [json_options][crate::model::ExternalDataConfiguration::json_options].
    pub fn set_or_clear_json_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::JsonOptions>,
    {
        self.json_options = v.map(|x| x.into());
        self
    }

    /// Sets the value of [bigtable_options][crate::model::ExternalDataConfiguration::bigtable_options].
    pub fn set_bigtable_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BigtableOptions>,
    {
        self.bigtable_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [bigtable_options][crate::model::ExternalDataConfiguration::bigtable_options].
    pub fn set_or_clear_bigtable_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BigtableOptions>,
    {
        self.bigtable_options = v.map(|x| x.into());
        self
    }

    /// Sets the value of [google_sheets_options][crate::model::ExternalDataConfiguration::google_sheets_options].
    pub fn set_google_sheets_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GoogleSheetsOptions>,
    {
        self.google_sheets_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [google_sheets_options][crate::model::ExternalDataConfiguration::google_sheets_options].
    pub fn set_or_clear_google_sheets_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GoogleSheetsOptions>,
    {
        self.google_sheets_options = v.map(|x| x.into());
        self
    }

    /// Sets the value of [hive_partitioning_options][crate::model::ExternalDataConfiguration::hive_partitioning_options].
    pub fn set_hive_partitioning_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::HivePartitioningOptions>,
    {
        self.hive_partitioning_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [hive_partitioning_options][crate::model::ExternalDataConfiguration::hive_partitioning_options].
    pub fn set_or_clear_hive_partitioning_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::HivePartitioningOptions>,
    {
        self.hive_partitioning_options = v.map(|x| x.into());
        self
    }

    /// Sets the value of [connection_id][crate::model::ExternalDataConfiguration::connection_id].
    pub fn set_connection_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.connection_id = v.into();
        self
    }

    /// Sets the value of [decimal_target_types][crate::model::ExternalDataConfiguration::decimal_target_types].
    pub fn set_decimal_target_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DecimalTargetType>,
    {
        use std::iter::Iterator;
        self.decimal_target_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [avro_options][crate::model::ExternalDataConfiguration::avro_options].
    pub fn set_avro_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AvroOptions>,
    {
        self.avro_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [avro_options][crate::model::ExternalDataConfiguration::avro_options].
    pub fn set_or_clear_avro_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AvroOptions>,
    {
        self.avro_options = v.map(|x| x.into());
        self
    }

    /// Sets the value of [json_extension][crate::model::ExternalDataConfiguration::json_extension].
    pub fn set_json_extension<T: std::convert::Into<crate::model::JsonExtension>>(
        mut self,
        v: T,
    ) -> Self {
        self.json_extension = v.into();
        self
    }

    /// Sets the value of [parquet_options][crate::model::ExternalDataConfiguration::parquet_options].
    pub fn set_parquet_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ParquetOptions>,
    {
        self.parquet_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [parquet_options][crate::model::ExternalDataConfiguration::parquet_options].
    pub fn set_or_clear_parquet_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ParquetOptions>,
    {
        self.parquet_options = v.map(|x| x.into());
        self
    }

    /// Sets the value of [object_metadata][crate::model::ExternalDataConfiguration::object_metadata].
    pub fn set_object_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::external_data_configuration::ObjectMetadata>,
    {
        self.object_metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [object_metadata][crate::model::ExternalDataConfiguration::object_metadata].
    pub fn set_or_clear_object_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::external_data_configuration::ObjectMetadata>,
    {
        self.object_metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [reference_file_schema_uri][crate::model::ExternalDataConfiguration::reference_file_schema_uri].
    pub fn set_reference_file_schema_uri<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.reference_file_schema_uri = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [reference_file_schema_uri][crate::model::ExternalDataConfiguration::reference_file_schema_uri].
    pub fn set_or_clear_reference_file_schema_uri<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.reference_file_schema_uri = v.map(|x| x.into());
        self
    }

    /// Sets the value of [metadata_cache_mode][crate::model::ExternalDataConfiguration::metadata_cache_mode].
    pub fn set_metadata_cache_mode<
        T: std::convert::Into<crate::model::external_data_configuration::MetadataCacheMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metadata_cache_mode = v.into();
        self
    }

    /// Sets the value of [time_zone][crate::model::ExternalDataConfiguration::time_zone].
    pub fn set_time_zone<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.time_zone = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [time_zone][crate::model::ExternalDataConfiguration::time_zone].
    pub fn set_or_clear_time_zone<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.time_zone = v.map(|x| x.into());
        self
    }

    /// Sets the value of [date_format][crate::model::ExternalDataConfiguration::date_format].
    pub fn set_date_format<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.date_format = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [date_format][crate::model::ExternalDataConfiguration::date_format].
    pub fn set_or_clear_date_format<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.date_format = v.map(|x| x.into());
        self
    }

    /// Sets the value of [datetime_format][crate::model::ExternalDataConfiguration::datetime_format].
    pub fn set_datetime_format<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.datetime_format = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [datetime_format][crate::model::ExternalDataConfiguration::datetime_format].
    pub fn set_or_clear_datetime_format<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.datetime_format = v.map(|x| x.into());
        self
    }

    /// Sets the value of [time_format][crate::model::ExternalDataConfiguration::time_format].
    pub fn set_time_format<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.time_format = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [time_format][crate::model::ExternalDataConfiguration::time_format].
    pub fn set_or_clear_time_format<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.time_format = v.map(|x| x.into());
        self
    }

    /// Sets the value of [timestamp_format][crate::model::ExternalDataConfiguration::timestamp_format].
    pub fn set_timestamp_format<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.timestamp_format = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [timestamp_format][crate::model::ExternalDataConfiguration::timestamp_format].
    pub fn set_or_clear_timestamp_format<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.timestamp_format = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ExternalDataConfiguration {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ExternalDataConfiguration"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExternalDataConfiguration {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source_uris,
            __file_set_spec_type,
            __schema,
            __source_format,
            __max_bad_records,
            __autodetect,
            __ignore_unknown_values,
            __compression,
            __csv_options,
            __json_options,
            __bigtable_options,
            __google_sheets_options,
            __hive_partitioning_options,
            __connection_id,
            __decimal_target_types,
            __avro_options,
            __json_extension,
            __parquet_options,
            __object_metadata,
            __reference_file_schema_uri,
            __metadata_cache_mode,
            __time_zone,
            __date_format,
            __datetime_format,
            __time_format,
            __timestamp_format,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExternalDataConfiguration")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sourceUris" => Ok(__FieldTag::__source_uris),
                            "source_uris" => Ok(__FieldTag::__source_uris),
                            "fileSetSpecType" => Ok(__FieldTag::__file_set_spec_type),
                            "file_set_spec_type" => Ok(__FieldTag::__file_set_spec_type),
                            "schema" => Ok(__FieldTag::__schema),
                            "sourceFormat" => Ok(__FieldTag::__source_format),
                            "source_format" => Ok(__FieldTag::__source_format),
                            "maxBadRecords" => Ok(__FieldTag::__max_bad_records),
                            "max_bad_records" => Ok(__FieldTag::__max_bad_records),
                            "autodetect" => Ok(__FieldTag::__autodetect),
                            "ignoreUnknownValues" => Ok(__FieldTag::__ignore_unknown_values),
                            "ignore_unknown_values" => Ok(__FieldTag::__ignore_unknown_values),
                            "compression" => Ok(__FieldTag::__compression),
                            "csvOptions" => Ok(__FieldTag::__csv_options),
                            "csv_options" => Ok(__FieldTag::__csv_options),
                            "jsonOptions" => Ok(__FieldTag::__json_options),
                            "json_options" => Ok(__FieldTag::__json_options),
                            "bigtableOptions" => Ok(__FieldTag::__bigtable_options),
                            "bigtable_options" => Ok(__FieldTag::__bigtable_options),
                            "googleSheetsOptions" => Ok(__FieldTag::__google_sheets_options),
                            "google_sheets_options" => Ok(__FieldTag::__google_sheets_options),
                            "hivePartitioningOptions" => {
                                Ok(__FieldTag::__hive_partitioning_options)
                            }
                            "hive_partitioning_options" => {
                                Ok(__FieldTag::__hive_partitioning_options)
                            }
                            "connectionId" => Ok(__FieldTag::__connection_id),
                            "connection_id" => Ok(__FieldTag::__connection_id),
                            "decimalTargetTypes" => Ok(__FieldTag::__decimal_target_types),
                            "decimal_target_types" => Ok(__FieldTag::__decimal_target_types),
                            "avroOptions" => Ok(__FieldTag::__avro_options),
                            "avro_options" => Ok(__FieldTag::__avro_options),
                            "jsonExtension" => Ok(__FieldTag::__json_extension),
                            "json_extension" => Ok(__FieldTag::__json_extension),
                            "parquetOptions" => Ok(__FieldTag::__parquet_options),
                            "parquet_options" => Ok(__FieldTag::__parquet_options),
                            "objectMetadata" => Ok(__FieldTag::__object_metadata),
                            "object_metadata" => Ok(__FieldTag::__object_metadata),
                            "referenceFileSchemaUri" => Ok(__FieldTag::__reference_file_schema_uri),
                            "reference_file_schema_uri" => {
                                Ok(__FieldTag::__reference_file_schema_uri)
                            }
                            "metadataCacheMode" => Ok(__FieldTag::__metadata_cache_mode),
                            "metadata_cache_mode" => Ok(__FieldTag::__metadata_cache_mode),
                            "timeZone" => Ok(__FieldTag::__time_zone),
                            "time_zone" => Ok(__FieldTag::__time_zone),
                            "dateFormat" => Ok(__FieldTag::__date_format),
                            "date_format" => Ok(__FieldTag::__date_format),
                            "datetimeFormat" => Ok(__FieldTag::__datetime_format),
                            "datetime_format" => Ok(__FieldTag::__datetime_format),
                            "timeFormat" => Ok(__FieldTag::__time_format),
                            "time_format" => Ok(__FieldTag::__time_format),
                            "timestampFormat" => Ok(__FieldTag::__timestamp_format),
                            "timestamp_format" => Ok(__FieldTag::__timestamp_format),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExternalDataConfiguration;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExternalDataConfiguration")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source_uris => {
                            if !fields.insert(__FieldTag::__source_uris) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_uris",
                                ));
                            }
                            result.source_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__file_set_spec_type => {
                            if !fields.insert(__FieldTag::__file_set_spec_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_set_spec_type",
                                ));
                            }
                            result.file_set_spec_type = map
                                .next_value::<std::option::Option<crate::model::FileSetSpecType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__schema => {
                            if !fields.insert(__FieldTag::__schema) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schema",
                                ));
                            }
                            result.schema =
                                map.next_value::<std::option::Option<crate::model::TableSchema>>()?;
                        }
                        __FieldTag::__source_format => {
                            if !fields.insert(__FieldTag::__source_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_format",
                                ));
                            }
                            result.source_format = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__max_bad_records => {
                            if !fields.insert(__FieldTag::__max_bad_records) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_bad_records",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int32Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_bad_records = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__autodetect => {
                            if !fields.insert(__FieldTag::__autodetect) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autodetect",
                                ));
                            }
                            result.autodetect =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__ignore_unknown_values => {
                            if !fields.insert(__FieldTag::__ignore_unknown_values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ignore_unknown_values",
                                ));
                            }
                            result.ignore_unknown_values =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__compression => {
                            if !fields.insert(__FieldTag::__compression) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compression",
                                ));
                            }
                            result.compression = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__csv_options => {
                            if !fields.insert(__FieldTag::__csv_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for csv_options",
                                ));
                            }
                            result.csv_options =
                                map.next_value::<std::option::Option<crate::model::CsvOptions>>()?;
                        }
                        __FieldTag::__json_options => {
                            if !fields.insert(__FieldTag::__json_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for json_options",
                                ));
                            }
                            result.json_options =
                                map.next_value::<std::option::Option<crate::model::JsonOptions>>()?;
                        }
                        __FieldTag::__bigtable_options => {
                            if !fields.insert(__FieldTag::__bigtable_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bigtable_options",
                                ));
                            }
                            result.bigtable_options = map
                                .next_value::<std::option::Option<crate::model::BigtableOptions>>(
                                )?;
                        }
                        __FieldTag::__google_sheets_options => {
                            if !fields.insert(__FieldTag::__google_sheets_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for google_sheets_options",
                                ));
                            }
                            result.google_sheets_options = map.next_value::<std::option::Option<crate::model::GoogleSheetsOptions>>()?
                                ;
                        }
                        __FieldTag::__hive_partitioning_options => {
                            if !fields.insert(__FieldTag::__hive_partitioning_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hive_partitioning_options",
                                ));
                            }
                            result.hive_partitioning_options = map.next_value::<std::option::Option<crate::model::HivePartitioningOptions>>()?
                                ;
                        }
                        __FieldTag::__connection_id => {
                            if !fields.insert(__FieldTag::__connection_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection_id",
                                ));
                            }
                            result.connection_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__decimal_target_types => {
                            if !fields.insert(__FieldTag::__decimal_target_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for decimal_target_types",
                                ));
                            }
                            result.decimal_target_types =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::DecimalTargetType>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__avro_options => {
                            if !fields.insert(__FieldTag::__avro_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for avro_options",
                                ));
                            }
                            result.avro_options =
                                map.next_value::<std::option::Option<crate::model::AvroOptions>>()?;
                        }
                        __FieldTag::__json_extension => {
                            if !fields.insert(__FieldTag::__json_extension) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for json_extension",
                                ));
                            }
                            result.json_extension = map
                                .next_value::<std::option::Option<crate::model::JsonExtension>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parquet_options => {
                            if !fields.insert(__FieldTag::__parquet_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parquet_options",
                                ));
                            }
                            result.parquet_options = map
                                .next_value::<std::option::Option<crate::model::ParquetOptions>>(
                                )?;
                        }
                        __FieldTag::__object_metadata => {
                            if !fields.insert(__FieldTag::__object_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for object_metadata",
                                ));
                            }
                            result.object_metadata = map.next_value::<std::option::Option<
                                crate::model::external_data_configuration::ObjectMetadata,
                            >>()?;
                        }
                        __FieldTag::__reference_file_schema_uri => {
                            if !fields.insert(__FieldTag::__reference_file_schema_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reference_file_schema_uri",
                                ));
                            }
                            result.reference_file_schema_uri =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::__metadata_cache_mode => {
                            if !fields.insert(__FieldTag::__metadata_cache_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata_cache_mode",
                                ));
                            }
                            result.metadata_cache_mode = map
                                .next_value::<std::option::Option<
                                    crate::model::external_data_configuration::MetadataCacheMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__time_zone => {
                            if !fields.insert(__FieldTag::__time_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_zone",
                                ));
                            }
                            result.time_zone =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__date_format => {
                            if !fields.insert(__FieldTag::__date_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for date_format",
                                ));
                            }
                            result.date_format =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__datetime_format => {
                            if !fields.insert(__FieldTag::__datetime_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for datetime_format",
                                ));
                            }
                            result.datetime_format =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__time_format => {
                            if !fields.insert(__FieldTag::__time_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_format",
                                ));
                            }
                            result.time_format =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__timestamp_format => {
                            if !fields.insert(__FieldTag::__timestamp_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timestamp_format",
                                ));
                            }
                            result.timestamp_format =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExternalDataConfiguration {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.source_uris.is_empty() {
            state.serialize_entry("sourceUris", &self.source_uris)?;
        }
        if !wkt::internal::is_default(&self.file_set_spec_type) {
            state.serialize_entry("fileSetSpecType", &self.file_set_spec_type)?;
        }
        if self.schema.is_some() {
            state.serialize_entry("schema", &self.schema)?;
        }
        if !self.source_format.is_empty() {
            state.serialize_entry("sourceFormat", &self.source_format)?;
        }
        if self.max_bad_records.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int32Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("maxBadRecords", &__With(&self.max_bad_records))?;
        }
        if self.autodetect.is_some() {
            state.serialize_entry("autodetect", &self.autodetect)?;
        }
        if self.ignore_unknown_values.is_some() {
            state.serialize_entry("ignoreUnknownValues", &self.ignore_unknown_values)?;
        }
        if !self.compression.is_empty() {
            state.serialize_entry("compression", &self.compression)?;
        }
        if self.csv_options.is_some() {
            state.serialize_entry("csvOptions", &self.csv_options)?;
        }
        if self.json_options.is_some() {
            state.serialize_entry("jsonOptions", &self.json_options)?;
        }
        if self.bigtable_options.is_some() {
            state.serialize_entry("bigtableOptions", &self.bigtable_options)?;
        }
        if self.google_sheets_options.is_some() {
            state.serialize_entry("googleSheetsOptions", &self.google_sheets_options)?;
        }
        if self.hive_partitioning_options.is_some() {
            state.serialize_entry("hivePartitioningOptions", &self.hive_partitioning_options)?;
        }
        if !self.connection_id.is_empty() {
            state.serialize_entry("connectionId", &self.connection_id)?;
        }
        if !self.decimal_target_types.is_empty() {
            state.serialize_entry("decimalTargetTypes", &self.decimal_target_types)?;
        }
        if self.avro_options.is_some() {
            state.serialize_entry("avroOptions", &self.avro_options)?;
        }
        if !wkt::internal::is_default(&self.json_extension) {
            state.serialize_entry("jsonExtension", &self.json_extension)?;
        }
        if self.parquet_options.is_some() {
            state.serialize_entry("parquetOptions", &self.parquet_options)?;
        }
        if self.object_metadata.is_some() {
            state.serialize_entry("objectMetadata", &self.object_metadata)?;
        }
        if self.reference_file_schema_uri.is_some() {
            state.serialize_entry("referenceFileSchemaUri", &self.reference_file_schema_uri)?;
        }
        if !wkt::internal::is_default(&self.metadata_cache_mode) {
            state.serialize_entry("metadataCacheMode", &self.metadata_cache_mode)?;
        }
        if self.time_zone.is_some() {
            state.serialize_entry("timeZone", &self.time_zone)?;
        }
        if self.date_format.is_some() {
            state.serialize_entry("dateFormat", &self.date_format)?;
        }
        if self.datetime_format.is_some() {
            state.serialize_entry("datetimeFormat", &self.datetime_format)?;
        }
        if self.time_format.is_some() {
            state.serialize_entry("timeFormat", &self.time_format)?;
        }
        if self.timestamp_format.is_some() {
            state.serialize_entry("timestampFormat", &self.timestamp_format)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ExternalDataConfiguration].
pub mod external_data_configuration {
    #[allow(unused_imports)]
    use super::*;

    /// Supported Object Metadata Types.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ObjectMetadata {
        /// Unspecified by default.
        Unspecified,
        /// A synonym for `SIMPLE`.
        Directory,
        /// Directory listing of objects.
        Simple,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ObjectMetadata::value] or
        /// [ObjectMetadata::name].
        UnknownValue(object_metadata::UnknownValue),
    }

    #[doc(hidden)]
    pub mod object_metadata {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ObjectMetadata {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Directory => std::option::Option::Some(1),
                Self::Simple => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("OBJECT_METADATA_UNSPECIFIED"),
                Self::Directory => std::option::Option::Some("DIRECTORY"),
                Self::Simple => std::option::Option::Some("SIMPLE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ObjectMetadata {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ObjectMetadata {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ObjectMetadata {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Directory,
                2 => Self::Simple,
                _ => Self::UnknownValue(object_metadata::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ObjectMetadata {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "OBJECT_METADATA_UNSPECIFIED" => Self::Unspecified,
                "DIRECTORY" => Self::Directory,
                "SIMPLE" => Self::Simple,
                _ => Self::UnknownValue(object_metadata::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ObjectMetadata {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Directory => serializer.serialize_i32(1),
                Self::Simple => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ObjectMetadata {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ObjectMetadata>::new(
                ".google.cloud.bigquery.v2.ExternalDataConfiguration.ObjectMetadata",
            ))
        }
    }

    /// MetadataCacheMode identifies if the table should use metadata caching for
    /// files from external source (eg Google Cloud Storage).
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MetadataCacheMode {
        /// Unspecified metadata cache mode.
        Unspecified,
        /// Set this mode to trigger automatic background refresh of metadata cache
        /// from the external source. Queries will use the latest available cache
        /// version within the table's maxStaleness interval.
        Automatic,
        /// Set this mode to enable triggering manual refresh of the metadata cache
        /// from external source. Queries will use the latest manually triggered
        /// cache version within the table's maxStaleness interval.
        Manual,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MetadataCacheMode::value] or
        /// [MetadataCacheMode::name].
        UnknownValue(metadata_cache_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod metadata_cache_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl MetadataCacheMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Automatic => std::option::Option::Some(1),
                Self::Manual => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("METADATA_CACHE_MODE_UNSPECIFIED"),
                Self::Automatic => std::option::Option::Some("AUTOMATIC"),
                Self::Manual => std::option::Option::Some("MANUAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for MetadataCacheMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for MetadataCacheMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for MetadataCacheMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Automatic,
                2 => Self::Manual,
                _ => Self::UnknownValue(metadata_cache_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for MetadataCacheMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "METADATA_CACHE_MODE_UNSPECIFIED" => Self::Unspecified,
                "AUTOMATIC" => Self::Automatic,
                "MANUAL" => Self::Manual,
                _ => Self::UnknownValue(metadata_cache_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for MetadataCacheMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Automatic => serializer.serialize_i32(1),
                Self::Manual => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for MetadataCacheMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MetadataCacheMode>::new(
                ".google.cloud.bigquery.v2.ExternalDataConfiguration.MetadataCacheMode",
            ))
        }
    }
}

/// Configures the access a dataset defined in an external metadata storage.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ExternalDatasetReference {
    /// Required. External source that backs this dataset.
    pub external_source: std::string::String,

    /// Required. The connection id that is used to access the external_source.
    ///
    /// Format:
    /// projects/{project_id}/locations/{location_id}/connections/{connection_id}
    pub connection: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExternalDatasetReference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [external_source][crate::model::ExternalDatasetReference::external_source].
    pub fn set_external_source<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.external_source = v.into();
        self
    }

    /// Sets the value of [connection][crate::model::ExternalDatasetReference::connection].
    pub fn set_connection<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.connection = v.into();
        self
    }
}

impl wkt::message::Message for ExternalDatasetReference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ExternalDatasetReference"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExternalDatasetReference {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __external_source,
            __connection,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExternalDatasetReference")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "externalSource" => Ok(__FieldTag::__external_source),
                            "external_source" => Ok(__FieldTag::__external_source),
                            "connection" => Ok(__FieldTag::__connection),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExternalDatasetReference;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExternalDatasetReference")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__external_source => {
                            if !fields.insert(__FieldTag::__external_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_source",
                                ));
                            }
                            result.external_source = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__connection => {
                            if !fields.insert(__FieldTag::__connection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection",
                                ));
                            }
                            result.connection = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExternalDatasetReference {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.external_source.is_empty() {
            state.serialize_entry("externalSource", &self.external_source)?;
        }
        if !self.connection.is_empty() {
            state.serialize_entry("connection", &self.connection)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Options for configuring hive partitioning detect.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct HivePartitioningOptions {
    /// Optional. When set, what mode of hive partitioning to use when reading
    /// data.  The following modes are supported:
    ///
    /// * AUTO: automatically infer partition key name(s) and type(s).
    ///
    /// * STRINGS: automatically infer partition key name(s).  All types are
    ///   strings.
    ///
    /// * CUSTOM: partition key schema is encoded in the source URI prefix.
    ///
    ///
    /// Not all storage formats support hive partitioning. Requesting hive
    /// partitioning on an unsupported format will lead to an error.
    /// Currently supported formats are: JSON, CSV, ORC, Avro and Parquet.
    pub mode: std::string::String,

    /// Optional. When hive partition detection is requested, a common prefix for
    /// all source uris must be required.  The prefix must end immediately before
    /// the partition key encoding begins. For example, consider files following
    /// this data layout:
    ///
    /// gs://bucket/path_to_table/dt=2019-06-01/country=USA/id=7/file.avro
    ///
    /// gs://bucket/path_to_table/dt=2019-05-31/country=CA/id=3/file.avro
    ///
    /// When hive partitioning is requested with either AUTO or STRINGS detection,
    /// the common prefix can be either of gs://bucket/path_to_table or
    /// gs://bucket/path_to_table/.
    ///
    /// CUSTOM detection requires encoding the partitioning schema immediately
    /// after the common prefix.  For CUSTOM, any of
    ///
    /// * gs://bucket/path_to_table/{dt:DATE}/{country:STRING}/{id:INTEGER}
    ///
    /// * gs://bucket/path_to_table/{dt:STRING}/{country:STRING}/{id:INTEGER}
    ///
    /// * gs://bucket/path_to_table/{dt:DATE}/{country:STRING}/{id:STRING}
    ///
    ///
    /// would all be valid source URI prefixes.
    pub source_uri_prefix: std::string::String,

    /// Optional. If set to true, queries over this table require a partition
    /// filter that can be used for partition elimination to be specified.
    ///
    /// Note that this field should only be true when creating a permanent
    /// external table or querying a temporary external table.
    ///
    /// Hive-partitioned loads with require_partition_filter explicitly set to
    /// true will fail.
    pub require_partition_filter: std::option::Option<wkt::BoolValue>,

    /// Output only. For permanent external tables, this field is populated with
    /// the hive partition keys in the order they were inferred. The types of the
    /// partition keys can be deduced by checking the table schema (which will
    /// include the partition keys). Not every API will populate this field in the
    /// output. For example, Tables.Get will populate it, but Tables.List will not
    /// contain this field.
    pub fields: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HivePartitioningOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mode][crate::model::HivePartitioningOptions::mode].
    pub fn set_mode<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mode = v.into();
        self
    }

    /// Sets the value of [source_uri_prefix][crate::model::HivePartitioningOptions::source_uri_prefix].
    pub fn set_source_uri_prefix<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_uri_prefix = v.into();
        self
    }

    /// Sets the value of [require_partition_filter][crate::model::HivePartitioningOptions::require_partition_filter].
    pub fn set_require_partition_filter<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.require_partition_filter = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [require_partition_filter][crate::model::HivePartitioningOptions::require_partition_filter].
    pub fn set_or_clear_require_partition_filter<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.require_partition_filter = v.map(|x| x.into());
        self
    }

    /// Sets the value of [fields][crate::model::HivePartitioningOptions::fields].
    pub fn set_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.fields = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for HivePartitioningOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.HivePartitioningOptions"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for HivePartitioningOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __mode,
            __source_uri_prefix,
            __require_partition_filter,
            __fields,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HivePartitioningOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "mode" => Ok(__FieldTag::__mode),
                            "sourceUriPrefix" => Ok(__FieldTag::__source_uri_prefix),
                            "source_uri_prefix" => Ok(__FieldTag::__source_uri_prefix),
                            "requirePartitionFilter" => Ok(__FieldTag::__require_partition_filter),
                            "require_partition_filter" => {
                                Ok(__FieldTag::__require_partition_filter)
                            }
                            "fields" => Ok(__FieldTag::__fields),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = HivePartitioningOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HivePartitioningOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__mode => {
                            if !fields.insert(__FieldTag::__mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mode",
                                ));
                            }
                            result.mode = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_uri_prefix => {
                            if !fields.insert(__FieldTag::__source_uri_prefix) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_uri_prefix",
                                ));
                            }
                            result.source_uri_prefix = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__require_partition_filter => {
                            if !fields.insert(__FieldTag::__require_partition_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for require_partition_filter",
                                ));
                            }
                            result.require_partition_filter =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__fields => {
                            if !fields.insert(__FieldTag::__fields) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fields",
                                ));
                            }
                            result.fields = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for HivePartitioningOptions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.mode.is_empty() {
            state.serialize_entry("mode", &self.mode)?;
        }
        if !self.source_uri_prefix.is_empty() {
            state.serialize_entry("sourceUriPrefix", &self.source_uri_prefix)?;
        }
        if self.require_partition_filter.is_some() {
            state.serialize_entry("requirePartitionFilter", &self.require_partition_filter)?;
        }
        if !self.fields.is_empty() {
            state.serialize_entry("fields", &self.fields)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// BigQuery-specific metadata about a location. This will be set on
/// google.cloud.location.Location.metadata in Cloud Location API
/// responses.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LocationMetadata {
    /// The legacy BigQuery location ID, e.g. “EU” for the “europe” location.
    /// This is for any API consumers that need the legacy “US” and “EU” locations.
    pub legacy_location_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LocationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [legacy_location_id][crate::model::LocationMetadata::legacy_location_id].
    pub fn set_legacy_location_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.legacy_location_id = v.into();
        self
    }
}

impl wkt::message::Message for LocationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.LocationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LocationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __legacy_location_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LocationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "legacyLocationId" => Ok(__FieldTag::__legacy_location_id),
                            "legacy_location_id" => Ok(__FieldTag::__legacy_location_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LocationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LocationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__legacy_location_id => {
                            if !fields.insert(__FieldTag::__legacy_location_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for legacy_location_id",
                                ));
                            }
                            result.legacy_location_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LocationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.legacy_location_id.is_empty() {
            state.serialize_entry("legacyLocationId", &self.legacy_location_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Remote Model Info
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RemoteModelInfo {
    /// Output only. Fully qualified name of the user-provided connection object of
    /// the remote model. Format:
    /// ```"projects/{project_id}/locations/{location_id}/connections/{connection_id}"```
    pub connection: std::string::String,

    /// Output only. Max number of rows in each batch sent to the remote service.
    /// If unset, the number of rows in each batch is set dynamically.
    pub max_batching_rows: i64,

    /// Output only. The model version for LLM.
    pub remote_model_version: std::string::String,

    /// Output only. The name of the speech recognizer to use for speech
    /// recognition. The expected format is
    /// `projects/{project}/locations/{location}/recognizers/{recognizer}`.
    /// Customers can specify this field at model creation. If not specified, a
    /// default recognizer `projects/{model
    /// project}/locations/global/recognizers/_` will be used. See more details at
    /// [recognizers](https://cloud.google.com/speech-to-text/v2/docs/reference/rest/v2/projects.locations.recognizers)
    pub speech_recognizer: std::string::String,

    /// Remote services are services outside of BigQuery used by remote models for
    /// predictions. A remote service is backed by either an arbitrary endpoint or
    /// a selected remote service type, but not both.
    pub remote_service: std::option::Option<crate::model::remote_model_info::RemoteService>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RemoteModelInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [connection][crate::model::RemoteModelInfo::connection].
    pub fn set_connection<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.connection = v.into();
        self
    }

    /// Sets the value of [max_batching_rows][crate::model::RemoteModelInfo::max_batching_rows].
    pub fn set_max_batching_rows<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.max_batching_rows = v.into();
        self
    }

    /// Sets the value of [remote_model_version][crate::model::RemoteModelInfo::remote_model_version].
    pub fn set_remote_model_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.remote_model_version = v.into();
        self
    }

    /// Sets the value of [speech_recognizer][crate::model::RemoteModelInfo::speech_recognizer].
    pub fn set_speech_recognizer<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.speech_recognizer = v.into();
        self
    }

    /// Sets the value of [remote_service][crate::model::RemoteModelInfo::remote_service].
    ///
    /// Note that all the setters affecting `remote_service` are mutually
    /// exclusive.
    pub fn set_remote_service<
        T: std::convert::Into<std::option::Option<crate::model::remote_model_info::RemoteService>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.remote_service = v.into();
        self
    }

    /// The value of [remote_service][crate::model::RemoteModelInfo::remote_service]
    /// if it holds a `Endpoint`, `None` if the field is not set or
    /// holds a different branch.
    pub fn endpoint(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.remote_service.as_ref().and_then(|v| match v {
            crate::model::remote_model_info::RemoteService::Endpoint(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [remote_service][crate::model::RemoteModelInfo::remote_service]
    /// to hold a `Endpoint`.
    ///
    /// Note that all the setters affecting `remote_service` are
    /// mutually exclusive.
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.remote_service = std::option::Option::Some(
            crate::model::remote_model_info::RemoteService::Endpoint(v.into()),
        );
        self
    }

    /// The value of [remote_service][crate::model::RemoteModelInfo::remote_service]
    /// if it holds a `RemoteServiceType`, `None` if the field is not set or
    /// holds a different branch.
    pub fn remote_service_type(
        &self,
    ) -> std::option::Option<&crate::model::remote_model_info::RemoteServiceType> {
        #[allow(unreachable_patterns)]
        self.remote_service.as_ref().and_then(|v| match v {
            crate::model::remote_model_info::RemoteService::RemoteServiceType(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [remote_service][crate::model::RemoteModelInfo::remote_service]
    /// to hold a `RemoteServiceType`.
    ///
    /// Note that all the setters affecting `remote_service` are
    /// mutually exclusive.
    pub fn set_remote_service_type<
        T: std::convert::Into<crate::model::remote_model_info::RemoteServiceType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.remote_service = std::option::Option::Some(
            crate::model::remote_model_info::RemoteService::RemoteServiceType(v.into()),
        );
        self
    }
}

impl wkt::message::Message for RemoteModelInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.RemoteModelInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RemoteModelInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __endpoint,
            __remote_service_type,
            __connection,
            __max_batching_rows,
            __remote_model_version,
            __speech_recognizer,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RemoteModelInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "endpoint" => Ok(__FieldTag::__endpoint),
                            "remoteServiceType" => Ok(__FieldTag::__remote_service_type),
                            "remote_service_type" => Ok(__FieldTag::__remote_service_type),
                            "connection" => Ok(__FieldTag::__connection),
                            "maxBatchingRows" => Ok(__FieldTag::__max_batching_rows),
                            "max_batching_rows" => Ok(__FieldTag::__max_batching_rows),
                            "remoteModelVersion" => Ok(__FieldTag::__remote_model_version),
                            "remote_model_version" => Ok(__FieldTag::__remote_model_version),
                            "speechRecognizer" => Ok(__FieldTag::__speech_recognizer),
                            "speech_recognizer" => Ok(__FieldTag::__speech_recognizer),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RemoteModelInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RemoteModelInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__endpoint => {
                            if !fields.insert(__FieldTag::__endpoint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for endpoint",
                                ));
                            }
                            if result.remote_service.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `remote_service`, a oneof with full ID .google.cloud.bigquery.v2.RemoteModelInfo.endpoint, latest field was endpoint",
                                ));
                            }
                            result.remote_service = std::option::Option::Some(
                                crate::model::remote_model_info::RemoteService::Endpoint(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__remote_service_type => {
                            if !fields.insert(__FieldTag::__remote_service_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for remote_service_type",
                                ));
                            }
                            if result.remote_service.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `remote_service`, a oneof with full ID .google.cloud.bigquery.v2.RemoteModelInfo.remote_service_type, latest field was remoteServiceType",
                                ));
                            }
                            result.remote_service = std::option::Option::Some(
                                crate::model::remote_model_info::RemoteService::RemoteServiceType(
                                    map.next_value::<std::option::Option<
                                        crate::model::remote_model_info::RemoteServiceType,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__connection => {
                            if !fields.insert(__FieldTag::__connection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection",
                                ));
                            }
                            result.connection = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__max_batching_rows => {
                            if !fields.insert(__FieldTag::__max_batching_rows) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_batching_rows",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_batching_rows =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__remote_model_version => {
                            if !fields.insert(__FieldTag::__remote_model_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for remote_model_version",
                                ));
                            }
                            result.remote_model_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__speech_recognizer => {
                            if !fields.insert(__FieldTag::__speech_recognizer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for speech_recognizer",
                                ));
                            }
                            result.speech_recognizer = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RemoteModelInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.endpoint() {
            state.serialize_entry("endpoint", value)?;
        }
        if let Some(value) = self.remote_service_type() {
            state.serialize_entry("remoteServiceType", value)?;
        }
        if !self.connection.is_empty() {
            state.serialize_entry("connection", &self.connection)?;
        }
        if !wkt::internal::is_default(&self.max_batching_rows) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxBatchingRows", &__With(&self.max_batching_rows))?;
        }
        if !self.remote_model_version.is_empty() {
            state.serialize_entry("remoteModelVersion", &self.remote_model_version)?;
        }
        if !self.speech_recognizer.is_empty() {
            state.serialize_entry("speechRecognizer", &self.speech_recognizer)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [RemoteModelInfo].
pub mod remote_model_info {
    #[allow(unused_imports)]
    use super::*;

    /// Supported service type for remote model.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RemoteServiceType {
        /// Unspecified remote service type.
        Unspecified,
        /// V3 Cloud AI Translation API. See more details at [Cloud Translation API]
        /// (<https://cloud.google.com/translate/docs/reference/rest>).
        CloudAiTranslateV3,
        /// V1 Cloud AI Vision API See more details at [Cloud Vision API]
        /// (<https://cloud.google.com/vision/docs/reference/rest>).
        CloudAiVisionV1,
        /// V1 Cloud AI Natural Language API. See more details at [REST Resource:
        /// documents](https://cloud.google.com/natural-language/docs/reference/rest/v1/documents).
        CloudAiNaturalLanguageV1,
        /// V2 Speech-to-Text API. See more details at [Google Cloud Speech-to-Text
        /// V2 API](https://cloud.google.com/speech-to-text/v2/docs)
        CloudAiSpeechToTextV2,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RemoteServiceType::value] or
        /// [RemoteServiceType::name].
        UnknownValue(remote_service_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod remote_service_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RemoteServiceType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::CloudAiTranslateV3 => std::option::Option::Some(1),
                Self::CloudAiVisionV1 => std::option::Option::Some(2),
                Self::CloudAiNaturalLanguageV1 => std::option::Option::Some(3),
                Self::CloudAiSpeechToTextV2 => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("REMOTE_SERVICE_TYPE_UNSPECIFIED"),
                Self::CloudAiTranslateV3 => std::option::Option::Some("CLOUD_AI_TRANSLATE_V3"),
                Self::CloudAiVisionV1 => std::option::Option::Some("CLOUD_AI_VISION_V1"),
                Self::CloudAiNaturalLanguageV1 => {
                    std::option::Option::Some("CLOUD_AI_NATURAL_LANGUAGE_V1")
                }
                Self::CloudAiSpeechToTextV2 => {
                    std::option::Option::Some("CLOUD_AI_SPEECH_TO_TEXT_V2")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RemoteServiceType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RemoteServiceType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RemoteServiceType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::CloudAiTranslateV3,
                2 => Self::CloudAiVisionV1,
                3 => Self::CloudAiNaturalLanguageV1,
                7 => Self::CloudAiSpeechToTextV2,
                _ => Self::UnknownValue(remote_service_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RemoteServiceType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "REMOTE_SERVICE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "CLOUD_AI_TRANSLATE_V3" => Self::CloudAiTranslateV3,
                "CLOUD_AI_VISION_V1" => Self::CloudAiVisionV1,
                "CLOUD_AI_NATURAL_LANGUAGE_V1" => Self::CloudAiNaturalLanguageV1,
                "CLOUD_AI_SPEECH_TO_TEXT_V2" => Self::CloudAiSpeechToTextV2,
                _ => Self::UnknownValue(remote_service_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RemoteServiceType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::CloudAiTranslateV3 => serializer.serialize_i32(1),
                Self::CloudAiVisionV1 => serializer.serialize_i32(2),
                Self::CloudAiNaturalLanguageV1 => serializer.serialize_i32(3),
                Self::CloudAiSpeechToTextV2 => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RemoteServiceType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RemoteServiceType>::new(
                ".google.cloud.bigquery.v2.RemoteModelInfo.RemoteServiceType",
            ))
        }
    }

    /// Remote services are services outside of BigQuery used by remote models for
    /// predictions. A remote service is backed by either an arbitrary endpoint or
    /// a selected remote service type, but not both.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RemoteService {
        /// Output only. The endpoint for remote model.
        Endpoint(std::string::String),
        /// Output only. The remote service type for remote model.
        RemoteServiceType(crate::model::remote_model_info::RemoteServiceType),
    }
}

/// Information about a single transform column.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TransformColumn {
    /// Output only. Name of the column.
    pub name: std::string::String,

    /// Output only. Data type of the column after the transform.
    pub r#type: std::option::Option<crate::model::StandardSqlDataType>,

    /// Output only. The SQL expression used in the column transform.
    pub transform_sql: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TransformColumn {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TransformColumn::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::TransformColumn::type].
    pub fn set_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::StandardSqlDataType>,
    {
        self.r#type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [r#type][crate::model::TransformColumn::type].
    pub fn set_or_clear_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::StandardSqlDataType>,
    {
        self.r#type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [transform_sql][crate::model::TransformColumn::transform_sql].
    pub fn set_transform_sql<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.transform_sql = v.into();
        self
    }
}

impl wkt::message::Message for TransformColumn {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.TransformColumn"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TransformColumn {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __type,
            __transform_sql,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TransformColumn")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "type" => Ok(__FieldTag::__type),
                            "transformSql" => Ok(__FieldTag::__transform_sql),
                            "transform_sql" => Ok(__FieldTag::__transform_sql),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TransformColumn;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TransformColumn")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::StandardSqlDataType>>()?
                                ;
                        }
                        __FieldTag::__transform_sql => {
                            if !fields.insert(__FieldTag::__transform_sql) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transform_sql",
                                ));
                            }
                            result.transform_sql = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TransformColumn {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.r#type.is_some() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.transform_sql.is_empty() {
            state.serialize_entry("transformSql", &self.transform_sql)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Model {
    /// Output only. A hash of this resource.
    pub etag: std::string::String,

    /// Required. Unique identifier for this model.
    pub model_reference: std::option::Option<crate::model::ModelReference>,

    /// Output only. The time when this model was created, in millisecs since the
    /// epoch.
    pub creation_time: i64,

    /// Output only. The time when this model was last modified, in millisecs since
    /// the epoch.
    pub last_modified_time: i64,

    /// Optional. A user-friendly description of this model.
    pub description: std::string::String,

    /// Optional. A descriptive name for this model.
    pub friendly_name: std::string::String,

    /// The labels associated with this model. You can use these to organize
    /// and group your models. Label keys and values can be no longer
    /// than 63 characters, can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    /// Label values are optional. Label keys must start with a letter and each
    /// label in the list must have a different key.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. The time when this model expires, in milliseconds since the
    /// epoch. If not present, the model will persist indefinitely. Expired models
    /// will be deleted and their storage reclaimed.  The defaultTableExpirationMs
    /// property of the encapsulating dataset can be used to set a default
    /// expirationTime on newly created models.
    pub expiration_time: i64,

    /// Output only. The geographic location where the model resides. This value
    /// is inherited from the dataset.
    pub location: std::string::String,

    /// Custom encryption configuration (e.g., Cloud KMS keys). This shows the
    /// encryption configuration of the model data while stored in BigQuery
    /// storage. This field can be used with PatchModel to update encryption key
    /// for an already encrypted model.
    pub encryption_configuration: std::option::Option<crate::model::EncryptionConfiguration>,

    /// Output only. Type of the model resource.
    pub model_type: crate::model::model::ModelType,

    /// Information for all training runs in increasing order of start_time.
    pub training_runs: std::vec::Vec<crate::model::model::TrainingRun>,

    /// Output only. Input feature columns for the model inference. If the model is
    /// trained with TRANSFORM clause, these are the input of the TRANSFORM clause.
    pub feature_columns: std::vec::Vec<crate::model::StandardSqlField>,

    /// Output only. Label columns that were used to train this model.
    /// The output of the model will have a "predicted_" prefix to these columns.
    pub label_columns: std::vec::Vec<crate::model::StandardSqlField>,

    /// Output only. This field will be populated if a TRANSFORM clause was used to
    /// train a model. TRANSFORM clause (if used) takes feature_columns as input
    /// and outputs transform_columns. transform_columns then are used to train the
    /// model.
    pub transform_columns: std::vec::Vec<crate::model::TransformColumn>,

    /// Output only. All hyperparameter search spaces in this model.
    pub hparam_search_spaces: std::option::Option<crate::model::model::HparamSearchSpaces>,

    /// Output only. The default trial_id to use in TVFs when the trial_id is not
    /// passed in. For single-objective [hyperparameter
    /// tuning](https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-hp-tuning-overview)
    /// models, this is the best trial ID. For multi-objective [hyperparameter
    /// tuning](https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-hp-tuning-overview)
    /// models, this is the smallest trial ID among all Pareto optimal trials.
    pub default_trial_id: i64,

    /// Output only. Trials of a [hyperparameter
    /// tuning](https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-hp-tuning-overview)
    /// model sorted by trial_id.
    pub hparam_trials: std::vec::Vec<crate::model::model::HparamTuningTrial>,

    /// Output only. For single-objective [hyperparameter
    /// tuning](https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-hp-tuning-overview)
    /// models, it only contains the best trial. For multi-objective
    /// [hyperparameter
    /// tuning](https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-hp-tuning-overview)
    /// models, it contains all Pareto optimal trials sorted by trial_id.
    pub optimal_trial_ids: std::vec::Vec<i64>,

    /// Output only. Remote model info
    pub remote_model_info: std::option::Option<crate::model::RemoteModelInfo>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Model {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [etag][crate::model::Model::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [model_reference][crate::model::Model::model_reference].
    pub fn set_model_reference<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ModelReference>,
    {
        self.model_reference = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [model_reference][crate::model::Model::model_reference].
    pub fn set_or_clear_model_reference<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ModelReference>,
    {
        self.model_reference = v.map(|x| x.into());
        self
    }

    /// Sets the value of [creation_time][crate::model::Model::creation_time].
    pub fn set_creation_time<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.creation_time = v.into();
        self
    }

    /// Sets the value of [last_modified_time][crate::model::Model::last_modified_time].
    pub fn set_last_modified_time<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.last_modified_time = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Model::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [friendly_name][crate::model::Model::friendly_name].
    pub fn set_friendly_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.friendly_name = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Model::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [expiration_time][crate::model::Model::expiration_time].
    pub fn set_expiration_time<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.expiration_time = v.into();
        self
    }

    /// Sets the value of [location][crate::model::Model::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [encryption_configuration][crate::model::Model::encryption_configuration].
    pub fn set_encryption_configuration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionConfiguration>,
    {
        self.encryption_configuration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [encryption_configuration][crate::model::Model::encryption_configuration].
    pub fn set_or_clear_encryption_configuration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionConfiguration>,
    {
        self.encryption_configuration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [model_type][crate::model::Model::model_type].
    pub fn set_model_type<T: std::convert::Into<crate::model::model::ModelType>>(
        mut self,
        v: T,
    ) -> Self {
        self.model_type = v.into();
        self
    }

    /// Sets the value of [training_runs][crate::model::Model::training_runs].
    pub fn set_training_runs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::model::TrainingRun>,
    {
        use std::iter::Iterator;
        self.training_runs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [feature_columns][crate::model::Model::feature_columns].
    pub fn set_feature_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::StandardSqlField>,
    {
        use std::iter::Iterator;
        self.feature_columns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [label_columns][crate::model::Model::label_columns].
    pub fn set_label_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::StandardSqlField>,
    {
        use std::iter::Iterator;
        self.label_columns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [transform_columns][crate::model::Model::transform_columns].
    pub fn set_transform_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TransformColumn>,
    {
        use std::iter::Iterator;
        self.transform_columns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [hparam_search_spaces][crate::model::Model::hparam_search_spaces].
    pub fn set_hparam_search_spaces<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::model::HparamSearchSpaces>,
    {
        self.hparam_search_spaces = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [hparam_search_spaces][crate::model::Model::hparam_search_spaces].
    pub fn set_or_clear_hparam_search_spaces<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::model::HparamSearchSpaces>,
    {
        self.hparam_search_spaces = v.map(|x| x.into());
        self
    }

    /// Sets the value of [default_trial_id][crate::model::Model::default_trial_id].
    pub fn set_default_trial_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.default_trial_id = v.into();
        self
    }

    /// Sets the value of [hparam_trials][crate::model::Model::hparam_trials].
    pub fn set_hparam_trials<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::model::HparamTuningTrial>,
    {
        use std::iter::Iterator;
        self.hparam_trials = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [optimal_trial_ids][crate::model::Model::optimal_trial_ids].
    pub fn set_optimal_trial_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i64>,
    {
        use std::iter::Iterator;
        self.optimal_trial_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [remote_model_info][crate::model::Model::remote_model_info].
    pub fn set_remote_model_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RemoteModelInfo>,
    {
        self.remote_model_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [remote_model_info][crate::model::Model::remote_model_info].
    pub fn set_or_clear_remote_model_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RemoteModelInfo>,
    {
        self.remote_model_info = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Model {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.Model"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Model {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __etag,
            __model_reference,
            __creation_time,
            __last_modified_time,
            __description,
            __friendly_name,
            __labels,
            __expiration_time,
            __location,
            __encryption_configuration,
            __model_type,
            __training_runs,
            __feature_columns,
            __label_columns,
            __transform_columns,
            __hparam_search_spaces,
            __default_trial_id,
            __hparam_trials,
            __optimal_trial_ids,
            __remote_model_info,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Model")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "etag" => Ok(__FieldTag::__etag),
                            "modelReference" => Ok(__FieldTag::__model_reference),
                            "model_reference" => Ok(__FieldTag::__model_reference),
                            "creationTime" => Ok(__FieldTag::__creation_time),
                            "creation_time" => Ok(__FieldTag::__creation_time),
                            "lastModifiedTime" => Ok(__FieldTag::__last_modified_time),
                            "last_modified_time" => Ok(__FieldTag::__last_modified_time),
                            "description" => Ok(__FieldTag::__description),
                            "friendlyName" => Ok(__FieldTag::__friendly_name),
                            "friendly_name" => Ok(__FieldTag::__friendly_name),
                            "labels" => Ok(__FieldTag::__labels),
                            "expirationTime" => Ok(__FieldTag::__expiration_time),
                            "expiration_time" => Ok(__FieldTag::__expiration_time),
                            "location" => Ok(__FieldTag::__location),
                            "encryptionConfiguration" => Ok(__FieldTag::__encryption_configuration),
                            "encryption_configuration" => {
                                Ok(__FieldTag::__encryption_configuration)
                            }
                            "modelType" => Ok(__FieldTag::__model_type),
                            "model_type" => Ok(__FieldTag::__model_type),
                            "trainingRuns" => Ok(__FieldTag::__training_runs),
                            "training_runs" => Ok(__FieldTag::__training_runs),
                            "featureColumns" => Ok(__FieldTag::__feature_columns),
                            "feature_columns" => Ok(__FieldTag::__feature_columns),
                            "labelColumns" => Ok(__FieldTag::__label_columns),
                            "label_columns" => Ok(__FieldTag::__label_columns),
                            "transformColumns" => Ok(__FieldTag::__transform_columns),
                            "transform_columns" => Ok(__FieldTag::__transform_columns),
                            "hparamSearchSpaces" => Ok(__FieldTag::__hparam_search_spaces),
                            "hparam_search_spaces" => Ok(__FieldTag::__hparam_search_spaces),
                            "defaultTrialId" => Ok(__FieldTag::__default_trial_id),
                            "default_trial_id" => Ok(__FieldTag::__default_trial_id),
                            "hparamTrials" => Ok(__FieldTag::__hparam_trials),
                            "hparam_trials" => Ok(__FieldTag::__hparam_trials),
                            "optimalTrialIds" => Ok(__FieldTag::__optimal_trial_ids),
                            "optimal_trial_ids" => Ok(__FieldTag::__optimal_trial_ids),
                            "remoteModelInfo" => Ok(__FieldTag::__remote_model_info),
                            "remote_model_info" => Ok(__FieldTag::__remote_model_info),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Model;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Model")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__model_reference => {
                            if !fields.insert(__FieldTag::__model_reference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model_reference",
                                ));
                            }
                            result.model_reference = map
                                .next_value::<std::option::Option<crate::model::ModelReference>>(
                                )?;
                        }
                        __FieldTag::__creation_time => {
                            if !fields.insert(__FieldTag::__creation_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for creation_time",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.creation_time =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__last_modified_time => {
                            if !fields.insert(__FieldTag::__last_modified_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_modified_time",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.last_modified_time =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__friendly_name => {
                            if !fields.insert(__FieldTag::__friendly_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for friendly_name",
                                ));
                            }
                            result.friendly_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__expiration_time => {
                            if !fields.insert(__FieldTag::__expiration_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expiration_time",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.expiration_time =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__encryption_configuration => {
                            if !fields.insert(__FieldTag::__encryption_configuration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption_configuration",
                                ));
                            }
                            result.encryption_configuration = map.next_value::<std::option::Option<crate::model::EncryptionConfiguration>>()?
                                ;
                        }
                        __FieldTag::__model_type => {
                            if !fields.insert(__FieldTag::__model_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model_type",
                                ));
                            }
                            result.model_type = map
                                .next_value::<std::option::Option<crate::model::model::ModelType>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__training_runs => {
                            if !fields.insert(__FieldTag::__training_runs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for training_runs",
                                ));
                            }
                            result.training_runs = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::model::TrainingRun>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__feature_columns => {
                            if !fields.insert(__FieldTag::__feature_columns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for feature_columns",
                                ));
                            }
                            result.feature_columns =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::StandardSqlField>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__label_columns => {
                            if !fields.insert(__FieldTag::__label_columns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for label_columns",
                                ));
                            }
                            result.label_columns =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::StandardSqlField>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__transform_columns => {
                            if !fields.insert(__FieldTag::__transform_columns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transform_columns",
                                ));
                            }
                            result.transform_columns =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::TransformColumn>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__hparam_search_spaces => {
                            if !fields.insert(__FieldTag::__hparam_search_spaces) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hparam_search_spaces",
                                ));
                            }
                            result.hparam_search_spaces = map.next_value::<std::option::Option<crate::model::model::HparamSearchSpaces>>()?
                                ;
                        }
                        __FieldTag::__default_trial_id => {
                            if !fields.insert(__FieldTag::__default_trial_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_trial_id",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.default_trial_id =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__hparam_trials => {
                            if !fields.insert(__FieldTag::__hparam_trials) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hparam_trials",
                                ));
                            }
                            result.hparam_trials = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::model::HparamTuningTrial>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__optimal_trial_ids => {
                            if !fields.insert(__FieldTag::__optimal_trial_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optimal_trial_ids",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i64>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I64>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.optimal_trial_ids =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__remote_model_info => {
                            if !fields.insert(__FieldTag::__remote_model_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for remote_model_info",
                                ));
                            }
                            result.remote_model_info = map
                                .next_value::<std::option::Option<crate::model::RemoteModelInfo>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Model {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.model_reference.is_some() {
            state.serialize_entry("modelReference", &self.model_reference)?;
        }
        if !wkt::internal::is_default(&self.creation_time) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("creationTime", &__With(&self.creation_time))?;
        }
        if !wkt::internal::is_default(&self.last_modified_time) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("lastModifiedTime", &__With(&self.last_modified_time))?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.friendly_name.is_empty() {
            state.serialize_entry("friendlyName", &self.friendly_name)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !wkt::internal::is_default(&self.expiration_time) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("expirationTime", &__With(&self.expiration_time))?;
        }
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if self.encryption_configuration.is_some() {
            state.serialize_entry("encryptionConfiguration", &self.encryption_configuration)?;
        }
        if !wkt::internal::is_default(&self.model_type) {
            state.serialize_entry("modelType", &self.model_type)?;
        }
        if !self.training_runs.is_empty() {
            state.serialize_entry("trainingRuns", &self.training_runs)?;
        }
        if !self.feature_columns.is_empty() {
            state.serialize_entry("featureColumns", &self.feature_columns)?;
        }
        if !self.label_columns.is_empty() {
            state.serialize_entry("labelColumns", &self.label_columns)?;
        }
        if !self.transform_columns.is_empty() {
            state.serialize_entry("transformColumns", &self.transform_columns)?;
        }
        if self.hparam_search_spaces.is_some() {
            state.serialize_entry("hparamSearchSpaces", &self.hparam_search_spaces)?;
        }
        if !wkt::internal::is_default(&self.default_trial_id) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("defaultTrialId", &__With(&self.default_trial_id))?;
        }
        if !self.hparam_trials.is_empty() {
            state.serialize_entry("hparamTrials", &self.hparam_trials)?;
        }
        if !self.optimal_trial_ids.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("optimalTrialIds", &__With(&self.optimal_trial_ids))?;
        }
        if self.remote_model_info.is_some() {
            state.serialize_entry("remoteModelInfo", &self.remote_model_info)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Model].
pub mod model {
    #[allow(unused_imports)]
    use super::*;

    /// Enums for seasonal period.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SeasonalPeriod {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SeasonalPeriod {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for SeasonalPeriod {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.SeasonalPeriod"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SeasonalPeriod {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SeasonalPeriod")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SeasonalPeriod;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SeasonalPeriod")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SeasonalPeriod {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [SeasonalPeriod].
    pub mod seasonal_period {
        #[allow(unused_imports)]
        use super::*;

        /// Seasonal period type.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum SeasonalPeriodType {
            /// Unspecified seasonal period.
            Unspecified,
            /// No seasonality
            NoSeasonality,
            /// Daily period, 24 hours.
            Daily,
            /// Weekly period, 7 days.
            Weekly,
            /// Monthly period, 30 days or irregular.
            Monthly,
            /// Quarterly period, 90 days or irregular.
            Quarterly,
            /// Yearly period, 365 days or irregular.
            Yearly,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [SeasonalPeriodType::value] or
            /// [SeasonalPeriodType::name].
            UnknownValue(seasonal_period_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod seasonal_period_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl SeasonalPeriodType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::NoSeasonality => std::option::Option::Some(1),
                    Self::Daily => std::option::Option::Some(2),
                    Self::Weekly => std::option::Option::Some(3),
                    Self::Monthly => std::option::Option::Some(4),
                    Self::Quarterly => std::option::Option::Some(5),
                    Self::Yearly => std::option::Option::Some(6),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => {
                        std::option::Option::Some("SEASONAL_PERIOD_TYPE_UNSPECIFIED")
                    }
                    Self::NoSeasonality => std::option::Option::Some("NO_SEASONALITY"),
                    Self::Daily => std::option::Option::Some("DAILY"),
                    Self::Weekly => std::option::Option::Some("WEEKLY"),
                    Self::Monthly => std::option::Option::Some("MONTHLY"),
                    Self::Quarterly => std::option::Option::Some("QUARTERLY"),
                    Self::Yearly => std::option::Option::Some("YEARLY"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for SeasonalPeriodType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for SeasonalPeriodType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for SeasonalPeriodType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::NoSeasonality,
                    2 => Self::Daily,
                    3 => Self::Weekly,
                    4 => Self::Monthly,
                    5 => Self::Quarterly,
                    6 => Self::Yearly,
                    _ => Self::UnknownValue(seasonal_period_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for SeasonalPeriodType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "SEASONAL_PERIOD_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "NO_SEASONALITY" => Self::NoSeasonality,
                    "DAILY" => Self::Daily,
                    "WEEKLY" => Self::Weekly,
                    "MONTHLY" => Self::Monthly,
                    "QUARTERLY" => Self::Quarterly,
                    "YEARLY" => Self::Yearly,
                    _ => Self::UnknownValue(seasonal_period_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for SeasonalPeriodType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::NoSeasonality => serializer.serialize_i32(1),
                    Self::Daily => serializer.serialize_i32(2),
                    Self::Weekly => serializer.serialize_i32(3),
                    Self::Monthly => serializer.serialize_i32(4),
                    Self::Quarterly => serializer.serialize_i32(5),
                    Self::Yearly => serializer.serialize_i32(6),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for SeasonalPeriodType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<SeasonalPeriodType>::new(
                    ".google.cloud.bigquery.v2.Model.SeasonalPeriod.SeasonalPeriodType",
                ))
            }
        }
    }

    /// Enums for kmeans model type.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct KmeansEnums {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl KmeansEnums {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for KmeansEnums {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.KmeansEnums"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for KmeansEnums {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for KmeansEnums")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = KmeansEnums;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct KmeansEnums")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for KmeansEnums {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [KmeansEnums].
    pub mod kmeans_enums {
        #[allow(unused_imports)]
        use super::*;

        /// Indicates the method used to initialize the centroids for KMeans
        /// clustering algorithm.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum KmeansInitializationMethod {
            /// Unspecified initialization method.
            Unspecified,
            /// Initializes the centroids randomly.
            Random,
            /// Initializes the centroids using data specified in
            /// kmeans_initialization_column.
            Custom,
            /// Initializes with kmeans++.
            KmeansPlusPlus,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [KmeansInitializationMethod::value] or
            /// [KmeansInitializationMethod::name].
            UnknownValue(kmeans_initialization_method::UnknownValue),
        }

        #[doc(hidden)]
        pub mod kmeans_initialization_method {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl KmeansInitializationMethod {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Random => std::option::Option::Some(1),
                    Self::Custom => std::option::Option::Some(2),
                    Self::KmeansPlusPlus => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => {
                        std::option::Option::Some("KMEANS_INITIALIZATION_METHOD_UNSPECIFIED")
                    }
                    Self::Random => std::option::Option::Some("RANDOM"),
                    Self::Custom => std::option::Option::Some("CUSTOM"),
                    Self::KmeansPlusPlus => std::option::Option::Some("KMEANS_PLUS_PLUS"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for KmeansInitializationMethod {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for KmeansInitializationMethod {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for KmeansInitializationMethod {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Random,
                    2 => Self::Custom,
                    3 => Self::KmeansPlusPlus,
                    _ => Self::UnknownValue(kmeans_initialization_method::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for KmeansInitializationMethod {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "KMEANS_INITIALIZATION_METHOD_UNSPECIFIED" => Self::Unspecified,
                    "RANDOM" => Self::Random,
                    "CUSTOM" => Self::Custom,
                    "KMEANS_PLUS_PLUS" => Self::KmeansPlusPlus,
                    _ => Self::UnknownValue(kmeans_initialization_method::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for KmeansInitializationMethod {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Random => serializer.serialize_i32(1),
                    Self::Custom => serializer.serialize_i32(2),
                    Self::KmeansPlusPlus => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for KmeansInitializationMethod {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(
                    wkt::internal::EnumVisitor::<KmeansInitializationMethod>::new(
                        ".google.cloud.bigquery.v2.Model.KmeansEnums.KmeansInitializationMethod",
                    ),
                )
            }
        }
    }

    /// Enums for XGBoost model type.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct BoostedTreeOptionEnums {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BoostedTreeOptionEnums {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for BoostedTreeOptionEnums {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.BoostedTreeOptionEnums"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for BoostedTreeOptionEnums {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for BoostedTreeOptionEnums")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = BoostedTreeOptionEnums;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct BoostedTreeOptionEnums")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for BoostedTreeOptionEnums {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [BoostedTreeOptionEnums].
    pub mod boosted_tree_option_enums {
        #[allow(unused_imports)]
        use super::*;

        /// Booster types supported. Refer to booster parameter in XGBoost.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum BoosterType {
            /// Unspecified booster type.
            Unspecified,
            /// Gbtree booster.
            Gbtree,
            /// Dart booster.
            Dart,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [BoosterType::value] or
            /// [BoosterType::name].
            UnknownValue(booster_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod booster_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl BoosterType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Gbtree => std::option::Option::Some(1),
                    Self::Dart => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("BOOSTER_TYPE_UNSPECIFIED"),
                    Self::Gbtree => std::option::Option::Some("GBTREE"),
                    Self::Dart => std::option::Option::Some("DART"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for BoosterType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for BoosterType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for BoosterType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Gbtree,
                    2 => Self::Dart,
                    _ => Self::UnknownValue(booster_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for BoosterType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "BOOSTER_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "GBTREE" => Self::Gbtree,
                    "DART" => Self::Dart,
                    _ => Self::UnknownValue(booster_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for BoosterType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Gbtree => serializer.serialize_i32(1),
                    Self::Dart => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for BoosterType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<BoosterType>::new(
                    ".google.cloud.bigquery.v2.Model.BoostedTreeOptionEnums.BoosterType",
                ))
            }
        }

        /// Type of normalization algorithm for boosted tree models using dart
        /// booster. Refer to normalize_type in XGBoost.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum DartNormalizeType {
            /// Unspecified dart normalize type.
            Unspecified,
            /// New trees have the same weight of each of dropped trees.
            Tree,
            /// New trees have the same weight of sum of dropped trees.
            Forest,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [DartNormalizeType::value] or
            /// [DartNormalizeType::name].
            UnknownValue(dart_normalize_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod dart_normalize_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl DartNormalizeType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Tree => std::option::Option::Some(1),
                    Self::Forest => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => {
                        std::option::Option::Some("DART_NORMALIZE_TYPE_UNSPECIFIED")
                    }
                    Self::Tree => std::option::Option::Some("TREE"),
                    Self::Forest => std::option::Option::Some("FOREST"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for DartNormalizeType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for DartNormalizeType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for DartNormalizeType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Tree,
                    2 => Self::Forest,
                    _ => Self::UnknownValue(dart_normalize_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for DartNormalizeType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "DART_NORMALIZE_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "TREE" => Self::Tree,
                    "FOREST" => Self::Forest,
                    _ => Self::UnknownValue(dart_normalize_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for DartNormalizeType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Tree => serializer.serialize_i32(1),
                    Self::Forest => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for DartNormalizeType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<DartNormalizeType>::new(
                    ".google.cloud.bigquery.v2.Model.BoostedTreeOptionEnums.DartNormalizeType",
                ))
            }
        }

        /// Tree construction algorithm used in boosted tree models.
        /// Refer to tree_method in XGBoost.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum TreeMethod {
            /// Unspecified tree method.
            Unspecified,
            /// Use heuristic to choose the fastest method.
            Auto,
            /// Exact greedy algorithm.
            Exact,
            /// Approximate greedy algorithm using quantile sketch and gradient
            /// histogram.
            Approx,
            /// Fast histogram optimized approximate greedy algorithm.
            Hist,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [TreeMethod::value] or
            /// [TreeMethod::name].
            UnknownValue(tree_method::UnknownValue),
        }

        #[doc(hidden)]
        pub mod tree_method {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl TreeMethod {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Auto => std::option::Option::Some(1),
                    Self::Exact => std::option::Option::Some(2),
                    Self::Approx => std::option::Option::Some(3),
                    Self::Hist => std::option::Option::Some(4),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("TREE_METHOD_UNSPECIFIED"),
                    Self::Auto => std::option::Option::Some("AUTO"),
                    Self::Exact => std::option::Option::Some("EXACT"),
                    Self::Approx => std::option::Option::Some("APPROX"),
                    Self::Hist => std::option::Option::Some("HIST"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for TreeMethod {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for TreeMethod {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for TreeMethod {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Auto,
                    2 => Self::Exact,
                    3 => Self::Approx,
                    4 => Self::Hist,
                    _ => Self::UnknownValue(tree_method::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for TreeMethod {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "TREE_METHOD_UNSPECIFIED" => Self::Unspecified,
                    "AUTO" => Self::Auto,
                    "EXACT" => Self::Exact,
                    "APPROX" => Self::Approx,
                    "HIST" => Self::Hist,
                    _ => Self::UnknownValue(tree_method::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for TreeMethod {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Auto => serializer.serialize_i32(1),
                    Self::Exact => serializer.serialize_i32(2),
                    Self::Approx => serializer.serialize_i32(3),
                    Self::Hist => serializer.serialize_i32(4),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for TreeMethod {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<TreeMethod>::new(
                    ".google.cloud.bigquery.v2.Model.BoostedTreeOptionEnums.TreeMethod",
                ))
            }
        }
    }

    /// Enums for hyperparameter tuning.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct HparamTuningEnums {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl HparamTuningEnums {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for HparamTuningEnums {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.HparamTuningEnums"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for HparamTuningEnums {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for HparamTuningEnums")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = HparamTuningEnums;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct HparamTuningEnums")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for HparamTuningEnums {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [HparamTuningEnums].
    pub mod hparam_tuning_enums {
        #[allow(unused_imports)]
        use super::*;

        /// Available evaluation metrics used as hyperparameter tuning objectives.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum HparamTuningObjective {
            /// Unspecified evaluation metric.
            Unspecified,
            /// Mean absolute error.
            /// mean_absolute_error = AVG(ABS(label - predicted))
            MeanAbsoluteError,
            /// Mean squared error.
            /// mean_squared_error = AVG(POW(label - predicted, 2))
            MeanSquaredError,
            /// Mean squared log error.
            /// mean_squared_log_error = AVG(POW(LN(1 + label) - LN(1 + predicted), 2))
            MeanSquaredLogError,
            /// Mean absolute error.
            /// median_absolute_error = APPROX_QUANTILES(absolute_error, 2)[OFFSET(1)]
            MedianAbsoluteError,
            /// R^2 score. This corresponds to r2_score in ML.EVALUATE.
            /// r_squared = 1 - SUM(squared_error)/(COUNT(label)*VAR_POP(label))
            RSquared,
            /// Explained variance.
            /// explained_variance = 1 - VAR_POP(label_error)/VAR_POP(label)
            ExplainedVariance,
            /// Precision is the fraction of actual positive predictions that had
            /// positive actual labels. For multiclass this is a macro-averaged metric
            /// treating each class as a binary classifier.
            Precision,
            /// Recall is the fraction of actual positive labels that were given a
            /// positive prediction. For multiclass this is a macro-averaged metric.
            Recall,
            /// Accuracy is the fraction of predictions given the correct label. For
            /// multiclass this is a globally micro-averaged metric.
            Accuracy,
            /// The F1 score is an average of recall and precision. For multiclass this
            /// is a macro-averaged metric.
            F1Score,
            /// Logarithmic Loss. For multiclass this is a macro-averaged metric.
            LogLoss,
            /// Area Under an ROC Curve. For multiclass this is a macro-averaged
            /// metric.
            RocAuc,
            /// Davies-Bouldin Index.
            DaviesBouldinIndex,
            /// Mean Average Precision.
            MeanAveragePrecision,
            /// Normalized Discounted Cumulative Gain.
            NormalizedDiscountedCumulativeGain,
            /// Average Rank.
            AverageRank,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [HparamTuningObjective::value] or
            /// [HparamTuningObjective::name].
            UnknownValue(hparam_tuning_objective::UnknownValue),
        }

        #[doc(hidden)]
        pub mod hparam_tuning_objective {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl HparamTuningObjective {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::MeanAbsoluteError => std::option::Option::Some(1),
                    Self::MeanSquaredError => std::option::Option::Some(2),
                    Self::MeanSquaredLogError => std::option::Option::Some(3),
                    Self::MedianAbsoluteError => std::option::Option::Some(4),
                    Self::RSquared => std::option::Option::Some(5),
                    Self::ExplainedVariance => std::option::Option::Some(6),
                    Self::Precision => std::option::Option::Some(7),
                    Self::Recall => std::option::Option::Some(8),
                    Self::Accuracy => std::option::Option::Some(9),
                    Self::F1Score => std::option::Option::Some(10),
                    Self::LogLoss => std::option::Option::Some(11),
                    Self::RocAuc => std::option::Option::Some(12),
                    Self::DaviesBouldinIndex => std::option::Option::Some(13),
                    Self::MeanAveragePrecision => std::option::Option::Some(14),
                    Self::NormalizedDiscountedCumulativeGain => std::option::Option::Some(15),
                    Self::AverageRank => std::option::Option::Some(16),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => {
                        std::option::Option::Some("HPARAM_TUNING_OBJECTIVE_UNSPECIFIED")
                    }
                    Self::MeanAbsoluteError => std::option::Option::Some("MEAN_ABSOLUTE_ERROR"),
                    Self::MeanSquaredError => std::option::Option::Some("MEAN_SQUARED_ERROR"),
                    Self::MeanSquaredLogError => {
                        std::option::Option::Some("MEAN_SQUARED_LOG_ERROR")
                    }
                    Self::MedianAbsoluteError => std::option::Option::Some("MEDIAN_ABSOLUTE_ERROR"),
                    Self::RSquared => std::option::Option::Some("R_SQUARED"),
                    Self::ExplainedVariance => std::option::Option::Some("EXPLAINED_VARIANCE"),
                    Self::Precision => std::option::Option::Some("PRECISION"),
                    Self::Recall => std::option::Option::Some("RECALL"),
                    Self::Accuracy => std::option::Option::Some("ACCURACY"),
                    Self::F1Score => std::option::Option::Some("F1_SCORE"),
                    Self::LogLoss => std::option::Option::Some("LOG_LOSS"),
                    Self::RocAuc => std::option::Option::Some("ROC_AUC"),
                    Self::DaviesBouldinIndex => std::option::Option::Some("DAVIES_BOULDIN_INDEX"),
                    Self::MeanAveragePrecision => {
                        std::option::Option::Some("MEAN_AVERAGE_PRECISION")
                    }
                    Self::NormalizedDiscountedCumulativeGain => {
                        std::option::Option::Some("NORMALIZED_DISCOUNTED_CUMULATIVE_GAIN")
                    }
                    Self::AverageRank => std::option::Option::Some("AVERAGE_RANK"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for HparamTuningObjective {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for HparamTuningObjective {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for HparamTuningObjective {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::MeanAbsoluteError,
                    2 => Self::MeanSquaredError,
                    3 => Self::MeanSquaredLogError,
                    4 => Self::MedianAbsoluteError,
                    5 => Self::RSquared,
                    6 => Self::ExplainedVariance,
                    7 => Self::Precision,
                    8 => Self::Recall,
                    9 => Self::Accuracy,
                    10 => Self::F1Score,
                    11 => Self::LogLoss,
                    12 => Self::RocAuc,
                    13 => Self::DaviesBouldinIndex,
                    14 => Self::MeanAveragePrecision,
                    15 => Self::NormalizedDiscountedCumulativeGain,
                    16 => Self::AverageRank,
                    _ => Self::UnknownValue(hparam_tuning_objective::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for HparamTuningObjective {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "HPARAM_TUNING_OBJECTIVE_UNSPECIFIED" => Self::Unspecified,
                    "MEAN_ABSOLUTE_ERROR" => Self::MeanAbsoluteError,
                    "MEAN_SQUARED_ERROR" => Self::MeanSquaredError,
                    "MEAN_SQUARED_LOG_ERROR" => Self::MeanSquaredLogError,
                    "MEDIAN_ABSOLUTE_ERROR" => Self::MedianAbsoluteError,
                    "R_SQUARED" => Self::RSquared,
                    "EXPLAINED_VARIANCE" => Self::ExplainedVariance,
                    "PRECISION" => Self::Precision,
                    "RECALL" => Self::Recall,
                    "ACCURACY" => Self::Accuracy,
                    "F1_SCORE" => Self::F1Score,
                    "LOG_LOSS" => Self::LogLoss,
                    "ROC_AUC" => Self::RocAuc,
                    "DAVIES_BOULDIN_INDEX" => Self::DaviesBouldinIndex,
                    "MEAN_AVERAGE_PRECISION" => Self::MeanAveragePrecision,
                    "NORMALIZED_DISCOUNTED_CUMULATIVE_GAIN" => {
                        Self::NormalizedDiscountedCumulativeGain
                    }
                    "AVERAGE_RANK" => Self::AverageRank,
                    _ => Self::UnknownValue(hparam_tuning_objective::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for HparamTuningObjective {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::MeanAbsoluteError => serializer.serialize_i32(1),
                    Self::MeanSquaredError => serializer.serialize_i32(2),
                    Self::MeanSquaredLogError => serializer.serialize_i32(3),
                    Self::MedianAbsoluteError => serializer.serialize_i32(4),
                    Self::RSquared => serializer.serialize_i32(5),
                    Self::ExplainedVariance => serializer.serialize_i32(6),
                    Self::Precision => serializer.serialize_i32(7),
                    Self::Recall => serializer.serialize_i32(8),
                    Self::Accuracy => serializer.serialize_i32(9),
                    Self::F1Score => serializer.serialize_i32(10),
                    Self::LogLoss => serializer.serialize_i32(11),
                    Self::RocAuc => serializer.serialize_i32(12),
                    Self::DaviesBouldinIndex => serializer.serialize_i32(13),
                    Self::MeanAveragePrecision => serializer.serialize_i32(14),
                    Self::NormalizedDiscountedCumulativeGain => serializer.serialize_i32(15),
                    Self::AverageRank => serializer.serialize_i32(16),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for HparamTuningObjective {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(
                    wkt::internal::EnumVisitor::<HparamTuningObjective>::new(
                        ".google.cloud.bigquery.v2.Model.HparamTuningEnums.HparamTuningObjective",
                    ),
                )
            }
        }
    }

    /// Evaluation metrics for regression and explicit feedback type matrix
    /// factorization models.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct RegressionMetrics {
        /// Mean absolute error.
        pub mean_absolute_error: std::option::Option<wkt::DoubleValue>,

        /// Mean squared error.
        pub mean_squared_error: std::option::Option<wkt::DoubleValue>,

        /// Mean squared log error.
        pub mean_squared_log_error: std::option::Option<wkt::DoubleValue>,

        /// Median absolute error.
        pub median_absolute_error: std::option::Option<wkt::DoubleValue>,

        /// R^2 score. This corresponds to r2_score in ML.EVALUATE.
        pub r_squared: std::option::Option<wkt::DoubleValue>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RegressionMetrics {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [mean_absolute_error][crate::model::model::RegressionMetrics::mean_absolute_error].
        pub fn set_mean_absolute_error<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::DoubleValue>,
        {
            self.mean_absolute_error = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [mean_absolute_error][crate::model::model::RegressionMetrics::mean_absolute_error].
        pub fn set_or_clear_mean_absolute_error<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::DoubleValue>,
        {
            self.mean_absolute_error = v.map(|x| x.into());
            self
        }

        /// Sets the value of [mean_squared_error][crate::model::model::RegressionMetrics::mean_squared_error].
        pub fn set_mean_squared_error<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::DoubleValue>,
        {
            self.mean_squared_error = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [mean_squared_error][crate::model::model::RegressionMetrics::mean_squared_error].
        pub fn set_or_clear_mean_squared_error<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::DoubleValue>,
        {
            self.mean_squared_error = v.map(|x| x.into());
            self
        }

        /// Sets the value of [mean_squared_log_error][crate::model::model::RegressionMetrics::mean_squared_log_error].
        pub fn set_mean_squared_log_error<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::DoubleValue>,
        {
            self.mean_squared_log_error = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [mean_squared_log_error][crate::model::model::RegressionMetrics::mean_squared_log_error].
        pub fn set_or_clear_mean_squared_log_error<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::DoubleValue>,
        {
            self.mean_squared_log_error = v.map(|x| x.into());
            self
        }

        /// Sets the value of [median_absolute_error][crate::model::model::RegressionMetrics::median_absolute_error].
        pub fn set_median_absolute_error<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::DoubleValue>,
        {
            self.median_absolute_error = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [median_absolute_error][crate::model::model::RegressionMetrics::median_absolute_error].
        pub fn set_or_clear_median_absolute_error<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::DoubleValue>,
        {
            self.median_absolute_error = v.map(|x| x.into());
            self
        }

        /// Sets the value of [r_squared][crate::model::model::RegressionMetrics::r_squared].
        pub fn set_r_squared<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::DoubleValue>,
        {
            self.r_squared = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [r_squared][crate::model::model::RegressionMetrics::r_squared].
        pub fn set_or_clear_r_squared<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::DoubleValue>,
        {
            self.r_squared = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for RegressionMetrics {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.RegressionMetrics"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for RegressionMetrics {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __mean_absolute_error,
                __mean_squared_error,
                __mean_squared_log_error,
                __median_absolute_error,
                __r_squared,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for RegressionMetrics")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "meanAbsoluteError" => Ok(__FieldTag::__mean_absolute_error),
                                "mean_absolute_error" => Ok(__FieldTag::__mean_absolute_error),
                                "meanSquaredError" => Ok(__FieldTag::__mean_squared_error),
                                "mean_squared_error" => Ok(__FieldTag::__mean_squared_error),
                                "meanSquaredLogError" => Ok(__FieldTag::__mean_squared_log_error),
                                "mean_squared_log_error" => {
                                    Ok(__FieldTag::__mean_squared_log_error)
                                }
                                "medianAbsoluteError" => Ok(__FieldTag::__median_absolute_error),
                                "median_absolute_error" => Ok(__FieldTag::__median_absolute_error),
                                "rSquared" => Ok(__FieldTag::__r_squared),
                                "r_squared" => Ok(__FieldTag::__r_squared),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = RegressionMetrics;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct RegressionMetrics")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__mean_absolute_error => {
                                if !fields.insert(__FieldTag::__mean_absolute_error) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for mean_absolute_error",
                                    ));
                                }
                                struct __With(std::option::Option<wkt::DoubleValue>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.mean_absolute_error = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::__mean_squared_error => {
                                if !fields.insert(__FieldTag::__mean_squared_error) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for mean_squared_error",
                                    ));
                                }
                                struct __With(std::option::Option<wkt::DoubleValue>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.mean_squared_error = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::__mean_squared_log_error => {
                                if !fields.insert(__FieldTag::__mean_squared_log_error) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for mean_squared_log_error",
                                    ));
                                }
                                struct __With(std::option::Option<wkt::DoubleValue>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.mean_squared_log_error = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::__median_absolute_error => {
                                if !fields.insert(__FieldTag::__median_absolute_error) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for median_absolute_error",
                                    ));
                                }
                                struct __With(std::option::Option<wkt::DoubleValue>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.median_absolute_error = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::__r_squared => {
                                if !fields.insert(__FieldTag::__r_squared) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for r_squared",
                                    ));
                                }
                                struct __With(std::option::Option<wkt::DoubleValue>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.r_squared = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for RegressionMetrics {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.mean_absolute_error.is_some() {
                struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("meanAbsoluteError", &__With(&self.mean_absolute_error))?;
            }
            if self.mean_squared_error.is_some() {
                struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("meanSquaredError", &__With(&self.mean_squared_error))?;
            }
            if self.mean_squared_log_error.is_some() {
                struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry(
                    "meanSquaredLogError",
                    &__With(&self.mean_squared_log_error),
                )?;
            }
            if self.median_absolute_error.is_some() {
                struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state
                    .serialize_entry("medianAbsoluteError", &__With(&self.median_absolute_error))?;
            }
            if self.r_squared.is_some() {
                struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("rSquared", &__With(&self.r_squared))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Aggregate metrics for classification/classifier models. For multi-class
    /// models, the metrics are either macro-averaged or micro-averaged. When
    /// macro-averaged, the metrics are calculated for each label and then an
    /// unweighted average is taken of those values. When micro-averaged, the
    /// metric is calculated globally by counting the total number of correctly
    /// predicted rows.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AggregateClassificationMetrics {
        /// Precision is the fraction of actual positive predictions that had
        /// positive actual labels. For multiclass this is a macro-averaged
        /// metric treating each class as a binary classifier.
        pub precision: std::option::Option<wkt::DoubleValue>,

        /// Recall is the fraction of actual positive labels that were given a
        /// positive prediction. For multiclass this is a macro-averaged metric.
        pub recall: std::option::Option<wkt::DoubleValue>,

        /// Accuracy is the fraction of predictions given the correct label. For
        /// multiclass this is a micro-averaged metric.
        pub accuracy: std::option::Option<wkt::DoubleValue>,

        /// Threshold at which the metrics are computed. For binary
        /// classification models this is the positive class threshold.
        /// For multi-class classification models this is the confidence
        /// threshold.
        pub threshold: std::option::Option<wkt::DoubleValue>,

        /// The F1 score is an average of recall and precision. For multiclass
        /// this is a macro-averaged metric.
        pub f1_score: std::option::Option<wkt::DoubleValue>,

        /// Logarithmic Loss. For multiclass this is a macro-averaged metric.
        pub log_loss: std::option::Option<wkt::DoubleValue>,

        /// Area Under a ROC Curve. For multiclass this is a macro-averaged
        /// metric.
        pub roc_auc: std::option::Option<wkt::DoubleValue>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AggregateClassificationMetrics {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [precision][crate::model::model::AggregateClassificationMetrics::precision].
        pub fn set_precision<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::DoubleValue>,
        {
            self.precision = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [precision][crate::model::model::AggregateClassificationMetrics::precision].
        pub fn set_or_clear_precision<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::DoubleValue>,
        {
            self.precision = v.map(|x| x.into());
            self
        }

        /// Sets the value of [recall][crate::model::model::AggregateClassificationMetrics::recall].
        pub fn set_recall<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::DoubleValue>,
        {
            self.recall = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [recall][crate::model::model::AggregateClassificationMetrics::recall].
        pub fn set_or_clear_recall<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::DoubleValue>,
        {
            self.recall = v.map(|x| x.into());
            self
        }

        /// Sets the value of [accuracy][crate::model::model::AggregateClassificationMetrics::accuracy].
        pub fn set_accuracy<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::DoubleValue>,
        {
            self.accuracy = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [accuracy][crate::model::model::AggregateClassificationMetrics::accuracy].
        pub fn set_or_clear_accuracy<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::DoubleValue>,
        {
            self.accuracy = v.map(|x| x.into());
            self
        }

        /// Sets the value of [threshold][crate::model::model::AggregateClassificationMetrics::threshold].
        pub fn set_threshold<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::DoubleValue>,
        {
            self.threshold = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [threshold][crate::model::model::AggregateClassificationMetrics::threshold].
        pub fn set_or_clear_threshold<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::DoubleValue>,
        {
            self.threshold = v.map(|x| x.into());
            self
        }

        /// Sets the value of [f1_score][crate::model::model::AggregateClassificationMetrics::f1_score].
        pub fn set_f1_score<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::DoubleValue>,
        {
            self.f1_score = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [f1_score][crate::model::model::AggregateClassificationMetrics::f1_score].
        pub fn set_or_clear_f1_score<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::DoubleValue>,
        {
            self.f1_score = v.map(|x| x.into());
            self
        }

        /// Sets the value of [log_loss][crate::model::model::AggregateClassificationMetrics::log_loss].
        pub fn set_log_loss<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::DoubleValue>,
        {
            self.log_loss = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [log_loss][crate::model::model::AggregateClassificationMetrics::log_loss].
        pub fn set_or_clear_log_loss<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::DoubleValue>,
        {
            self.log_loss = v.map(|x| x.into());
            self
        }

        /// Sets the value of [roc_auc][crate::model::model::AggregateClassificationMetrics::roc_auc].
        pub fn set_roc_auc<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::DoubleValue>,
        {
            self.roc_auc = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [roc_auc][crate::model::model::AggregateClassificationMetrics::roc_auc].
        pub fn set_or_clear_roc_auc<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::DoubleValue>,
        {
            self.roc_auc = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for AggregateClassificationMetrics {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.AggregateClassificationMetrics"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AggregateClassificationMetrics {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __precision,
                __recall,
                __accuracy,
                __threshold,
                __f1_score,
                __log_loss,
                __roc_auc,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AggregateClassificationMetrics")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "precision" => Ok(__FieldTag::__precision),
                                "recall" => Ok(__FieldTag::__recall),
                                "accuracy" => Ok(__FieldTag::__accuracy),
                                "threshold" => Ok(__FieldTag::__threshold),
                                "f1Score" => Ok(__FieldTag::__f1_score),
                                "f1_score" => Ok(__FieldTag::__f1_score),
                                "logLoss" => Ok(__FieldTag::__log_loss),
                                "log_loss" => Ok(__FieldTag::__log_loss),
                                "rocAuc" => Ok(__FieldTag::__roc_auc),
                                "roc_auc" => Ok(__FieldTag::__roc_auc),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AggregateClassificationMetrics;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AggregateClassificationMetrics")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__precision => {
                                if !fields.insert(__FieldTag::__precision) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for precision",
                                    ));
                                }
                                struct __With(std::option::Option<wkt::DoubleValue>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.precision = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::__recall => {
                                if !fields.insert(__FieldTag::__recall) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for recall",
                                    ));
                                }
                                struct __With(std::option::Option<wkt::DoubleValue>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.recall = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::__accuracy => {
                                if !fields.insert(__FieldTag::__accuracy) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for accuracy",
                                    ));
                                }
                                struct __With(std::option::Option<wkt::DoubleValue>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.accuracy = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::__threshold => {
                                if !fields.insert(__FieldTag::__threshold) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for threshold",
                                    ));
                                }
                                struct __With(std::option::Option<wkt::DoubleValue>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.threshold = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::__f1_score => {
                                if !fields.insert(__FieldTag::__f1_score) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for f1_score",
                                    ));
                                }
                                struct __With(std::option::Option<wkt::DoubleValue>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.f1_score = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::__log_loss => {
                                if !fields.insert(__FieldTag::__log_loss) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for log_loss",
                                    ));
                                }
                                struct __With(std::option::Option<wkt::DoubleValue>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.log_loss = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::__roc_auc => {
                                if !fields.insert(__FieldTag::__roc_auc) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for roc_auc",
                                    ));
                                }
                                struct __With(std::option::Option<wkt::DoubleValue>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.roc_auc = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AggregateClassificationMetrics {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.precision.is_some() {
                struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("precision", &__With(&self.precision))?;
            }
            if self.recall.is_some() {
                struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("recall", &__With(&self.recall))?;
            }
            if self.accuracy.is_some() {
                struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("accuracy", &__With(&self.accuracy))?;
            }
            if self.threshold.is_some() {
                struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("threshold", &__With(&self.threshold))?;
            }
            if self.f1_score.is_some() {
                struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("f1Score", &__With(&self.f1_score))?;
            }
            if self.log_loss.is_some() {
                struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("logLoss", &__With(&self.log_loss))?;
            }
            if self.roc_auc.is_some() {
                struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("rocAuc", &__With(&self.roc_auc))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Evaluation metrics for binary classification/classifier models.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct BinaryClassificationMetrics {
        /// Aggregate classification metrics.
        pub aggregate_classification_metrics:
            std::option::Option<crate::model::model::AggregateClassificationMetrics>,

        /// Binary confusion matrix at multiple thresholds.
        pub binary_confusion_matrix_list: std::vec::Vec<
            crate::model::model::binary_classification_metrics::BinaryConfusionMatrix,
        >,

        /// Label representing the positive class.
        pub positive_label: std::string::String,

        /// Label representing the negative class.
        pub negative_label: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BinaryClassificationMetrics {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [aggregate_classification_metrics][crate::model::model::BinaryClassificationMetrics::aggregate_classification_metrics].
        pub fn set_aggregate_classification_metrics<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::model::AggregateClassificationMetrics>,
        {
            self.aggregate_classification_metrics = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [aggregate_classification_metrics][crate::model::model::BinaryClassificationMetrics::aggregate_classification_metrics].
        pub fn set_or_clear_aggregate_classification_metrics<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<crate::model::model::AggregateClassificationMetrics>,
        {
            self.aggregate_classification_metrics = v.map(|x| x.into());
            self
        }

        /// Sets the value of [binary_confusion_matrix_list][crate::model::model::BinaryClassificationMetrics::binary_confusion_matrix_list].
        pub fn set_binary_confusion_matrix_list<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                    crate::model::model::binary_classification_metrics::BinaryConfusionMatrix,
                >,
        {
            use std::iter::Iterator;
            self.binary_confusion_matrix_list = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [positive_label][crate::model::model::BinaryClassificationMetrics::positive_label].
        pub fn set_positive_label<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.positive_label = v.into();
            self
        }

        /// Sets the value of [negative_label][crate::model::model::BinaryClassificationMetrics::negative_label].
        pub fn set_negative_label<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.negative_label = v.into();
            self
        }
    }

    impl wkt::message::Message for BinaryClassificationMetrics {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.BinaryClassificationMetrics"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for BinaryClassificationMetrics {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __aggregate_classification_metrics,
                __binary_confusion_matrix_list,
                __positive_label,
                __negative_label,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for BinaryClassificationMetrics")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "aggregateClassificationMetrics" => {
                                    Ok(__FieldTag::__aggregate_classification_metrics)
                                }
                                "aggregate_classification_metrics" => {
                                    Ok(__FieldTag::__aggregate_classification_metrics)
                                }
                                "binaryConfusionMatrixList" => {
                                    Ok(__FieldTag::__binary_confusion_matrix_list)
                                }
                                "binary_confusion_matrix_list" => {
                                    Ok(__FieldTag::__binary_confusion_matrix_list)
                                }
                                "positiveLabel" => Ok(__FieldTag::__positive_label),
                                "positive_label" => Ok(__FieldTag::__positive_label),
                                "negativeLabel" => Ok(__FieldTag::__negative_label),
                                "negative_label" => Ok(__FieldTag::__negative_label),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = BinaryClassificationMetrics;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct BinaryClassificationMetrics")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__aggregate_classification_metrics => {
                                if !fields.insert(__FieldTag::__aggregate_classification_metrics) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for aggregate_classification_metrics",
                                    ));
                                }
                                result.aggregate_classification_metrics = map
                                    .next_value::<std::option::Option<
                                        crate::model::model::AggregateClassificationMetrics,
                                    >>()?;
                            }
                            __FieldTag::__binary_confusion_matrix_list => {
                                if !fields.insert(__FieldTag::__binary_confusion_matrix_list) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for binary_confusion_matrix_list",
                                    ));
                                }
                                result.binary_confusion_matrix_list = map.next_value::<std::option::Option<std::vec::Vec<crate::model::model::binary_classification_metrics::BinaryConfusionMatrix>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__positive_label => {
                                if !fields.insert(__FieldTag::__positive_label) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for positive_label",
                                    ));
                                }
                                result.positive_label = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__negative_label => {
                                if !fields.insert(__FieldTag::__negative_label) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for negative_label",
                                    ));
                                }
                                result.negative_label = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for BinaryClassificationMetrics {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.aggregate_classification_metrics.is_some() {
                state.serialize_entry(
                    "aggregateClassificationMetrics",
                    &self.aggregate_classification_metrics,
                )?;
            }
            if !self.binary_confusion_matrix_list.is_empty() {
                state.serialize_entry(
                    "binaryConfusionMatrixList",
                    &self.binary_confusion_matrix_list,
                )?;
            }
            if !self.positive_label.is_empty() {
                state.serialize_entry("positiveLabel", &self.positive_label)?;
            }
            if !self.negative_label.is_empty() {
                state.serialize_entry("negativeLabel", &self.negative_label)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [BinaryClassificationMetrics].
    pub mod binary_classification_metrics {
        #[allow(unused_imports)]
        use super::*;

        /// Confusion matrix for binary classification models.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct BinaryConfusionMatrix {
            /// Threshold value used when computing each of the following metric.
            pub positive_class_threshold: std::option::Option<wkt::DoubleValue>,

            /// Number of true samples predicted as true.
            pub true_positives: std::option::Option<wkt::Int64Value>,

            /// Number of false samples predicted as true.
            pub false_positives: std::option::Option<wkt::Int64Value>,

            /// Number of true samples predicted as false.
            pub true_negatives: std::option::Option<wkt::Int64Value>,

            /// Number of false samples predicted as false.
            pub false_negatives: std::option::Option<wkt::Int64Value>,

            /// The fraction of actual positive predictions that had positive actual
            /// labels.
            pub precision: std::option::Option<wkt::DoubleValue>,

            /// The fraction of actual positive labels that were given a positive
            /// prediction.
            pub recall: std::option::Option<wkt::DoubleValue>,

            /// The equally weighted average of recall and precision.
            pub f1_score: std::option::Option<wkt::DoubleValue>,

            /// The fraction of predictions given the correct label.
            pub accuracy: std::option::Option<wkt::DoubleValue>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl BinaryConfusionMatrix {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [positive_class_threshold][crate::model::model::binary_classification_metrics::BinaryConfusionMatrix::positive_class_threshold].
            pub fn set_positive_class_threshold<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::DoubleValue>,
            {
                self.positive_class_threshold = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [positive_class_threshold][crate::model::model::binary_classification_metrics::BinaryConfusionMatrix::positive_class_threshold].
            pub fn set_or_clear_positive_class_threshold<T>(
                mut self,
                v: std::option::Option<T>,
            ) -> Self
            where
                T: std::convert::Into<wkt::DoubleValue>,
            {
                self.positive_class_threshold = v.map(|x| x.into());
                self
            }

            /// Sets the value of [true_positives][crate::model::model::binary_classification_metrics::BinaryConfusionMatrix::true_positives].
            pub fn set_true_positives<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::Int64Value>,
            {
                self.true_positives = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [true_positives][crate::model::model::binary_classification_metrics::BinaryConfusionMatrix::true_positives].
            pub fn set_or_clear_true_positives<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::Int64Value>,
            {
                self.true_positives = v.map(|x| x.into());
                self
            }

            /// Sets the value of [false_positives][crate::model::model::binary_classification_metrics::BinaryConfusionMatrix::false_positives].
            pub fn set_false_positives<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::Int64Value>,
            {
                self.false_positives = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [false_positives][crate::model::model::binary_classification_metrics::BinaryConfusionMatrix::false_positives].
            pub fn set_or_clear_false_positives<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::Int64Value>,
            {
                self.false_positives = v.map(|x| x.into());
                self
            }

            /// Sets the value of [true_negatives][crate::model::model::binary_classification_metrics::BinaryConfusionMatrix::true_negatives].
            pub fn set_true_negatives<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::Int64Value>,
            {
                self.true_negatives = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [true_negatives][crate::model::model::binary_classification_metrics::BinaryConfusionMatrix::true_negatives].
            pub fn set_or_clear_true_negatives<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::Int64Value>,
            {
                self.true_negatives = v.map(|x| x.into());
                self
            }

            /// Sets the value of [false_negatives][crate::model::model::binary_classification_metrics::BinaryConfusionMatrix::false_negatives].
            pub fn set_false_negatives<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::Int64Value>,
            {
                self.false_negatives = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [false_negatives][crate::model::model::binary_classification_metrics::BinaryConfusionMatrix::false_negatives].
            pub fn set_or_clear_false_negatives<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::Int64Value>,
            {
                self.false_negatives = v.map(|x| x.into());
                self
            }

            /// Sets the value of [precision][crate::model::model::binary_classification_metrics::BinaryConfusionMatrix::precision].
            pub fn set_precision<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::DoubleValue>,
            {
                self.precision = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [precision][crate::model::model::binary_classification_metrics::BinaryConfusionMatrix::precision].
            pub fn set_or_clear_precision<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::DoubleValue>,
            {
                self.precision = v.map(|x| x.into());
                self
            }

            /// Sets the value of [recall][crate::model::model::binary_classification_metrics::BinaryConfusionMatrix::recall].
            pub fn set_recall<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::DoubleValue>,
            {
                self.recall = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [recall][crate::model::model::binary_classification_metrics::BinaryConfusionMatrix::recall].
            pub fn set_or_clear_recall<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::DoubleValue>,
            {
                self.recall = v.map(|x| x.into());
                self
            }

            /// Sets the value of [f1_score][crate::model::model::binary_classification_metrics::BinaryConfusionMatrix::f1_score].
            pub fn set_f1_score<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::DoubleValue>,
            {
                self.f1_score = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [f1_score][crate::model::model::binary_classification_metrics::BinaryConfusionMatrix::f1_score].
            pub fn set_or_clear_f1_score<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::DoubleValue>,
            {
                self.f1_score = v.map(|x| x.into());
                self
            }

            /// Sets the value of [accuracy][crate::model::model::binary_classification_metrics::BinaryConfusionMatrix::accuracy].
            pub fn set_accuracy<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::DoubleValue>,
            {
                self.accuracy = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [accuracy][crate::model::model::binary_classification_metrics::BinaryConfusionMatrix::accuracy].
            pub fn set_or_clear_accuracy<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::DoubleValue>,
            {
                self.accuracy = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for BinaryConfusionMatrix {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.bigquery.v2.Model.BinaryClassificationMetrics.BinaryConfusionMatrix"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for BinaryConfusionMatrix {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __positive_class_threshold,
                    __true_positives,
                    __false_positives,
                    __true_negatives,
                    __false_negatives,
                    __precision,
                    __recall,
                    __f1_score,
                    __accuracy,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for BinaryConfusionMatrix")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "positiveClassThreshold" => {
                                        Ok(__FieldTag::__positive_class_threshold)
                                    }
                                    "positive_class_threshold" => {
                                        Ok(__FieldTag::__positive_class_threshold)
                                    }
                                    "truePositives" => Ok(__FieldTag::__true_positives),
                                    "true_positives" => Ok(__FieldTag::__true_positives),
                                    "falsePositives" => Ok(__FieldTag::__false_positives),
                                    "false_positives" => Ok(__FieldTag::__false_positives),
                                    "trueNegatives" => Ok(__FieldTag::__true_negatives),
                                    "true_negatives" => Ok(__FieldTag::__true_negatives),
                                    "falseNegatives" => Ok(__FieldTag::__false_negatives),
                                    "false_negatives" => Ok(__FieldTag::__false_negatives),
                                    "precision" => Ok(__FieldTag::__precision),
                                    "recall" => Ok(__FieldTag::__recall),
                                    "f1Score" => Ok(__FieldTag::__f1_score),
                                    "f1_score" => Ok(__FieldTag::__f1_score),
                                    "accuracy" => Ok(__FieldTag::__accuracy),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = BinaryConfusionMatrix;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct BinaryConfusionMatrix")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__positive_class_threshold => {
                                    if !fields.insert(__FieldTag::__positive_class_threshold) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for positive_class_threshold",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<wkt::DoubleValue>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.positive_class_threshold = map.next_value::<__With>()?.0;
                                }
                                __FieldTag::__true_positives => {
                                    if !fields.insert(__FieldTag::__true_positives) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for true_positives",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<wkt::Int64Value>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.true_positives = map.next_value::<__With>()?.0;
                                }
                                __FieldTag::__false_positives => {
                                    if !fields.insert(__FieldTag::__false_positives) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for false_positives",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<wkt::Int64Value>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.false_positives = map.next_value::<__With>()?.0;
                                }
                                __FieldTag::__true_negatives => {
                                    if !fields.insert(__FieldTag::__true_negatives) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for true_negatives",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<wkt::Int64Value>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.true_negatives = map.next_value::<__With>()?.0;
                                }
                                __FieldTag::__false_negatives => {
                                    if !fields.insert(__FieldTag::__false_negatives) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for false_negatives",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<wkt::Int64Value>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.false_negatives = map.next_value::<__With>()?.0;
                                }
                                __FieldTag::__precision => {
                                    if !fields.insert(__FieldTag::__precision) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for precision",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<wkt::DoubleValue>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.precision = map.next_value::<__With>()?.0;
                                }
                                __FieldTag::__recall => {
                                    if !fields.insert(__FieldTag::__recall) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for recall"),
                                        );
                                    }
                                    struct __With(std::option::Option<wkt::DoubleValue>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.recall = map.next_value::<__With>()?.0;
                                }
                                __FieldTag::__f1_score => {
                                    if !fields.insert(__FieldTag::__f1_score) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for f1_score",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<wkt::DoubleValue>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.f1_score = map.next_value::<__With>()?.0;
                                }
                                __FieldTag::__accuracy => {
                                    if !fields.insert(__FieldTag::__accuracy) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for accuracy",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<wkt::DoubleValue>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.accuracy = map.next_value::<__With>()?.0;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for BinaryConfusionMatrix {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if self.positive_class_threshold.is_some() {
                    struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                                self.0, serializer,
                            )
                        }
                    }
                    state.serialize_entry(
                        "positiveClassThreshold",
                        &__With(&self.positive_class_threshold),
                    )?;
                }
                if self.true_positives.is_some() {
                    struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                                self.0, serializer,
                            )
                        }
                    }
                    state.serialize_entry("truePositives", &__With(&self.true_positives))?;
                }
                if self.false_positives.is_some() {
                    struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                                self.0, serializer,
                            )
                        }
                    }
                    state.serialize_entry("falsePositives", &__With(&self.false_positives))?;
                }
                if self.true_negatives.is_some() {
                    struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                                self.0, serializer,
                            )
                        }
                    }
                    state.serialize_entry("trueNegatives", &__With(&self.true_negatives))?;
                }
                if self.false_negatives.is_some() {
                    struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                                self.0, serializer,
                            )
                        }
                    }
                    state.serialize_entry("falseNegatives", &__With(&self.false_negatives))?;
                }
                if self.precision.is_some() {
                    struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                                self.0, serializer,
                            )
                        }
                    }
                    state.serialize_entry("precision", &__With(&self.precision))?;
                }
                if self.recall.is_some() {
                    struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                                self.0, serializer,
                            )
                        }
                    }
                    state.serialize_entry("recall", &__With(&self.recall))?;
                }
                if self.f1_score.is_some() {
                    struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                                self.0, serializer,
                            )
                        }
                    }
                    state.serialize_entry("f1Score", &__With(&self.f1_score))?;
                }
                if self.accuracy.is_some() {
                    struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                                self.0, serializer,
                            )
                        }
                    }
                    state.serialize_entry("accuracy", &__With(&self.accuracy))?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }
    }

    /// Evaluation metrics for multi-class classification/classifier models.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct MultiClassClassificationMetrics {
        /// Aggregate classification metrics.
        pub aggregate_classification_metrics:
            std::option::Option<crate::model::model::AggregateClassificationMetrics>,

        /// Confusion matrix at different thresholds.
        pub confusion_matrix_list:
            std::vec::Vec<crate::model::model::multi_class_classification_metrics::ConfusionMatrix>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl MultiClassClassificationMetrics {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [aggregate_classification_metrics][crate::model::model::MultiClassClassificationMetrics::aggregate_classification_metrics].
        pub fn set_aggregate_classification_metrics<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::model::AggregateClassificationMetrics>,
        {
            self.aggregate_classification_metrics = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [aggregate_classification_metrics][crate::model::model::MultiClassClassificationMetrics::aggregate_classification_metrics].
        pub fn set_or_clear_aggregate_classification_metrics<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<crate::model::model::AggregateClassificationMetrics>,
        {
            self.aggregate_classification_metrics = v.map(|x| x.into());
            self
        }

        /// Sets the value of [confusion_matrix_list][crate::model::model::MultiClassClassificationMetrics::confusion_matrix_list].
        pub fn set_confusion_matrix_list<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                    crate::model::model::multi_class_classification_metrics::ConfusionMatrix,
                >,
        {
            use std::iter::Iterator;
            self.confusion_matrix_list = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for MultiClassClassificationMetrics {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.MultiClassClassificationMetrics"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for MultiClassClassificationMetrics {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __aggregate_classification_metrics,
                __confusion_matrix_list,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for MultiClassClassificationMetrics")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "aggregateClassificationMetrics" => {
                                    Ok(__FieldTag::__aggregate_classification_metrics)
                                }
                                "aggregate_classification_metrics" => {
                                    Ok(__FieldTag::__aggregate_classification_metrics)
                                }
                                "confusionMatrixList" => Ok(__FieldTag::__confusion_matrix_list),
                                "confusion_matrix_list" => Ok(__FieldTag::__confusion_matrix_list),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = MultiClassClassificationMetrics;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct MultiClassClassificationMetrics")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__aggregate_classification_metrics => {
                                if !fields.insert(__FieldTag::__aggregate_classification_metrics) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for aggregate_classification_metrics",
                                    ));
                                }
                                result.aggregate_classification_metrics = map
                                    .next_value::<std::option::Option<
                                        crate::model::model::AggregateClassificationMetrics,
                                    >>()?;
                            }
                            __FieldTag::__confusion_matrix_list => {
                                if !fields.insert(__FieldTag::__confusion_matrix_list) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for confusion_matrix_list",
                                    ));
                                }
                                result.confusion_matrix_list = map.next_value::<std::option::Option<std::vec::Vec<crate::model::model::multi_class_classification_metrics::ConfusionMatrix>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for MultiClassClassificationMetrics {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.aggregate_classification_metrics.is_some() {
                state.serialize_entry(
                    "aggregateClassificationMetrics",
                    &self.aggregate_classification_metrics,
                )?;
            }
            if !self.confusion_matrix_list.is_empty() {
                state.serialize_entry("confusionMatrixList", &self.confusion_matrix_list)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [MultiClassClassificationMetrics].
    pub mod multi_class_classification_metrics {
        #[allow(unused_imports)]
        use super::*;

        /// Confusion matrix for multi-class classification models.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct ConfusionMatrix {
            /// Confidence threshold used when computing the entries of the
            /// confusion matrix.
            pub confidence_threshold: std::option::Option<wkt::DoubleValue>,

            /// One row per actual label.
            pub rows: std::vec::Vec<
                crate::model::model::multi_class_classification_metrics::confusion_matrix::Row,
            >,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl ConfusionMatrix {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [confidence_threshold][crate::model::model::multi_class_classification_metrics::ConfusionMatrix::confidence_threshold].
            pub fn set_confidence_threshold<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::DoubleValue>,
            {
                self.confidence_threshold = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [confidence_threshold][crate::model::model::multi_class_classification_metrics::ConfusionMatrix::confidence_threshold].
            pub fn set_or_clear_confidence_threshold<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::DoubleValue>,
            {
                self.confidence_threshold = v.map(|x| x.into());
                self
            }

            /// Sets the value of [rows][crate::model::model::multi_class_classification_metrics::ConfusionMatrix::rows].
            pub fn set_rows<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::model::multi_class_classification_metrics::confusion_matrix::Row>
            {
                use std::iter::Iterator;
                self.rows = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for ConfusionMatrix {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.bigquery.v2.Model.MultiClassClassificationMetrics.ConfusionMatrix"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for ConfusionMatrix {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __confidence_threshold,
                    __rows,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for ConfusionMatrix")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "confidenceThreshold" => Ok(__FieldTag::__confidence_threshold),
                                    "confidence_threshold" => {
                                        Ok(__FieldTag::__confidence_threshold)
                                    }
                                    "rows" => Ok(__FieldTag::__rows),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = ConfusionMatrix;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct ConfusionMatrix")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__confidence_threshold => {
                                    if !fields.insert(__FieldTag::__confidence_threshold) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for confidence_threshold",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<wkt::DoubleValue>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.confidence_threshold = map.next_value::<__With>()?.0;
                                }
                                __FieldTag::__rows => {
                                    if !fields.insert(__FieldTag::__rows) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for rows"),
                                        );
                                    }
                                    result.rows = map.next_value::<std::option::Option<std::vec::Vec<crate::model::model::multi_class_classification_metrics::confusion_matrix::Row>>>()?.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for ConfusionMatrix {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if self.confidence_threshold.is_some() {
                    struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                                self.0, serializer,
                            )
                        }
                    }
                    state.serialize_entry(
                        "confidenceThreshold",
                        &__With(&self.confidence_threshold),
                    )?;
                }
                if !self.rows.is_empty() {
                    state.serialize_entry("rows", &self.rows)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [ConfusionMatrix].
        pub mod confusion_matrix {
            #[allow(unused_imports)]
            use super::*;

            /// A single entry in the confusion matrix.
            #[derive(Clone, Debug, Default, PartialEq)]
            #[non_exhaustive]
            pub struct Entry {
                /// The predicted label. For confidence_threshold > 0, we will
                /// also add an entry indicating the number of items under the
                /// confidence threshold.
                pub predicted_label: std::string::String,

                /// Number of items being predicted as this label.
                pub item_count: std::option::Option<wkt::Int64Value>,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl Entry {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [predicted_label][crate::model::model::multi_class_classification_metrics::confusion_matrix::Entry::predicted_label].
                pub fn set_predicted_label<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.predicted_label = v.into();
                    self
                }

                /// Sets the value of [item_count][crate::model::model::multi_class_classification_metrics::confusion_matrix::Entry::item_count].
                pub fn set_item_count<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<wkt::Int64Value>,
                {
                    self.item_count = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [item_count][crate::model::model::multi_class_classification_metrics::confusion_matrix::Entry::item_count].
                pub fn set_or_clear_item_count<T>(mut self, v: std::option::Option<T>) -> Self
                where
                    T: std::convert::Into<wkt::Int64Value>,
                {
                    self.item_count = v.map(|x| x.into());
                    self
                }
            }

            impl wkt::message::Message for Entry {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.bigquery.v2.Model.MultiClassClassificationMetrics.ConfusionMatrix.Entry"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for Entry {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __predicted_label,
                        __item_count,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for Entry")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "predictedLabel" => Ok(__FieldTag::__predicted_label),
                                        "predicted_label" => Ok(__FieldTag::__predicted_label),
                                        "itemCount" => Ok(__FieldTag::__item_count),
                                        "item_count" => Ok(__FieldTag::__item_count),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = Entry;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct Entry")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__predicted_label => {
                                        if !fields.insert(__FieldTag::__predicted_label) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for predicted_label",
                                                ),
                                            );
                                        }
                                        result.predicted_label = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__item_count => {
                                        if !fields.insert(__FieldTag::__item_count) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for item_count",
                                                ),
                                            );
                                        }
                                        struct __With(std::option::Option<wkt::Int64Value>);
                                        impl<'de> serde::de::Deserialize<'de> for __With {
                                            fn deserialize<D>(
                                                deserializer: D,
                                            ) -> std::result::Result<Self, D::Error>
                                            where
                                                D: serde::de::Deserializer<'de>,
                                            {
                                                serde_with::As::<
                                                    std::option::Option<wkt::internal::I64>,
                                                >::deserialize(
                                                    deserializer
                                                )
                                                .map(__With)
                                            }
                                        }
                                        result.item_count = map.next_value::<__With>()?.0;
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for Entry {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self.predicted_label.is_empty() {
                        state.serialize_entry("predictedLabel", &self.predicted_label)?;
                    }
                    if self.item_count.is_some() {
                        struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
                        impl<'a> serde::ser::Serialize for __With<'a> {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::ser::Serializer,
                            {
                                serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                                    self.0, serializer,
                                )
                            }
                        }
                        state.serialize_entry("itemCount", &__With(&self.item_count))?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            /// A single row in the confusion matrix.
            #[derive(Clone, Debug, Default, PartialEq)]
            #[non_exhaustive]
            pub struct Row {

                /// The original label of this row.
                pub actual_label: std::string::String,

                /// Info describing predicted label distribution.
                pub entries: std::vec::Vec<crate::model::model::multi_class_classification_metrics::confusion_matrix::Entry>,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl Row {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [actual_label][crate::model::model::multi_class_classification_metrics::confusion_matrix::Row::actual_label].
                pub fn set_actual_label<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.actual_label = v.into();
                    self
                }

                /// Sets the value of [entries][crate::model::model::multi_class_classification_metrics::confusion_matrix::Row::entries].
                pub fn set_entries<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<crate::model::model::multi_class_classification_metrics::confusion_matrix::Entry>
                {
                    use std::iter::Iterator;
                    self.entries = v.into_iter().map(|i| i.into()).collect();
                    self
                }
            }

            impl wkt::message::Message for Row {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.bigquery.v2.Model.MultiClassClassificationMetrics.ConfusionMatrix.Row"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for Row {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __actual_label,
                        __entries,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for Row")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "actualLabel" => Ok(__FieldTag::__actual_label),
                                        "actual_label" => Ok(__FieldTag::__actual_label),
                                        "entries" => Ok(__FieldTag::__entries),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = Row;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct Row")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__actual_label => {
                                        if !fields.insert(__FieldTag::__actual_label) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for actual_label",
                                                ),
                                            );
                                        }
                                        result.actual_label = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__entries => {
                                        if !fields.insert(__FieldTag::__entries) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for entries",
                                                ),
                                            );
                                        }
                                        result.entries = map.next_value::<std::option::Option<std::vec::Vec<crate::model::model::multi_class_classification_metrics::confusion_matrix::Entry>>>()?.unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for Row {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self.actual_label.is_empty() {
                        state.serialize_entry("actualLabel", &self.actual_label)?;
                    }
                    if !self.entries.is_empty() {
                        state.serialize_entry("entries", &self.entries)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }
        }
    }

    /// Evaluation metrics for clustering models.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ClusteringMetrics {
        /// Davies-Bouldin index.
        pub davies_bouldin_index: std::option::Option<wkt::DoubleValue>,

        /// Mean of squared distances between each sample to its cluster centroid.
        pub mean_squared_distance: std::option::Option<wkt::DoubleValue>,

        /// Information for all clusters.
        pub clusters: std::vec::Vec<crate::model::model::clustering_metrics::Cluster>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ClusteringMetrics {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [davies_bouldin_index][crate::model::model::ClusteringMetrics::davies_bouldin_index].
        pub fn set_davies_bouldin_index<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::DoubleValue>,
        {
            self.davies_bouldin_index = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [davies_bouldin_index][crate::model::model::ClusteringMetrics::davies_bouldin_index].
        pub fn set_or_clear_davies_bouldin_index<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::DoubleValue>,
        {
            self.davies_bouldin_index = v.map(|x| x.into());
            self
        }

        /// Sets the value of [mean_squared_distance][crate::model::model::ClusteringMetrics::mean_squared_distance].
        pub fn set_mean_squared_distance<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::DoubleValue>,
        {
            self.mean_squared_distance = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [mean_squared_distance][crate::model::model::ClusteringMetrics::mean_squared_distance].
        pub fn set_or_clear_mean_squared_distance<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::DoubleValue>,
        {
            self.mean_squared_distance = v.map(|x| x.into());
            self
        }

        /// Sets the value of [clusters][crate::model::model::ClusteringMetrics::clusters].
        pub fn set_clusters<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::model::clustering_metrics::Cluster>,
        {
            use std::iter::Iterator;
            self.clusters = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ClusteringMetrics {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.ClusteringMetrics"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ClusteringMetrics {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __davies_bouldin_index,
                __mean_squared_distance,
                __clusters,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ClusteringMetrics")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "daviesBouldinIndex" => Ok(__FieldTag::__davies_bouldin_index),
                                "davies_bouldin_index" => Ok(__FieldTag::__davies_bouldin_index),
                                "meanSquaredDistance" => Ok(__FieldTag::__mean_squared_distance),
                                "mean_squared_distance" => Ok(__FieldTag::__mean_squared_distance),
                                "clusters" => Ok(__FieldTag::__clusters),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ClusteringMetrics;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ClusteringMetrics")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__davies_bouldin_index => {
                                if !fields.insert(__FieldTag::__davies_bouldin_index) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for davies_bouldin_index",
                                    ));
                                }
                                struct __With(std::option::Option<wkt::DoubleValue>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.davies_bouldin_index = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::__mean_squared_distance => {
                                if !fields.insert(__FieldTag::__mean_squared_distance) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for mean_squared_distance",
                                    ));
                                }
                                struct __With(std::option::Option<wkt::DoubleValue>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.mean_squared_distance = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::__clusters => {
                                if !fields.insert(__FieldTag::__clusters) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for clusters",
                                    ));
                                }
                                result.clusters = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<
                                            crate::model::model::clustering_metrics::Cluster,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ClusteringMetrics {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.davies_bouldin_index.is_some() {
                struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("daviesBouldinIndex", &__With(&self.davies_bouldin_index))?;
            }
            if self.mean_squared_distance.is_some() {
                struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state
                    .serialize_entry("meanSquaredDistance", &__With(&self.mean_squared_distance))?;
            }
            if !self.clusters.is_empty() {
                state.serialize_entry("clusters", &self.clusters)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [ClusteringMetrics].
    pub mod clustering_metrics {
        #[allow(unused_imports)]
        use super::*;

        /// Message containing the information about one cluster.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Cluster {
            /// Centroid id.
            pub centroid_id: i64,

            /// Values of highly variant features for this cluster.
            pub feature_values:
                std::vec::Vec<crate::model::model::clustering_metrics::cluster::FeatureValue>,

            /// Count of training data rows that were assigned to this cluster.
            pub count: std::option::Option<wkt::Int64Value>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Cluster {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [centroid_id][crate::model::model::clustering_metrics::Cluster::centroid_id].
            pub fn set_centroid_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.centroid_id = v.into();
                self
            }

            /// Sets the value of [feature_values][crate::model::model::clustering_metrics::Cluster::feature_values].
            pub fn set_feature_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<
                        crate::model::model::clustering_metrics::cluster::FeatureValue,
                    >,
            {
                use std::iter::Iterator;
                self.feature_values = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [count][crate::model::model::clustering_metrics::Cluster::count].
            pub fn set_count<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::Int64Value>,
            {
                self.count = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [count][crate::model::model::clustering_metrics::Cluster::count].
            pub fn set_or_clear_count<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::Int64Value>,
            {
                self.count = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for Cluster {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.bigquery.v2.Model.ClusteringMetrics.Cluster"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Cluster {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __centroid_id,
                    __feature_values,
                    __count,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Cluster")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "centroidId" => Ok(__FieldTag::__centroid_id),
                                    "centroid_id" => Ok(__FieldTag::__centroid_id),
                                    "featureValues" => Ok(__FieldTag::__feature_values),
                                    "feature_values" => Ok(__FieldTag::__feature_values),
                                    "count" => Ok(__FieldTag::__count),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Cluster;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Cluster")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__centroid_id => {
                                    if !fields.insert(__FieldTag::__centroid_id) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for centroid_id",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.centroid_id =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__feature_values => {
                                    if !fields.insert(__FieldTag::__feature_values) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for feature_values",
                                            ),
                                        );
                                    }
                                    result.feature_values = map.next_value::<std::option::Option<std::vec::Vec<crate::model::model::clustering_metrics::cluster::FeatureValue>>>()?.unwrap_or_default();
                                }
                                __FieldTag::__count => {
                                    if !fields.insert(__FieldTag::__count) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for count"),
                                        );
                                    }
                                    struct __With(std::option::Option<wkt::Int64Value>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.count = map.next_value::<__With>()?.0;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Cluster {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.centroid_id) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("centroidId", &__With(&self.centroid_id))?;
                }
                if !self.feature_values.is_empty() {
                    state.serialize_entry("featureValues", &self.feature_values)?;
                }
                if self.count.is_some() {
                    struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                                self.0, serializer,
                            )
                        }
                    }
                    state.serialize_entry("count", &__With(&self.count))?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [Cluster].
        pub mod cluster {
            #[allow(unused_imports)]
            use super::*;

            /// Representative value of a single feature within the cluster.
            #[derive(Clone, Debug, Default, PartialEq)]
            #[non_exhaustive]
            pub struct FeatureValue {
                /// The feature column name.
                pub feature_column: std::string::String,

                /// Value.
                pub value: std::option::Option<
                    crate::model::model::clustering_metrics::cluster::feature_value::Value,
                >,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl FeatureValue {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [feature_column][crate::model::model::clustering_metrics::cluster::FeatureValue::feature_column].
                pub fn set_feature_column<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.feature_column = v.into();
                    self
                }

                /// Sets the value of [value][crate::model::model::clustering_metrics::cluster::FeatureValue::value].
                ///
                /// Note that all the setters affecting `value` are mutually
                /// exclusive.
                pub fn set_value<T: std::convert::Into<std::option::Option<crate::model::model::clustering_metrics::cluster::feature_value::Value>>>(mut self, v: T) -> Self
                {
                    self.value = v.into();
                    self
                }

                /// The value of [value][crate::model::model::clustering_metrics::cluster::FeatureValue::value]
                /// if it holds a `NumericalValue`, `None` if the field is not set or
                /// holds a different branch.
                pub fn numerical_value(
                    &self,
                ) -> std::option::Option<&std::boxed::Box<wkt::DoubleValue>> {
                    #[allow(unreachable_patterns)]
                    self.value.as_ref().and_then(|v| match v {
                        crate::model::model::clustering_metrics::cluster::feature_value::Value::NumericalValue(v) => std::option::Option::Some(v),
                        _ => std::option::Option::None,
                    })
                }

                /// Sets the value of [value][crate::model::model::clustering_metrics::cluster::FeatureValue::value]
                /// to hold a `NumericalValue`.
                ///
                /// Note that all the setters affecting `value` are
                /// mutually exclusive.
                pub fn set_numerical_value<
                    T: std::convert::Into<std::boxed::Box<wkt::DoubleValue>>,
                >(
                    mut self,
                    v: T,
                ) -> Self {
                    self.value = std::option::Option::Some(
                        crate::model::model::clustering_metrics::cluster::feature_value::Value::NumericalValue(
                            v.into()
                        )
                    );
                    self
                }

                /// The value of [value][crate::model::model::clustering_metrics::cluster::FeatureValue::value]
                /// if it holds a `CategoricalValue`, `None` if the field is not set or
                /// holds a different branch.
                pub fn categorical_value(&self) -> std::option::Option<&std::boxed::Box<crate::model::model::clustering_metrics::cluster::feature_value::CategoricalValue>>{
                    #[allow(unreachable_patterns)]
                    self.value.as_ref().and_then(|v| match v {
                        crate::model::model::clustering_metrics::cluster::feature_value::Value::CategoricalValue(v) => std::option::Option::Some(v),
                        _ => std::option::Option::None,
                    })
                }

                /// Sets the value of [value][crate::model::model::clustering_metrics::cluster::FeatureValue::value]
                /// to hold a `CategoricalValue`.
                ///
                /// Note that all the setters affecting `value` are
                /// mutually exclusive.
                pub fn set_categorical_value<T: std::convert::Into<std::boxed::Box<crate::model::model::clustering_metrics::cluster::feature_value::CategoricalValue>>>(mut self, v: T) -> Self{
                    self.value = std::option::Option::Some(
                        crate::model::model::clustering_metrics::cluster::feature_value::Value::CategoricalValue(
                            v.into()
                        )
                    );
                    self
                }
            }

            impl wkt::message::Message for FeatureValue {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.bigquery.v2.Model.ClusteringMetrics.Cluster.FeatureValue"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for FeatureValue {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __feature_column,
                        __numerical_value,
                        __categorical_value,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for FeatureValue")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "featureColumn" => Ok(__FieldTag::__feature_column),
                                        "feature_column" => Ok(__FieldTag::__feature_column),
                                        "numericalValue" => Ok(__FieldTag::__numerical_value),
                                        "numerical_value" => Ok(__FieldTag::__numerical_value),
                                        "categoricalValue" => Ok(__FieldTag::__categorical_value),
                                        "categorical_value" => Ok(__FieldTag::__categorical_value),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = FeatureValue;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct FeatureValue")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__feature_column => {
                                        if !fields.insert(__FieldTag::__feature_column) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for feature_column",
                                                ),
                                            );
                                        }
                                        result.feature_column = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__numerical_value => {
                                        if !fields.insert(__FieldTag::__numerical_value) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for numerical_value",
                                                ),
                                            );
                                        }
                                        struct __With(
                                            std::option::Option<std::boxed::Box<wkt::DoubleValue>>,
                                        );
                                        impl<'de> serde::de::Deserialize<'de> for __With {
                                            fn deserialize<D>(
                                                deserializer: D,
                                            ) -> std::result::Result<Self, D::Error>
                                            where
                                                D: serde::de::Deserializer<'de>,
                                            {
                                                serde_with::As::<
                                                    std::option::Option<
                                                        std::boxed::Box<wkt::internal::F64>,
                                                    >,
                                                >::deserialize(
                                                    deserializer
                                                )
                                                .map(__With)
                                            }
                                        }
                                        if result.value.is_some() {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for `value`, a oneof with full ID .google.cloud.bigquery.v2.Model.ClusteringMetrics.Cluster.FeatureValue.numerical_value, latest field was numericalValue",
                                                ),
                                            );
                                        }
                                        result.value = std::option::Option::Some(
                                            crate::model::model::clustering_metrics::cluster::feature_value::Value::NumericalValue(
                                                map.next_value::<__With>()?.0.unwrap_or_default()
                                            ),
                                        );
                                    }
                                    __FieldTag::__categorical_value => {
                                        if !fields.insert(__FieldTag::__categorical_value) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for categorical_value",
                                                ),
                                            );
                                        }
                                        if result.value.is_some() {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for `value`, a oneof with full ID .google.cloud.bigquery.v2.Model.ClusteringMetrics.Cluster.FeatureValue.categorical_value, latest field was categoricalValue",
                                                ),
                                            );
                                        }
                                        result.value = std::option::Option::Some(
                                            crate::model::model::clustering_metrics::cluster::feature_value::Value::CategoricalValue(
                                                map.next_value::<std::option::Option<std::boxed::Box<crate::model::model::clustering_metrics::cluster::feature_value::CategoricalValue>>>()?.unwrap_or_default()
                                            ),
                                        );
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for FeatureValue {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self.feature_column.is_empty() {
                        state.serialize_entry("featureColumn", &self.feature_column)?;
                    }
                    if let Some(value) = self.numerical_value() {
                        struct __With<'a>(&'a std::boxed::Box<wkt::DoubleValue>);
                        impl<'a> serde::ser::Serialize for __With<'a> {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::ser::Serializer,
                            {
                                serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                            }
                        }
                        state.serialize_entry("numericalValue", &__With(value))?;
                    }
                    if let Some(value) = self.categorical_value() {
                        state.serialize_entry("categoricalValue", value)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            /// Defines additional types related to [FeatureValue].
            pub mod feature_value {
                #[allow(unused_imports)]
                use super::*;

                /// Representative value of a categorical feature.
                #[derive(Clone, Debug, Default, PartialEq)]
                #[non_exhaustive]
                pub struct CategoricalValue {

                    /// Counts of all categories for the categorical feature. If there are
                    /// more than ten categories, we return top ten (by count) and return
                    /// one more CategoryCount with category "_OTHER_" and count as
                    /// aggregate counts of remaining categories.
                    pub category_counts: std::vec::Vec<crate::model::model::clustering_metrics::cluster::feature_value::categorical_value::CategoryCount>,

                    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
                }

                impl CategoricalValue {
                    pub fn new() -> Self {
                        std::default::Default::default()
                    }

                    /// Sets the value of [category_counts][crate::model::model::clustering_metrics::cluster::feature_value::CategoricalValue::category_counts].
                    pub fn set_category_counts<T, V>(mut self, v: T) -> Self
                    where
                        T: std::iter::IntoIterator<Item = V>,
                        V: std::convert::Into<crate::model::model::clustering_metrics::cluster::feature_value::categorical_value::CategoryCount>
                    {
                        use std::iter::Iterator;
                        self.category_counts = v.into_iter().map(|i| i.into()).collect();
                        self
                    }
                }

                impl wkt::message::Message for CategoricalValue {
                    fn typename() -> &'static str {
                        "type.googleapis.com/google.cloud.bigquery.v2.Model.ClusteringMetrics.Cluster.FeatureValue.CategoricalValue"
                    }
                }

                #[doc(hidden)]
                impl<'de> serde::de::Deserialize<'de> for CategoricalValue {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        #[derive(PartialEq, Eq, Hash)]
                        enum __FieldTag {
                            __category_counts,
                            Unknown(std::string::String),
                        }
                        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                            fn deserialize<D>(
                                deserializer: D,
                            ) -> std::result::Result<Self, D::Error>
                            where
                                D: serde::Deserializer<'de>,
                            {
                                struct Visitor;
                                impl<'de> serde::de::Visitor<'de> for Visitor {
                                    type Value = __FieldTag;
                                    fn expecting(
                                        &self,
                                        formatter: &mut std::fmt::Formatter,
                                    ) -> std::fmt::Result {
                                        formatter.write_str("a field name for CategoricalValue")
                                    }
                                    fn visit_str<E>(
                                        self,
                                        value: &str,
                                    ) -> std::result::Result<Self::Value, E>
                                    where
                                        E: serde::de::Error,
                                    {
                                        use std::result::Result::Ok;
                                        use std::string::ToString;
                                        match value {
                                            "categoryCounts" => Ok(__FieldTag::__category_counts),
                                            "category_counts" => Ok(__FieldTag::__category_counts),
                                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                                        }
                                    }
                                }
                                deserializer.deserialize_identifier(Visitor)
                            }
                        }
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = CategoricalValue;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("struct CategoricalValue")
                            }
                            fn visit_map<A>(
                                self,
                                mut map: A,
                            ) -> std::result::Result<Self::Value, A::Error>
                            where
                                A: serde::de::MapAccess<'de>,
                            {
                                #[allow(unused_imports)]
                                use serde::de::Error;
                                use std::option::Option::Some;
                                let mut fields = std::collections::HashSet::new();
                                let mut result = Self::Value::new();
                                while let Some(tag) = map.next_key::<__FieldTag>()? {
                                    #[allow(clippy::match_single_binding)]
                                    match tag {
                                        __FieldTag::__category_counts => {
                                            if !fields.insert(__FieldTag::__category_counts) {
                                                return std::result::Result::Err(
                                                    A::Error::duplicate_field(
                                                        "multiple values for category_counts",
                                                    ),
                                                );
                                            }
                                            result.category_counts = map.next_value::<std::option::Option<std::vec::Vec<crate::model::model::clustering_metrics::cluster::feature_value::categorical_value::CategoryCount>>>()?.unwrap_or_default();
                                        }
                                        __FieldTag::Unknown(key) => {
                                            let value = map.next_value::<serde_json::Value>()?;
                                            result._unknown_fields.insert(key, value);
                                        }
                                    }
                                }
                                std::result::Result::Ok(result)
                            }
                        }
                        deserializer.deserialize_any(Visitor)
                    }
                }

                #[doc(hidden)]
                impl serde::ser::Serialize for CategoricalValue {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        use serde::ser::SerializeMap;
                        #[allow(unused_imports)]
                        use std::option::Option::Some;
                        let mut state = serializer.serialize_map(std::option::Option::None)?;
                        if !self.category_counts.is_empty() {
                            state.serialize_entry("categoryCounts", &self.category_counts)?;
                        }
                        if !self._unknown_fields.is_empty() {
                            for (key, value) in self._unknown_fields.iter() {
                                state.serialize_entry(key, &value)?;
                            }
                        }
                        state.end()
                    }
                }

                /// Defines additional types related to [CategoricalValue].
                pub mod categorical_value {
                    #[allow(unused_imports)]
                    use super::*;

                    /// Represents the count of a single category within the cluster.
                    #[derive(Clone, Debug, Default, PartialEq)]
                    #[non_exhaustive]
                    pub struct CategoryCount {
                        /// The name of category.
                        pub category: std::string::String,

                        /// The count of training samples matching the category within the
                        /// cluster.
                        pub count: std::option::Option<wkt::Int64Value>,

                        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
                    }

                    impl CategoryCount {
                        pub fn new() -> Self {
                            std::default::Default::default()
                        }

                        /// Sets the value of [category][crate::model::model::clustering_metrics::cluster::feature_value::categorical_value::CategoryCount::category].
                        pub fn set_category<T: std::convert::Into<std::string::String>>(
                            mut self,
                            v: T,
                        ) -> Self {
                            self.category = v.into();
                            self
                        }

                        /// Sets the value of [count][crate::model::model::clustering_metrics::cluster::feature_value::categorical_value::CategoryCount::count].
                        pub fn set_count<T>(mut self, v: T) -> Self
                        where
                            T: std::convert::Into<wkt::Int64Value>,
                        {
                            self.count = std::option::Option::Some(v.into());
                            self
                        }

                        /// Sets or clears the value of [count][crate::model::model::clustering_metrics::cluster::feature_value::categorical_value::CategoryCount::count].
                        pub fn set_or_clear_count<T>(mut self, v: std::option::Option<T>) -> Self
                        where
                            T: std::convert::Into<wkt::Int64Value>,
                        {
                            self.count = v.map(|x| x.into());
                            self
                        }
                    }

                    impl wkt::message::Message for CategoryCount {
                        fn typename() -> &'static str {
                            "type.googleapis.com/google.cloud.bigquery.v2.Model.ClusteringMetrics.Cluster.FeatureValue.CategoricalValue.CategoryCount"
                        }
                    }

                    #[doc(hidden)]
                    impl<'de> serde::de::Deserialize<'de> for CategoryCount {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            #[derive(PartialEq, Eq, Hash)]
                            enum __FieldTag {
                                __category,
                                __count,
                                Unknown(std::string::String),
                            }
                            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::Deserializer<'de>,
                                {
                                    struct Visitor;
                                    impl<'de> serde::de::Visitor<'de> for Visitor {
                                        type Value = __FieldTag;
                                        fn expecting(
                                            &self,
                                            formatter: &mut std::fmt::Formatter,
                                        ) -> std::fmt::Result
                                        {
                                            formatter.write_str("a field name for CategoryCount")
                                        }
                                        fn visit_str<E>(
                                            self,
                                            value: &str,
                                        ) -> std::result::Result<Self::Value, E>
                                        where
                                            E: serde::de::Error,
                                        {
                                            use std::result::Result::Ok;
                                            use std::string::ToString;
                                            match value {
                                                "category" => Ok(__FieldTag::__category),
                                                "count" => Ok(__FieldTag::__count),
                                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                                            }
                                        }
                                    }
                                    deserializer.deserialize_identifier(Visitor)
                                }
                            }
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = CategoryCount;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("struct CategoryCount")
                                }
                                fn visit_map<A>(
                                    self,
                                    mut map: A,
                                ) -> std::result::Result<Self::Value, A::Error>
                                where
                                    A: serde::de::MapAccess<'de>,
                                {
                                    #[allow(unused_imports)]
                                    use serde::de::Error;
                                    use std::option::Option::Some;
                                    let mut fields = std::collections::HashSet::new();
                                    let mut result = Self::Value::new();
                                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                                        #[allow(clippy::match_single_binding)]
                                        match tag {
                                            __FieldTag::__category => {
                                                if !fields.insert(__FieldTag::__category) {
                                                    return std::result::Result::Err(
                                                        A::Error::duplicate_field(
                                                            "multiple values for category",
                                                        ),
                                                    );
                                                }
                                                result.category = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                                            }
                                            __FieldTag::__count => {
                                                if !fields.insert(__FieldTag::__count) {
                                                    return std::result::Result::Err(
                                                        A::Error::duplicate_field(
                                                            "multiple values for count",
                                                        ),
                                                    );
                                                }
                                                struct __With(std::option::Option<wkt::Int64Value>);
                                                impl<'de> serde::de::Deserialize<'de> for __With {
                                                    fn deserialize<D>(
                                                        deserializer: D,
                                                    ) -> std::result::Result<Self, D::Error>
                                                    where
                                                        D: serde::de::Deserializer<'de>,
                                                    {
                                                        serde_with::As::<
                                                            std::option::Option<wkt::internal::I64>,
                                                        >::deserialize(
                                                            deserializer
                                                        )
                                                        .map(__With)
                                                    }
                                                }
                                                result.count = map.next_value::<__With>()?.0;
                                            }
                                            __FieldTag::Unknown(key) => {
                                                let value =
                                                    map.next_value::<serde_json::Value>()?;
                                                result._unknown_fields.insert(key, value);
                                            }
                                        }
                                    }
                                    std::result::Result::Ok(result)
                                }
                            }
                            deserializer.deserialize_any(Visitor)
                        }
                    }

                    #[doc(hidden)]
                    impl serde::ser::Serialize for CategoryCount {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            use serde::ser::SerializeMap;
                            #[allow(unused_imports)]
                            use std::option::Option::Some;
                            let mut state = serializer.serialize_map(std::option::Option::None)?;
                            if !self.category.is_empty() {
                                state.serialize_entry("category", &self.category)?;
                            }
                            if self.count.is_some() {
                                struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
                                impl<'a> serde::ser::Serialize for __With<'a> {
                                    fn serialize<S>(
                                        &self,
                                        serializer: S,
                                    ) -> std::result::Result<S::Ok, S::Error>
                                    where
                                        S: serde::ser::Serializer,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                                    }
                                }
                                state.serialize_entry("count", &__With(&self.count))?;
                            }
                            if !self._unknown_fields.is_empty() {
                                for (key, value) in self._unknown_fields.iter() {
                                    state.serialize_entry(key, &value)?;
                                }
                            }
                            state.end()
                        }
                    }
                }

                /// Value.
                #[derive(Clone, Debug, PartialEq)]
                #[non_exhaustive]
                pub enum Value {
                    /// The numerical feature value. This is the centroid value for this
                    /// feature.
                    NumericalValue(std::boxed::Box<wkt::DoubleValue>),
                    /// The categorical feature value.
                    CategoricalValue(std::boxed::Box<crate::model::model::clustering_metrics::cluster::feature_value::CategoricalValue>),
                }
            }
        }
    }

    /// Evaluation metrics used by weighted-ALS models specified by
    /// feedback_type=implicit.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct RankingMetrics {
        /// Calculates a precision per user for all the items by ranking them and
        /// then averages all the precisions across all the users.
        pub mean_average_precision: std::option::Option<wkt::DoubleValue>,

        /// Similar to the mean squared error computed in regression and explicit
        /// recommendation models except instead of computing the rating directly,
        /// the output from evaluate is computed against a preference which is 1 or 0
        /// depending on if the rating exists or not.
        pub mean_squared_error: std::option::Option<wkt::DoubleValue>,

        /// A metric to determine the goodness of a ranking calculated from the
        /// predicted confidence by comparing it to an ideal rank measured by the
        /// original ratings.
        pub normalized_discounted_cumulative_gain: std::option::Option<wkt::DoubleValue>,

        /// Determines the goodness of a ranking by computing the percentile rank
        /// from the predicted confidence and dividing it by the original rank.
        pub average_rank: std::option::Option<wkt::DoubleValue>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RankingMetrics {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [mean_average_precision][crate::model::model::RankingMetrics::mean_average_precision].
        pub fn set_mean_average_precision<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::DoubleValue>,
        {
            self.mean_average_precision = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [mean_average_precision][crate::model::model::RankingMetrics::mean_average_precision].
        pub fn set_or_clear_mean_average_precision<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::DoubleValue>,
        {
            self.mean_average_precision = v.map(|x| x.into());
            self
        }

        /// Sets the value of [mean_squared_error][crate::model::model::RankingMetrics::mean_squared_error].
        pub fn set_mean_squared_error<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::DoubleValue>,
        {
            self.mean_squared_error = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [mean_squared_error][crate::model::model::RankingMetrics::mean_squared_error].
        pub fn set_or_clear_mean_squared_error<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::DoubleValue>,
        {
            self.mean_squared_error = v.map(|x| x.into());
            self
        }

        /// Sets the value of [normalized_discounted_cumulative_gain][crate::model::model::RankingMetrics::normalized_discounted_cumulative_gain].
        pub fn set_normalized_discounted_cumulative_gain<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::DoubleValue>,
        {
            self.normalized_discounted_cumulative_gain = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [normalized_discounted_cumulative_gain][crate::model::model::RankingMetrics::normalized_discounted_cumulative_gain].
        pub fn set_or_clear_normalized_discounted_cumulative_gain<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<wkt::DoubleValue>,
        {
            self.normalized_discounted_cumulative_gain = v.map(|x| x.into());
            self
        }

        /// Sets the value of [average_rank][crate::model::model::RankingMetrics::average_rank].
        pub fn set_average_rank<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::DoubleValue>,
        {
            self.average_rank = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [average_rank][crate::model::model::RankingMetrics::average_rank].
        pub fn set_or_clear_average_rank<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::DoubleValue>,
        {
            self.average_rank = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for RankingMetrics {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.RankingMetrics"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for RankingMetrics {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __mean_average_precision,
                __mean_squared_error,
                __normalized_discounted_cumulative_gain,
                __average_rank,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for RankingMetrics")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "meanAveragePrecision" => Ok(__FieldTag::__mean_average_precision),
                                "mean_average_precision" => {
                                    Ok(__FieldTag::__mean_average_precision)
                                }
                                "meanSquaredError" => Ok(__FieldTag::__mean_squared_error),
                                "mean_squared_error" => Ok(__FieldTag::__mean_squared_error),
                                "normalizedDiscountedCumulativeGain" => {
                                    Ok(__FieldTag::__normalized_discounted_cumulative_gain)
                                }
                                "normalized_discounted_cumulative_gain" => {
                                    Ok(__FieldTag::__normalized_discounted_cumulative_gain)
                                }
                                "averageRank" => Ok(__FieldTag::__average_rank),
                                "average_rank" => Ok(__FieldTag::__average_rank),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = RankingMetrics;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct RankingMetrics")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__mean_average_precision => {
                                if !fields.insert(__FieldTag::__mean_average_precision) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for mean_average_precision",
                                    ));
                                }
                                struct __With(std::option::Option<wkt::DoubleValue>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.mean_average_precision = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::__mean_squared_error => {
                                if !fields.insert(__FieldTag::__mean_squared_error) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for mean_squared_error",
                                    ));
                                }
                                struct __With(std::option::Option<wkt::DoubleValue>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.mean_squared_error = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::__normalized_discounted_cumulative_gain => {
                                if !fields
                                    .insert(__FieldTag::__normalized_discounted_cumulative_gain)
                                {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for normalized_discounted_cumulative_gain",
                                    ));
                                }
                                struct __With(std::option::Option<wkt::DoubleValue>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.normalized_discounted_cumulative_gain =
                                    map.next_value::<__With>()?.0;
                            }
                            __FieldTag::__average_rank => {
                                if !fields.insert(__FieldTag::__average_rank) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for average_rank",
                                    ));
                                }
                                struct __With(std::option::Option<wkt::DoubleValue>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.average_rank = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for RankingMetrics {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.mean_average_precision.is_some() {
                struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry(
                    "meanAveragePrecision",
                    &__With(&self.mean_average_precision),
                )?;
            }
            if self.mean_squared_error.is_some() {
                struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("meanSquaredError", &__With(&self.mean_squared_error))?;
            }
            if self.normalized_discounted_cumulative_gain.is_some() {
                struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry(
                    "normalizedDiscountedCumulativeGain",
                    &__With(&self.normalized_discounted_cumulative_gain),
                )?;
            }
            if self.average_rank.is_some() {
                struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("averageRank", &__With(&self.average_rank))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Model evaluation metrics for ARIMA forecasting models.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ArimaForecastingMetrics {
        /// Repeated as there can be many metric sets (one for each model) in
        /// auto-arima and the large-scale case.
        pub arima_single_model_forecasting_metrics: std::vec::Vec<
            crate::model::model::arima_forecasting_metrics::ArimaSingleModelForecastingMetrics,
        >,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ArimaForecastingMetrics {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [arima_single_model_forecasting_metrics][crate::model::model::ArimaForecastingMetrics::arima_single_model_forecasting_metrics].
        pub fn set_arima_single_model_forecasting_metrics<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::model::arima_forecasting_metrics::ArimaSingleModelForecastingMetrics>
        {
            use std::iter::Iterator;
            self.arima_single_model_forecasting_metrics = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ArimaForecastingMetrics {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.ArimaForecastingMetrics"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ArimaForecastingMetrics {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __arima_single_model_forecasting_metrics,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ArimaForecastingMetrics")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "arimaSingleModelForecastingMetrics" => {
                                    Ok(__FieldTag::__arima_single_model_forecasting_metrics)
                                }
                                "arima_single_model_forecasting_metrics" => {
                                    Ok(__FieldTag::__arima_single_model_forecasting_metrics)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ArimaForecastingMetrics;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ArimaForecastingMetrics")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__arima_single_model_forecasting_metrics => {
                                if !fields
                                    .insert(__FieldTag::__arima_single_model_forecasting_metrics)
                                {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for arima_single_model_forecasting_metrics",
                                    ));
                                }
                                result.arima_single_model_forecasting_metrics = map.next_value::<std::option::Option<std::vec::Vec<crate::model::model::arima_forecasting_metrics::ArimaSingleModelForecastingMetrics>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ArimaForecastingMetrics {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.arima_single_model_forecasting_metrics.is_empty() {
                state.serialize_entry(
                    "arimaSingleModelForecastingMetrics",
                    &self.arima_single_model_forecasting_metrics,
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [ArimaForecastingMetrics].
    pub mod arima_forecasting_metrics {
        #[allow(unused_imports)]
        use super::*;

        /// Model evaluation metrics for a single ARIMA forecasting model.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct ArimaSingleModelForecastingMetrics {
            /// Non-seasonal order.
            pub non_seasonal_order: std::option::Option<crate::model::model::ArimaOrder>,

            /// Arima fitting metrics.
            pub arima_fitting_metrics:
                std::option::Option<crate::model::model::ArimaFittingMetrics>,

            /// Is arima model fitted with drift or not. It is always false when d
            /// is not 1.
            pub has_drift: std::option::Option<wkt::BoolValue>,

            /// The time_series_id value for this time series. It will be one of
            /// the unique values from the time_series_id_column specified during
            /// ARIMA model training. Only present when time_series_id_column
            /// training option was used.
            pub time_series_id: std::string::String,

            /// The tuple of time_series_ids identifying this time series. It will
            /// be one of the unique tuples of values present in the
            /// time_series_id_columns specified during ARIMA model training. Only
            /// present when time_series_id_columns training option was used and
            /// the order of values here are same as the order of
            /// time_series_id_columns.
            pub time_series_ids: std::vec::Vec<std::string::String>,

            /// Seasonal periods. Repeated because multiple periods are supported
            /// for one time series.
            pub seasonal_periods:
                std::vec::Vec<crate::model::model::seasonal_period::SeasonalPeriodType>,

            /// If true, holiday_effect is a part of time series decomposition result.
            pub has_holiday_effect: std::option::Option<wkt::BoolValue>,

            /// If true, spikes_and_dips is a part of time series decomposition result.
            pub has_spikes_and_dips: std::option::Option<wkt::BoolValue>,

            /// If true, step_changes is a part of time series decomposition result.
            pub has_step_changes: std::option::Option<wkt::BoolValue>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl ArimaSingleModelForecastingMetrics {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [non_seasonal_order][crate::model::model::arima_forecasting_metrics::ArimaSingleModelForecastingMetrics::non_seasonal_order].
            pub fn set_non_seasonal_order<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::model::ArimaOrder>,
            {
                self.non_seasonal_order = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [non_seasonal_order][crate::model::model::arima_forecasting_metrics::ArimaSingleModelForecastingMetrics::non_seasonal_order].
            pub fn set_or_clear_non_seasonal_order<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::model::ArimaOrder>,
            {
                self.non_seasonal_order = v.map(|x| x.into());
                self
            }

            /// Sets the value of [arima_fitting_metrics][crate::model::model::arima_forecasting_metrics::ArimaSingleModelForecastingMetrics::arima_fitting_metrics].
            pub fn set_arima_fitting_metrics<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::model::ArimaFittingMetrics>,
            {
                self.arima_fitting_metrics = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [arima_fitting_metrics][crate::model::model::arima_forecasting_metrics::ArimaSingleModelForecastingMetrics::arima_fitting_metrics].
            pub fn set_or_clear_arima_fitting_metrics<T>(
                mut self,
                v: std::option::Option<T>,
            ) -> Self
            where
                T: std::convert::Into<crate::model::model::ArimaFittingMetrics>,
            {
                self.arima_fitting_metrics = v.map(|x| x.into());
                self
            }

            /// Sets the value of [has_drift][crate::model::model::arima_forecasting_metrics::ArimaSingleModelForecastingMetrics::has_drift].
            pub fn set_has_drift<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::BoolValue>,
            {
                self.has_drift = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [has_drift][crate::model::model::arima_forecasting_metrics::ArimaSingleModelForecastingMetrics::has_drift].
            pub fn set_or_clear_has_drift<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::BoolValue>,
            {
                self.has_drift = v.map(|x| x.into());
                self
            }

            /// Sets the value of [time_series_id][crate::model::model::arima_forecasting_metrics::ArimaSingleModelForecastingMetrics::time_series_id].
            pub fn set_time_series_id<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.time_series_id = v.into();
                self
            }

            /// Sets the value of [time_series_ids][crate::model::model::arima_forecasting_metrics::ArimaSingleModelForecastingMetrics::time_series_ids].
            pub fn set_time_series_ids<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.time_series_ids = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [seasonal_periods][crate::model::model::arima_forecasting_metrics::ArimaSingleModelForecastingMetrics::seasonal_periods].
            pub fn set_seasonal_periods<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::model::seasonal_period::SeasonalPeriodType>,
            {
                use std::iter::Iterator;
                self.seasonal_periods = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [has_holiday_effect][crate::model::model::arima_forecasting_metrics::ArimaSingleModelForecastingMetrics::has_holiday_effect].
            pub fn set_has_holiday_effect<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::BoolValue>,
            {
                self.has_holiday_effect = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [has_holiday_effect][crate::model::model::arima_forecasting_metrics::ArimaSingleModelForecastingMetrics::has_holiday_effect].
            pub fn set_or_clear_has_holiday_effect<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::BoolValue>,
            {
                self.has_holiday_effect = v.map(|x| x.into());
                self
            }

            /// Sets the value of [has_spikes_and_dips][crate::model::model::arima_forecasting_metrics::ArimaSingleModelForecastingMetrics::has_spikes_and_dips].
            pub fn set_has_spikes_and_dips<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::BoolValue>,
            {
                self.has_spikes_and_dips = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [has_spikes_and_dips][crate::model::model::arima_forecasting_metrics::ArimaSingleModelForecastingMetrics::has_spikes_and_dips].
            pub fn set_or_clear_has_spikes_and_dips<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::BoolValue>,
            {
                self.has_spikes_and_dips = v.map(|x| x.into());
                self
            }

            /// Sets the value of [has_step_changes][crate::model::model::arima_forecasting_metrics::ArimaSingleModelForecastingMetrics::has_step_changes].
            pub fn set_has_step_changes<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::BoolValue>,
            {
                self.has_step_changes = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [has_step_changes][crate::model::model::arima_forecasting_metrics::ArimaSingleModelForecastingMetrics::has_step_changes].
            pub fn set_or_clear_has_step_changes<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::BoolValue>,
            {
                self.has_step_changes = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for ArimaSingleModelForecastingMetrics {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.bigquery.v2.Model.ArimaForecastingMetrics.ArimaSingleModelForecastingMetrics"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for ArimaSingleModelForecastingMetrics {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __non_seasonal_order,
                    __arima_fitting_metrics,
                    __has_drift,
                    __time_series_id,
                    __time_series_ids,
                    __seasonal_periods,
                    __has_holiday_effect,
                    __has_spikes_and_dips,
                    __has_step_changes,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str(
                                    "a field name for ArimaSingleModelForecastingMetrics",
                                )
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "nonSeasonalOrder" => Ok(__FieldTag::__non_seasonal_order),
                                    "non_seasonal_order" => Ok(__FieldTag::__non_seasonal_order),
                                    "arimaFittingMetrics" => {
                                        Ok(__FieldTag::__arima_fitting_metrics)
                                    }
                                    "arima_fitting_metrics" => {
                                        Ok(__FieldTag::__arima_fitting_metrics)
                                    }
                                    "hasDrift" => Ok(__FieldTag::__has_drift),
                                    "has_drift" => Ok(__FieldTag::__has_drift),
                                    "timeSeriesId" => Ok(__FieldTag::__time_series_id),
                                    "time_series_id" => Ok(__FieldTag::__time_series_id),
                                    "timeSeriesIds" => Ok(__FieldTag::__time_series_ids),
                                    "time_series_ids" => Ok(__FieldTag::__time_series_ids),
                                    "seasonalPeriods" => Ok(__FieldTag::__seasonal_periods),
                                    "seasonal_periods" => Ok(__FieldTag::__seasonal_periods),
                                    "hasHolidayEffect" => Ok(__FieldTag::__has_holiday_effect),
                                    "has_holiday_effect" => Ok(__FieldTag::__has_holiday_effect),
                                    "hasSpikesAndDips" => Ok(__FieldTag::__has_spikes_and_dips),
                                    "has_spikes_and_dips" => Ok(__FieldTag::__has_spikes_and_dips),
                                    "hasStepChanges" => Ok(__FieldTag::__has_step_changes),
                                    "has_step_changes" => Ok(__FieldTag::__has_step_changes),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = ArimaSingleModelForecastingMetrics;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct ArimaSingleModelForecastingMetrics")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__non_seasonal_order => {
                                    if !fields.insert(__FieldTag::__non_seasonal_order) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for non_seasonal_order",
                                            ),
                                        );
                                    }
                                    result.non_seasonal_order = map.next_value::<std::option::Option<crate::model::model::ArimaOrder>>()?
                                        ;
                                }
                                __FieldTag::__arima_fitting_metrics => {
                                    if !fields.insert(__FieldTag::__arima_fitting_metrics) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for arima_fitting_metrics",
                                            ),
                                        );
                                    }
                                    result.arima_fitting_metrics = map
                                        .next_value::<std::option::Option<
                                            crate::model::model::ArimaFittingMetrics,
                                        >>()?;
                                }
                                __FieldTag::__has_drift => {
                                    if !fields.insert(__FieldTag::__has_drift) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for has_drift",
                                            ),
                                        );
                                    }
                                    result.has_drift =
                                        map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                                }
                                __FieldTag::__time_series_id => {
                                    if !fields.insert(__FieldTag::__time_series_id) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for time_series_id",
                                            ),
                                        );
                                    }
                                    result.time_series_id = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__time_series_ids => {
                                    if !fields.insert(__FieldTag::__time_series_ids) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for time_series_ids",
                                            ),
                                        );
                                    }
                                    result.time_series_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::__seasonal_periods => {
                                    if !fields.insert(__FieldTag::__seasonal_periods) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for seasonal_periods",
                                            ),
                                        );
                                    }
                                    result.seasonal_periods = map.next_value::<std::option::Option<std::vec::Vec<crate::model::model::seasonal_period::SeasonalPeriodType>>>()?.unwrap_or_default();
                                }
                                __FieldTag::__has_holiday_effect => {
                                    if !fields.insert(__FieldTag::__has_holiday_effect) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for has_holiday_effect",
                                            ),
                                        );
                                    }
                                    result.has_holiday_effect =
                                        map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                                }
                                __FieldTag::__has_spikes_and_dips => {
                                    if !fields.insert(__FieldTag::__has_spikes_and_dips) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for has_spikes_and_dips",
                                            ),
                                        );
                                    }
                                    result.has_spikes_and_dips =
                                        map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                                }
                                __FieldTag::__has_step_changes => {
                                    if !fields.insert(__FieldTag::__has_step_changes) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for has_step_changes",
                                            ),
                                        );
                                    }
                                    result.has_step_changes =
                                        map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for ArimaSingleModelForecastingMetrics {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if self.non_seasonal_order.is_some() {
                    state.serialize_entry("nonSeasonalOrder", &self.non_seasonal_order)?;
                }
                if self.arima_fitting_metrics.is_some() {
                    state.serialize_entry("arimaFittingMetrics", &self.arima_fitting_metrics)?;
                }
                if self.has_drift.is_some() {
                    state.serialize_entry("hasDrift", &self.has_drift)?;
                }
                if !self.time_series_id.is_empty() {
                    state.serialize_entry("timeSeriesId", &self.time_series_id)?;
                }
                if !self.time_series_ids.is_empty() {
                    state.serialize_entry("timeSeriesIds", &self.time_series_ids)?;
                }
                if !self.seasonal_periods.is_empty() {
                    state.serialize_entry("seasonalPeriods", &self.seasonal_periods)?;
                }
                if self.has_holiday_effect.is_some() {
                    state.serialize_entry("hasHolidayEffect", &self.has_holiday_effect)?;
                }
                if self.has_spikes_and_dips.is_some() {
                    state.serialize_entry("hasSpikesAndDips", &self.has_spikes_and_dips)?;
                }
                if self.has_step_changes.is_some() {
                    state.serialize_entry("hasStepChanges", &self.has_step_changes)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }
    }

    /// Model evaluation metrics for dimensionality reduction models.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DimensionalityReductionMetrics {
        /// Total percentage of variance explained by the selected principal
        /// components.
        pub total_explained_variance_ratio: std::option::Option<wkt::DoubleValue>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DimensionalityReductionMetrics {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [total_explained_variance_ratio][crate::model::model::DimensionalityReductionMetrics::total_explained_variance_ratio].
        pub fn set_total_explained_variance_ratio<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::DoubleValue>,
        {
            self.total_explained_variance_ratio = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [total_explained_variance_ratio][crate::model::model::DimensionalityReductionMetrics::total_explained_variance_ratio].
        pub fn set_or_clear_total_explained_variance_ratio<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<wkt::DoubleValue>,
        {
            self.total_explained_variance_ratio = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for DimensionalityReductionMetrics {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.DimensionalityReductionMetrics"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for DimensionalityReductionMetrics {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __total_explained_variance_ratio,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for DimensionalityReductionMetrics")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "totalExplainedVarianceRatio" => {
                                    Ok(__FieldTag::__total_explained_variance_ratio)
                                }
                                "total_explained_variance_ratio" => {
                                    Ok(__FieldTag::__total_explained_variance_ratio)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = DimensionalityReductionMetrics;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct DimensionalityReductionMetrics")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__total_explained_variance_ratio => {
                                if !fields.insert(__FieldTag::__total_explained_variance_ratio) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for total_explained_variance_ratio",
                                    ));
                                }
                                struct __With(std::option::Option<wkt::DoubleValue>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.total_explained_variance_ratio =
                                    map.next_value::<__With>()?.0;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for DimensionalityReductionMetrics {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.total_explained_variance_ratio.is_some() {
                struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry(
                    "totalExplainedVarianceRatio",
                    &__With(&self.total_explained_variance_ratio),
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Evaluation metrics of a model. These are either computed on all training
    /// data or just the eval data based on whether eval data was used during
    /// training. These are not present for imported models.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct EvaluationMetrics {
        /// Metrics.
        pub metrics: std::option::Option<crate::model::model::evaluation_metrics::Metrics>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl EvaluationMetrics {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [metrics][crate::model::model::EvaluationMetrics::metrics].
        ///
        /// Note that all the setters affecting `metrics` are mutually
        /// exclusive.
        pub fn set_metrics<
            T: std::convert::Into<
                    std::option::Option<crate::model::model::evaluation_metrics::Metrics>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.metrics = v.into();
            self
        }

        /// The value of [metrics][crate::model::model::EvaluationMetrics::metrics]
        /// if it holds a `RegressionMetrics`, `None` if the field is not set or
        /// holds a different branch.
        pub fn regression_metrics(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::model::RegressionMetrics>> {
            #[allow(unreachable_patterns)]
            self.metrics.as_ref().and_then(|v| match v {
                crate::model::model::evaluation_metrics::Metrics::RegressionMetrics(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [metrics][crate::model::model::EvaluationMetrics::metrics]
        /// to hold a `RegressionMetrics`.
        ///
        /// Note that all the setters affecting `metrics` are
        /// mutually exclusive.
        pub fn set_regression_metrics<
            T: std::convert::Into<std::boxed::Box<crate::model::model::RegressionMetrics>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.metrics = std::option::Option::Some(
                crate::model::model::evaluation_metrics::Metrics::RegressionMetrics(v.into()),
            );
            self
        }

        /// The value of [metrics][crate::model::model::EvaluationMetrics::metrics]
        /// if it holds a `BinaryClassificationMetrics`, `None` if the field is not set or
        /// holds a different branch.
        pub fn binary_classification_metrics(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::model::BinaryClassificationMetrics>>
        {
            #[allow(unreachable_patterns)]
            self.metrics.as_ref().and_then(|v| match v {
                crate::model::model::evaluation_metrics::Metrics::BinaryClassificationMetrics(
                    v,
                ) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [metrics][crate::model::model::EvaluationMetrics::metrics]
        /// to hold a `BinaryClassificationMetrics`.
        ///
        /// Note that all the setters affecting `metrics` are
        /// mutually exclusive.
        pub fn set_binary_classification_metrics<
            T: std::convert::Into<std::boxed::Box<crate::model::model::BinaryClassificationMetrics>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.metrics = std::option::Option::Some(
                crate::model::model::evaluation_metrics::Metrics::BinaryClassificationMetrics(
                    v.into(),
                ),
            );
            self
        }

        /// The value of [metrics][crate::model::model::EvaluationMetrics::metrics]
        /// if it holds a `MultiClassClassificationMetrics`, `None` if the field is not set or
        /// holds a different branch.
        pub fn multi_class_classification_metrics(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::model::MultiClassClassificationMetrics>,
        > {
            #[allow(unreachable_patterns)]
            self.metrics.as_ref().and_then(|v| match v {
                crate::model::model::evaluation_metrics::Metrics::MultiClassClassificationMetrics(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [metrics][crate::model::model::EvaluationMetrics::metrics]
        /// to hold a `MultiClassClassificationMetrics`.
        ///
        /// Note that all the setters affecting `metrics` are
        /// mutually exclusive.
        pub fn set_multi_class_classification_metrics<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::model::MultiClassClassificationMetrics>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.metrics = std::option::Option::Some(
                crate::model::model::evaluation_metrics::Metrics::MultiClassClassificationMetrics(
                    v.into(),
                ),
            );
            self
        }

        /// The value of [metrics][crate::model::model::EvaluationMetrics::metrics]
        /// if it holds a `ClusteringMetrics`, `None` if the field is not set or
        /// holds a different branch.
        pub fn clustering_metrics(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::model::ClusteringMetrics>> {
            #[allow(unreachable_patterns)]
            self.metrics.as_ref().and_then(|v| match v {
                crate::model::model::evaluation_metrics::Metrics::ClusteringMetrics(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [metrics][crate::model::model::EvaluationMetrics::metrics]
        /// to hold a `ClusteringMetrics`.
        ///
        /// Note that all the setters affecting `metrics` are
        /// mutually exclusive.
        pub fn set_clustering_metrics<
            T: std::convert::Into<std::boxed::Box<crate::model::model::ClusteringMetrics>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.metrics = std::option::Option::Some(
                crate::model::model::evaluation_metrics::Metrics::ClusteringMetrics(v.into()),
            );
            self
        }

        /// The value of [metrics][crate::model::model::EvaluationMetrics::metrics]
        /// if it holds a `RankingMetrics`, `None` if the field is not set or
        /// holds a different branch.
        pub fn ranking_metrics(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::model::RankingMetrics>> {
            #[allow(unreachable_patterns)]
            self.metrics.as_ref().and_then(|v| match v {
                crate::model::model::evaluation_metrics::Metrics::RankingMetrics(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [metrics][crate::model::model::EvaluationMetrics::metrics]
        /// to hold a `RankingMetrics`.
        ///
        /// Note that all the setters affecting `metrics` are
        /// mutually exclusive.
        pub fn set_ranking_metrics<
            T: std::convert::Into<std::boxed::Box<crate::model::model::RankingMetrics>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.metrics = std::option::Option::Some(
                crate::model::model::evaluation_metrics::Metrics::RankingMetrics(v.into()),
            );
            self
        }

        /// The value of [metrics][crate::model::model::EvaluationMetrics::metrics]
        /// if it holds a `ArimaForecastingMetrics`, `None` if the field is not set or
        /// holds a different branch.
        pub fn arima_forecasting_metrics(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::model::ArimaForecastingMetrics>>
        {
            #[allow(unreachable_patterns)]
            self.metrics.as_ref().and_then(|v| match v {
                crate::model::model::evaluation_metrics::Metrics::ArimaForecastingMetrics(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [metrics][crate::model::model::EvaluationMetrics::metrics]
        /// to hold a `ArimaForecastingMetrics`.
        ///
        /// Note that all the setters affecting `metrics` are
        /// mutually exclusive.
        pub fn set_arima_forecasting_metrics<
            T: std::convert::Into<std::boxed::Box<crate::model::model::ArimaForecastingMetrics>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.metrics = std::option::Option::Some(
                crate::model::model::evaluation_metrics::Metrics::ArimaForecastingMetrics(v.into()),
            );
            self
        }

        /// The value of [metrics][crate::model::model::EvaluationMetrics::metrics]
        /// if it holds a `DimensionalityReductionMetrics`, `None` if the field is not set or
        /// holds a different branch.
        pub fn dimensionality_reduction_metrics(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::model::DimensionalityReductionMetrics>,
        > {
            #[allow(unreachable_patterns)]
            self.metrics.as_ref().and_then(|v| match v {
                crate::model::model::evaluation_metrics::Metrics::DimensionalityReductionMetrics(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [metrics][crate::model::model::EvaluationMetrics::metrics]
        /// to hold a `DimensionalityReductionMetrics`.
        ///
        /// Note that all the setters affecting `metrics` are
        /// mutually exclusive.
        pub fn set_dimensionality_reduction_metrics<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::model::DimensionalityReductionMetrics>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.metrics = std::option::Option::Some(
                crate::model::model::evaluation_metrics::Metrics::DimensionalityReductionMetrics(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for EvaluationMetrics {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.EvaluationMetrics"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for EvaluationMetrics {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __regression_metrics,
                __binary_classification_metrics,
                __multi_class_classification_metrics,
                __clustering_metrics,
                __ranking_metrics,
                __arima_forecasting_metrics,
                __dimensionality_reduction_metrics,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for EvaluationMetrics")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "regressionMetrics" => Ok(__FieldTag::__regression_metrics),
                                "regression_metrics" => Ok(__FieldTag::__regression_metrics),
                                "binaryClassificationMetrics" => {
                                    Ok(__FieldTag::__binary_classification_metrics)
                                }
                                "binary_classification_metrics" => {
                                    Ok(__FieldTag::__binary_classification_metrics)
                                }
                                "multiClassClassificationMetrics" => {
                                    Ok(__FieldTag::__multi_class_classification_metrics)
                                }
                                "multi_class_classification_metrics" => {
                                    Ok(__FieldTag::__multi_class_classification_metrics)
                                }
                                "clusteringMetrics" => Ok(__FieldTag::__clustering_metrics),
                                "clustering_metrics" => Ok(__FieldTag::__clustering_metrics),
                                "rankingMetrics" => Ok(__FieldTag::__ranking_metrics),
                                "ranking_metrics" => Ok(__FieldTag::__ranking_metrics),
                                "arimaForecastingMetrics" => {
                                    Ok(__FieldTag::__arima_forecasting_metrics)
                                }
                                "arima_forecasting_metrics" => {
                                    Ok(__FieldTag::__arima_forecasting_metrics)
                                }
                                "dimensionalityReductionMetrics" => {
                                    Ok(__FieldTag::__dimensionality_reduction_metrics)
                                }
                                "dimensionality_reduction_metrics" => {
                                    Ok(__FieldTag::__dimensionality_reduction_metrics)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = EvaluationMetrics;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct EvaluationMetrics")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__regression_metrics => {
                                if !fields.insert(__FieldTag::__regression_metrics) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for regression_metrics",
                                    ));
                                }
                                if result.metrics.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `metrics`, a oneof with full ID .google.cloud.bigquery.v2.Model.EvaluationMetrics.regression_metrics, latest field was regressionMetrics",
                                    ));
                                }
                                result.metrics = std::option::Option::Some(
                                    crate::model::model::evaluation_metrics::Metrics::RegressionMetrics(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::model::RegressionMetrics>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__binary_classification_metrics => {
                                if !fields.insert(__FieldTag::__binary_classification_metrics) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for binary_classification_metrics",
                                    ));
                                }
                                if result.metrics.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `metrics`, a oneof with full ID .google.cloud.bigquery.v2.Model.EvaluationMetrics.binary_classification_metrics, latest field was binaryClassificationMetrics",
                                    ));
                                }
                                result.metrics = std::option::Option::Some(
                                    crate::model::model::evaluation_metrics::Metrics::BinaryClassificationMetrics(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::model::BinaryClassificationMetrics>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__multi_class_classification_metrics => {
                                if !fields.insert(__FieldTag::__multi_class_classification_metrics)
                                {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for multi_class_classification_metrics",
                                    ));
                                }
                                if result.metrics.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `metrics`, a oneof with full ID .google.cloud.bigquery.v2.Model.EvaluationMetrics.multi_class_classification_metrics, latest field was multiClassClassificationMetrics",
                                    ));
                                }
                                result.metrics = std::option::Option::Some(
                                    crate::model::model::evaluation_metrics::Metrics::MultiClassClassificationMetrics(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::model::MultiClassClassificationMetrics>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__clustering_metrics => {
                                if !fields.insert(__FieldTag::__clustering_metrics) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for clustering_metrics",
                                    ));
                                }
                                if result.metrics.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `metrics`, a oneof with full ID .google.cloud.bigquery.v2.Model.EvaluationMetrics.clustering_metrics, latest field was clusteringMetrics",
                                    ));
                                }
                                result.metrics = std::option::Option::Some(
                                    crate::model::model::evaluation_metrics::Metrics::ClusteringMetrics(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::model::ClusteringMetrics>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__ranking_metrics => {
                                if !fields.insert(__FieldTag::__ranking_metrics) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for ranking_metrics",
                                    ));
                                }
                                if result.metrics.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `metrics`, a oneof with full ID .google.cloud.bigquery.v2.Model.EvaluationMetrics.ranking_metrics, latest field was rankingMetrics",
                                    ));
                                }
                                result.metrics = std::option::Option::Some(
                                    crate::model::model::evaluation_metrics::Metrics::RankingMetrics(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::model::RankingMetrics>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__arima_forecasting_metrics => {
                                if !fields.insert(__FieldTag::__arima_forecasting_metrics) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for arima_forecasting_metrics",
                                    ));
                                }
                                if result.metrics.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `metrics`, a oneof with full ID .google.cloud.bigquery.v2.Model.EvaluationMetrics.arima_forecasting_metrics, latest field was arimaForecastingMetrics",
                                    ));
                                }
                                result.metrics = std::option::Option::Some(
                                    crate::model::model::evaluation_metrics::Metrics::ArimaForecastingMetrics(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::model::ArimaForecastingMetrics>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__dimensionality_reduction_metrics => {
                                if !fields.insert(__FieldTag::__dimensionality_reduction_metrics) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for dimensionality_reduction_metrics",
                                    ));
                                }
                                if result.metrics.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `metrics`, a oneof with full ID .google.cloud.bigquery.v2.Model.EvaluationMetrics.dimensionality_reduction_metrics, latest field was dimensionalityReductionMetrics",
                                    ));
                                }
                                result.metrics = std::option::Option::Some(
                                    crate::model::model::evaluation_metrics::Metrics::DimensionalityReductionMetrics(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::model::DimensionalityReductionMetrics>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for EvaluationMetrics {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.regression_metrics() {
                state.serialize_entry("regressionMetrics", value)?;
            }
            if let Some(value) = self.binary_classification_metrics() {
                state.serialize_entry("binaryClassificationMetrics", value)?;
            }
            if let Some(value) = self.multi_class_classification_metrics() {
                state.serialize_entry("multiClassClassificationMetrics", value)?;
            }
            if let Some(value) = self.clustering_metrics() {
                state.serialize_entry("clusteringMetrics", value)?;
            }
            if let Some(value) = self.ranking_metrics() {
                state.serialize_entry("rankingMetrics", value)?;
            }
            if let Some(value) = self.arima_forecasting_metrics() {
                state.serialize_entry("arimaForecastingMetrics", value)?;
            }
            if let Some(value) = self.dimensionality_reduction_metrics() {
                state.serialize_entry("dimensionalityReductionMetrics", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [EvaluationMetrics].
    pub mod evaluation_metrics {
        #[allow(unused_imports)]
        use super::*;

        /// Metrics.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Metrics {
            /// Populated for regression models and explicit feedback type matrix
            /// factorization models.
            RegressionMetrics(std::boxed::Box<crate::model::model::RegressionMetrics>),
            /// Populated for binary classification/classifier models.
            BinaryClassificationMetrics(
                std::boxed::Box<crate::model::model::BinaryClassificationMetrics>,
            ),
            /// Populated for multi-class classification/classifier models.
            MultiClassClassificationMetrics(
                std::boxed::Box<crate::model::model::MultiClassClassificationMetrics>,
            ),
            /// Populated for clustering models.
            ClusteringMetrics(std::boxed::Box<crate::model::model::ClusteringMetrics>),
            /// Populated for implicit feedback type matrix factorization models.
            RankingMetrics(std::boxed::Box<crate::model::model::RankingMetrics>),
            /// Populated for ARIMA models.
            ArimaForecastingMetrics(std::boxed::Box<crate::model::model::ArimaForecastingMetrics>),
            /// Evaluation metrics when the model is a dimensionality reduction model,
            /// which currently includes PCA.
            DimensionalityReductionMetrics(
                std::boxed::Box<crate::model::model::DimensionalityReductionMetrics>,
            ),
        }
    }

    /// Data split result. This contains references to the training and evaluation
    /// data tables that were used to train the model.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DataSplitResult {
        /// Table reference of the training data after split.
        pub training_table: std::option::Option<crate::model::TableReference>,

        /// Table reference of the evaluation data after split.
        pub evaluation_table: std::option::Option<crate::model::TableReference>,

        /// Table reference of the test data after split.
        pub test_table: std::option::Option<crate::model::TableReference>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DataSplitResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [training_table][crate::model::model::DataSplitResult::training_table].
        pub fn set_training_table<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::TableReference>,
        {
            self.training_table = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [training_table][crate::model::model::DataSplitResult::training_table].
        pub fn set_or_clear_training_table<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::TableReference>,
        {
            self.training_table = v.map(|x| x.into());
            self
        }

        /// Sets the value of [evaluation_table][crate::model::model::DataSplitResult::evaluation_table].
        pub fn set_evaluation_table<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::TableReference>,
        {
            self.evaluation_table = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [evaluation_table][crate::model::model::DataSplitResult::evaluation_table].
        pub fn set_or_clear_evaluation_table<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::TableReference>,
        {
            self.evaluation_table = v.map(|x| x.into());
            self
        }

        /// Sets the value of [test_table][crate::model::model::DataSplitResult::test_table].
        pub fn set_test_table<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::TableReference>,
        {
            self.test_table = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [test_table][crate::model::model::DataSplitResult::test_table].
        pub fn set_or_clear_test_table<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::TableReference>,
        {
            self.test_table = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for DataSplitResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.DataSplitResult"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for DataSplitResult {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __training_table,
                __evaluation_table,
                __test_table,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for DataSplitResult")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "trainingTable" => Ok(__FieldTag::__training_table),
                                "training_table" => Ok(__FieldTag::__training_table),
                                "evaluationTable" => Ok(__FieldTag::__evaluation_table),
                                "evaluation_table" => Ok(__FieldTag::__evaluation_table),
                                "testTable" => Ok(__FieldTag::__test_table),
                                "test_table" => Ok(__FieldTag::__test_table),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = DataSplitResult;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct DataSplitResult")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__training_table => {
                                if !fields.insert(__FieldTag::__training_table) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for training_table",
                                    ));
                                }
                                result.training_table = map.next_value::<std::option::Option<crate::model::TableReference>>()?
                                    ;
                            }
                            __FieldTag::__evaluation_table => {
                                if !fields.insert(__FieldTag::__evaluation_table) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for evaluation_table",
                                    ));
                                }
                                result.evaluation_table = map.next_value::<std::option::Option<crate::model::TableReference>>()?
                                    ;
                            }
                            __FieldTag::__test_table => {
                                if !fields.insert(__FieldTag::__test_table) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for test_table",
                                    ));
                                }
                                result.test_table = map.next_value::<std::option::Option<crate::model::TableReference>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for DataSplitResult {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.training_table.is_some() {
                state.serialize_entry("trainingTable", &self.training_table)?;
            }
            if self.evaluation_table.is_some() {
                state.serialize_entry("evaluationTable", &self.evaluation_table)?;
            }
            if self.test_table.is_some() {
                state.serialize_entry("testTable", &self.test_table)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Arima order, can be used for both non-seasonal and seasonal parts.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ArimaOrder {
        /// Order of the autoregressive part.
        pub p: std::option::Option<wkt::Int64Value>,

        /// Order of the differencing part.
        pub d: std::option::Option<wkt::Int64Value>,

        /// Order of the moving-average part.
        pub q: std::option::Option<wkt::Int64Value>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ArimaOrder {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [p][crate::model::model::ArimaOrder::p].
        pub fn set_p<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Int64Value>,
        {
            self.p = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [p][crate::model::model::ArimaOrder::p].
        pub fn set_or_clear_p<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Int64Value>,
        {
            self.p = v.map(|x| x.into());
            self
        }

        /// Sets the value of [d][crate::model::model::ArimaOrder::d].
        pub fn set_d<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Int64Value>,
        {
            self.d = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [d][crate::model::model::ArimaOrder::d].
        pub fn set_or_clear_d<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Int64Value>,
        {
            self.d = v.map(|x| x.into());
            self
        }

        /// Sets the value of [q][crate::model::model::ArimaOrder::q].
        pub fn set_q<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Int64Value>,
        {
            self.q = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [q][crate::model::model::ArimaOrder::q].
        pub fn set_or_clear_q<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Int64Value>,
        {
            self.q = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for ArimaOrder {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.ArimaOrder"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ArimaOrder {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __p,
                __d,
                __q,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ArimaOrder")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "p" => Ok(__FieldTag::__p),
                                "d" => Ok(__FieldTag::__d),
                                "q" => Ok(__FieldTag::__q),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ArimaOrder;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ArimaOrder")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__p => {
                                if !fields.insert(__FieldTag::__p) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for p",
                                    ));
                                }
                                struct __With(std::option::Option<wkt::Int64Value>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.p = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::__d => {
                                if !fields.insert(__FieldTag::__d) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for d",
                                    ));
                                }
                                struct __With(std::option::Option<wkt::Int64Value>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.d = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::__q => {
                                if !fields.insert(__FieldTag::__q) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for q",
                                    ));
                                }
                                struct __With(std::option::Option<wkt::Int64Value>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.q = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ArimaOrder {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.p.is_some() {
                struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("p", &__With(&self.p))?;
            }
            if self.d.is_some() {
                struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("d", &__With(&self.d))?;
            }
            if self.q.is_some() {
                struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("q", &__With(&self.q))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// ARIMA model fitting metrics.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ArimaFittingMetrics {
        /// Log-likelihood.
        pub log_likelihood: std::option::Option<wkt::DoubleValue>,

        /// AIC.
        pub aic: std::option::Option<wkt::DoubleValue>,

        /// Variance.
        pub variance: std::option::Option<wkt::DoubleValue>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ArimaFittingMetrics {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [log_likelihood][crate::model::model::ArimaFittingMetrics::log_likelihood].
        pub fn set_log_likelihood<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::DoubleValue>,
        {
            self.log_likelihood = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [log_likelihood][crate::model::model::ArimaFittingMetrics::log_likelihood].
        pub fn set_or_clear_log_likelihood<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::DoubleValue>,
        {
            self.log_likelihood = v.map(|x| x.into());
            self
        }

        /// Sets the value of [aic][crate::model::model::ArimaFittingMetrics::aic].
        pub fn set_aic<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::DoubleValue>,
        {
            self.aic = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [aic][crate::model::model::ArimaFittingMetrics::aic].
        pub fn set_or_clear_aic<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::DoubleValue>,
        {
            self.aic = v.map(|x| x.into());
            self
        }

        /// Sets the value of [variance][crate::model::model::ArimaFittingMetrics::variance].
        pub fn set_variance<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::DoubleValue>,
        {
            self.variance = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [variance][crate::model::model::ArimaFittingMetrics::variance].
        pub fn set_or_clear_variance<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::DoubleValue>,
        {
            self.variance = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for ArimaFittingMetrics {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.ArimaFittingMetrics"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ArimaFittingMetrics {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __log_likelihood,
                __aic,
                __variance,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ArimaFittingMetrics")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "logLikelihood" => Ok(__FieldTag::__log_likelihood),
                                "log_likelihood" => Ok(__FieldTag::__log_likelihood),
                                "aic" => Ok(__FieldTag::__aic),
                                "variance" => Ok(__FieldTag::__variance),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ArimaFittingMetrics;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ArimaFittingMetrics")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__log_likelihood => {
                                if !fields.insert(__FieldTag::__log_likelihood) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for log_likelihood",
                                    ));
                                }
                                struct __With(std::option::Option<wkt::DoubleValue>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.log_likelihood = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::__aic => {
                                if !fields.insert(__FieldTag::__aic) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for aic",
                                    ));
                                }
                                struct __With(std::option::Option<wkt::DoubleValue>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.aic = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::__variance => {
                                if !fields.insert(__FieldTag::__variance) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for variance",
                                    ));
                                }
                                struct __With(std::option::Option<wkt::DoubleValue>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.variance = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ArimaFittingMetrics {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.log_likelihood.is_some() {
                struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("logLikelihood", &__With(&self.log_likelihood))?;
            }
            if self.aic.is_some() {
                struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("aic", &__With(&self.aic))?;
            }
            if self.variance.is_some() {
                struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("variance", &__With(&self.variance))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Global explanations containing the top most important features
    /// after training.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GlobalExplanation {
        /// A list of the top global explanations. Sorted by absolute value of
        /// attribution in descending order.
        pub explanations: std::vec::Vec<crate::model::model::global_explanation::Explanation>,

        /// Class label for this set of global explanations. Will be empty/null for
        /// binary logistic and linear regression models. Sorted alphabetically in
        /// descending order.
        pub class_label: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GlobalExplanation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [explanations][crate::model::model::GlobalExplanation::explanations].
        pub fn set_explanations<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::model::global_explanation::Explanation>,
        {
            use std::iter::Iterator;
            self.explanations = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [class_label][crate::model::model::GlobalExplanation::class_label].
        pub fn set_class_label<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.class_label = v.into();
            self
        }
    }

    impl wkt::message::Message for GlobalExplanation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.GlobalExplanation"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for GlobalExplanation {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __explanations,
                __class_label,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for GlobalExplanation")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "explanations" => Ok(__FieldTag::__explanations),
                                "classLabel" => Ok(__FieldTag::__class_label),
                                "class_label" => Ok(__FieldTag::__class_label),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = GlobalExplanation;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct GlobalExplanation")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__explanations => {
                                if !fields.insert(__FieldTag::__explanations) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for explanations",
                                    ));
                                }
                                result.explanations = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<
                                            crate::model::model::global_explanation::Explanation,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__class_label => {
                                if !fields.insert(__FieldTag::__class_label) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for class_label",
                                    ));
                                }
                                result.class_label = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for GlobalExplanation {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.explanations.is_empty() {
                state.serialize_entry("explanations", &self.explanations)?;
            }
            if !self.class_label.is_empty() {
                state.serialize_entry("classLabel", &self.class_label)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [GlobalExplanation].
    pub mod global_explanation {
        #[allow(unused_imports)]
        use super::*;

        /// Explanation for a single feature.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Explanation {
            /// The full feature name. For non-numerical features, will be formatted
            /// like `<column_name>.<encoded_feature_name>`. Overall size of feature
            /// name will always be truncated to first 120 characters.
            pub feature_name: std::string::String,

            /// Attribution of feature.
            pub attribution: std::option::Option<wkt::DoubleValue>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Explanation {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [feature_name][crate::model::model::global_explanation::Explanation::feature_name].
            pub fn set_feature_name<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.feature_name = v.into();
                self
            }

            /// Sets the value of [attribution][crate::model::model::global_explanation::Explanation::attribution].
            pub fn set_attribution<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::DoubleValue>,
            {
                self.attribution = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [attribution][crate::model::model::global_explanation::Explanation::attribution].
            pub fn set_or_clear_attribution<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::DoubleValue>,
            {
                self.attribution = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for Explanation {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.bigquery.v2.Model.GlobalExplanation.Explanation"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Explanation {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __feature_name,
                    __attribution,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Explanation")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "featureName" => Ok(__FieldTag::__feature_name),
                                    "feature_name" => Ok(__FieldTag::__feature_name),
                                    "attribution" => Ok(__FieldTag::__attribution),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Explanation;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Explanation")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__feature_name => {
                                    if !fields.insert(__FieldTag::__feature_name) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for feature_name",
                                            ),
                                        );
                                    }
                                    result.feature_name = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__attribution => {
                                    if !fields.insert(__FieldTag::__attribution) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for attribution",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<wkt::DoubleValue>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.attribution = map.next_value::<__With>()?.0;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Explanation {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.feature_name.is_empty() {
                    state.serialize_entry("featureName", &self.feature_name)?;
                }
                if self.attribution.is_some() {
                    struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                                self.0, serializer,
                            )
                        }
                    }
                    state.serialize_entry("attribution", &__With(&self.attribution))?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }
    }

    /// Encoding methods for categorical features.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CategoryEncodingMethod {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CategoryEncodingMethod {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for CategoryEncodingMethod {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.CategoryEncodingMethod"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for CategoryEncodingMethod {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for CategoryEncodingMethod")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = CategoryEncodingMethod;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct CategoryEncodingMethod")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for CategoryEncodingMethod {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [CategoryEncodingMethod].
    pub mod category_encoding_method {
        #[allow(unused_imports)]
        use super::*;

        /// Supported encoding methods for categorical features.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum EncodingMethod {
            /// Unspecified encoding method.
            Unspecified,
            /// Applies one-hot encoding.
            OneHotEncoding,
            /// Applies label encoding.
            LabelEncoding,
            /// Applies dummy encoding.
            DummyEncoding,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [EncodingMethod::value] or
            /// [EncodingMethod::name].
            UnknownValue(encoding_method::UnknownValue),
        }

        #[doc(hidden)]
        pub mod encoding_method {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl EncodingMethod {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::OneHotEncoding => std::option::Option::Some(1),
                    Self::LabelEncoding => std::option::Option::Some(2),
                    Self::DummyEncoding => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("ENCODING_METHOD_UNSPECIFIED"),
                    Self::OneHotEncoding => std::option::Option::Some("ONE_HOT_ENCODING"),
                    Self::LabelEncoding => std::option::Option::Some("LABEL_ENCODING"),
                    Self::DummyEncoding => std::option::Option::Some("DUMMY_ENCODING"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for EncodingMethod {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for EncodingMethod {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for EncodingMethod {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::OneHotEncoding,
                    2 => Self::LabelEncoding,
                    3 => Self::DummyEncoding,
                    _ => Self::UnknownValue(encoding_method::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for EncodingMethod {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "ENCODING_METHOD_UNSPECIFIED" => Self::Unspecified,
                    "ONE_HOT_ENCODING" => Self::OneHotEncoding,
                    "LABEL_ENCODING" => Self::LabelEncoding,
                    "DUMMY_ENCODING" => Self::DummyEncoding,
                    _ => Self::UnknownValue(encoding_method::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for EncodingMethod {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::OneHotEncoding => serializer.serialize_i32(1),
                    Self::LabelEncoding => serializer.serialize_i32(2),
                    Self::DummyEncoding => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for EncodingMethod {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<EncodingMethod>::new(
                    ".google.cloud.bigquery.v2.Model.CategoryEncodingMethod.EncodingMethod",
                ))
            }
        }
    }

    /// PCA solver options.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PcaSolverOptionEnums {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PcaSolverOptionEnums {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for PcaSolverOptionEnums {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.PcaSolverOptionEnums"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PcaSolverOptionEnums {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PcaSolverOptionEnums")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PcaSolverOptionEnums;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PcaSolverOptionEnums")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PcaSolverOptionEnums {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [PcaSolverOptionEnums].
    pub mod pca_solver_option_enums {
        #[allow(unused_imports)]
        use super::*;

        /// Enums for supported PCA solvers.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum PcaSolver {
            /// Default value.
            Unspecified,
            /// Full eigen-decoposition.
            Full,
            /// Randomized SVD.
            Randomized,
            /// Auto.
            Auto,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [PcaSolver::value] or
            /// [PcaSolver::name].
            UnknownValue(pca_solver::UnknownValue),
        }

        #[doc(hidden)]
        pub mod pca_solver {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl PcaSolver {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Full => std::option::Option::Some(1),
                    Self::Randomized => std::option::Option::Some(2),
                    Self::Auto => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("UNSPECIFIED"),
                    Self::Full => std::option::Option::Some("FULL"),
                    Self::Randomized => std::option::Option::Some("RANDOMIZED"),
                    Self::Auto => std::option::Option::Some("AUTO"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for PcaSolver {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for PcaSolver {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for PcaSolver {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Full,
                    2 => Self::Randomized,
                    3 => Self::Auto,
                    _ => Self::UnknownValue(pca_solver::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for PcaSolver {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "UNSPECIFIED" => Self::Unspecified,
                    "FULL" => Self::Full,
                    "RANDOMIZED" => Self::Randomized,
                    "AUTO" => Self::Auto,
                    _ => Self::UnknownValue(pca_solver::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for PcaSolver {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Full => serializer.serialize_i32(1),
                    Self::Randomized => serializer.serialize_i32(2),
                    Self::Auto => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for PcaSolver {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<PcaSolver>::new(
                    ".google.cloud.bigquery.v2.Model.PcaSolverOptionEnums.PcaSolver",
                ))
            }
        }
    }

    /// Model registry options.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ModelRegistryOptionEnums {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ModelRegistryOptionEnums {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for ModelRegistryOptionEnums {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.ModelRegistryOptionEnums"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ModelRegistryOptionEnums {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ModelRegistryOptionEnums")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ModelRegistryOptionEnums;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ModelRegistryOptionEnums")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ModelRegistryOptionEnums {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [ModelRegistryOptionEnums].
    pub mod model_registry_option_enums {
        #[allow(unused_imports)]
        use super::*;

        /// Enums for supported model registries.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum ModelRegistry {
            /// Default value.
            Unspecified,
            /// Vertex AI.
            VertexAi,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [ModelRegistry::value] or
            /// [ModelRegistry::name].
            UnknownValue(model_registry::UnknownValue),
        }

        #[doc(hidden)]
        pub mod model_registry {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl ModelRegistry {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::VertexAi => std::option::Option::Some(1),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("MODEL_REGISTRY_UNSPECIFIED"),
                    Self::VertexAi => std::option::Option::Some("VERTEX_AI"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for ModelRegistry {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for ModelRegistry {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for ModelRegistry {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::VertexAi,
                    _ => Self::UnknownValue(model_registry::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for ModelRegistry {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "MODEL_REGISTRY_UNSPECIFIED" => Self::Unspecified,
                    "VERTEX_AI" => Self::VertexAi,
                    _ => Self::UnknownValue(model_registry::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for ModelRegistry {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::VertexAi => serializer.serialize_i32(1),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for ModelRegistry {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<ModelRegistry>::new(
                    ".google.cloud.bigquery.v2.Model.ModelRegistryOptionEnums.ModelRegistry",
                ))
            }
        }
    }

    /// Information about a single training query run for the model.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TrainingRun {
        /// Output only. Options that were used for this training run, includes
        /// user specified and default options that were used.
        pub training_options:
            std::option::Option<crate::model::model::training_run::TrainingOptions>,

        /// Output only. The start time of this training run.
        pub start_time: std::option::Option<wkt::Timestamp>,

        /// Output only. Output of each iteration run, results.size() <=
        /// max_iterations.
        pub results: std::vec::Vec<crate::model::model::training_run::IterationResult>,

        /// Output only. The evaluation metrics over training/eval data that were
        /// computed at the end of training.
        pub evaluation_metrics: std::option::Option<crate::model::model::EvaluationMetrics>,

        /// Output only. Data split result of the training run. Only set when the
        /// input data is actually split.
        pub data_split_result: std::option::Option<crate::model::model::DataSplitResult>,

        /// Output only. Global explanation contains the explanation of top features
        /// on the model level. Applies to both regression and classification models.
        pub model_level_global_explanation:
            std::option::Option<crate::model::model::GlobalExplanation>,

        /// Output only. Global explanation contains the explanation of top features
        /// on the class level. Applies to classification models only.
        pub class_level_global_explanations: std::vec::Vec<crate::model::model::GlobalExplanation>,

        /// The model id in the [Vertex AI Model
        /// Registry](https://cloud.google.com/vertex-ai/docs/model-registry/introduction)
        /// for this training run.
        pub vertex_ai_model_id: std::string::String,

        /// Output only. The model version in the [Vertex AI Model
        /// Registry](https://cloud.google.com/vertex-ai/docs/model-registry/introduction)
        /// for this training run.
        pub vertex_ai_model_version: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TrainingRun {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [training_options][crate::model::model::TrainingRun::training_options].
        pub fn set_training_options<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::model::training_run::TrainingOptions>,
        {
            self.training_options = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [training_options][crate::model::model::TrainingRun::training_options].
        pub fn set_or_clear_training_options<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::model::training_run::TrainingOptions>,
        {
            self.training_options = v.map(|x| x.into());
            self
        }

        /// Sets the value of [start_time][crate::model::model::TrainingRun::start_time].
        pub fn set_start_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.start_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [start_time][crate::model::model::TrainingRun::start_time].
        pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.start_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [results][crate::model::model::TrainingRun::results].
        pub fn set_results<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::model::training_run::IterationResult>,
        {
            use std::iter::Iterator;
            self.results = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [evaluation_metrics][crate::model::model::TrainingRun::evaluation_metrics].
        pub fn set_evaluation_metrics<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::model::EvaluationMetrics>,
        {
            self.evaluation_metrics = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [evaluation_metrics][crate::model::model::TrainingRun::evaluation_metrics].
        pub fn set_or_clear_evaluation_metrics<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::model::EvaluationMetrics>,
        {
            self.evaluation_metrics = v.map(|x| x.into());
            self
        }

        /// Sets the value of [data_split_result][crate::model::model::TrainingRun::data_split_result].
        pub fn set_data_split_result<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::model::DataSplitResult>,
        {
            self.data_split_result = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [data_split_result][crate::model::model::TrainingRun::data_split_result].
        pub fn set_or_clear_data_split_result<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::model::DataSplitResult>,
        {
            self.data_split_result = v.map(|x| x.into());
            self
        }

        /// Sets the value of [model_level_global_explanation][crate::model::model::TrainingRun::model_level_global_explanation].
        pub fn set_model_level_global_explanation<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::model::GlobalExplanation>,
        {
            self.model_level_global_explanation = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [model_level_global_explanation][crate::model::model::TrainingRun::model_level_global_explanation].
        pub fn set_or_clear_model_level_global_explanation<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<crate::model::model::GlobalExplanation>,
        {
            self.model_level_global_explanation = v.map(|x| x.into());
            self
        }

        /// Sets the value of [class_level_global_explanations][crate::model::model::TrainingRun::class_level_global_explanations].
        pub fn set_class_level_global_explanations<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::model::GlobalExplanation>,
        {
            use std::iter::Iterator;
            self.class_level_global_explanations = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [vertex_ai_model_id][crate::model::model::TrainingRun::vertex_ai_model_id].
        pub fn set_vertex_ai_model_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.vertex_ai_model_id = v.into();
            self
        }

        /// Sets the value of [vertex_ai_model_version][crate::model::model::TrainingRun::vertex_ai_model_version].
        pub fn set_vertex_ai_model_version<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.vertex_ai_model_version = v.into();
            self
        }
    }

    impl wkt::message::Message for TrainingRun {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.TrainingRun"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for TrainingRun {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __training_options,
                __start_time,
                __results,
                __evaluation_metrics,
                __data_split_result,
                __model_level_global_explanation,
                __class_level_global_explanations,
                __vertex_ai_model_id,
                __vertex_ai_model_version,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for TrainingRun")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "trainingOptions" => Ok(__FieldTag::__training_options),
                                "training_options" => Ok(__FieldTag::__training_options),
                                "startTime" => Ok(__FieldTag::__start_time),
                                "start_time" => Ok(__FieldTag::__start_time),
                                "results" => Ok(__FieldTag::__results),
                                "evaluationMetrics" => Ok(__FieldTag::__evaluation_metrics),
                                "evaluation_metrics" => Ok(__FieldTag::__evaluation_metrics),
                                "dataSplitResult" => Ok(__FieldTag::__data_split_result),
                                "data_split_result" => Ok(__FieldTag::__data_split_result),
                                "modelLevelGlobalExplanation" => {
                                    Ok(__FieldTag::__model_level_global_explanation)
                                }
                                "model_level_global_explanation" => {
                                    Ok(__FieldTag::__model_level_global_explanation)
                                }
                                "classLevelGlobalExplanations" => {
                                    Ok(__FieldTag::__class_level_global_explanations)
                                }
                                "class_level_global_explanations" => {
                                    Ok(__FieldTag::__class_level_global_explanations)
                                }
                                "vertexAiModelId" => Ok(__FieldTag::__vertex_ai_model_id),
                                "vertex_ai_model_id" => Ok(__FieldTag::__vertex_ai_model_id),
                                "vertexAiModelVersion" => Ok(__FieldTag::__vertex_ai_model_version),
                                "vertex_ai_model_version" => {
                                    Ok(__FieldTag::__vertex_ai_model_version)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = TrainingRun;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct TrainingRun")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__training_options => {
                                if !fields.insert(__FieldTag::__training_options) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for training_options",
                                    ));
                                }
                                result.training_options = map
                                    .next_value::<std::option::Option<
                                        crate::model::model::training_run::TrainingOptions,
                                    >>()?;
                            }
                            __FieldTag::__start_time => {
                                if !fields.insert(__FieldTag::__start_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for start_time",
                                    ));
                                }
                                result.start_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__results => {
                                if !fields.insert(__FieldTag::__results) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for results",
                                    ));
                                }
                                result.results = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<
                                            crate::model::model::training_run::IterationResult,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__evaluation_metrics => {
                                if !fields.insert(__FieldTag::__evaluation_metrics) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for evaluation_metrics",
                                    ));
                                }
                                result.evaluation_metrics = map.next_value::<std::option::Option<crate::model::model::EvaluationMetrics>>()?
                                    ;
                            }
                            __FieldTag::__data_split_result => {
                                if !fields.insert(__FieldTag::__data_split_result) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for data_split_result",
                                    ));
                                }
                                result.data_split_result = map.next_value::<std::option::Option<crate::model::model::DataSplitResult>>()?
                                    ;
                            }
                            __FieldTag::__model_level_global_explanation => {
                                if !fields.insert(__FieldTag::__model_level_global_explanation) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for model_level_global_explanation",
                                    ));
                                }
                                result.model_level_global_explanation = map.next_value::<std::option::Option<crate::model::model::GlobalExplanation>>()?
                                    ;
                            }
                            __FieldTag::__class_level_global_explanations => {
                                if !fields.insert(__FieldTag::__class_level_global_explanations) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for class_level_global_explanations",
                                    ));
                                }
                                result.class_level_global_explanations = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::model::GlobalExplanation>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__vertex_ai_model_id => {
                                if !fields.insert(__FieldTag::__vertex_ai_model_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for vertex_ai_model_id",
                                    ));
                                }
                                result.vertex_ai_model_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__vertex_ai_model_version => {
                                if !fields.insert(__FieldTag::__vertex_ai_model_version) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for vertex_ai_model_version",
                                    ));
                                }
                                result.vertex_ai_model_version = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for TrainingRun {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.training_options.is_some() {
                state.serialize_entry("trainingOptions", &self.training_options)?;
            }
            if self.start_time.is_some() {
                state.serialize_entry("startTime", &self.start_time)?;
            }
            if !self.results.is_empty() {
                state.serialize_entry("results", &self.results)?;
            }
            if self.evaluation_metrics.is_some() {
                state.serialize_entry("evaluationMetrics", &self.evaluation_metrics)?;
            }
            if self.data_split_result.is_some() {
                state.serialize_entry("dataSplitResult", &self.data_split_result)?;
            }
            if self.model_level_global_explanation.is_some() {
                state.serialize_entry(
                    "modelLevelGlobalExplanation",
                    &self.model_level_global_explanation,
                )?;
            }
            if !self.class_level_global_explanations.is_empty() {
                state.serialize_entry(
                    "classLevelGlobalExplanations",
                    &self.class_level_global_explanations,
                )?;
            }
            if !self.vertex_ai_model_id.is_empty() {
                state.serialize_entry("vertexAiModelId", &self.vertex_ai_model_id)?;
            }
            if !self.vertex_ai_model_version.is_empty() {
                state.serialize_entry("vertexAiModelVersion", &self.vertex_ai_model_version)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [TrainingRun].
    pub mod training_run {
        #[allow(unused_imports)]
        use super::*;

        /// Options used in model training.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct TrainingOptions {
            /// The maximum number of iterations in training. Used only for iterative
            /// training algorithms.
            pub max_iterations: i64,

            /// Type of loss function used during training run.
            pub loss_type: crate::model::model::LossType,

            /// Learning rate in training. Used only for iterative training algorithms.
            pub learn_rate: f64,

            /// L1 regularization coefficient.
            pub l1_regularization: std::option::Option<wkt::DoubleValue>,

            /// L2 regularization coefficient.
            pub l2_regularization: std::option::Option<wkt::DoubleValue>,

            /// When early_stop is true, stops training when accuracy improvement is
            /// less than 'min_relative_progress'. Used only for iterative training
            /// algorithms.
            pub min_relative_progress: std::option::Option<wkt::DoubleValue>,

            /// Whether to train a model from the last checkpoint.
            pub warm_start: std::option::Option<wkt::BoolValue>,

            /// Whether to stop early when the loss doesn't improve significantly
            /// any more (compared to min_relative_progress). Used only for iterative
            /// training algorithms.
            pub early_stop: std::option::Option<wkt::BoolValue>,

            /// Name of input label columns in training data.
            pub input_label_columns: std::vec::Vec<std::string::String>,

            /// The data split type for training and evaluation, e.g. RANDOM.
            pub data_split_method: crate::model::model::DataSplitMethod,

            /// The fraction of evaluation data over the whole input data. The rest
            /// of data will be used as training data. The format should be double.
            /// Accurate to two decimal places.
            /// Default value is 0.2.
            pub data_split_eval_fraction: f64,

            /// The column to split data with. This column won't be used as a
            /// feature.
            ///
            /// 1. When data_split_method is CUSTOM, the corresponding column should
            ///    be boolean. The rows with true value tag are eval data, and the false
            ///    are training data.
            /// 1. When data_split_method is SEQ, the first DATA_SPLIT_EVAL_FRACTION
            ///    rows (from smallest to largest) in the corresponding column are used
            ///    as training data, and the rest are eval data. It respects the order
            ///    in Orderable data types:
            ///    <https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#data_type_properties>
            pub data_split_column: std::string::String,

            /// The strategy to determine learn rate for the current iteration.
            pub learn_rate_strategy: crate::model::model::LearnRateStrategy,

            /// Specifies the initial learning rate for the line search learn rate
            /// strategy.
            pub initial_learn_rate: f64,

            /// Weights associated with each label class, for rebalancing the
            /// training data. Only applicable for classification models.
            pub label_class_weights: std::collections::HashMap<std::string::String, f64>,

            /// User column specified for matrix factorization models.
            pub user_column: std::string::String,

            /// Item column specified for matrix factorization models.
            pub item_column: std::string::String,

            /// Distance type for clustering models.
            pub distance_type: crate::model::model::DistanceType,

            /// Number of clusters for clustering models.
            pub num_clusters: i64,

            /// Google Cloud Storage URI from which the model was imported. Only
            /// applicable for imported models.
            pub model_uri: std::string::String,

            /// Optimization strategy for training linear regression models.
            pub optimization_strategy: crate::model::model::OptimizationStrategy,

            /// Hidden units for dnn models.
            pub hidden_units: std::vec::Vec<i64>,

            /// Batch size for dnn models.
            pub batch_size: i64,

            /// Dropout probability for dnn models.
            pub dropout: std::option::Option<wkt::DoubleValue>,

            /// Maximum depth of a tree for boosted tree models.
            pub max_tree_depth: i64,

            /// Subsample fraction of the training data to grow tree to prevent
            /// overfitting for boosted tree models.
            pub subsample: f64,

            /// Minimum split loss for boosted tree models.
            pub min_split_loss: std::option::Option<wkt::DoubleValue>,

            /// Booster type for boosted tree models.
            pub booster_type: crate::model::model::boosted_tree_option_enums::BoosterType,

            /// Number of parallel trees constructed during each iteration for boosted
            /// tree models.
            pub num_parallel_tree: std::option::Option<wkt::Int64Value>,

            /// Type of normalization algorithm for boosted tree models using
            /// dart booster.
            pub dart_normalize_type:
                crate::model::model::boosted_tree_option_enums::DartNormalizeType,

            /// Tree construction algorithm for boosted tree models.
            pub tree_method: crate::model::model::boosted_tree_option_enums::TreeMethod,

            /// Minimum sum of instance weight needed in a child for boosted tree
            /// models.
            pub min_tree_child_weight: std::option::Option<wkt::Int64Value>,

            /// Subsample ratio of columns when constructing each tree for boosted tree
            /// models.
            pub colsample_bytree: std::option::Option<wkt::DoubleValue>,

            /// Subsample ratio of columns for each level for boosted tree models.
            pub colsample_bylevel: std::option::Option<wkt::DoubleValue>,

            /// Subsample ratio of columns for each node(split) for boosted tree
            /// models.
            pub colsample_bynode: std::option::Option<wkt::DoubleValue>,

            /// Num factors specified for matrix factorization models.
            pub num_factors: i64,

            /// Feedback type that specifies which algorithm to run for matrix
            /// factorization.
            pub feedback_type: crate::model::model::FeedbackType,

            /// Hyperparameter for matrix factoration when implicit feedback type is
            /// specified.
            pub wals_alpha: std::option::Option<wkt::DoubleValue>,

            /// The method used to initialize the centroids for kmeans algorithm.
            pub kmeans_initialization_method:
                crate::model::model::kmeans_enums::KmeansInitializationMethod,

            /// The column used to provide the initial centroids for kmeans algorithm
            /// when kmeans_initialization_method is CUSTOM.
            pub kmeans_initialization_column: std::string::String,

            /// Column to be designated as time series timestamp for ARIMA model.
            pub time_series_timestamp_column: std::string::String,

            /// Column to be designated as time series data for ARIMA model.
            pub time_series_data_column: std::string::String,

            /// Whether to enable auto ARIMA or not.
            pub auto_arima: std::option::Option<wkt::BoolValue>,

            /// A specification of the non-seasonal part of the ARIMA model: the three
            /// components (p, d, q) are the AR order, the degree of differencing, and
            /// the MA order.
            pub non_seasonal_order: std::option::Option<crate::model::model::ArimaOrder>,

            /// The data frequency of a time series.
            pub data_frequency: crate::model::model::DataFrequency,

            /// Whether or not p-value test should be computed for this model. Only
            /// available for linear and logistic regression models.
            pub calculate_p_values: std::option::Option<wkt::BoolValue>,

            /// Include drift when fitting an ARIMA model.
            pub include_drift: std::option::Option<wkt::BoolValue>,

            /// The geographical region based on which the holidays are considered in
            /// time series modeling. If a valid value is specified, then holiday
            /// effects modeling is enabled.
            pub holiday_region: crate::model::model::HolidayRegion,

            /// A list of geographical regions that are used for time series modeling.
            pub holiday_regions: std::vec::Vec<crate::model::model::HolidayRegion>,

            /// The time series id column that was used during ARIMA model training.
            pub time_series_id_column: std::string::String,

            /// The time series id columns that were used during ARIMA model training.
            pub time_series_id_columns: std::vec::Vec<std::string::String>,

            /// The forecast limit lower bound that was used during ARIMA model
            /// training with limits. To see more details of the algorithm:
            /// <https://otexts.com/fpp2/limits.html>
            pub forecast_limit_lower_bound: f64,

            /// The forecast limit upper bound that was used during ARIMA model
            /// training with limits.
            pub forecast_limit_upper_bound: f64,

            /// The number of periods ahead that need to be forecasted.
            pub horizon: i64,

            /// The max value of the sum of non-seasonal p and q.
            pub auto_arima_max_order: i64,

            /// The min value of the sum of non-seasonal p and q.
            pub auto_arima_min_order: i64,

            /// Number of trials to run this hyperparameter tuning job.
            pub num_trials: i64,

            /// Maximum number of trials to run in parallel.
            pub max_parallel_trials: i64,

            /// The target evaluation metrics to optimize the hyperparameters for.
            pub hparam_tuning_objectives:
                std::vec::Vec<crate::model::model::hparam_tuning_enums::HparamTuningObjective>,

            /// If true, perform decompose time series and save the results.
            pub decompose_time_series: std::option::Option<wkt::BoolValue>,

            /// If true, clean spikes and dips in the input time series.
            pub clean_spikes_and_dips: std::option::Option<wkt::BoolValue>,

            /// If true, detect step changes and make data adjustment in the input time
            /// series.
            pub adjust_step_changes: std::option::Option<wkt::BoolValue>,

            /// If true, enable global explanation during training.
            pub enable_global_explain: std::option::Option<wkt::BoolValue>,

            /// Number of paths for the sampled Shapley explain method.
            pub sampled_shapley_num_paths: i64,

            /// Number of integral steps for the integrated gradients explain method.
            pub integrated_gradients_num_steps: i64,

            /// Categorical feature encoding method.
            pub category_encoding_method:
                crate::model::model::category_encoding_method::EncodingMethod,

            /// Based on the selected TF version, the corresponding docker image is
            /// used to train external models.
            pub tf_version: std::string::String,

            /// Enums for color space, used for processing images in Object Table.
            /// See more details at
            /// <https://www.tensorflow.org/io/tutorials/colorspace>.
            pub color_space: crate::model::model::ColorSpace,

            /// Name of the instance weight column for training data.
            /// This column isn't be used as a feature.
            pub instance_weight_column: std::string::String,

            /// Smoothing window size for the trend component. When a positive value is
            /// specified, a center moving average smoothing is applied on the history
            /// trend. When the smoothing window is out of the boundary at the
            /// beginning or the end of the trend, the first element or the last
            /// element is padded to fill the smoothing window before the average is
            /// applied.
            pub trend_smoothing_window_size: i64,

            /// The fraction of the interpolated length of the time series that's used
            /// to model the time series trend component. All of the time points of the
            /// time series are used to model the non-trend component. This training
            /// option accelerates modeling training without sacrificing much
            /// forecasting accuracy. You can use this option with
            /// `minTimeSeriesLength` but not with `maxTimeSeriesLength`.
            pub time_series_length_fraction: f64,

            /// The minimum number of time points in a time series that are used in
            /// modeling the trend component of the time series. If you use this option
            /// you must also set the `timeSeriesLengthFraction` option. This training
            /// option ensures that enough time points are available when you use
            /// `timeSeriesLengthFraction` in trend modeling. This is particularly
            /// important when forecasting multiple time series in a single query using
            /// `timeSeriesIdColumn`. If the total number of time points is less than
            /// the `minTimeSeriesLength` value, then the query uses all available time
            /// points.
            pub min_time_series_length: i64,

            /// The maximum number of time points in a time series that can be used in
            /// modeling the trend component of the time series. Don't use this option
            /// with the `timeSeriesLengthFraction` or `minTimeSeriesLength` options.
            pub max_time_series_length: i64,

            /// User-selected XGBoost versions for training of XGBoost models.
            pub xgboost_version: std::string::String,

            /// Whether to use approximate feature contribution method in XGBoost model
            /// explanation for global explain.
            pub approx_global_feature_contrib: std::option::Option<wkt::BoolValue>,

            /// Whether the model should include intercept during model training.
            pub fit_intercept: std::option::Option<wkt::BoolValue>,

            /// Number of principal components to keep in the PCA model. Must be <= the
            /// number of features.
            pub num_principal_components: i64,

            /// The minimum ratio of cumulative explained variance that needs to be
            /// given by the PCA model.
            pub pca_explained_variance_ratio: f64,

            /// If true, scale the feature values by dividing the feature standard
            /// deviation. Currently only apply to PCA.
            pub scale_features: std::option::Option<wkt::BoolValue>,

            /// The solver for PCA.
            pub pca_solver: crate::model::model::pca_solver_option_enums::PcaSolver,

            /// Whether to calculate class weights automatically based on the
            /// popularity of each label.
            pub auto_class_weights: std::option::Option<wkt::BoolValue>,

            /// Activation function of the neural nets.
            pub activation_fn: std::string::String,

            /// Optimizer used for training the neural nets.
            pub optimizer: std::string::String,

            /// Budget in hours for AutoML training.
            pub budget_hours: f64,

            /// Whether to standardize numerical features. Default to true.
            pub standardize_features: std::option::Option<wkt::BoolValue>,

            /// L1 regularization coefficient to activations.
            pub l1_reg_activation: f64,

            /// The model registry.
            pub model_registry: crate::model::model::model_registry_option_enums::ModelRegistry,

            /// The version aliases to apply in Vertex AI model registry. Always
            /// overwrite if the version aliases exists in a existing model.
            pub vertex_ai_model_version_aliases: std::vec::Vec<std::string::String>,

            /// Optional. Names of the columns to slice on. Applies to contribution
            /// analysis models.
            pub dimension_id_columns: std::vec::Vec<std::string::String>,

            /// The contribution metric. Applies to contribution analysis models.
            /// Allowed formats supported are for summable and summable ratio
            /// contribution metrics. These include expressions such as `SUM(x)` or
            /// `SUM(x)/SUM(y)`, where x and y are column names from the base table.
            pub contribution_metric: std::option::Option<std::string::String>,

            /// Name of the column used to determine the rows corresponding to control
            /// and test. Applies to contribution analysis models.
            pub is_test_column: std::option::Option<std::string::String>,

            /// The apriori support minimum. Applies to contribution analysis models.
            pub min_apriori_support: std::option::Option<f64>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl TrainingOptions {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [max_iterations][crate::model::model::training_run::TrainingOptions::max_iterations].
            pub fn set_max_iterations<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.max_iterations = v.into();
                self
            }

            /// Sets the value of [loss_type][crate::model::model::training_run::TrainingOptions::loss_type].
            pub fn set_loss_type<T: std::convert::Into<crate::model::model::LossType>>(
                mut self,
                v: T,
            ) -> Self {
                self.loss_type = v.into();
                self
            }

            /// Sets the value of [learn_rate][crate::model::model::training_run::TrainingOptions::learn_rate].
            pub fn set_learn_rate<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                self.learn_rate = v.into();
                self
            }

            /// Sets the value of [l1_regularization][crate::model::model::training_run::TrainingOptions::l1_regularization].
            pub fn set_l1_regularization<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::DoubleValue>,
            {
                self.l1_regularization = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [l1_regularization][crate::model::model::training_run::TrainingOptions::l1_regularization].
            pub fn set_or_clear_l1_regularization<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::DoubleValue>,
            {
                self.l1_regularization = v.map(|x| x.into());
                self
            }

            /// Sets the value of [l2_regularization][crate::model::model::training_run::TrainingOptions::l2_regularization].
            pub fn set_l2_regularization<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::DoubleValue>,
            {
                self.l2_regularization = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [l2_regularization][crate::model::model::training_run::TrainingOptions::l2_regularization].
            pub fn set_or_clear_l2_regularization<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::DoubleValue>,
            {
                self.l2_regularization = v.map(|x| x.into());
                self
            }

            /// Sets the value of [min_relative_progress][crate::model::model::training_run::TrainingOptions::min_relative_progress].
            pub fn set_min_relative_progress<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::DoubleValue>,
            {
                self.min_relative_progress = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [min_relative_progress][crate::model::model::training_run::TrainingOptions::min_relative_progress].
            pub fn set_or_clear_min_relative_progress<T>(
                mut self,
                v: std::option::Option<T>,
            ) -> Self
            where
                T: std::convert::Into<wkt::DoubleValue>,
            {
                self.min_relative_progress = v.map(|x| x.into());
                self
            }

            /// Sets the value of [warm_start][crate::model::model::training_run::TrainingOptions::warm_start].
            pub fn set_warm_start<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::BoolValue>,
            {
                self.warm_start = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [warm_start][crate::model::model::training_run::TrainingOptions::warm_start].
            pub fn set_or_clear_warm_start<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::BoolValue>,
            {
                self.warm_start = v.map(|x| x.into());
                self
            }

            /// Sets the value of [early_stop][crate::model::model::training_run::TrainingOptions::early_stop].
            pub fn set_early_stop<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::BoolValue>,
            {
                self.early_stop = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [early_stop][crate::model::model::training_run::TrainingOptions::early_stop].
            pub fn set_or_clear_early_stop<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::BoolValue>,
            {
                self.early_stop = v.map(|x| x.into());
                self
            }

            /// Sets the value of [input_label_columns][crate::model::model::training_run::TrainingOptions::input_label_columns].
            pub fn set_input_label_columns<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.input_label_columns = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [data_split_method][crate::model::model::training_run::TrainingOptions::data_split_method].
            pub fn set_data_split_method<
                T: std::convert::Into<crate::model::model::DataSplitMethod>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.data_split_method = v.into();
                self
            }

            /// Sets the value of [data_split_eval_fraction][crate::model::model::training_run::TrainingOptions::data_split_eval_fraction].
            pub fn set_data_split_eval_fraction<T: std::convert::Into<f64>>(
                mut self,
                v: T,
            ) -> Self {
                self.data_split_eval_fraction = v.into();
                self
            }

            /// Sets the value of [data_split_column][crate::model::model::training_run::TrainingOptions::data_split_column].
            pub fn set_data_split_column<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.data_split_column = v.into();
                self
            }

            /// Sets the value of [learn_rate_strategy][crate::model::model::training_run::TrainingOptions::learn_rate_strategy].
            pub fn set_learn_rate_strategy<
                T: std::convert::Into<crate::model::model::LearnRateStrategy>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.learn_rate_strategy = v.into();
                self
            }

            /// Sets the value of [initial_learn_rate][crate::model::model::training_run::TrainingOptions::initial_learn_rate].
            pub fn set_initial_learn_rate<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                self.initial_learn_rate = v.into();
                self
            }

            /// Sets the value of [label_class_weights][crate::model::model::training_run::TrainingOptions::label_class_weights].
            pub fn set_label_class_weights<T, K, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = (K, V)>,
                K: std::convert::Into<std::string::String>,
                V: std::convert::Into<f64>,
            {
                use std::iter::Iterator;
                self.label_class_weights =
                    v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
                self
            }

            /// Sets the value of [user_column][crate::model::model::training_run::TrainingOptions::user_column].
            pub fn set_user_column<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.user_column = v.into();
                self
            }

            /// Sets the value of [item_column][crate::model::model::training_run::TrainingOptions::item_column].
            pub fn set_item_column<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.item_column = v.into();
                self
            }

            /// Sets the value of [distance_type][crate::model::model::training_run::TrainingOptions::distance_type].
            pub fn set_distance_type<T: std::convert::Into<crate::model::model::DistanceType>>(
                mut self,
                v: T,
            ) -> Self {
                self.distance_type = v.into();
                self
            }

            /// Sets the value of [num_clusters][crate::model::model::training_run::TrainingOptions::num_clusters].
            pub fn set_num_clusters<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.num_clusters = v.into();
                self
            }

            /// Sets the value of [model_uri][crate::model::model::training_run::TrainingOptions::model_uri].
            pub fn set_model_uri<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.model_uri = v.into();
                self
            }

            /// Sets the value of [optimization_strategy][crate::model::model::training_run::TrainingOptions::optimization_strategy].
            pub fn set_optimization_strategy<
                T: std::convert::Into<crate::model::model::OptimizationStrategy>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.optimization_strategy = v.into();
                self
            }

            /// Sets the value of [hidden_units][crate::model::model::training_run::TrainingOptions::hidden_units].
            pub fn set_hidden_units<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<i64>,
            {
                use std::iter::Iterator;
                self.hidden_units = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [batch_size][crate::model::model::training_run::TrainingOptions::batch_size].
            pub fn set_batch_size<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.batch_size = v.into();
                self
            }

            /// Sets the value of [dropout][crate::model::model::training_run::TrainingOptions::dropout].
            pub fn set_dropout<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::DoubleValue>,
            {
                self.dropout = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [dropout][crate::model::model::training_run::TrainingOptions::dropout].
            pub fn set_or_clear_dropout<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::DoubleValue>,
            {
                self.dropout = v.map(|x| x.into());
                self
            }

            /// Sets the value of [max_tree_depth][crate::model::model::training_run::TrainingOptions::max_tree_depth].
            pub fn set_max_tree_depth<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.max_tree_depth = v.into();
                self
            }

            /// Sets the value of [subsample][crate::model::model::training_run::TrainingOptions::subsample].
            pub fn set_subsample<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                self.subsample = v.into();
                self
            }

            /// Sets the value of [min_split_loss][crate::model::model::training_run::TrainingOptions::min_split_loss].
            pub fn set_min_split_loss<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::DoubleValue>,
            {
                self.min_split_loss = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [min_split_loss][crate::model::model::training_run::TrainingOptions::min_split_loss].
            pub fn set_or_clear_min_split_loss<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::DoubleValue>,
            {
                self.min_split_loss = v.map(|x| x.into());
                self
            }

            /// Sets the value of [booster_type][crate::model::model::training_run::TrainingOptions::booster_type].
            pub fn set_booster_type<
                T: std::convert::Into<crate::model::model::boosted_tree_option_enums::BoosterType>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.booster_type = v.into();
                self
            }

            /// Sets the value of [num_parallel_tree][crate::model::model::training_run::TrainingOptions::num_parallel_tree].
            pub fn set_num_parallel_tree<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::Int64Value>,
            {
                self.num_parallel_tree = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [num_parallel_tree][crate::model::model::training_run::TrainingOptions::num_parallel_tree].
            pub fn set_or_clear_num_parallel_tree<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::Int64Value>,
            {
                self.num_parallel_tree = v.map(|x| x.into());
                self
            }

            /// Sets the value of [dart_normalize_type][crate::model::model::training_run::TrainingOptions::dart_normalize_type].
            pub fn set_dart_normalize_type<
                T: std::convert::Into<
                        crate::model::model::boosted_tree_option_enums::DartNormalizeType,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.dart_normalize_type = v.into();
                self
            }

            /// Sets the value of [tree_method][crate::model::model::training_run::TrainingOptions::tree_method].
            pub fn set_tree_method<
                T: std::convert::Into<crate::model::model::boosted_tree_option_enums::TreeMethod>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.tree_method = v.into();
                self
            }

            /// Sets the value of [min_tree_child_weight][crate::model::model::training_run::TrainingOptions::min_tree_child_weight].
            pub fn set_min_tree_child_weight<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::Int64Value>,
            {
                self.min_tree_child_weight = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [min_tree_child_weight][crate::model::model::training_run::TrainingOptions::min_tree_child_weight].
            pub fn set_or_clear_min_tree_child_weight<T>(
                mut self,
                v: std::option::Option<T>,
            ) -> Self
            where
                T: std::convert::Into<wkt::Int64Value>,
            {
                self.min_tree_child_weight = v.map(|x| x.into());
                self
            }

            /// Sets the value of [colsample_bytree][crate::model::model::training_run::TrainingOptions::colsample_bytree].
            pub fn set_colsample_bytree<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::DoubleValue>,
            {
                self.colsample_bytree = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [colsample_bytree][crate::model::model::training_run::TrainingOptions::colsample_bytree].
            pub fn set_or_clear_colsample_bytree<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::DoubleValue>,
            {
                self.colsample_bytree = v.map(|x| x.into());
                self
            }

            /// Sets the value of [colsample_bylevel][crate::model::model::training_run::TrainingOptions::colsample_bylevel].
            pub fn set_colsample_bylevel<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::DoubleValue>,
            {
                self.colsample_bylevel = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [colsample_bylevel][crate::model::model::training_run::TrainingOptions::colsample_bylevel].
            pub fn set_or_clear_colsample_bylevel<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::DoubleValue>,
            {
                self.colsample_bylevel = v.map(|x| x.into());
                self
            }

            /// Sets the value of [colsample_bynode][crate::model::model::training_run::TrainingOptions::colsample_bynode].
            pub fn set_colsample_bynode<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::DoubleValue>,
            {
                self.colsample_bynode = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [colsample_bynode][crate::model::model::training_run::TrainingOptions::colsample_bynode].
            pub fn set_or_clear_colsample_bynode<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::DoubleValue>,
            {
                self.colsample_bynode = v.map(|x| x.into());
                self
            }

            /// Sets the value of [num_factors][crate::model::model::training_run::TrainingOptions::num_factors].
            pub fn set_num_factors<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.num_factors = v.into();
                self
            }

            /// Sets the value of [feedback_type][crate::model::model::training_run::TrainingOptions::feedback_type].
            pub fn set_feedback_type<T: std::convert::Into<crate::model::model::FeedbackType>>(
                mut self,
                v: T,
            ) -> Self {
                self.feedback_type = v.into();
                self
            }

            /// Sets the value of [wals_alpha][crate::model::model::training_run::TrainingOptions::wals_alpha].
            pub fn set_wals_alpha<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::DoubleValue>,
            {
                self.wals_alpha = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [wals_alpha][crate::model::model::training_run::TrainingOptions::wals_alpha].
            pub fn set_or_clear_wals_alpha<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::DoubleValue>,
            {
                self.wals_alpha = v.map(|x| x.into());
                self
            }

            /// Sets the value of [kmeans_initialization_method][crate::model::model::training_run::TrainingOptions::kmeans_initialization_method].
            pub fn set_kmeans_initialization_method<
                T: std::convert::Into<crate::model::model::kmeans_enums::KmeansInitializationMethod>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.kmeans_initialization_method = v.into();
                self
            }

            /// Sets the value of [kmeans_initialization_column][crate::model::model::training_run::TrainingOptions::kmeans_initialization_column].
            pub fn set_kmeans_initialization_column<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.kmeans_initialization_column = v.into();
                self
            }

            /// Sets the value of [time_series_timestamp_column][crate::model::model::training_run::TrainingOptions::time_series_timestamp_column].
            pub fn set_time_series_timestamp_column<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.time_series_timestamp_column = v.into();
                self
            }

            /// Sets the value of [time_series_data_column][crate::model::model::training_run::TrainingOptions::time_series_data_column].
            pub fn set_time_series_data_column<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.time_series_data_column = v.into();
                self
            }

            /// Sets the value of [auto_arima][crate::model::model::training_run::TrainingOptions::auto_arima].
            pub fn set_auto_arima<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::BoolValue>,
            {
                self.auto_arima = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [auto_arima][crate::model::model::training_run::TrainingOptions::auto_arima].
            pub fn set_or_clear_auto_arima<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::BoolValue>,
            {
                self.auto_arima = v.map(|x| x.into());
                self
            }

            /// Sets the value of [non_seasonal_order][crate::model::model::training_run::TrainingOptions::non_seasonal_order].
            pub fn set_non_seasonal_order<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::model::ArimaOrder>,
            {
                self.non_seasonal_order = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [non_seasonal_order][crate::model::model::training_run::TrainingOptions::non_seasonal_order].
            pub fn set_or_clear_non_seasonal_order<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::model::ArimaOrder>,
            {
                self.non_seasonal_order = v.map(|x| x.into());
                self
            }

            /// Sets the value of [data_frequency][crate::model::model::training_run::TrainingOptions::data_frequency].
            pub fn set_data_frequency<T: std::convert::Into<crate::model::model::DataFrequency>>(
                mut self,
                v: T,
            ) -> Self {
                self.data_frequency = v.into();
                self
            }

            /// Sets the value of [calculate_p_values][crate::model::model::training_run::TrainingOptions::calculate_p_values].
            pub fn set_calculate_p_values<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::BoolValue>,
            {
                self.calculate_p_values = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [calculate_p_values][crate::model::model::training_run::TrainingOptions::calculate_p_values].
            pub fn set_or_clear_calculate_p_values<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::BoolValue>,
            {
                self.calculate_p_values = v.map(|x| x.into());
                self
            }

            /// Sets the value of [include_drift][crate::model::model::training_run::TrainingOptions::include_drift].
            pub fn set_include_drift<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::BoolValue>,
            {
                self.include_drift = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [include_drift][crate::model::model::training_run::TrainingOptions::include_drift].
            pub fn set_or_clear_include_drift<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::BoolValue>,
            {
                self.include_drift = v.map(|x| x.into());
                self
            }

            /// Sets the value of [holiday_region][crate::model::model::training_run::TrainingOptions::holiday_region].
            pub fn set_holiday_region<T: std::convert::Into<crate::model::model::HolidayRegion>>(
                mut self,
                v: T,
            ) -> Self {
                self.holiday_region = v.into();
                self
            }

            /// Sets the value of [holiday_regions][crate::model::model::training_run::TrainingOptions::holiday_regions].
            pub fn set_holiday_regions<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::model::HolidayRegion>,
            {
                use std::iter::Iterator;
                self.holiday_regions = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [time_series_id_column][crate::model::model::training_run::TrainingOptions::time_series_id_column].
            pub fn set_time_series_id_column<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.time_series_id_column = v.into();
                self
            }

            /// Sets the value of [time_series_id_columns][crate::model::model::training_run::TrainingOptions::time_series_id_columns].
            pub fn set_time_series_id_columns<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.time_series_id_columns = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [forecast_limit_lower_bound][crate::model::model::training_run::TrainingOptions::forecast_limit_lower_bound].
            pub fn set_forecast_limit_lower_bound<T: std::convert::Into<f64>>(
                mut self,
                v: T,
            ) -> Self {
                self.forecast_limit_lower_bound = v.into();
                self
            }

            /// Sets the value of [forecast_limit_upper_bound][crate::model::model::training_run::TrainingOptions::forecast_limit_upper_bound].
            pub fn set_forecast_limit_upper_bound<T: std::convert::Into<f64>>(
                mut self,
                v: T,
            ) -> Self {
                self.forecast_limit_upper_bound = v.into();
                self
            }

            /// Sets the value of [horizon][crate::model::model::training_run::TrainingOptions::horizon].
            pub fn set_horizon<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.horizon = v.into();
                self
            }

            /// Sets the value of [auto_arima_max_order][crate::model::model::training_run::TrainingOptions::auto_arima_max_order].
            pub fn set_auto_arima_max_order<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.auto_arima_max_order = v.into();
                self
            }

            /// Sets the value of [auto_arima_min_order][crate::model::model::training_run::TrainingOptions::auto_arima_min_order].
            pub fn set_auto_arima_min_order<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.auto_arima_min_order = v.into();
                self
            }

            /// Sets the value of [num_trials][crate::model::model::training_run::TrainingOptions::num_trials].
            pub fn set_num_trials<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.num_trials = v.into();
                self
            }

            /// Sets the value of [max_parallel_trials][crate::model::model::training_run::TrainingOptions::max_parallel_trials].
            pub fn set_max_parallel_trials<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.max_parallel_trials = v.into();
                self
            }

            /// Sets the value of [hparam_tuning_objectives][crate::model::model::training_run::TrainingOptions::hparam_tuning_objectives].
            pub fn set_hparam_tuning_objectives<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<
                        crate::model::model::hparam_tuning_enums::HparamTuningObjective,
                    >,
            {
                use std::iter::Iterator;
                self.hparam_tuning_objectives = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [decompose_time_series][crate::model::model::training_run::TrainingOptions::decompose_time_series].
            pub fn set_decompose_time_series<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::BoolValue>,
            {
                self.decompose_time_series = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [decompose_time_series][crate::model::model::training_run::TrainingOptions::decompose_time_series].
            pub fn set_or_clear_decompose_time_series<T>(
                mut self,
                v: std::option::Option<T>,
            ) -> Self
            where
                T: std::convert::Into<wkt::BoolValue>,
            {
                self.decompose_time_series = v.map(|x| x.into());
                self
            }

            /// Sets the value of [clean_spikes_and_dips][crate::model::model::training_run::TrainingOptions::clean_spikes_and_dips].
            pub fn set_clean_spikes_and_dips<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::BoolValue>,
            {
                self.clean_spikes_and_dips = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [clean_spikes_and_dips][crate::model::model::training_run::TrainingOptions::clean_spikes_and_dips].
            pub fn set_or_clear_clean_spikes_and_dips<T>(
                mut self,
                v: std::option::Option<T>,
            ) -> Self
            where
                T: std::convert::Into<wkt::BoolValue>,
            {
                self.clean_spikes_and_dips = v.map(|x| x.into());
                self
            }

            /// Sets the value of [adjust_step_changes][crate::model::model::training_run::TrainingOptions::adjust_step_changes].
            pub fn set_adjust_step_changes<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::BoolValue>,
            {
                self.adjust_step_changes = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [adjust_step_changes][crate::model::model::training_run::TrainingOptions::adjust_step_changes].
            pub fn set_or_clear_adjust_step_changes<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::BoolValue>,
            {
                self.adjust_step_changes = v.map(|x| x.into());
                self
            }

            /// Sets the value of [enable_global_explain][crate::model::model::training_run::TrainingOptions::enable_global_explain].
            pub fn set_enable_global_explain<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::BoolValue>,
            {
                self.enable_global_explain = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [enable_global_explain][crate::model::model::training_run::TrainingOptions::enable_global_explain].
            pub fn set_or_clear_enable_global_explain<T>(
                mut self,
                v: std::option::Option<T>,
            ) -> Self
            where
                T: std::convert::Into<wkt::BoolValue>,
            {
                self.enable_global_explain = v.map(|x| x.into());
                self
            }

            /// Sets the value of [sampled_shapley_num_paths][crate::model::model::training_run::TrainingOptions::sampled_shapley_num_paths].
            pub fn set_sampled_shapley_num_paths<T: std::convert::Into<i64>>(
                mut self,
                v: T,
            ) -> Self {
                self.sampled_shapley_num_paths = v.into();
                self
            }

            /// Sets the value of [integrated_gradients_num_steps][crate::model::model::training_run::TrainingOptions::integrated_gradients_num_steps].
            pub fn set_integrated_gradients_num_steps<T: std::convert::Into<i64>>(
                mut self,
                v: T,
            ) -> Self {
                self.integrated_gradients_num_steps = v.into();
                self
            }

            /// Sets the value of [category_encoding_method][crate::model::model::training_run::TrainingOptions::category_encoding_method].
            pub fn set_category_encoding_method<
                T: std::convert::Into<crate::model::model::category_encoding_method::EncodingMethod>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.category_encoding_method = v.into();
                self
            }

            /// Sets the value of [tf_version][crate::model::model::training_run::TrainingOptions::tf_version].
            pub fn set_tf_version<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.tf_version = v.into();
                self
            }

            /// Sets the value of [color_space][crate::model::model::training_run::TrainingOptions::color_space].
            pub fn set_color_space<T: std::convert::Into<crate::model::model::ColorSpace>>(
                mut self,
                v: T,
            ) -> Self {
                self.color_space = v.into();
                self
            }

            /// Sets the value of [instance_weight_column][crate::model::model::training_run::TrainingOptions::instance_weight_column].
            pub fn set_instance_weight_column<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.instance_weight_column = v.into();
                self
            }

            /// Sets the value of [trend_smoothing_window_size][crate::model::model::training_run::TrainingOptions::trend_smoothing_window_size].
            pub fn set_trend_smoothing_window_size<T: std::convert::Into<i64>>(
                mut self,
                v: T,
            ) -> Self {
                self.trend_smoothing_window_size = v.into();
                self
            }

            /// Sets the value of [time_series_length_fraction][crate::model::model::training_run::TrainingOptions::time_series_length_fraction].
            pub fn set_time_series_length_fraction<T: std::convert::Into<f64>>(
                mut self,
                v: T,
            ) -> Self {
                self.time_series_length_fraction = v.into();
                self
            }

            /// Sets the value of [min_time_series_length][crate::model::model::training_run::TrainingOptions::min_time_series_length].
            pub fn set_min_time_series_length<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.min_time_series_length = v.into();
                self
            }

            /// Sets the value of [max_time_series_length][crate::model::model::training_run::TrainingOptions::max_time_series_length].
            pub fn set_max_time_series_length<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.max_time_series_length = v.into();
                self
            }

            /// Sets the value of [xgboost_version][crate::model::model::training_run::TrainingOptions::xgboost_version].
            pub fn set_xgboost_version<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.xgboost_version = v.into();
                self
            }

            /// Sets the value of [approx_global_feature_contrib][crate::model::model::training_run::TrainingOptions::approx_global_feature_contrib].
            pub fn set_approx_global_feature_contrib<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::BoolValue>,
            {
                self.approx_global_feature_contrib = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [approx_global_feature_contrib][crate::model::model::training_run::TrainingOptions::approx_global_feature_contrib].
            pub fn set_or_clear_approx_global_feature_contrib<T>(
                mut self,
                v: std::option::Option<T>,
            ) -> Self
            where
                T: std::convert::Into<wkt::BoolValue>,
            {
                self.approx_global_feature_contrib = v.map(|x| x.into());
                self
            }

            /// Sets the value of [fit_intercept][crate::model::model::training_run::TrainingOptions::fit_intercept].
            pub fn set_fit_intercept<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::BoolValue>,
            {
                self.fit_intercept = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [fit_intercept][crate::model::model::training_run::TrainingOptions::fit_intercept].
            pub fn set_or_clear_fit_intercept<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::BoolValue>,
            {
                self.fit_intercept = v.map(|x| x.into());
                self
            }

            /// Sets the value of [num_principal_components][crate::model::model::training_run::TrainingOptions::num_principal_components].
            pub fn set_num_principal_components<T: std::convert::Into<i64>>(
                mut self,
                v: T,
            ) -> Self {
                self.num_principal_components = v.into();
                self
            }

            /// Sets the value of [pca_explained_variance_ratio][crate::model::model::training_run::TrainingOptions::pca_explained_variance_ratio].
            pub fn set_pca_explained_variance_ratio<T: std::convert::Into<f64>>(
                mut self,
                v: T,
            ) -> Self {
                self.pca_explained_variance_ratio = v.into();
                self
            }

            /// Sets the value of [scale_features][crate::model::model::training_run::TrainingOptions::scale_features].
            pub fn set_scale_features<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::BoolValue>,
            {
                self.scale_features = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [scale_features][crate::model::model::training_run::TrainingOptions::scale_features].
            pub fn set_or_clear_scale_features<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::BoolValue>,
            {
                self.scale_features = v.map(|x| x.into());
                self
            }

            /// Sets the value of [pca_solver][crate::model::model::training_run::TrainingOptions::pca_solver].
            pub fn set_pca_solver<
                T: std::convert::Into<crate::model::model::pca_solver_option_enums::PcaSolver>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.pca_solver = v.into();
                self
            }

            /// Sets the value of [auto_class_weights][crate::model::model::training_run::TrainingOptions::auto_class_weights].
            pub fn set_auto_class_weights<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::BoolValue>,
            {
                self.auto_class_weights = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [auto_class_weights][crate::model::model::training_run::TrainingOptions::auto_class_weights].
            pub fn set_or_clear_auto_class_weights<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::BoolValue>,
            {
                self.auto_class_weights = v.map(|x| x.into());
                self
            }

            /// Sets the value of [activation_fn][crate::model::model::training_run::TrainingOptions::activation_fn].
            pub fn set_activation_fn<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.activation_fn = v.into();
                self
            }

            /// Sets the value of [optimizer][crate::model::model::training_run::TrainingOptions::optimizer].
            pub fn set_optimizer<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.optimizer = v.into();
                self
            }

            /// Sets the value of [budget_hours][crate::model::model::training_run::TrainingOptions::budget_hours].
            pub fn set_budget_hours<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                self.budget_hours = v.into();
                self
            }

            /// Sets the value of [standardize_features][crate::model::model::training_run::TrainingOptions::standardize_features].
            pub fn set_standardize_features<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::BoolValue>,
            {
                self.standardize_features = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [standardize_features][crate::model::model::training_run::TrainingOptions::standardize_features].
            pub fn set_or_clear_standardize_features<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::BoolValue>,
            {
                self.standardize_features = v.map(|x| x.into());
                self
            }

            /// Sets the value of [l1_reg_activation][crate::model::model::training_run::TrainingOptions::l1_reg_activation].
            pub fn set_l1_reg_activation<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                self.l1_reg_activation = v.into();
                self
            }

            /// Sets the value of [model_registry][crate::model::model::training_run::TrainingOptions::model_registry].
            pub fn set_model_registry<
                T: std::convert::Into<crate::model::model::model_registry_option_enums::ModelRegistry>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.model_registry = v.into();
                self
            }

            /// Sets the value of [vertex_ai_model_version_aliases][crate::model::model::training_run::TrainingOptions::vertex_ai_model_version_aliases].
            pub fn set_vertex_ai_model_version_aliases<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.vertex_ai_model_version_aliases = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [dimension_id_columns][crate::model::model::training_run::TrainingOptions::dimension_id_columns].
            pub fn set_dimension_id_columns<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.dimension_id_columns = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [contribution_metric][crate::model::model::training_run::TrainingOptions::contribution_metric].
            pub fn set_contribution_metric<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.contribution_metric = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [contribution_metric][crate::model::model::training_run::TrainingOptions::contribution_metric].
            pub fn set_or_clear_contribution_metric<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.contribution_metric = v.map(|x| x.into());
                self
            }

            /// Sets the value of [is_test_column][crate::model::model::training_run::TrainingOptions::is_test_column].
            pub fn set_is_test_column<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.is_test_column = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [is_test_column][crate::model::model::training_run::TrainingOptions::is_test_column].
            pub fn set_or_clear_is_test_column<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.is_test_column = v.map(|x| x.into());
                self
            }

            /// Sets the value of [min_apriori_support][crate::model::model::training_run::TrainingOptions::min_apriori_support].
            pub fn set_min_apriori_support<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<f64>,
            {
                self.min_apriori_support = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [min_apriori_support][crate::model::model::training_run::TrainingOptions::min_apriori_support].
            pub fn set_or_clear_min_apriori_support<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<f64>,
            {
                self.min_apriori_support = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for TrainingOptions {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.bigquery.v2.Model.TrainingRun.TrainingOptions"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for TrainingOptions {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __max_iterations,
                    __loss_type,
                    __learn_rate,
                    __l1_regularization,
                    __l2_regularization,
                    __min_relative_progress,
                    __warm_start,
                    __early_stop,
                    __input_label_columns,
                    __data_split_method,
                    __data_split_eval_fraction,
                    __data_split_column,
                    __learn_rate_strategy,
                    __initial_learn_rate,
                    __label_class_weights,
                    __user_column,
                    __item_column,
                    __distance_type,
                    __num_clusters,
                    __model_uri,
                    __optimization_strategy,
                    __hidden_units,
                    __batch_size,
                    __dropout,
                    __max_tree_depth,
                    __subsample,
                    __min_split_loss,
                    __booster_type,
                    __num_parallel_tree,
                    __dart_normalize_type,
                    __tree_method,
                    __min_tree_child_weight,
                    __colsample_bytree,
                    __colsample_bylevel,
                    __colsample_bynode,
                    __num_factors,
                    __feedback_type,
                    __wals_alpha,
                    __kmeans_initialization_method,
                    __kmeans_initialization_column,
                    __time_series_timestamp_column,
                    __time_series_data_column,
                    __auto_arima,
                    __non_seasonal_order,
                    __data_frequency,
                    __calculate_p_values,
                    __include_drift,
                    __holiday_region,
                    __holiday_regions,
                    __time_series_id_column,
                    __time_series_id_columns,
                    __forecast_limit_lower_bound,
                    __forecast_limit_upper_bound,
                    __horizon,
                    __auto_arima_max_order,
                    __auto_arima_min_order,
                    __num_trials,
                    __max_parallel_trials,
                    __hparam_tuning_objectives,
                    __decompose_time_series,
                    __clean_spikes_and_dips,
                    __adjust_step_changes,
                    __enable_global_explain,
                    __sampled_shapley_num_paths,
                    __integrated_gradients_num_steps,
                    __category_encoding_method,
                    __tf_version,
                    __color_space,
                    __instance_weight_column,
                    __trend_smoothing_window_size,
                    __time_series_length_fraction,
                    __min_time_series_length,
                    __max_time_series_length,
                    __xgboost_version,
                    __approx_global_feature_contrib,
                    __fit_intercept,
                    __num_principal_components,
                    __pca_explained_variance_ratio,
                    __scale_features,
                    __pca_solver,
                    __auto_class_weights,
                    __activation_fn,
                    __optimizer,
                    __budget_hours,
                    __standardize_features,
                    __l1_reg_activation,
                    __model_registry,
                    __vertex_ai_model_version_aliases,
                    __dimension_id_columns,
                    __contribution_metric,
                    __is_test_column,
                    __min_apriori_support,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for TrainingOptions")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "maxIterations" => Ok(__FieldTag::__max_iterations),
                                    "max_iterations" => Ok(__FieldTag::__max_iterations),
                                    "lossType" => Ok(__FieldTag::__loss_type),
                                    "loss_type" => Ok(__FieldTag::__loss_type),
                                    "learnRate" => Ok(__FieldTag::__learn_rate),
                                    "learn_rate" => Ok(__FieldTag::__learn_rate),
                                    "l1Regularization" => Ok(__FieldTag::__l1_regularization),
                                    "l1_regularization" => Ok(__FieldTag::__l1_regularization),
                                    "l2Regularization" => Ok(__FieldTag::__l2_regularization),
                                    "l2_regularization" => Ok(__FieldTag::__l2_regularization),
                                    "minRelativeProgress" => {
                                        Ok(__FieldTag::__min_relative_progress)
                                    }
                                    "min_relative_progress" => {
                                        Ok(__FieldTag::__min_relative_progress)
                                    }
                                    "warmStart" => Ok(__FieldTag::__warm_start),
                                    "warm_start" => Ok(__FieldTag::__warm_start),
                                    "earlyStop" => Ok(__FieldTag::__early_stop),
                                    "early_stop" => Ok(__FieldTag::__early_stop),
                                    "inputLabelColumns" => Ok(__FieldTag::__input_label_columns),
                                    "input_label_columns" => Ok(__FieldTag::__input_label_columns),
                                    "dataSplitMethod" => Ok(__FieldTag::__data_split_method),
                                    "data_split_method" => Ok(__FieldTag::__data_split_method),
                                    "dataSplitEvalFraction" => {
                                        Ok(__FieldTag::__data_split_eval_fraction)
                                    }
                                    "data_split_eval_fraction" => {
                                        Ok(__FieldTag::__data_split_eval_fraction)
                                    }
                                    "dataSplitColumn" => Ok(__FieldTag::__data_split_column),
                                    "data_split_column" => Ok(__FieldTag::__data_split_column),
                                    "learnRateStrategy" => Ok(__FieldTag::__learn_rate_strategy),
                                    "learn_rate_strategy" => Ok(__FieldTag::__learn_rate_strategy),
                                    "initialLearnRate" => Ok(__FieldTag::__initial_learn_rate),
                                    "initial_learn_rate" => Ok(__FieldTag::__initial_learn_rate),
                                    "labelClassWeights" => Ok(__FieldTag::__label_class_weights),
                                    "label_class_weights" => Ok(__FieldTag::__label_class_weights),
                                    "userColumn" => Ok(__FieldTag::__user_column),
                                    "user_column" => Ok(__FieldTag::__user_column),
                                    "itemColumn" => Ok(__FieldTag::__item_column),
                                    "item_column" => Ok(__FieldTag::__item_column),
                                    "distanceType" => Ok(__FieldTag::__distance_type),
                                    "distance_type" => Ok(__FieldTag::__distance_type),
                                    "numClusters" => Ok(__FieldTag::__num_clusters),
                                    "num_clusters" => Ok(__FieldTag::__num_clusters),
                                    "modelUri" => Ok(__FieldTag::__model_uri),
                                    "model_uri" => Ok(__FieldTag::__model_uri),
                                    "optimizationStrategy" => {
                                        Ok(__FieldTag::__optimization_strategy)
                                    }
                                    "optimization_strategy" => {
                                        Ok(__FieldTag::__optimization_strategy)
                                    }
                                    "hiddenUnits" => Ok(__FieldTag::__hidden_units),
                                    "hidden_units" => Ok(__FieldTag::__hidden_units),
                                    "batchSize" => Ok(__FieldTag::__batch_size),
                                    "batch_size" => Ok(__FieldTag::__batch_size),
                                    "dropout" => Ok(__FieldTag::__dropout),
                                    "maxTreeDepth" => Ok(__FieldTag::__max_tree_depth),
                                    "max_tree_depth" => Ok(__FieldTag::__max_tree_depth),
                                    "subsample" => Ok(__FieldTag::__subsample),
                                    "minSplitLoss" => Ok(__FieldTag::__min_split_loss),
                                    "min_split_loss" => Ok(__FieldTag::__min_split_loss),
                                    "boosterType" => Ok(__FieldTag::__booster_type),
                                    "booster_type" => Ok(__FieldTag::__booster_type),
                                    "numParallelTree" => Ok(__FieldTag::__num_parallel_tree),
                                    "num_parallel_tree" => Ok(__FieldTag::__num_parallel_tree),
                                    "dartNormalizeType" => Ok(__FieldTag::__dart_normalize_type),
                                    "dart_normalize_type" => Ok(__FieldTag::__dart_normalize_type),
                                    "treeMethod" => Ok(__FieldTag::__tree_method),
                                    "tree_method" => Ok(__FieldTag::__tree_method),
                                    "minTreeChildWeight" => Ok(__FieldTag::__min_tree_child_weight),
                                    "min_tree_child_weight" => {
                                        Ok(__FieldTag::__min_tree_child_weight)
                                    }
                                    "colsampleBytree" => Ok(__FieldTag::__colsample_bytree),
                                    "colsample_bytree" => Ok(__FieldTag::__colsample_bytree),
                                    "colsampleBylevel" => Ok(__FieldTag::__colsample_bylevel),
                                    "colsample_bylevel" => Ok(__FieldTag::__colsample_bylevel),
                                    "colsampleBynode" => Ok(__FieldTag::__colsample_bynode),
                                    "colsample_bynode" => Ok(__FieldTag::__colsample_bynode),
                                    "numFactors" => Ok(__FieldTag::__num_factors),
                                    "num_factors" => Ok(__FieldTag::__num_factors),
                                    "feedbackType" => Ok(__FieldTag::__feedback_type),
                                    "feedback_type" => Ok(__FieldTag::__feedback_type),
                                    "walsAlpha" => Ok(__FieldTag::__wals_alpha),
                                    "wals_alpha" => Ok(__FieldTag::__wals_alpha),
                                    "kmeansInitializationMethod" => {
                                        Ok(__FieldTag::__kmeans_initialization_method)
                                    }
                                    "kmeans_initialization_method" => {
                                        Ok(__FieldTag::__kmeans_initialization_method)
                                    }
                                    "kmeansInitializationColumn" => {
                                        Ok(__FieldTag::__kmeans_initialization_column)
                                    }
                                    "kmeans_initialization_column" => {
                                        Ok(__FieldTag::__kmeans_initialization_column)
                                    }
                                    "timeSeriesTimestampColumn" => {
                                        Ok(__FieldTag::__time_series_timestamp_column)
                                    }
                                    "time_series_timestamp_column" => {
                                        Ok(__FieldTag::__time_series_timestamp_column)
                                    }
                                    "timeSeriesDataColumn" => {
                                        Ok(__FieldTag::__time_series_data_column)
                                    }
                                    "time_series_data_column" => {
                                        Ok(__FieldTag::__time_series_data_column)
                                    }
                                    "autoArima" => Ok(__FieldTag::__auto_arima),
                                    "auto_arima" => Ok(__FieldTag::__auto_arima),
                                    "nonSeasonalOrder" => Ok(__FieldTag::__non_seasonal_order),
                                    "non_seasonal_order" => Ok(__FieldTag::__non_seasonal_order),
                                    "dataFrequency" => Ok(__FieldTag::__data_frequency),
                                    "data_frequency" => Ok(__FieldTag::__data_frequency),
                                    "calculatePValues" => Ok(__FieldTag::__calculate_p_values),
                                    "calculate_p_values" => Ok(__FieldTag::__calculate_p_values),
                                    "includeDrift" => Ok(__FieldTag::__include_drift),
                                    "include_drift" => Ok(__FieldTag::__include_drift),
                                    "holidayRegion" => Ok(__FieldTag::__holiday_region),
                                    "holiday_region" => Ok(__FieldTag::__holiday_region),
                                    "holidayRegions" => Ok(__FieldTag::__holiday_regions),
                                    "holiday_regions" => Ok(__FieldTag::__holiday_regions),
                                    "timeSeriesIdColumn" => Ok(__FieldTag::__time_series_id_column),
                                    "time_series_id_column" => {
                                        Ok(__FieldTag::__time_series_id_column)
                                    }
                                    "timeSeriesIdColumns" => {
                                        Ok(__FieldTag::__time_series_id_columns)
                                    }
                                    "time_series_id_columns" => {
                                        Ok(__FieldTag::__time_series_id_columns)
                                    }
                                    "forecastLimitLowerBound" => {
                                        Ok(__FieldTag::__forecast_limit_lower_bound)
                                    }
                                    "forecast_limit_lower_bound" => {
                                        Ok(__FieldTag::__forecast_limit_lower_bound)
                                    }
                                    "forecastLimitUpperBound" => {
                                        Ok(__FieldTag::__forecast_limit_upper_bound)
                                    }
                                    "forecast_limit_upper_bound" => {
                                        Ok(__FieldTag::__forecast_limit_upper_bound)
                                    }
                                    "horizon" => Ok(__FieldTag::__horizon),
                                    "autoArimaMaxOrder" => Ok(__FieldTag::__auto_arima_max_order),
                                    "auto_arima_max_order" => {
                                        Ok(__FieldTag::__auto_arima_max_order)
                                    }
                                    "autoArimaMinOrder" => Ok(__FieldTag::__auto_arima_min_order),
                                    "auto_arima_min_order" => {
                                        Ok(__FieldTag::__auto_arima_min_order)
                                    }
                                    "numTrials" => Ok(__FieldTag::__num_trials),
                                    "num_trials" => Ok(__FieldTag::__num_trials),
                                    "maxParallelTrials" => Ok(__FieldTag::__max_parallel_trials),
                                    "max_parallel_trials" => Ok(__FieldTag::__max_parallel_trials),
                                    "hparamTuningObjectives" => {
                                        Ok(__FieldTag::__hparam_tuning_objectives)
                                    }
                                    "hparam_tuning_objectives" => {
                                        Ok(__FieldTag::__hparam_tuning_objectives)
                                    }
                                    "decomposeTimeSeries" => {
                                        Ok(__FieldTag::__decompose_time_series)
                                    }
                                    "decompose_time_series" => {
                                        Ok(__FieldTag::__decompose_time_series)
                                    }
                                    "cleanSpikesAndDips" => Ok(__FieldTag::__clean_spikes_and_dips),
                                    "clean_spikes_and_dips" => {
                                        Ok(__FieldTag::__clean_spikes_and_dips)
                                    }
                                    "adjustStepChanges" => Ok(__FieldTag::__adjust_step_changes),
                                    "adjust_step_changes" => Ok(__FieldTag::__adjust_step_changes),
                                    "enableGlobalExplain" => {
                                        Ok(__FieldTag::__enable_global_explain)
                                    }
                                    "enable_global_explain" => {
                                        Ok(__FieldTag::__enable_global_explain)
                                    }
                                    "sampledShapleyNumPaths" => {
                                        Ok(__FieldTag::__sampled_shapley_num_paths)
                                    }
                                    "sampled_shapley_num_paths" => {
                                        Ok(__FieldTag::__sampled_shapley_num_paths)
                                    }
                                    "integratedGradientsNumSteps" => {
                                        Ok(__FieldTag::__integrated_gradients_num_steps)
                                    }
                                    "integrated_gradients_num_steps" => {
                                        Ok(__FieldTag::__integrated_gradients_num_steps)
                                    }
                                    "categoryEncodingMethod" => {
                                        Ok(__FieldTag::__category_encoding_method)
                                    }
                                    "category_encoding_method" => {
                                        Ok(__FieldTag::__category_encoding_method)
                                    }
                                    "tfVersion" => Ok(__FieldTag::__tf_version),
                                    "tf_version" => Ok(__FieldTag::__tf_version),
                                    "colorSpace" => Ok(__FieldTag::__color_space),
                                    "color_space" => Ok(__FieldTag::__color_space),
                                    "instanceWeightColumn" => {
                                        Ok(__FieldTag::__instance_weight_column)
                                    }
                                    "instance_weight_column" => {
                                        Ok(__FieldTag::__instance_weight_column)
                                    }
                                    "trendSmoothingWindowSize" => {
                                        Ok(__FieldTag::__trend_smoothing_window_size)
                                    }
                                    "trend_smoothing_window_size" => {
                                        Ok(__FieldTag::__trend_smoothing_window_size)
                                    }
                                    "timeSeriesLengthFraction" => {
                                        Ok(__FieldTag::__time_series_length_fraction)
                                    }
                                    "time_series_length_fraction" => {
                                        Ok(__FieldTag::__time_series_length_fraction)
                                    }
                                    "minTimeSeriesLength" => {
                                        Ok(__FieldTag::__min_time_series_length)
                                    }
                                    "min_time_series_length" => {
                                        Ok(__FieldTag::__min_time_series_length)
                                    }
                                    "maxTimeSeriesLength" => {
                                        Ok(__FieldTag::__max_time_series_length)
                                    }
                                    "max_time_series_length" => {
                                        Ok(__FieldTag::__max_time_series_length)
                                    }
                                    "xgboostVersion" => Ok(__FieldTag::__xgboost_version),
                                    "xgboost_version" => Ok(__FieldTag::__xgboost_version),
                                    "approxGlobalFeatureContrib" => {
                                        Ok(__FieldTag::__approx_global_feature_contrib)
                                    }
                                    "approx_global_feature_contrib" => {
                                        Ok(__FieldTag::__approx_global_feature_contrib)
                                    }
                                    "fitIntercept" => Ok(__FieldTag::__fit_intercept),
                                    "fit_intercept" => Ok(__FieldTag::__fit_intercept),
                                    "numPrincipalComponents" => {
                                        Ok(__FieldTag::__num_principal_components)
                                    }
                                    "num_principal_components" => {
                                        Ok(__FieldTag::__num_principal_components)
                                    }
                                    "pcaExplainedVarianceRatio" => {
                                        Ok(__FieldTag::__pca_explained_variance_ratio)
                                    }
                                    "pca_explained_variance_ratio" => {
                                        Ok(__FieldTag::__pca_explained_variance_ratio)
                                    }
                                    "scaleFeatures" => Ok(__FieldTag::__scale_features),
                                    "scale_features" => Ok(__FieldTag::__scale_features),
                                    "pcaSolver" => Ok(__FieldTag::__pca_solver),
                                    "pca_solver" => Ok(__FieldTag::__pca_solver),
                                    "autoClassWeights" => Ok(__FieldTag::__auto_class_weights),
                                    "auto_class_weights" => Ok(__FieldTag::__auto_class_weights),
                                    "activationFn" => Ok(__FieldTag::__activation_fn),
                                    "activation_fn" => Ok(__FieldTag::__activation_fn),
                                    "optimizer" => Ok(__FieldTag::__optimizer),
                                    "budgetHours" => Ok(__FieldTag::__budget_hours),
                                    "budget_hours" => Ok(__FieldTag::__budget_hours),
                                    "standardizeFeatures" => Ok(__FieldTag::__standardize_features),
                                    "standardize_features" => {
                                        Ok(__FieldTag::__standardize_features)
                                    }
                                    "l1RegActivation" => Ok(__FieldTag::__l1_reg_activation),
                                    "l1_reg_activation" => Ok(__FieldTag::__l1_reg_activation),
                                    "modelRegistry" => Ok(__FieldTag::__model_registry),
                                    "model_registry" => Ok(__FieldTag::__model_registry),
                                    "vertexAiModelVersionAliases" => {
                                        Ok(__FieldTag::__vertex_ai_model_version_aliases)
                                    }
                                    "vertex_ai_model_version_aliases" => {
                                        Ok(__FieldTag::__vertex_ai_model_version_aliases)
                                    }
                                    "dimensionIdColumns" => Ok(__FieldTag::__dimension_id_columns),
                                    "dimension_id_columns" => {
                                        Ok(__FieldTag::__dimension_id_columns)
                                    }
                                    "contributionMetric" => Ok(__FieldTag::__contribution_metric),
                                    "contribution_metric" => Ok(__FieldTag::__contribution_metric),
                                    "isTestColumn" => Ok(__FieldTag::__is_test_column),
                                    "is_test_column" => Ok(__FieldTag::__is_test_column),
                                    "minAprioriSupport" => Ok(__FieldTag::__min_apriori_support),
                                    "min_apriori_support" => Ok(__FieldTag::__min_apriori_support),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = TrainingOptions;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct TrainingOptions")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__max_iterations => {
                                    if !fields.insert(__FieldTag::__max_iterations) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for max_iterations",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.max_iterations =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__loss_type => {
                                    if !fields.insert(__FieldTag::__loss_type) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for loss_type",
                                            ),
                                        );
                                    }
                                    result.loss_type = map.next_value::<std::option::Option<crate::model::model::LossType>>()?.unwrap_or_default();
                                }
                                __FieldTag::__learn_rate => {
                                    if !fields.insert(__FieldTag::__learn_rate) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for learn_rate",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<f64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.learn_rate =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__l1_regularization => {
                                    if !fields.insert(__FieldTag::__l1_regularization) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for l1_regularization",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<wkt::DoubleValue>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.l1_regularization = map.next_value::<__With>()?.0;
                                }
                                __FieldTag::__l2_regularization => {
                                    if !fields.insert(__FieldTag::__l2_regularization) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for l2_regularization",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<wkt::DoubleValue>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.l2_regularization = map.next_value::<__With>()?.0;
                                }
                                __FieldTag::__min_relative_progress => {
                                    if !fields.insert(__FieldTag::__min_relative_progress) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for min_relative_progress",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<wkt::DoubleValue>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.min_relative_progress = map.next_value::<__With>()?.0;
                                }
                                __FieldTag::__warm_start => {
                                    if !fields.insert(__FieldTag::__warm_start) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for warm_start",
                                            ),
                                        );
                                    }
                                    result.warm_start =
                                        map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                                }
                                __FieldTag::__early_stop => {
                                    if !fields.insert(__FieldTag::__early_stop) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for early_stop",
                                            ),
                                        );
                                    }
                                    result.early_stop =
                                        map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                                }
                                __FieldTag::__input_label_columns => {
                                    if !fields.insert(__FieldTag::__input_label_columns) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for input_label_columns",
                                            ),
                                        );
                                    }
                                    result.input_label_columns = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::__data_split_method => {
                                    if !fields.insert(__FieldTag::__data_split_method) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for data_split_method",
                                            ),
                                        );
                                    }
                                    result.data_split_method =
                                        map.next_value::<std::option::Option<
                                            crate::model::model::DataSplitMethod,
                                        >>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__data_split_eval_fraction => {
                                    if !fields.insert(__FieldTag::__data_split_eval_fraction) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for data_split_eval_fraction",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<f64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.data_split_eval_fraction =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__data_split_column => {
                                    if !fields.insert(__FieldTag::__data_split_column) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for data_split_column",
                                            ),
                                        );
                                    }
                                    result.data_split_column = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__learn_rate_strategy => {
                                    if !fields.insert(__FieldTag::__learn_rate_strategy) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for learn_rate_strategy",
                                            ),
                                        );
                                    }
                                    result.learn_rate_strategy =
                                        map.next_value::<std::option::Option<
                                            crate::model::model::LearnRateStrategy,
                                        >>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__initial_learn_rate => {
                                    if !fields.insert(__FieldTag::__initial_learn_rate) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for initial_learn_rate",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<f64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.initial_learn_rate =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__label_class_weights => {
                                    if !fields.insert(__FieldTag::__label_class_weights) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for label_class_weights",
                                            ),
                                        );
                                    }
                                    struct __With(
                                        std::option::Option<
                                            std::collections::HashMap<std::string::String, f64>,
                                        >,
                                    );
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::<
                                                std::option::Option<
                                                    std::collections::HashMap<
                                                        serde_with::Same,
                                                        wkt::internal::F64,
                                                    >,
                                                >,
                                            >::deserialize(
                                                deserializer
                                            )
                                            .map(__With)
                                        }
                                    }
                                    result.label_class_weights =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__user_column => {
                                    if !fields.insert(__FieldTag::__user_column) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for user_column",
                                            ),
                                        );
                                    }
                                    result.user_column = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__item_column => {
                                    if !fields.insert(__FieldTag::__item_column) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for item_column",
                                            ),
                                        );
                                    }
                                    result.item_column = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__distance_type => {
                                    if !fields.insert(__FieldTag::__distance_type) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for distance_type",
                                            ),
                                        );
                                    }
                                    result.distance_type = map.next_value::<std::option::Option<crate::model::model::DistanceType>>()?.unwrap_or_default();
                                }
                                __FieldTag::__num_clusters => {
                                    if !fields.insert(__FieldTag::__num_clusters) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for num_clusters",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.num_clusters =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__model_uri => {
                                    if !fields.insert(__FieldTag::__model_uri) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for model_uri",
                                            ),
                                        );
                                    }
                                    result.model_uri = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__optimization_strategy => {
                                    if !fields.insert(__FieldTag::__optimization_strategy) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for optimization_strategy",
                                            ),
                                        );
                                    }
                                    result.optimization_strategy = map
                                        .next_value::<std::option::Option<
                                            crate::model::model::OptimizationStrategy,
                                        >>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__hidden_units => {
                                    if !fields.insert(__FieldTag::__hidden_units) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for hidden_units",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<std::vec::Vec<i64>>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::<
                                                std::option::Option<
                                                    std::vec::Vec<wkt::internal::I64>,
                                                >,
                                            >::deserialize(
                                                deserializer
                                            )
                                            .map(__With)
                                        }
                                    }
                                    result.hidden_units =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__batch_size => {
                                    if !fields.insert(__FieldTag::__batch_size) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for batch_size",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.batch_size =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__dropout => {
                                    if !fields.insert(__FieldTag::__dropout) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for dropout",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<wkt::DoubleValue>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.dropout = map.next_value::<__With>()?.0;
                                }
                                __FieldTag::__max_tree_depth => {
                                    if !fields.insert(__FieldTag::__max_tree_depth) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for max_tree_depth",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.max_tree_depth =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__subsample => {
                                    if !fields.insert(__FieldTag::__subsample) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for subsample",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<f64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.subsample =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__min_split_loss => {
                                    if !fields.insert(__FieldTag::__min_split_loss) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for min_split_loss",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<wkt::DoubleValue>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.min_split_loss = map.next_value::<__With>()?.0;
                                }
                                __FieldTag::__booster_type => {
                                    if !fields.insert(__FieldTag::__booster_type) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for booster_type",
                                            ),
                                        );
                                    }
                                    result.booster_type = map.next_value::<std::option::Option<crate::model::model::boosted_tree_option_enums::BoosterType>>()?.unwrap_or_default();
                                }
                                __FieldTag::__num_parallel_tree => {
                                    if !fields.insert(__FieldTag::__num_parallel_tree) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for num_parallel_tree",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<wkt::Int64Value>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.num_parallel_tree = map.next_value::<__With>()?.0;
                                }
                                __FieldTag::__dart_normalize_type => {
                                    if !fields.insert(__FieldTag::__dart_normalize_type) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for dart_normalize_type",
                                            ),
                                        );
                                    }
                                    result.dart_normalize_type = map.next_value::<std::option::Option<crate::model::model::boosted_tree_option_enums::DartNormalizeType>>()?.unwrap_or_default();
                                }
                                __FieldTag::__tree_method => {
                                    if !fields.insert(__FieldTag::__tree_method) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for tree_method",
                                            ),
                                        );
                                    }
                                    result.tree_method = map.next_value::<std::option::Option<crate::model::model::boosted_tree_option_enums::TreeMethod>>()?.unwrap_or_default();
                                }
                                __FieldTag::__min_tree_child_weight => {
                                    if !fields.insert(__FieldTag::__min_tree_child_weight) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for min_tree_child_weight",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<wkt::Int64Value>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.min_tree_child_weight = map.next_value::<__With>()?.0;
                                }
                                __FieldTag::__colsample_bytree => {
                                    if !fields.insert(__FieldTag::__colsample_bytree) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for colsample_bytree",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<wkt::DoubleValue>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.colsample_bytree = map.next_value::<__With>()?.0;
                                }
                                __FieldTag::__colsample_bylevel => {
                                    if !fields.insert(__FieldTag::__colsample_bylevel) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for colsample_bylevel",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<wkt::DoubleValue>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.colsample_bylevel = map.next_value::<__With>()?.0;
                                }
                                __FieldTag::__colsample_bynode => {
                                    if !fields.insert(__FieldTag::__colsample_bynode) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for colsample_bynode",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<wkt::DoubleValue>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.colsample_bynode = map.next_value::<__With>()?.0;
                                }
                                __FieldTag::__num_factors => {
                                    if !fields.insert(__FieldTag::__num_factors) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for num_factors",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.num_factors =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__feedback_type => {
                                    if !fields.insert(__FieldTag::__feedback_type) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for feedback_type",
                                            ),
                                        );
                                    }
                                    result.feedback_type = map.next_value::<std::option::Option<crate::model::model::FeedbackType>>()?.unwrap_or_default();
                                }
                                __FieldTag::__wals_alpha => {
                                    if !fields.insert(__FieldTag::__wals_alpha) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for wals_alpha",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<wkt::DoubleValue>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.wals_alpha = map.next_value::<__With>()?.0;
                                }
                                __FieldTag::__kmeans_initialization_method => {
                                    if !fields.insert(__FieldTag::__kmeans_initialization_method) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for kmeans_initialization_method",
                                            ),
                                        );
                                    }
                                    result.kmeans_initialization_method = map.next_value::<std::option::Option<crate::model::model::kmeans_enums::KmeansInitializationMethod>>()?.unwrap_or_default();
                                }
                                __FieldTag::__kmeans_initialization_column => {
                                    if !fields.insert(__FieldTag::__kmeans_initialization_column) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for kmeans_initialization_column",
                                            ),
                                        );
                                    }
                                    result.kmeans_initialization_column = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__time_series_timestamp_column => {
                                    if !fields.insert(__FieldTag::__time_series_timestamp_column) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for time_series_timestamp_column",
                                            ),
                                        );
                                    }
                                    result.time_series_timestamp_column = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__time_series_data_column => {
                                    if !fields.insert(__FieldTag::__time_series_data_column) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for time_series_data_column",
                                            ),
                                        );
                                    }
                                    result.time_series_data_column = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__auto_arima => {
                                    if !fields.insert(__FieldTag::__auto_arima) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for auto_arima",
                                            ),
                                        );
                                    }
                                    result.auto_arima =
                                        map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                                }
                                __FieldTag::__non_seasonal_order => {
                                    if !fields.insert(__FieldTag::__non_seasonal_order) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for non_seasonal_order",
                                            ),
                                        );
                                    }
                                    result.non_seasonal_order = map.next_value::<std::option::Option<crate::model::model::ArimaOrder>>()?
                                        ;
                                }
                                __FieldTag::__data_frequency => {
                                    if !fields.insert(__FieldTag::__data_frequency) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for data_frequency",
                                            ),
                                        );
                                    }
                                    result.data_frequency = map.next_value::<std::option::Option<crate::model::model::DataFrequency>>()?.unwrap_or_default();
                                }
                                __FieldTag::__calculate_p_values => {
                                    if !fields.insert(__FieldTag::__calculate_p_values) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for calculate_p_values",
                                            ),
                                        );
                                    }
                                    result.calculate_p_values =
                                        map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                                }
                                __FieldTag::__include_drift => {
                                    if !fields.insert(__FieldTag::__include_drift) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for include_drift",
                                            ),
                                        );
                                    }
                                    result.include_drift =
                                        map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                                }
                                __FieldTag::__holiday_region => {
                                    if !fields.insert(__FieldTag::__holiday_region) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for holiday_region",
                                            ),
                                        );
                                    }
                                    result.holiday_region = map.next_value::<std::option::Option<crate::model::model::HolidayRegion>>()?.unwrap_or_default();
                                }
                                __FieldTag::__holiday_regions => {
                                    if !fields.insert(__FieldTag::__holiday_regions) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for holiday_regions",
                                            ),
                                        );
                                    }
                                    result.holiday_regions = map
                                        .next_value::<std::option::Option<
                                            std::vec::Vec<crate::model::model::HolidayRegion>,
                                        >>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__time_series_id_column => {
                                    if !fields.insert(__FieldTag::__time_series_id_column) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for time_series_id_column",
                                            ),
                                        );
                                    }
                                    result.time_series_id_column = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__time_series_id_columns => {
                                    if !fields.insert(__FieldTag::__time_series_id_columns) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for time_series_id_columns",
                                            ),
                                        );
                                    }
                                    result.time_series_id_columns = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::__forecast_limit_lower_bound => {
                                    if !fields.insert(__FieldTag::__forecast_limit_lower_bound) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for forecast_limit_lower_bound",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<f64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.forecast_limit_lower_bound =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__forecast_limit_upper_bound => {
                                    if !fields.insert(__FieldTag::__forecast_limit_upper_bound) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for forecast_limit_upper_bound",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<f64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.forecast_limit_upper_bound =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__horizon => {
                                    if !fields.insert(__FieldTag::__horizon) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for horizon",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.horizon =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__auto_arima_max_order => {
                                    if !fields.insert(__FieldTag::__auto_arima_max_order) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for auto_arima_max_order",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.auto_arima_max_order =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__auto_arima_min_order => {
                                    if !fields.insert(__FieldTag::__auto_arima_min_order) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for auto_arima_min_order",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.auto_arima_min_order =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__num_trials => {
                                    if !fields.insert(__FieldTag::__num_trials) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for num_trials",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.num_trials =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__max_parallel_trials => {
                                    if !fields.insert(__FieldTag::__max_parallel_trials) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for max_parallel_trials",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.max_parallel_trials =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__hparam_tuning_objectives => {
                                    if !fields.insert(__FieldTag::__hparam_tuning_objectives) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for hparam_tuning_objectives",
                                            ),
                                        );
                                    }
                                    result.hparam_tuning_objectives = map.next_value::<std::option::Option<std::vec::Vec<crate::model::model::hparam_tuning_enums::HparamTuningObjective>>>()?.unwrap_or_default();
                                }
                                __FieldTag::__decompose_time_series => {
                                    if !fields.insert(__FieldTag::__decompose_time_series) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for decompose_time_series",
                                            ),
                                        );
                                    }
                                    result.decompose_time_series =
                                        map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                                }
                                __FieldTag::__clean_spikes_and_dips => {
                                    if !fields.insert(__FieldTag::__clean_spikes_and_dips) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for clean_spikes_and_dips",
                                            ),
                                        );
                                    }
                                    result.clean_spikes_and_dips =
                                        map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                                }
                                __FieldTag::__adjust_step_changes => {
                                    if !fields.insert(__FieldTag::__adjust_step_changes) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for adjust_step_changes",
                                            ),
                                        );
                                    }
                                    result.adjust_step_changes =
                                        map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                                }
                                __FieldTag::__enable_global_explain => {
                                    if !fields.insert(__FieldTag::__enable_global_explain) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for enable_global_explain",
                                            ),
                                        );
                                    }
                                    result.enable_global_explain =
                                        map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                                }
                                __FieldTag::__sampled_shapley_num_paths => {
                                    if !fields.insert(__FieldTag::__sampled_shapley_num_paths) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for sampled_shapley_num_paths",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.sampled_shapley_num_paths =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__integrated_gradients_num_steps => {
                                    if !fields.insert(__FieldTag::__integrated_gradients_num_steps)
                                    {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for integrated_gradients_num_steps",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.integrated_gradients_num_steps =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__category_encoding_method => {
                                    if !fields.insert(__FieldTag::__category_encoding_method) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for category_encoding_method",
                                            ),
                                        );
                                    }
                                    result.category_encoding_method = map.next_value::<std::option::Option<crate::model::model::category_encoding_method::EncodingMethod>>()?.unwrap_or_default();
                                }
                                __FieldTag::__tf_version => {
                                    if !fields.insert(__FieldTag::__tf_version) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for tf_version",
                                            ),
                                        );
                                    }
                                    result.tf_version = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__color_space => {
                                    if !fields.insert(__FieldTag::__color_space) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for color_space",
                                            ),
                                        );
                                    }
                                    result.color_space = map.next_value::<std::option::Option<crate::model::model::ColorSpace>>()?.unwrap_or_default();
                                }
                                __FieldTag::__instance_weight_column => {
                                    if !fields.insert(__FieldTag::__instance_weight_column) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for instance_weight_column",
                                            ),
                                        );
                                    }
                                    result.instance_weight_column = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__trend_smoothing_window_size => {
                                    if !fields.insert(__FieldTag::__trend_smoothing_window_size) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for trend_smoothing_window_size",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.trend_smoothing_window_size =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__time_series_length_fraction => {
                                    if !fields.insert(__FieldTag::__time_series_length_fraction) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for time_series_length_fraction",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<f64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.time_series_length_fraction =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__min_time_series_length => {
                                    if !fields.insert(__FieldTag::__min_time_series_length) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for min_time_series_length",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.min_time_series_length =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__max_time_series_length => {
                                    if !fields.insert(__FieldTag::__max_time_series_length) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for max_time_series_length",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.max_time_series_length =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__xgboost_version => {
                                    if !fields.insert(__FieldTag::__xgboost_version) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for xgboost_version",
                                            ),
                                        );
                                    }
                                    result.xgboost_version = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__approx_global_feature_contrib => {
                                    if !fields.insert(__FieldTag::__approx_global_feature_contrib) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for approx_global_feature_contrib",
                                            ),
                                        );
                                    }
                                    result.approx_global_feature_contrib =
                                        map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                                }
                                __FieldTag::__fit_intercept => {
                                    if !fields.insert(__FieldTag::__fit_intercept) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for fit_intercept",
                                            ),
                                        );
                                    }
                                    result.fit_intercept =
                                        map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                                }
                                __FieldTag::__num_principal_components => {
                                    if !fields.insert(__FieldTag::__num_principal_components) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for num_principal_components",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.num_principal_components =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__pca_explained_variance_ratio => {
                                    if !fields.insert(__FieldTag::__pca_explained_variance_ratio) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for pca_explained_variance_ratio",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<f64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.pca_explained_variance_ratio =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__scale_features => {
                                    if !fields.insert(__FieldTag::__scale_features) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for scale_features",
                                            ),
                                        );
                                    }
                                    result.scale_features =
                                        map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                                }
                                __FieldTag::__pca_solver => {
                                    if !fields.insert(__FieldTag::__pca_solver) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for pca_solver",
                                            ),
                                        );
                                    }
                                    result.pca_solver = map
                                        .next_value::<std::option::Option<
                                            crate::model::model::pca_solver_option_enums::PcaSolver,
                                        >>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__auto_class_weights => {
                                    if !fields.insert(__FieldTag::__auto_class_weights) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for auto_class_weights",
                                            ),
                                        );
                                    }
                                    result.auto_class_weights =
                                        map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                                }
                                __FieldTag::__activation_fn => {
                                    if !fields.insert(__FieldTag::__activation_fn) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for activation_fn",
                                            ),
                                        );
                                    }
                                    result.activation_fn = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__optimizer => {
                                    if !fields.insert(__FieldTag::__optimizer) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for optimizer",
                                            ),
                                        );
                                    }
                                    result.optimizer = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__budget_hours => {
                                    if !fields.insert(__FieldTag::__budget_hours) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for budget_hours",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<f64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.budget_hours =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__standardize_features => {
                                    if !fields.insert(__FieldTag::__standardize_features) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for standardize_features",
                                            ),
                                        );
                                    }
                                    result.standardize_features =
                                        map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                                }
                                __FieldTag::__l1_reg_activation => {
                                    if !fields.insert(__FieldTag::__l1_reg_activation) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for l1_reg_activation",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<f64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.l1_reg_activation =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__model_registry => {
                                    if !fields.insert(__FieldTag::__model_registry) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for model_registry",
                                            ),
                                        );
                                    }
                                    result.model_registry = map.next_value::<std::option::Option<crate::model::model::model_registry_option_enums::ModelRegistry>>()?.unwrap_or_default();
                                }
                                __FieldTag::__vertex_ai_model_version_aliases => {
                                    if !fields.insert(__FieldTag::__vertex_ai_model_version_aliases)
                                    {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for vertex_ai_model_version_aliases",
                                            ),
                                        );
                                    }
                                    result.vertex_ai_model_version_aliases = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::__dimension_id_columns => {
                                    if !fields.insert(__FieldTag::__dimension_id_columns) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for dimension_id_columns",
                                            ),
                                        );
                                    }
                                    result.dimension_id_columns = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::__contribution_metric => {
                                    if !fields.insert(__FieldTag::__contribution_metric) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for contribution_metric",
                                            ),
                                        );
                                    }
                                    result.contribution_metric = map
                                        .next_value::<std::option::Option<std::string::String>>()?;
                                }
                                __FieldTag::__is_test_column => {
                                    if !fields.insert(__FieldTag::__is_test_column) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for is_test_column",
                                            ),
                                        );
                                    }
                                    result.is_test_column = map
                                        .next_value::<std::option::Option<std::string::String>>()?;
                                }
                                __FieldTag::__min_apriori_support => {
                                    if !fields.insert(__FieldTag::__min_apriori_support) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for min_apriori_support",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<f64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.min_apriori_support = map.next_value::<__With>()?.0;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for TrainingOptions {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.max_iterations) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("maxIterations", &__With(&self.max_iterations))?;
                }
                if !wkt::internal::is_default(&self.loss_type) {
                    state.serialize_entry("lossType", &self.loss_type)?;
                }
                if !wkt::internal::is_default(&self.learn_rate) {
                    struct __With<'a>(&'a f64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("learnRate", &__With(&self.learn_rate))?;
                }
                if self.l1_regularization.is_some() {
                    struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                                self.0, serializer,
                            )
                        }
                    }
                    state.serialize_entry("l1Regularization", &__With(&self.l1_regularization))?;
                }
                if self.l2_regularization.is_some() {
                    struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                                self.0, serializer,
                            )
                        }
                    }
                    state.serialize_entry("l2Regularization", &__With(&self.l2_regularization))?;
                }
                if self.min_relative_progress.is_some() {
                    struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                                self.0, serializer,
                            )
                        }
                    }
                    state.serialize_entry(
                        "minRelativeProgress",
                        &__With(&self.min_relative_progress),
                    )?;
                }
                if self.warm_start.is_some() {
                    state.serialize_entry("warmStart", &self.warm_start)?;
                }
                if self.early_stop.is_some() {
                    state.serialize_entry("earlyStop", &self.early_stop)?;
                }
                if !self.input_label_columns.is_empty() {
                    state.serialize_entry("inputLabelColumns", &self.input_label_columns)?;
                }
                if !wkt::internal::is_default(&self.data_split_method) {
                    state.serialize_entry("dataSplitMethod", &self.data_split_method)?;
                }
                if !wkt::internal::is_default(&self.data_split_eval_fraction) {
                    struct __With<'a>(&'a f64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry(
                        "dataSplitEvalFraction",
                        &__With(&self.data_split_eval_fraction),
                    )?;
                }
                if !self.data_split_column.is_empty() {
                    state.serialize_entry("dataSplitColumn", &self.data_split_column)?;
                }
                if !wkt::internal::is_default(&self.learn_rate_strategy) {
                    state.serialize_entry("learnRateStrategy", &self.learn_rate_strategy)?;
                }
                if !wkt::internal::is_default(&self.initial_learn_rate) {
                    struct __With<'a>(&'a f64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("initialLearnRate", &__With(&self.initial_learn_rate))?;
                }
                if !self.label_class_weights.is_empty() {
                    struct __With<'a>(&'a std::collections::HashMap<std::string::String, f64>);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<
                                std::collections::HashMap<serde_with::Same, wkt::internal::F64>,
                            >::serialize(self.0, serializer)
                        }
                    }
                    state
                        .serialize_entry("labelClassWeights", &__With(&self.label_class_weights))?;
                }
                if !self.user_column.is_empty() {
                    state.serialize_entry("userColumn", &self.user_column)?;
                }
                if !self.item_column.is_empty() {
                    state.serialize_entry("itemColumn", &self.item_column)?;
                }
                if !wkt::internal::is_default(&self.distance_type) {
                    state.serialize_entry("distanceType", &self.distance_type)?;
                }
                if !wkt::internal::is_default(&self.num_clusters) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("numClusters", &__With(&self.num_clusters))?;
                }
                if !self.model_uri.is_empty() {
                    state.serialize_entry("modelUri", &self.model_uri)?;
                }
                if !wkt::internal::is_default(&self.optimization_strategy) {
                    state.serialize_entry("optimizationStrategy", &self.optimization_strategy)?;
                }
                if !self.hidden_units.is_empty() {
                    struct __With<'a>(&'a std::vec::Vec<i64>);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<std::vec::Vec<wkt::internal::I64>>::serialize(
                                self.0, serializer,
                            )
                        }
                    }
                    state.serialize_entry("hiddenUnits", &__With(&self.hidden_units))?;
                }
                if !wkt::internal::is_default(&self.batch_size) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("batchSize", &__With(&self.batch_size))?;
                }
                if self.dropout.is_some() {
                    struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                                self.0, serializer,
                            )
                        }
                    }
                    state.serialize_entry("dropout", &__With(&self.dropout))?;
                }
                if !wkt::internal::is_default(&self.max_tree_depth) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("maxTreeDepth", &__With(&self.max_tree_depth))?;
                }
                if !wkt::internal::is_default(&self.subsample) {
                    struct __With<'a>(&'a f64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("subsample", &__With(&self.subsample))?;
                }
                if self.min_split_loss.is_some() {
                    struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                                self.0, serializer,
                            )
                        }
                    }
                    state.serialize_entry("minSplitLoss", &__With(&self.min_split_loss))?;
                }
                if !wkt::internal::is_default(&self.booster_type) {
                    state.serialize_entry("boosterType", &self.booster_type)?;
                }
                if self.num_parallel_tree.is_some() {
                    struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                                self.0, serializer,
                            )
                        }
                    }
                    state.serialize_entry("numParallelTree", &__With(&self.num_parallel_tree))?;
                }
                if !wkt::internal::is_default(&self.dart_normalize_type) {
                    state.serialize_entry("dartNormalizeType", &self.dart_normalize_type)?;
                }
                if !wkt::internal::is_default(&self.tree_method) {
                    state.serialize_entry("treeMethod", &self.tree_method)?;
                }
                if self.min_tree_child_weight.is_some() {
                    struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                                self.0, serializer,
                            )
                        }
                    }
                    state.serialize_entry(
                        "minTreeChildWeight",
                        &__With(&self.min_tree_child_weight),
                    )?;
                }
                if self.colsample_bytree.is_some() {
                    struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                                self.0, serializer,
                            )
                        }
                    }
                    state.serialize_entry("colsampleBytree", &__With(&self.colsample_bytree))?;
                }
                if self.colsample_bylevel.is_some() {
                    struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                                self.0, serializer,
                            )
                        }
                    }
                    state.serialize_entry("colsampleBylevel", &__With(&self.colsample_bylevel))?;
                }
                if self.colsample_bynode.is_some() {
                    struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                                self.0, serializer,
                            )
                        }
                    }
                    state.serialize_entry("colsampleBynode", &__With(&self.colsample_bynode))?;
                }
                if !wkt::internal::is_default(&self.num_factors) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("numFactors", &__With(&self.num_factors))?;
                }
                if !wkt::internal::is_default(&self.feedback_type) {
                    state.serialize_entry("feedbackType", &self.feedback_type)?;
                }
                if self.wals_alpha.is_some() {
                    struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                                self.0, serializer,
                            )
                        }
                    }
                    state.serialize_entry("walsAlpha", &__With(&self.wals_alpha))?;
                }
                if !wkt::internal::is_default(&self.kmeans_initialization_method) {
                    state.serialize_entry(
                        "kmeansInitializationMethod",
                        &self.kmeans_initialization_method,
                    )?;
                }
                if !self.kmeans_initialization_column.is_empty() {
                    state.serialize_entry(
                        "kmeansInitializationColumn",
                        &self.kmeans_initialization_column,
                    )?;
                }
                if !self.time_series_timestamp_column.is_empty() {
                    state.serialize_entry(
                        "timeSeriesTimestampColumn",
                        &self.time_series_timestamp_column,
                    )?;
                }
                if !self.time_series_data_column.is_empty() {
                    state.serialize_entry("timeSeriesDataColumn", &self.time_series_data_column)?;
                }
                if self.auto_arima.is_some() {
                    state.serialize_entry("autoArima", &self.auto_arima)?;
                }
                if self.non_seasonal_order.is_some() {
                    state.serialize_entry("nonSeasonalOrder", &self.non_seasonal_order)?;
                }
                if !wkt::internal::is_default(&self.data_frequency) {
                    state.serialize_entry("dataFrequency", &self.data_frequency)?;
                }
                if self.calculate_p_values.is_some() {
                    state.serialize_entry("calculatePValues", &self.calculate_p_values)?;
                }
                if self.include_drift.is_some() {
                    state.serialize_entry("includeDrift", &self.include_drift)?;
                }
                if !wkt::internal::is_default(&self.holiday_region) {
                    state.serialize_entry("holidayRegion", &self.holiday_region)?;
                }
                if !self.holiday_regions.is_empty() {
                    state.serialize_entry("holidayRegions", &self.holiday_regions)?;
                }
                if !self.time_series_id_column.is_empty() {
                    state.serialize_entry("timeSeriesIdColumn", &self.time_series_id_column)?;
                }
                if !self.time_series_id_columns.is_empty() {
                    state.serialize_entry("timeSeriesIdColumns", &self.time_series_id_columns)?;
                }
                if !wkt::internal::is_default(&self.forecast_limit_lower_bound) {
                    struct __With<'a>(&'a f64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry(
                        "forecastLimitLowerBound",
                        &__With(&self.forecast_limit_lower_bound),
                    )?;
                }
                if !wkt::internal::is_default(&self.forecast_limit_upper_bound) {
                    struct __With<'a>(&'a f64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry(
                        "forecastLimitUpperBound",
                        &__With(&self.forecast_limit_upper_bound),
                    )?;
                }
                if !wkt::internal::is_default(&self.horizon) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("horizon", &__With(&self.horizon))?;
                }
                if !wkt::internal::is_default(&self.auto_arima_max_order) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry(
                        "autoArimaMaxOrder",
                        &__With(&self.auto_arima_max_order),
                    )?;
                }
                if !wkt::internal::is_default(&self.auto_arima_min_order) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry(
                        "autoArimaMinOrder",
                        &__With(&self.auto_arima_min_order),
                    )?;
                }
                if !wkt::internal::is_default(&self.num_trials) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("numTrials", &__With(&self.num_trials))?;
                }
                if !wkt::internal::is_default(&self.max_parallel_trials) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state
                        .serialize_entry("maxParallelTrials", &__With(&self.max_parallel_trials))?;
                }
                if !self.hparam_tuning_objectives.is_empty() {
                    state.serialize_entry(
                        "hparamTuningObjectives",
                        &self.hparam_tuning_objectives,
                    )?;
                }
                if self.decompose_time_series.is_some() {
                    state.serialize_entry("decomposeTimeSeries", &self.decompose_time_series)?;
                }
                if self.clean_spikes_and_dips.is_some() {
                    state.serialize_entry("cleanSpikesAndDips", &self.clean_spikes_and_dips)?;
                }
                if self.adjust_step_changes.is_some() {
                    state.serialize_entry("adjustStepChanges", &self.adjust_step_changes)?;
                }
                if self.enable_global_explain.is_some() {
                    state.serialize_entry("enableGlobalExplain", &self.enable_global_explain)?;
                }
                if !wkt::internal::is_default(&self.sampled_shapley_num_paths) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry(
                        "sampledShapleyNumPaths",
                        &__With(&self.sampled_shapley_num_paths),
                    )?;
                }
                if !wkt::internal::is_default(&self.integrated_gradients_num_steps) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry(
                        "integratedGradientsNumSteps",
                        &__With(&self.integrated_gradients_num_steps),
                    )?;
                }
                if !wkt::internal::is_default(&self.category_encoding_method) {
                    state.serialize_entry(
                        "categoryEncodingMethod",
                        &self.category_encoding_method,
                    )?;
                }
                if !self.tf_version.is_empty() {
                    state.serialize_entry("tfVersion", &self.tf_version)?;
                }
                if !wkt::internal::is_default(&self.color_space) {
                    state.serialize_entry("colorSpace", &self.color_space)?;
                }
                if !self.instance_weight_column.is_empty() {
                    state.serialize_entry("instanceWeightColumn", &self.instance_weight_column)?;
                }
                if !wkt::internal::is_default(&self.trend_smoothing_window_size) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry(
                        "trendSmoothingWindowSize",
                        &__With(&self.trend_smoothing_window_size),
                    )?;
                }
                if !wkt::internal::is_default(&self.time_series_length_fraction) {
                    struct __With<'a>(&'a f64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry(
                        "timeSeriesLengthFraction",
                        &__With(&self.time_series_length_fraction),
                    )?;
                }
                if !wkt::internal::is_default(&self.min_time_series_length) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry(
                        "minTimeSeriesLength",
                        &__With(&self.min_time_series_length),
                    )?;
                }
                if !wkt::internal::is_default(&self.max_time_series_length) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry(
                        "maxTimeSeriesLength",
                        &__With(&self.max_time_series_length),
                    )?;
                }
                if !self.xgboost_version.is_empty() {
                    state.serialize_entry("xgboostVersion", &self.xgboost_version)?;
                }
                if self.approx_global_feature_contrib.is_some() {
                    state.serialize_entry(
                        "approxGlobalFeatureContrib",
                        &self.approx_global_feature_contrib,
                    )?;
                }
                if self.fit_intercept.is_some() {
                    state.serialize_entry("fitIntercept", &self.fit_intercept)?;
                }
                if !wkt::internal::is_default(&self.num_principal_components) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry(
                        "numPrincipalComponents",
                        &__With(&self.num_principal_components),
                    )?;
                }
                if !wkt::internal::is_default(&self.pca_explained_variance_ratio) {
                    struct __With<'a>(&'a f64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry(
                        "pcaExplainedVarianceRatio",
                        &__With(&self.pca_explained_variance_ratio),
                    )?;
                }
                if self.scale_features.is_some() {
                    state.serialize_entry("scaleFeatures", &self.scale_features)?;
                }
                if !wkt::internal::is_default(&self.pca_solver) {
                    state.serialize_entry("pcaSolver", &self.pca_solver)?;
                }
                if self.auto_class_weights.is_some() {
                    state.serialize_entry("autoClassWeights", &self.auto_class_weights)?;
                }
                if !self.activation_fn.is_empty() {
                    state.serialize_entry("activationFn", &self.activation_fn)?;
                }
                if !self.optimizer.is_empty() {
                    state.serialize_entry("optimizer", &self.optimizer)?;
                }
                if !wkt::internal::is_default(&self.budget_hours) {
                    struct __With<'a>(&'a f64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("budgetHours", &__With(&self.budget_hours))?;
                }
                if self.standardize_features.is_some() {
                    state.serialize_entry("standardizeFeatures", &self.standardize_features)?;
                }
                if !wkt::internal::is_default(&self.l1_reg_activation) {
                    struct __With<'a>(&'a f64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("l1RegActivation", &__With(&self.l1_reg_activation))?;
                }
                if !wkt::internal::is_default(&self.model_registry) {
                    state.serialize_entry("modelRegistry", &self.model_registry)?;
                }
                if !self.vertex_ai_model_version_aliases.is_empty() {
                    state.serialize_entry(
                        "vertexAiModelVersionAliases",
                        &self.vertex_ai_model_version_aliases,
                    )?;
                }
                if !self.dimension_id_columns.is_empty() {
                    state.serialize_entry("dimensionIdColumns", &self.dimension_id_columns)?;
                }
                if self.contribution_metric.is_some() {
                    state.serialize_entry("contributionMetric", &self.contribution_metric)?;
                }
                if self.is_test_column.is_some() {
                    state.serialize_entry("isTestColumn", &self.is_test_column)?;
                }
                if self.min_apriori_support.is_some() {
                    struct __With<'a>(&'a std::option::Option<f64>);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                                self.0, serializer,
                            )
                        }
                    }
                    state
                        .serialize_entry("minAprioriSupport", &__With(&self.min_apriori_support))?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Information about a single iteration of the training run.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct IterationResult {
            /// Index of the iteration, 0 based.
            pub index: std::option::Option<wkt::Int32Value>,

            /// Time taken to run the iteration in milliseconds.
            pub duration_ms: std::option::Option<wkt::Int64Value>,

            /// Loss computed on the training data at the end of iteration.
            pub training_loss: std::option::Option<wkt::DoubleValue>,

            /// Loss computed on the eval data at the end of iteration.
            pub eval_loss: std::option::Option<wkt::DoubleValue>,

            /// Learn rate used for this iteration.
            pub learn_rate: f64,

            /// Information about top clusters for clustering models.
            pub cluster_infos:
                std::vec::Vec<crate::model::model::training_run::iteration_result::ClusterInfo>,

            /// Arima result.
            pub arima_result: std::option::Option<
                crate::model::model::training_run::iteration_result::ArimaResult,
            >,

            /// The information of the principal components.
            pub principal_component_infos: std::vec::Vec<
                crate::model::model::training_run::iteration_result::PrincipalComponentInfo,
            >,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl IterationResult {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [index][crate::model::model::training_run::IterationResult::index].
            pub fn set_index<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::Int32Value>,
            {
                self.index = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [index][crate::model::model::training_run::IterationResult::index].
            pub fn set_or_clear_index<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::Int32Value>,
            {
                self.index = v.map(|x| x.into());
                self
            }

            /// Sets the value of [duration_ms][crate::model::model::training_run::IterationResult::duration_ms].
            pub fn set_duration_ms<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::Int64Value>,
            {
                self.duration_ms = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [duration_ms][crate::model::model::training_run::IterationResult::duration_ms].
            pub fn set_or_clear_duration_ms<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::Int64Value>,
            {
                self.duration_ms = v.map(|x| x.into());
                self
            }

            /// Sets the value of [training_loss][crate::model::model::training_run::IterationResult::training_loss].
            pub fn set_training_loss<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::DoubleValue>,
            {
                self.training_loss = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [training_loss][crate::model::model::training_run::IterationResult::training_loss].
            pub fn set_or_clear_training_loss<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::DoubleValue>,
            {
                self.training_loss = v.map(|x| x.into());
                self
            }

            /// Sets the value of [eval_loss][crate::model::model::training_run::IterationResult::eval_loss].
            pub fn set_eval_loss<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::DoubleValue>,
            {
                self.eval_loss = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [eval_loss][crate::model::model::training_run::IterationResult::eval_loss].
            pub fn set_or_clear_eval_loss<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::DoubleValue>,
            {
                self.eval_loss = v.map(|x| x.into());
                self
            }

            /// Sets the value of [learn_rate][crate::model::model::training_run::IterationResult::learn_rate].
            pub fn set_learn_rate<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                self.learn_rate = v.into();
                self
            }

            /// Sets the value of [cluster_infos][crate::model::model::training_run::IterationResult::cluster_infos].
            pub fn set_cluster_infos<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<
                        crate::model::model::training_run::iteration_result::ClusterInfo,
                    >,
            {
                use std::iter::Iterator;
                self.cluster_infos = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [arima_result][crate::model::model::training_run::IterationResult::arima_result].
            pub fn set_arima_result<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<
                        crate::model::model::training_run::iteration_result::ArimaResult,
                    >,
            {
                self.arima_result = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [arima_result][crate::model::model::training_run::IterationResult::arima_result].
            pub fn set_or_clear_arima_result<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<
                        crate::model::model::training_run::iteration_result::ArimaResult,
                    >,
            {
                self.arima_result = v.map(|x| x.into());
                self
            }

            /// Sets the value of [principal_component_infos][crate::model::model::training_run::IterationResult::principal_component_infos].
            pub fn set_principal_component_infos<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<
                        crate::model::model::training_run::iteration_result::PrincipalComponentInfo,
                    >,
            {
                use std::iter::Iterator;
                self.principal_component_infos = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for IterationResult {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.bigquery.v2.Model.TrainingRun.IterationResult"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for IterationResult {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __index,
                    __duration_ms,
                    __training_loss,
                    __eval_loss,
                    __learn_rate,
                    __cluster_infos,
                    __arima_result,
                    __principal_component_infos,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for IterationResult")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "index" => Ok(__FieldTag::__index),
                                    "durationMs" => Ok(__FieldTag::__duration_ms),
                                    "duration_ms" => Ok(__FieldTag::__duration_ms),
                                    "trainingLoss" => Ok(__FieldTag::__training_loss),
                                    "training_loss" => Ok(__FieldTag::__training_loss),
                                    "evalLoss" => Ok(__FieldTag::__eval_loss),
                                    "eval_loss" => Ok(__FieldTag::__eval_loss),
                                    "learnRate" => Ok(__FieldTag::__learn_rate),
                                    "learn_rate" => Ok(__FieldTag::__learn_rate),
                                    "clusterInfos" => Ok(__FieldTag::__cluster_infos),
                                    "cluster_infos" => Ok(__FieldTag::__cluster_infos),
                                    "arimaResult" => Ok(__FieldTag::__arima_result),
                                    "arima_result" => Ok(__FieldTag::__arima_result),
                                    "principalComponentInfos" => {
                                        Ok(__FieldTag::__principal_component_infos)
                                    }
                                    "principal_component_infos" => {
                                        Ok(__FieldTag::__principal_component_infos)
                                    }
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = IterationResult;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct IterationResult")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__index => {
                                    if !fields.insert(__FieldTag::__index) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for index"),
                                        );
                                    }
                                    struct __With(std::option::Option<wkt::Int32Value>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.index = map.next_value::<__With>()?.0;
                                }
                                __FieldTag::__duration_ms => {
                                    if !fields.insert(__FieldTag::__duration_ms) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for duration_ms",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<wkt::Int64Value>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.duration_ms = map.next_value::<__With>()?.0;
                                }
                                __FieldTag::__training_loss => {
                                    if !fields.insert(__FieldTag::__training_loss) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for training_loss",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<wkt::DoubleValue>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.training_loss = map.next_value::<__With>()?.0;
                                }
                                __FieldTag::__eval_loss => {
                                    if !fields.insert(__FieldTag::__eval_loss) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for eval_loss",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<wkt::DoubleValue>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.eval_loss = map.next_value::<__With>()?.0;
                                }
                                __FieldTag::__learn_rate => {
                                    if !fields.insert(__FieldTag::__learn_rate) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for learn_rate",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<f64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.learn_rate =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__cluster_infos => {
                                    if !fields.insert(__FieldTag::__cluster_infos) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for cluster_infos",
                                            ),
                                        );
                                    }
                                    result.cluster_infos = map.next_value::<std::option::Option<std::vec::Vec<crate::model::model::training_run::iteration_result::ClusterInfo>>>()?.unwrap_or_default();
                                }
                                __FieldTag::__arima_result => {
                                    if !fields.insert(__FieldTag::__arima_result) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for arima_result",
                                            ),
                                        );
                                    }
                                    result.arima_result = map.next_value::<std::option::Option<crate::model::model::training_run::iteration_result::ArimaResult>>()?
                                        ;
                                }
                                __FieldTag::__principal_component_infos => {
                                    if !fields.insert(__FieldTag::__principal_component_infos) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for principal_component_infos",
                                            ),
                                        );
                                    }
                                    result.principal_component_infos = map.next_value::<std::option::Option<std::vec::Vec<crate::model::model::training_run::iteration_result::PrincipalComponentInfo>>>()?.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for IterationResult {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if self.index.is_some() {
                    struct __With<'a>(&'a std::option::Option<wkt::Int32Value>);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                                self.0, serializer,
                            )
                        }
                    }
                    state.serialize_entry("index", &__With(&self.index))?;
                }
                if self.duration_ms.is_some() {
                    struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                                self.0, serializer,
                            )
                        }
                    }
                    state.serialize_entry("durationMs", &__With(&self.duration_ms))?;
                }
                if self.training_loss.is_some() {
                    struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                                self.0, serializer,
                            )
                        }
                    }
                    state.serialize_entry("trainingLoss", &__With(&self.training_loss))?;
                }
                if self.eval_loss.is_some() {
                    struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                                self.0, serializer,
                            )
                        }
                    }
                    state.serialize_entry("evalLoss", &__With(&self.eval_loss))?;
                }
                if !wkt::internal::is_default(&self.learn_rate) {
                    struct __With<'a>(&'a f64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("learnRate", &__With(&self.learn_rate))?;
                }
                if !self.cluster_infos.is_empty() {
                    state.serialize_entry("clusterInfos", &self.cluster_infos)?;
                }
                if self.arima_result.is_some() {
                    state.serialize_entry("arimaResult", &self.arima_result)?;
                }
                if !self.principal_component_infos.is_empty() {
                    state.serialize_entry(
                        "principalComponentInfos",
                        &self.principal_component_infos,
                    )?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [IterationResult].
        pub mod iteration_result {
            #[allow(unused_imports)]
            use super::*;

            /// Information about a single cluster for clustering model.
            #[derive(Clone, Debug, Default, PartialEq)]
            #[non_exhaustive]
            pub struct ClusterInfo {
                /// Centroid id.
                pub centroid_id: i64,

                /// Cluster radius, the average distance from centroid
                /// to each point assigned to the cluster.
                pub cluster_radius: std::option::Option<wkt::DoubleValue>,

                /// Cluster size, the total number of points assigned to the cluster.
                pub cluster_size: std::option::Option<wkt::Int64Value>,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl ClusterInfo {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [centroid_id][crate::model::model::training_run::iteration_result::ClusterInfo::centroid_id].
                pub fn set_centroid_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                    self.centroid_id = v.into();
                    self
                }

                /// Sets the value of [cluster_radius][crate::model::model::training_run::iteration_result::ClusterInfo::cluster_radius].
                pub fn set_cluster_radius<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<wkt::DoubleValue>,
                {
                    self.cluster_radius = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [cluster_radius][crate::model::model::training_run::iteration_result::ClusterInfo::cluster_radius].
                pub fn set_or_clear_cluster_radius<T>(mut self, v: std::option::Option<T>) -> Self
                where
                    T: std::convert::Into<wkt::DoubleValue>,
                {
                    self.cluster_radius = v.map(|x| x.into());
                    self
                }

                /// Sets the value of [cluster_size][crate::model::model::training_run::iteration_result::ClusterInfo::cluster_size].
                pub fn set_cluster_size<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<wkt::Int64Value>,
                {
                    self.cluster_size = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [cluster_size][crate::model::model::training_run::iteration_result::ClusterInfo::cluster_size].
                pub fn set_or_clear_cluster_size<T>(mut self, v: std::option::Option<T>) -> Self
                where
                    T: std::convert::Into<wkt::Int64Value>,
                {
                    self.cluster_size = v.map(|x| x.into());
                    self
                }
            }

            impl wkt::message::Message for ClusterInfo {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.bigquery.v2.Model.TrainingRun.IterationResult.ClusterInfo"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for ClusterInfo {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __centroid_id,
                        __cluster_radius,
                        __cluster_size,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for ClusterInfo")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "centroidId" => Ok(__FieldTag::__centroid_id),
                                        "centroid_id" => Ok(__FieldTag::__centroid_id),
                                        "clusterRadius" => Ok(__FieldTag::__cluster_radius),
                                        "cluster_radius" => Ok(__FieldTag::__cluster_radius),
                                        "clusterSize" => Ok(__FieldTag::__cluster_size),
                                        "cluster_size" => Ok(__FieldTag::__cluster_size),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = ClusterInfo;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct ClusterInfo")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__centroid_id => {
                                        if !fields.insert(__FieldTag::__centroid_id) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for centroid_id",
                                                ),
                                            );
                                        }
                                        struct __With(std::option::Option<i64>);
                                        impl<'de> serde::de::Deserialize<'de> for __With {
                                            fn deserialize<D>(
                                                deserializer: D,
                                            ) -> std::result::Result<Self, D::Error>
                                            where
                                                D: serde::de::Deserializer<'de>,
                                            {
                                                serde_with::As::<
                                                    std::option::Option<wkt::internal::I64>,
                                                >::deserialize(
                                                    deserializer
                                                )
                                                .map(__With)
                                            }
                                        }
                                        result.centroid_id =
                                            map.next_value::<__With>()?.0.unwrap_or_default();
                                    }
                                    __FieldTag::__cluster_radius => {
                                        if !fields.insert(__FieldTag::__cluster_radius) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for cluster_radius",
                                                ),
                                            );
                                        }
                                        struct __With(std::option::Option<wkt::DoubleValue>);
                                        impl<'de> serde::de::Deserialize<'de> for __With {
                                            fn deserialize<D>(
                                                deserializer: D,
                                            ) -> std::result::Result<Self, D::Error>
                                            where
                                                D: serde::de::Deserializer<'de>,
                                            {
                                                serde_with::As::<
                                                    std::option::Option<wkt::internal::F64>,
                                                >::deserialize(
                                                    deserializer
                                                )
                                                .map(__With)
                                            }
                                        }
                                        result.cluster_radius = map.next_value::<__With>()?.0;
                                    }
                                    __FieldTag::__cluster_size => {
                                        if !fields.insert(__FieldTag::__cluster_size) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for cluster_size",
                                                ),
                                            );
                                        }
                                        struct __With(std::option::Option<wkt::Int64Value>);
                                        impl<'de> serde::de::Deserialize<'de> for __With {
                                            fn deserialize<D>(
                                                deserializer: D,
                                            ) -> std::result::Result<Self, D::Error>
                                            where
                                                D: serde::de::Deserializer<'de>,
                                            {
                                                serde_with::As::<
                                                    std::option::Option<wkt::internal::I64>,
                                                >::deserialize(
                                                    deserializer
                                                )
                                                .map(__With)
                                            }
                                        }
                                        result.cluster_size = map.next_value::<__With>()?.0;
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for ClusterInfo {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !wkt::internal::is_default(&self.centroid_id) {
                        struct __With<'a>(&'a i64);
                        impl<'a> serde::ser::Serialize for __With<'a> {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::ser::Serializer,
                            {
                                serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                            }
                        }
                        state.serialize_entry("centroidId", &__With(&self.centroid_id))?;
                    }
                    if self.cluster_radius.is_some() {
                        struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
                        impl<'a> serde::ser::Serialize for __With<'a> {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::ser::Serializer,
                            {
                                serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                                    self.0, serializer,
                                )
                            }
                        }
                        state.serialize_entry("clusterRadius", &__With(&self.cluster_radius))?;
                    }
                    if self.cluster_size.is_some() {
                        struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
                        impl<'a> serde::ser::Serialize for __With<'a> {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::ser::Serializer,
                            {
                                serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                                    self.0, serializer,
                                )
                            }
                        }
                        state.serialize_entry("clusterSize", &__With(&self.cluster_size))?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            /// (Auto-)arima fitting result. Wrap everything in ArimaResult for easier
            /// refactoring if we want to use model-specific iteration results.
            #[derive(Clone, Debug, Default, PartialEq)]
            #[non_exhaustive]
            pub struct ArimaResult {

                /// This message is repeated because there are multiple arima models
                /// fitted in auto-arima. For non-auto-arima model, its size is one.
                pub arima_model_info: std::vec::Vec<crate::model::model::training_run::iteration_result::arima_result::ArimaModelInfo>,

                /// Seasonal periods. Repeated because multiple periods are supported for
                /// one time series.
                pub seasonal_periods: std::vec::Vec<crate::model::model::seasonal_period::SeasonalPeriodType>,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl ArimaResult {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [arima_model_info][crate::model::model::training_run::iteration_result::ArimaResult::arima_model_info].
                pub fn set_arima_model_info<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<crate::model::model::training_run::iteration_result::arima_result::ArimaModelInfo>
                {
                    use std::iter::Iterator;
                    self.arima_model_info = v.into_iter().map(|i| i.into()).collect();
                    self
                }

                /// Sets the value of [seasonal_periods][crate::model::model::training_run::iteration_result::ArimaResult::seasonal_periods].
                pub fn set_seasonal_periods<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<crate::model::model::seasonal_period::SeasonalPeriodType>,
                {
                    use std::iter::Iterator;
                    self.seasonal_periods = v.into_iter().map(|i| i.into()).collect();
                    self
                }
            }

            impl wkt::message::Message for ArimaResult {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.bigquery.v2.Model.TrainingRun.IterationResult.ArimaResult"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for ArimaResult {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __arima_model_info,
                        __seasonal_periods,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for ArimaResult")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "arimaModelInfo" => Ok(__FieldTag::__arima_model_info),
                                        "arima_model_info" => Ok(__FieldTag::__arima_model_info),
                                        "seasonalPeriods" => Ok(__FieldTag::__seasonal_periods),
                                        "seasonal_periods" => Ok(__FieldTag::__seasonal_periods),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = ArimaResult;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct ArimaResult")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__arima_model_info => {
                                        if !fields.insert(__FieldTag::__arima_model_info) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for arima_model_info",
                                                ),
                                            );
                                        }
                                        result.arima_model_info = map.next_value::<std::option::Option<std::vec::Vec<crate::model::model::training_run::iteration_result::arima_result::ArimaModelInfo>>>()?.unwrap_or_default();
                                    }
                                    __FieldTag::__seasonal_periods => {
                                        if !fields.insert(__FieldTag::__seasonal_periods) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for seasonal_periods",
                                                ),
                                            );
                                        }
                                        result.seasonal_periods = map.next_value::<std::option::Option<std::vec::Vec<crate::model::model::seasonal_period::SeasonalPeriodType>>>()?.unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for ArimaResult {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self.arima_model_info.is_empty() {
                        state.serialize_entry("arimaModelInfo", &self.arima_model_info)?;
                    }
                    if !self.seasonal_periods.is_empty() {
                        state.serialize_entry("seasonalPeriods", &self.seasonal_periods)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            /// Defines additional types related to [ArimaResult].
            pub mod arima_result {
                #[allow(unused_imports)]
                use super::*;

                /// Arima coefficients.
                #[derive(Clone, Debug, Default, PartialEq)]
                #[non_exhaustive]
                pub struct ArimaCoefficients {
                    /// Auto-regressive coefficients, an array of double.
                    pub auto_regressive_coefficients: std::vec::Vec<f64>,

                    /// Moving-average coefficients, an array of double.
                    pub moving_average_coefficients: std::vec::Vec<f64>,

                    /// Intercept coefficient, just a double not an array.
                    pub intercept_coefficient: std::option::Option<wkt::DoubleValue>,

                    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
                }

                impl ArimaCoefficients {
                    pub fn new() -> Self {
                        std::default::Default::default()
                    }

                    /// Sets the value of [auto_regressive_coefficients][crate::model::model::training_run::iteration_result::arima_result::ArimaCoefficients::auto_regressive_coefficients].
                    pub fn set_auto_regressive_coefficients<T, V>(mut self, v: T) -> Self
                    where
                        T: std::iter::IntoIterator<Item = V>,
                        V: std::convert::Into<f64>,
                    {
                        use std::iter::Iterator;
                        self.auto_regressive_coefficients =
                            v.into_iter().map(|i| i.into()).collect();
                        self
                    }

                    /// Sets the value of [moving_average_coefficients][crate::model::model::training_run::iteration_result::arima_result::ArimaCoefficients::moving_average_coefficients].
                    pub fn set_moving_average_coefficients<T, V>(mut self, v: T) -> Self
                    where
                        T: std::iter::IntoIterator<Item = V>,
                        V: std::convert::Into<f64>,
                    {
                        use std::iter::Iterator;
                        self.moving_average_coefficients =
                            v.into_iter().map(|i| i.into()).collect();
                        self
                    }

                    /// Sets the value of [intercept_coefficient][crate::model::model::training_run::iteration_result::arima_result::ArimaCoefficients::intercept_coefficient].
                    pub fn set_intercept_coefficient<T>(mut self, v: T) -> Self
                    where
                        T: std::convert::Into<wkt::DoubleValue>,
                    {
                        self.intercept_coefficient = std::option::Option::Some(v.into());
                        self
                    }

                    /// Sets or clears the value of [intercept_coefficient][crate::model::model::training_run::iteration_result::arima_result::ArimaCoefficients::intercept_coefficient].
                    pub fn set_or_clear_intercept_coefficient<T>(
                        mut self,
                        v: std::option::Option<T>,
                    ) -> Self
                    where
                        T: std::convert::Into<wkt::DoubleValue>,
                    {
                        self.intercept_coefficient = v.map(|x| x.into());
                        self
                    }
                }

                impl wkt::message::Message for ArimaCoefficients {
                    fn typename() -> &'static str {
                        "type.googleapis.com/google.cloud.bigquery.v2.Model.TrainingRun.IterationResult.ArimaResult.ArimaCoefficients"
                    }
                }

                #[doc(hidden)]
                impl<'de> serde::de::Deserialize<'de> for ArimaCoefficients {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        #[derive(PartialEq, Eq, Hash)]
                        enum __FieldTag {
                            __auto_regressive_coefficients,
                            __moving_average_coefficients,
                            __intercept_coefficient,
                            Unknown(std::string::String),
                        }
                        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                            fn deserialize<D>(
                                deserializer: D,
                            ) -> std::result::Result<Self, D::Error>
                            where
                                D: serde::Deserializer<'de>,
                            {
                                struct Visitor;
                                impl<'de> serde::de::Visitor<'de> for Visitor {
                                    type Value = __FieldTag;
                                    fn expecting(
                                        &self,
                                        formatter: &mut std::fmt::Formatter,
                                    ) -> std::fmt::Result {
                                        formatter.write_str("a field name for ArimaCoefficients")
                                    }
                                    fn visit_str<E>(
                                        self,
                                        value: &str,
                                    ) -> std::result::Result<Self::Value, E>
                                    where
                                        E: serde::de::Error,
                                    {
                                        use std::result::Result::Ok;
                                        use std::string::ToString;
                                        match value {
                                            "autoRegressiveCoefficients" => {
                                                Ok(__FieldTag::__auto_regressive_coefficients)
                                            }
                                            "auto_regressive_coefficients" => {
                                                Ok(__FieldTag::__auto_regressive_coefficients)
                                            }
                                            "movingAverageCoefficients" => {
                                                Ok(__FieldTag::__moving_average_coefficients)
                                            }
                                            "moving_average_coefficients" => {
                                                Ok(__FieldTag::__moving_average_coefficients)
                                            }
                                            "interceptCoefficient" => {
                                                Ok(__FieldTag::__intercept_coefficient)
                                            }
                                            "intercept_coefficient" => {
                                                Ok(__FieldTag::__intercept_coefficient)
                                            }
                                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                                        }
                                    }
                                }
                                deserializer.deserialize_identifier(Visitor)
                            }
                        }
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = ArimaCoefficients;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("struct ArimaCoefficients")
                            }
                            fn visit_map<A>(
                                self,
                                mut map: A,
                            ) -> std::result::Result<Self::Value, A::Error>
                            where
                                A: serde::de::MapAccess<'de>,
                            {
                                #[allow(unused_imports)]
                                use serde::de::Error;
                                use std::option::Option::Some;
                                let mut fields = std::collections::HashSet::new();
                                let mut result = Self::Value::new();
                                while let Some(tag) = map.next_key::<__FieldTag>()? {
                                    #[allow(clippy::match_single_binding)]
                                    match tag {
                                        __FieldTag::__auto_regressive_coefficients => {
                                            if !fields
                                                .insert(__FieldTag::__auto_regressive_coefficients)
                                            {
                                                return std::result::Result::Err(
                                                    A::Error::duplicate_field(
                                                        "multiple values for auto_regressive_coefficients",
                                                    ),
                                                );
                                            }
                                            struct __With(std::option::Option<std::vec::Vec<f64>>);
                                            impl<'de> serde::de::Deserialize<'de> for __With {
                                                fn deserialize<D>(
                                                    deserializer: D,
                                                ) -> std::result::Result<Self, D::Error>
                                                where
                                                    D: serde::de::Deserializer<'de>,
                                                {
                                                    serde_with::As::<
                                                        std::option::Option<
                                                            std::vec::Vec<wkt::internal::F64>,
                                                        >,
                                                    >::deserialize(
                                                        deserializer
                                                    )
                                                    .map(__With)
                                                }
                                            }
                                            result.auto_regressive_coefficients =
                                                map.next_value::<__With>()?.0.unwrap_or_default();
                                        }
                                        __FieldTag::__moving_average_coefficients => {
                                            if !fields
                                                .insert(__FieldTag::__moving_average_coefficients)
                                            {
                                                return std::result::Result::Err(
                                                    A::Error::duplicate_field(
                                                        "multiple values for moving_average_coefficients",
                                                    ),
                                                );
                                            }
                                            struct __With(std::option::Option<std::vec::Vec<f64>>);
                                            impl<'de> serde::de::Deserialize<'de> for __With {
                                                fn deserialize<D>(
                                                    deserializer: D,
                                                ) -> std::result::Result<Self, D::Error>
                                                where
                                                    D: serde::de::Deserializer<'de>,
                                                {
                                                    serde_with::As::<
                                                        std::option::Option<
                                                            std::vec::Vec<wkt::internal::F64>,
                                                        >,
                                                    >::deserialize(
                                                        deserializer
                                                    )
                                                    .map(__With)
                                                }
                                            }
                                            result.moving_average_coefficients =
                                                map.next_value::<__With>()?.0.unwrap_or_default();
                                        }
                                        __FieldTag::__intercept_coefficient => {
                                            if !fields.insert(__FieldTag::__intercept_coefficient) {
                                                return std::result::Result::Err(
                                                    A::Error::duplicate_field(
                                                        "multiple values for intercept_coefficient",
                                                    ),
                                                );
                                            }
                                            struct __With(std::option::Option<wkt::DoubleValue>);
                                            impl<'de> serde::de::Deserialize<'de> for __With {
                                                fn deserialize<D>(
                                                    deserializer: D,
                                                ) -> std::result::Result<Self, D::Error>
                                                where
                                                    D: serde::de::Deserializer<'de>,
                                                {
                                                    serde_with::As::<
                                                        std::option::Option<wkt::internal::F64>,
                                                    >::deserialize(
                                                        deserializer
                                                    )
                                                    .map(__With)
                                                }
                                            }
                                            result.intercept_coefficient =
                                                map.next_value::<__With>()?.0;
                                        }
                                        __FieldTag::Unknown(key) => {
                                            let value = map.next_value::<serde_json::Value>()?;
                                            result._unknown_fields.insert(key, value);
                                        }
                                    }
                                }
                                std::result::Result::Ok(result)
                            }
                        }
                        deserializer.deserialize_any(Visitor)
                    }
                }

                #[doc(hidden)]
                impl serde::ser::Serialize for ArimaCoefficients {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        use serde::ser::SerializeMap;
                        #[allow(unused_imports)]
                        use std::option::Option::Some;
                        let mut state = serializer.serialize_map(std::option::Option::None)?;
                        if !self.auto_regressive_coefficients.is_empty() {
                            struct __With<'a>(&'a std::vec::Vec<f64>);
                            impl<'a> serde::ser::Serialize for __With<'a> {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde_with::As::<std::vec::Vec<wkt::internal::F64>>::serialize(
                                        self.0, serializer,
                                    )
                                }
                            }
                            state.serialize_entry(
                                "autoRegressiveCoefficients",
                                &__With(&self.auto_regressive_coefficients),
                            )?;
                        }
                        if !self.moving_average_coefficients.is_empty() {
                            struct __With<'a>(&'a std::vec::Vec<f64>);
                            impl<'a> serde::ser::Serialize for __With<'a> {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde_with::As::<std::vec::Vec<wkt::internal::F64>>::serialize(
                                        self.0, serializer,
                                    )
                                }
                            }
                            state.serialize_entry(
                                "movingAverageCoefficients",
                                &__With(&self.moving_average_coefficients),
                            )?;
                        }
                        if self.intercept_coefficient.is_some() {
                            struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
                            impl<'a> serde::ser::Serialize for __With<'a> {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::serialize(self.0, serializer)
                                }
                            }
                            state.serialize_entry(
                                "interceptCoefficient",
                                &__With(&self.intercept_coefficient),
                            )?;
                        }
                        if !self._unknown_fields.is_empty() {
                            for (key, value) in self._unknown_fields.iter() {
                                state.serialize_entry(key, &value)?;
                            }
                        }
                        state.end()
                    }
                }

                /// Arima model information.
                #[derive(Clone, Debug, Default, PartialEq)]
                #[non_exhaustive]
                pub struct ArimaModelInfo {

                    /// Non-seasonal order.
                    pub non_seasonal_order: std::option::Option<crate::model::model::ArimaOrder>,

                    /// Arima coefficients.
                    pub arima_coefficients: std::option::Option<crate::model::model::training_run::iteration_result::arima_result::ArimaCoefficients>,

                    /// Arima fitting metrics.
                    pub arima_fitting_metrics: std::option::Option<crate::model::model::ArimaFittingMetrics>,

                    /// Whether Arima model fitted with drift or not. It is always false
                    /// when d is not 1.
                    pub has_drift: std::option::Option<wkt::BoolValue>,

                    /// The time_series_id value for this time series. It will be one of
                    /// the unique values from the time_series_id_column specified during
                    /// ARIMA model training. Only present when time_series_id_column
                    /// training option was used.
                    pub time_series_id: std::string::String,

                    /// The tuple of time_series_ids identifying this time series. It will
                    /// be one of the unique tuples of values present in the
                    /// time_series_id_columns specified during ARIMA model training. Only
                    /// present when time_series_id_columns training option was used and
                    /// the order of values here are same as the order of
                    /// time_series_id_columns.
                    pub time_series_ids: std::vec::Vec<std::string::String>,

                    /// Seasonal periods. Repeated because multiple periods are supported
                    /// for one time series.
                    pub seasonal_periods: std::vec::Vec<crate::model::model::seasonal_period::SeasonalPeriodType>,

                    /// If true, holiday_effect is a part of time series decomposition
                    /// result.
                    pub has_holiday_effect: std::option::Option<wkt::BoolValue>,

                    /// If true, spikes_and_dips is a part of time series decomposition
                    /// result.
                    pub has_spikes_and_dips: std::option::Option<wkt::BoolValue>,

                    /// If true, step_changes is a part of time series decomposition
                    /// result.
                    pub has_step_changes: std::option::Option<wkt::BoolValue>,

                    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
                }

                impl ArimaModelInfo {
                    pub fn new() -> Self {
                        std::default::Default::default()
                    }

                    /// Sets the value of [non_seasonal_order][crate::model::model::training_run::iteration_result::arima_result::ArimaModelInfo::non_seasonal_order].
                    pub fn set_non_seasonal_order<T>(mut self, v: T) -> Self
                    where
                        T: std::convert::Into<crate::model::model::ArimaOrder>,
                    {
                        self.non_seasonal_order = std::option::Option::Some(v.into());
                        self
                    }

                    /// Sets or clears the value of [non_seasonal_order][crate::model::model::training_run::iteration_result::arima_result::ArimaModelInfo::non_seasonal_order].
                    pub fn set_or_clear_non_seasonal_order<T>(
                        mut self,
                        v: std::option::Option<T>,
                    ) -> Self
                    where
                        T: std::convert::Into<crate::model::model::ArimaOrder>,
                    {
                        self.non_seasonal_order = v.map(|x| x.into());
                        self
                    }

                    /// Sets the value of [arima_coefficients][crate::model::model::training_run::iteration_result::arima_result::ArimaModelInfo::arima_coefficients].
                    pub fn set_arima_coefficients<T>(mut self, v: T) -> Self
                    where T: std::convert::Into<crate::model::model::training_run::iteration_result::arima_result::ArimaCoefficients>
                    {
                        self.arima_coefficients = std::option::Option::Some(v.into());
                        self
                    }

                    /// Sets or clears the value of [arima_coefficients][crate::model::model::training_run::iteration_result::arima_result::ArimaModelInfo::arima_coefficients].
                    pub fn set_or_clear_arima_coefficients<T>(mut self, v: std::option::Option<T>) -> Self
                    where T: std::convert::Into<crate::model::model::training_run::iteration_result::arima_result::ArimaCoefficients>
                    {
                        self.arima_coefficients = v.map(|x| x.into());
                        self
                    }

                    /// Sets the value of [arima_fitting_metrics][crate::model::model::training_run::iteration_result::arima_result::ArimaModelInfo::arima_fitting_metrics].
                    pub fn set_arima_fitting_metrics<T>(mut self, v: T) -> Self
                    where
                        T: std::convert::Into<crate::model::model::ArimaFittingMetrics>,
                    {
                        self.arima_fitting_metrics = std::option::Option::Some(v.into());
                        self
                    }

                    /// Sets or clears the value of [arima_fitting_metrics][crate::model::model::training_run::iteration_result::arima_result::ArimaModelInfo::arima_fitting_metrics].
                    pub fn set_or_clear_arima_fitting_metrics<T>(
                        mut self,
                        v: std::option::Option<T>,
                    ) -> Self
                    where
                        T: std::convert::Into<crate::model::model::ArimaFittingMetrics>,
                    {
                        self.arima_fitting_metrics = v.map(|x| x.into());
                        self
                    }

                    /// Sets the value of [has_drift][crate::model::model::training_run::iteration_result::arima_result::ArimaModelInfo::has_drift].
                    pub fn set_has_drift<T>(mut self, v: T) -> Self
                    where
                        T: std::convert::Into<wkt::BoolValue>,
                    {
                        self.has_drift = std::option::Option::Some(v.into());
                        self
                    }

                    /// Sets or clears the value of [has_drift][crate::model::model::training_run::iteration_result::arima_result::ArimaModelInfo::has_drift].
                    pub fn set_or_clear_has_drift<T>(mut self, v: std::option::Option<T>) -> Self
                    where
                        T: std::convert::Into<wkt::BoolValue>,
                    {
                        self.has_drift = v.map(|x| x.into());
                        self
                    }

                    /// Sets the value of [time_series_id][crate::model::model::training_run::iteration_result::arima_result::ArimaModelInfo::time_series_id].
                    pub fn set_time_series_id<T: std::convert::Into<std::string::String>>(
                        mut self,
                        v: T,
                    ) -> Self {
                        self.time_series_id = v.into();
                        self
                    }

                    /// Sets the value of [time_series_ids][crate::model::model::training_run::iteration_result::arima_result::ArimaModelInfo::time_series_ids].
                    pub fn set_time_series_ids<T, V>(mut self, v: T) -> Self
                    where
                        T: std::iter::IntoIterator<Item = V>,
                        V: std::convert::Into<std::string::String>,
                    {
                        use std::iter::Iterator;
                        self.time_series_ids = v.into_iter().map(|i| i.into()).collect();
                        self
                    }

                    /// Sets the value of [seasonal_periods][crate::model::model::training_run::iteration_result::arima_result::ArimaModelInfo::seasonal_periods].
                    pub fn set_seasonal_periods<T, V>(mut self, v: T) -> Self
                    where
                        T: std::iter::IntoIterator<Item = V>,
                        V: std::convert::Into<
                                crate::model::model::seasonal_period::SeasonalPeriodType,
                            >,
                    {
                        use std::iter::Iterator;
                        self.seasonal_periods = v.into_iter().map(|i| i.into()).collect();
                        self
                    }

                    /// Sets the value of [has_holiday_effect][crate::model::model::training_run::iteration_result::arima_result::ArimaModelInfo::has_holiday_effect].
                    pub fn set_has_holiday_effect<T>(mut self, v: T) -> Self
                    where
                        T: std::convert::Into<wkt::BoolValue>,
                    {
                        self.has_holiday_effect = std::option::Option::Some(v.into());
                        self
                    }

                    /// Sets or clears the value of [has_holiday_effect][crate::model::model::training_run::iteration_result::arima_result::ArimaModelInfo::has_holiday_effect].
                    pub fn set_or_clear_has_holiday_effect<T>(
                        mut self,
                        v: std::option::Option<T>,
                    ) -> Self
                    where
                        T: std::convert::Into<wkt::BoolValue>,
                    {
                        self.has_holiday_effect = v.map(|x| x.into());
                        self
                    }

                    /// Sets the value of [has_spikes_and_dips][crate::model::model::training_run::iteration_result::arima_result::ArimaModelInfo::has_spikes_and_dips].
                    pub fn set_has_spikes_and_dips<T>(mut self, v: T) -> Self
                    where
                        T: std::convert::Into<wkt::BoolValue>,
                    {
                        self.has_spikes_and_dips = std::option::Option::Some(v.into());
                        self
                    }

                    /// Sets or clears the value of [has_spikes_and_dips][crate::model::model::training_run::iteration_result::arima_result::ArimaModelInfo::has_spikes_and_dips].
                    pub fn set_or_clear_has_spikes_and_dips<T>(
                        mut self,
                        v: std::option::Option<T>,
                    ) -> Self
                    where
                        T: std::convert::Into<wkt::BoolValue>,
                    {
                        self.has_spikes_and_dips = v.map(|x| x.into());
                        self
                    }

                    /// Sets the value of [has_step_changes][crate::model::model::training_run::iteration_result::arima_result::ArimaModelInfo::has_step_changes].
                    pub fn set_has_step_changes<T>(mut self, v: T) -> Self
                    where
                        T: std::convert::Into<wkt::BoolValue>,
                    {
                        self.has_step_changes = std::option::Option::Some(v.into());
                        self
                    }

                    /// Sets or clears the value of [has_step_changes][crate::model::model::training_run::iteration_result::arima_result::ArimaModelInfo::has_step_changes].
                    pub fn set_or_clear_has_step_changes<T>(
                        mut self,
                        v: std::option::Option<T>,
                    ) -> Self
                    where
                        T: std::convert::Into<wkt::BoolValue>,
                    {
                        self.has_step_changes = v.map(|x| x.into());
                        self
                    }
                }

                impl wkt::message::Message for ArimaModelInfo {
                    fn typename() -> &'static str {
                        "type.googleapis.com/google.cloud.bigquery.v2.Model.TrainingRun.IterationResult.ArimaResult.ArimaModelInfo"
                    }
                }

                #[doc(hidden)]
                impl<'de> serde::de::Deserialize<'de> for ArimaModelInfo {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        #[derive(PartialEq, Eq, Hash)]
                        enum __FieldTag {
                            __non_seasonal_order,
                            __arima_coefficients,
                            __arima_fitting_metrics,
                            __has_drift,
                            __time_series_id,
                            __time_series_ids,
                            __seasonal_periods,
                            __has_holiday_effect,
                            __has_spikes_and_dips,
                            __has_step_changes,
                            Unknown(std::string::String),
                        }
                        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                            fn deserialize<D>(
                                deserializer: D,
                            ) -> std::result::Result<Self, D::Error>
                            where
                                D: serde::Deserializer<'de>,
                            {
                                struct Visitor;
                                impl<'de> serde::de::Visitor<'de> for Visitor {
                                    type Value = __FieldTag;
                                    fn expecting(
                                        &self,
                                        formatter: &mut std::fmt::Formatter,
                                    ) -> std::fmt::Result {
                                        formatter.write_str("a field name for ArimaModelInfo")
                                    }
                                    fn visit_str<E>(
                                        self,
                                        value: &str,
                                    ) -> std::result::Result<Self::Value, E>
                                    where
                                        E: serde::de::Error,
                                    {
                                        use std::result::Result::Ok;
                                        use std::string::ToString;
                                        match value {
                                            "nonSeasonalOrder" => {
                                                Ok(__FieldTag::__non_seasonal_order)
                                            }
                                            "non_seasonal_order" => {
                                                Ok(__FieldTag::__non_seasonal_order)
                                            }
                                            "arimaCoefficients" => {
                                                Ok(__FieldTag::__arima_coefficients)
                                            }
                                            "arima_coefficients" => {
                                                Ok(__FieldTag::__arima_coefficients)
                                            }
                                            "arimaFittingMetrics" => {
                                                Ok(__FieldTag::__arima_fitting_metrics)
                                            }
                                            "arima_fitting_metrics" => {
                                                Ok(__FieldTag::__arima_fitting_metrics)
                                            }
                                            "hasDrift" => Ok(__FieldTag::__has_drift),
                                            "has_drift" => Ok(__FieldTag::__has_drift),
                                            "timeSeriesId" => Ok(__FieldTag::__time_series_id),
                                            "time_series_id" => Ok(__FieldTag::__time_series_id),
                                            "timeSeriesIds" => Ok(__FieldTag::__time_series_ids),
                                            "time_series_ids" => Ok(__FieldTag::__time_series_ids),
                                            "seasonalPeriods" => Ok(__FieldTag::__seasonal_periods),
                                            "seasonal_periods" => {
                                                Ok(__FieldTag::__seasonal_periods)
                                            }
                                            "hasHolidayEffect" => {
                                                Ok(__FieldTag::__has_holiday_effect)
                                            }
                                            "has_holiday_effect" => {
                                                Ok(__FieldTag::__has_holiday_effect)
                                            }
                                            "hasSpikesAndDips" => {
                                                Ok(__FieldTag::__has_spikes_and_dips)
                                            }
                                            "has_spikes_and_dips" => {
                                                Ok(__FieldTag::__has_spikes_and_dips)
                                            }
                                            "hasStepChanges" => Ok(__FieldTag::__has_step_changes),
                                            "has_step_changes" => {
                                                Ok(__FieldTag::__has_step_changes)
                                            }
                                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                                        }
                                    }
                                }
                                deserializer.deserialize_identifier(Visitor)
                            }
                        }
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = ArimaModelInfo;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("struct ArimaModelInfo")
                            }
                            fn visit_map<A>(
                                self,
                                mut map: A,
                            ) -> std::result::Result<Self::Value, A::Error>
                            where
                                A: serde::de::MapAccess<'de>,
                            {
                                #[allow(unused_imports)]
                                use serde::de::Error;
                                use std::option::Option::Some;
                                let mut fields = std::collections::HashSet::new();
                                let mut result = Self::Value::new();
                                while let Some(tag) = map.next_key::<__FieldTag>()? {
                                    #[allow(clippy::match_single_binding)]
                                    match tag {
                                        __FieldTag::__non_seasonal_order => {
                                            if !fields.insert(__FieldTag::__non_seasonal_order) {
                                                return std::result::Result::Err(
                                                    A::Error::duplicate_field(
                                                        "multiple values for non_seasonal_order",
                                                    ),
                                                );
                                            }
                                            result.non_seasonal_order = map
                                                .next_value::<std::option::Option<
                                                    crate::model::model::ArimaOrder,
                                                >>(
                                                )?;
                                        }
                                        __FieldTag::__arima_coefficients => {
                                            if !fields.insert(__FieldTag::__arima_coefficients) {
                                                return std::result::Result::Err(
                                                    A::Error::duplicate_field(
                                                        "multiple values for arima_coefficients",
                                                    ),
                                                );
                                            }
                                            result.arima_coefficients = map.next_value::<std::option::Option<crate::model::model::training_run::iteration_result::arima_result::ArimaCoefficients>>()?
                                                ;
                                        }
                                        __FieldTag::__arima_fitting_metrics => {
                                            if !fields.insert(__FieldTag::__arima_fitting_metrics) {
                                                return std::result::Result::Err(
                                                    A::Error::duplicate_field(
                                                        "multiple values for arima_fitting_metrics",
                                                    ),
                                                );
                                            }
                                            result.arima_fitting_metrics = map
                                                .next_value::<std::option::Option<
                                                crate::model::model::ArimaFittingMetrics,
                                            >>(
                                            )?;
                                        }
                                        __FieldTag::__has_drift => {
                                            if !fields.insert(__FieldTag::__has_drift) {
                                                return std::result::Result::Err(
                                                    A::Error::duplicate_field(
                                                        "multiple values for has_drift",
                                                    ),
                                                );
                                            }
                                            result.has_drift = map
                                                .next_value::<std::option::Option<wkt::BoolValue>>(
                                                )?;
                                        }
                                        __FieldTag::__time_series_id => {
                                            if !fields.insert(__FieldTag::__time_series_id) {
                                                return std::result::Result::Err(
                                                    A::Error::duplicate_field(
                                                        "multiple values for time_series_id",
                                                    ),
                                                );
                                            }
                                            result.time_series_id = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                                        }
                                        __FieldTag::__time_series_ids => {
                                            if !fields.insert(__FieldTag::__time_series_ids) {
                                                return std::result::Result::Err(
                                                    A::Error::duplicate_field(
                                                        "multiple values for time_series_ids",
                                                    ),
                                                );
                                            }
                                            result.time_series_ids = map
                                                .next_value::<std::option::Option<
                                                    std::vec::Vec<std::string::String>,
                                                >>(
                                                )?
                                                .unwrap_or_default();
                                        }
                                        __FieldTag::__seasonal_periods => {
                                            if !fields.insert(__FieldTag::__seasonal_periods) {
                                                return std::result::Result::Err(
                                                    A::Error::duplicate_field(
                                                        "multiple values for seasonal_periods",
                                                    ),
                                                );
                                            }
                                            result.seasonal_periods = map.next_value::<std::option::Option<std::vec::Vec<crate::model::model::seasonal_period::SeasonalPeriodType>>>()?.unwrap_or_default();
                                        }
                                        __FieldTag::__has_holiday_effect => {
                                            if !fields.insert(__FieldTag::__has_holiday_effect) {
                                                return std::result::Result::Err(
                                                    A::Error::duplicate_field(
                                                        "multiple values for has_holiday_effect",
                                                    ),
                                                );
                                            }
                                            result.has_holiday_effect = map
                                                .next_value::<std::option::Option<wkt::BoolValue>>(
                                                )?;
                                        }
                                        __FieldTag::__has_spikes_and_dips => {
                                            if !fields.insert(__FieldTag::__has_spikes_and_dips) {
                                                return std::result::Result::Err(
                                                    A::Error::duplicate_field(
                                                        "multiple values for has_spikes_and_dips",
                                                    ),
                                                );
                                            }
                                            result.has_spikes_and_dips = map
                                                .next_value::<std::option::Option<wkt::BoolValue>>(
                                                )?;
                                        }
                                        __FieldTag::__has_step_changes => {
                                            if !fields.insert(__FieldTag::__has_step_changes) {
                                                return std::result::Result::Err(
                                                    A::Error::duplicate_field(
                                                        "multiple values for has_step_changes",
                                                    ),
                                                );
                                            }
                                            result.has_step_changes = map
                                                .next_value::<std::option::Option<wkt::BoolValue>>(
                                                )?;
                                        }
                                        __FieldTag::Unknown(key) => {
                                            let value = map.next_value::<serde_json::Value>()?;
                                            result._unknown_fields.insert(key, value);
                                        }
                                    }
                                }
                                std::result::Result::Ok(result)
                            }
                        }
                        deserializer.deserialize_any(Visitor)
                    }
                }

                #[doc(hidden)]
                impl serde::ser::Serialize for ArimaModelInfo {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        use serde::ser::SerializeMap;
                        #[allow(unused_imports)]
                        use std::option::Option::Some;
                        let mut state = serializer.serialize_map(std::option::Option::None)?;
                        if self.non_seasonal_order.is_some() {
                            state.serialize_entry("nonSeasonalOrder", &self.non_seasonal_order)?;
                        }
                        if self.arima_coefficients.is_some() {
                            state.serialize_entry("arimaCoefficients", &self.arima_coefficients)?;
                        }
                        if self.arima_fitting_metrics.is_some() {
                            state.serialize_entry(
                                "arimaFittingMetrics",
                                &self.arima_fitting_metrics,
                            )?;
                        }
                        if self.has_drift.is_some() {
                            state.serialize_entry("hasDrift", &self.has_drift)?;
                        }
                        if !self.time_series_id.is_empty() {
                            state.serialize_entry("timeSeriesId", &self.time_series_id)?;
                        }
                        if !self.time_series_ids.is_empty() {
                            state.serialize_entry("timeSeriesIds", &self.time_series_ids)?;
                        }
                        if !self.seasonal_periods.is_empty() {
                            state.serialize_entry("seasonalPeriods", &self.seasonal_periods)?;
                        }
                        if self.has_holiday_effect.is_some() {
                            state.serialize_entry("hasHolidayEffect", &self.has_holiday_effect)?;
                        }
                        if self.has_spikes_and_dips.is_some() {
                            state.serialize_entry("hasSpikesAndDips", &self.has_spikes_and_dips)?;
                        }
                        if self.has_step_changes.is_some() {
                            state.serialize_entry("hasStepChanges", &self.has_step_changes)?;
                        }
                        if !self._unknown_fields.is_empty() {
                            for (key, value) in self._unknown_fields.iter() {
                                state.serialize_entry(key, &value)?;
                            }
                        }
                        state.end()
                    }
                }
            }

            /// Principal component infos, used only for eigen decomposition based
            /// models, e.g., PCA. Ordered by explained_variance in the descending
            /// order.
            #[derive(Clone, Debug, Default, PartialEq)]
            #[non_exhaustive]
            pub struct PrincipalComponentInfo {
                /// Id of the principal component.
                pub principal_component_id: std::option::Option<wkt::Int64Value>,

                /// Explained variance by this principal component, which is simply the
                /// eigenvalue.
                pub explained_variance: std::option::Option<wkt::DoubleValue>,

                /// Explained_variance over the total explained variance.
                pub explained_variance_ratio: std::option::Option<wkt::DoubleValue>,

                /// The explained_variance is pre-ordered in the descending order to
                /// compute the cumulative explained variance ratio.
                pub cumulative_explained_variance_ratio: std::option::Option<wkt::DoubleValue>,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl PrincipalComponentInfo {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [principal_component_id][crate::model::model::training_run::iteration_result::PrincipalComponentInfo::principal_component_id].
                pub fn set_principal_component_id<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<wkt::Int64Value>,
                {
                    self.principal_component_id = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [principal_component_id][crate::model::model::training_run::iteration_result::PrincipalComponentInfo::principal_component_id].
                pub fn set_or_clear_principal_component_id<T>(
                    mut self,
                    v: std::option::Option<T>,
                ) -> Self
                where
                    T: std::convert::Into<wkt::Int64Value>,
                {
                    self.principal_component_id = v.map(|x| x.into());
                    self
                }

                /// Sets the value of [explained_variance][crate::model::model::training_run::iteration_result::PrincipalComponentInfo::explained_variance].
                pub fn set_explained_variance<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<wkt::DoubleValue>,
                {
                    self.explained_variance = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [explained_variance][crate::model::model::training_run::iteration_result::PrincipalComponentInfo::explained_variance].
                pub fn set_or_clear_explained_variance<T>(
                    mut self,
                    v: std::option::Option<T>,
                ) -> Self
                where
                    T: std::convert::Into<wkt::DoubleValue>,
                {
                    self.explained_variance = v.map(|x| x.into());
                    self
                }

                /// Sets the value of [explained_variance_ratio][crate::model::model::training_run::iteration_result::PrincipalComponentInfo::explained_variance_ratio].
                pub fn set_explained_variance_ratio<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<wkt::DoubleValue>,
                {
                    self.explained_variance_ratio = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [explained_variance_ratio][crate::model::model::training_run::iteration_result::PrincipalComponentInfo::explained_variance_ratio].
                pub fn set_or_clear_explained_variance_ratio<T>(
                    mut self,
                    v: std::option::Option<T>,
                ) -> Self
                where
                    T: std::convert::Into<wkt::DoubleValue>,
                {
                    self.explained_variance_ratio = v.map(|x| x.into());
                    self
                }

                /// Sets the value of [cumulative_explained_variance_ratio][crate::model::model::training_run::iteration_result::PrincipalComponentInfo::cumulative_explained_variance_ratio].
                pub fn set_cumulative_explained_variance_ratio<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<wkt::DoubleValue>,
                {
                    self.cumulative_explained_variance_ratio = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [cumulative_explained_variance_ratio][crate::model::model::training_run::iteration_result::PrincipalComponentInfo::cumulative_explained_variance_ratio].
                pub fn set_or_clear_cumulative_explained_variance_ratio<T>(
                    mut self,
                    v: std::option::Option<T>,
                ) -> Self
                where
                    T: std::convert::Into<wkt::DoubleValue>,
                {
                    self.cumulative_explained_variance_ratio = v.map(|x| x.into());
                    self
                }
            }

            impl wkt::message::Message for PrincipalComponentInfo {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.bigquery.v2.Model.TrainingRun.IterationResult.PrincipalComponentInfo"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for PrincipalComponentInfo {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __principal_component_id,
                        __explained_variance,
                        __explained_variance_ratio,
                        __cumulative_explained_variance_ratio,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for PrincipalComponentInfo")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "principalComponentId" => {
                                            Ok(__FieldTag::__principal_component_id)
                                        }
                                        "principal_component_id" => {
                                            Ok(__FieldTag::__principal_component_id)
                                        }
                                        "explainedVariance" => Ok(__FieldTag::__explained_variance),
                                        "explained_variance" => {
                                            Ok(__FieldTag::__explained_variance)
                                        }
                                        "explainedVarianceRatio" => {
                                            Ok(__FieldTag::__explained_variance_ratio)
                                        }
                                        "explained_variance_ratio" => {
                                            Ok(__FieldTag::__explained_variance_ratio)
                                        }
                                        "cumulativeExplainedVarianceRatio" => {
                                            Ok(__FieldTag::__cumulative_explained_variance_ratio)
                                        }
                                        "cumulative_explained_variance_ratio" => {
                                            Ok(__FieldTag::__cumulative_explained_variance_ratio)
                                        }
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = PrincipalComponentInfo;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct PrincipalComponentInfo")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__principal_component_id => {
                                        if !fields.insert(__FieldTag::__principal_component_id) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for principal_component_id",
                                                ),
                                            );
                                        }
                                        struct __With(std::option::Option<wkt::Int64Value>);
                                        impl<'de> serde::de::Deserialize<'de> for __With {
                                            fn deserialize<D>(
                                                deserializer: D,
                                            ) -> std::result::Result<Self, D::Error>
                                            where
                                                D: serde::de::Deserializer<'de>,
                                            {
                                                serde_with::As::<
                                                    std::option::Option<wkt::internal::I64>,
                                                >::deserialize(
                                                    deserializer
                                                )
                                                .map(__With)
                                            }
                                        }
                                        result.principal_component_id =
                                            map.next_value::<__With>()?.0;
                                    }
                                    __FieldTag::__explained_variance => {
                                        if !fields.insert(__FieldTag::__explained_variance) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for explained_variance",
                                                ),
                                            );
                                        }
                                        struct __With(std::option::Option<wkt::DoubleValue>);
                                        impl<'de> serde::de::Deserialize<'de> for __With {
                                            fn deserialize<D>(
                                                deserializer: D,
                                            ) -> std::result::Result<Self, D::Error>
                                            where
                                                D: serde::de::Deserializer<'de>,
                                            {
                                                serde_with::As::<
                                                    std::option::Option<wkt::internal::F64>,
                                                >::deserialize(
                                                    deserializer
                                                )
                                                .map(__With)
                                            }
                                        }
                                        result.explained_variance = map.next_value::<__With>()?.0;
                                    }
                                    __FieldTag::__explained_variance_ratio => {
                                        if !fields.insert(__FieldTag::__explained_variance_ratio) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for explained_variance_ratio",
                                                ),
                                            );
                                        }
                                        struct __With(std::option::Option<wkt::DoubleValue>);
                                        impl<'de> serde::de::Deserialize<'de> for __With {
                                            fn deserialize<D>(
                                                deserializer: D,
                                            ) -> std::result::Result<Self, D::Error>
                                            where
                                                D: serde::de::Deserializer<'de>,
                                            {
                                                serde_with::As::<
                                                    std::option::Option<wkt::internal::F64>,
                                                >::deserialize(
                                                    deserializer
                                                )
                                                .map(__With)
                                            }
                                        }
                                        result.explained_variance_ratio =
                                            map.next_value::<__With>()?.0;
                                    }
                                    __FieldTag::__cumulative_explained_variance_ratio => {
                                        if !fields.insert(
                                            __FieldTag::__cumulative_explained_variance_ratio,
                                        ) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for cumulative_explained_variance_ratio",
                                                ),
                                            );
                                        }
                                        struct __With(std::option::Option<wkt::DoubleValue>);
                                        impl<'de> serde::de::Deserialize<'de> for __With {
                                            fn deserialize<D>(
                                                deserializer: D,
                                            ) -> std::result::Result<Self, D::Error>
                                            where
                                                D: serde::de::Deserializer<'de>,
                                            {
                                                serde_with::As::<
                                                    std::option::Option<wkt::internal::F64>,
                                                >::deserialize(
                                                    deserializer
                                                )
                                                .map(__With)
                                            }
                                        }
                                        result.cumulative_explained_variance_ratio =
                                            map.next_value::<__With>()?.0;
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for PrincipalComponentInfo {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if self.principal_component_id.is_some() {
                        struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
                        impl<'a> serde::ser::Serialize for __With<'a> {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::ser::Serializer,
                            {
                                serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                                    self.0, serializer,
                                )
                            }
                        }
                        state.serialize_entry(
                            "principalComponentId",
                            &__With(&self.principal_component_id),
                        )?;
                    }
                    if self.explained_variance.is_some() {
                        struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
                        impl<'a> serde::ser::Serialize for __With<'a> {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::ser::Serializer,
                            {
                                serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                                    self.0, serializer,
                                )
                            }
                        }
                        state.serialize_entry(
                            "explainedVariance",
                            &__With(&self.explained_variance),
                        )?;
                    }
                    if self.explained_variance_ratio.is_some() {
                        struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
                        impl<'a> serde::ser::Serialize for __With<'a> {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::ser::Serializer,
                            {
                                serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                                    self.0, serializer,
                                )
                            }
                        }
                        state.serialize_entry(
                            "explainedVarianceRatio",
                            &__With(&self.explained_variance_ratio),
                        )?;
                    }
                    if self.cumulative_explained_variance_ratio.is_some() {
                        struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
                        impl<'a> serde::ser::Serialize for __With<'a> {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::ser::Serializer,
                            {
                                serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                                    self.0, serializer,
                                )
                            }
                        }
                        state.serialize_entry(
                            "cumulativeExplainedVarianceRatio",
                            &__With(&self.cumulative_explained_variance_ratio),
                        )?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }
        }
    }

    /// Search space for a double hyperparameter.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DoubleHparamSearchSpace {
        /// Search space.
        pub search_space:
            std::option::Option<crate::model::model::double_hparam_search_space::SearchSpace>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DoubleHparamSearchSpace {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [search_space][crate::model::model::DoubleHparamSearchSpace::search_space].
        ///
        /// Note that all the setters affecting `search_space` are mutually
        /// exclusive.
        pub fn set_search_space<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::model::double_hparam_search_space::SearchSpace,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.search_space = v.into();
            self
        }

        /// The value of [search_space][crate::model::model::DoubleHparamSearchSpace::search_space]
        /// if it holds a `Range`, `None` if the field is not set or
        /// holds a different branch.
        pub fn range(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::model::double_hparam_search_space::DoubleRange>,
        > {
            #[allow(unreachable_patterns)]
            self.search_space.as_ref().and_then(|v| match v {
                crate::model::model::double_hparam_search_space::SearchSpace::Range(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [search_space][crate::model::model::DoubleHparamSearchSpace::search_space]
        /// to hold a `Range`.
        ///
        /// Note that all the setters affecting `search_space` are
        /// mutually exclusive.
        pub fn set_range<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::model::double_hparam_search_space::DoubleRange>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.search_space = std::option::Option::Some(
                crate::model::model::double_hparam_search_space::SearchSpace::Range(v.into()),
            );
            self
        }

        /// The value of [search_space][crate::model::model::DoubleHparamSearchSpace::search_space]
        /// if it holds a `Candidates`, `None` if the field is not set or
        /// holds a different branch.
        pub fn candidates(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::model::double_hparam_search_space::DoubleCandidates>,
        > {
            #[allow(unreachable_patterns)]
            self.search_space.as_ref().and_then(|v| match v {
                crate::model::model::double_hparam_search_space::SearchSpace::Candidates(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [search_space][crate::model::model::DoubleHparamSearchSpace::search_space]
        /// to hold a `Candidates`.
        ///
        /// Note that all the setters affecting `search_space` are
        /// mutually exclusive.
        pub fn set_candidates<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::model::double_hparam_search_space::DoubleCandidates,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.search_space = std::option::Option::Some(
                crate::model::model::double_hparam_search_space::SearchSpace::Candidates(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for DoubleHparamSearchSpace {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.DoubleHparamSearchSpace"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for DoubleHparamSearchSpace {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __range,
                __candidates,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for DoubleHparamSearchSpace")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "range" => Ok(__FieldTag::__range),
                                "candidates" => Ok(__FieldTag::__candidates),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = DoubleHparamSearchSpace;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct DoubleHparamSearchSpace")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__range => {
                                if !fields.insert(__FieldTag::__range) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for range",
                                    ));
                                }
                                if result.search_space.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `search_space`, a oneof with full ID .google.cloud.bigquery.v2.Model.DoubleHparamSearchSpace.range, latest field was range",
                                    ));
                                }
                                result.search_space = std::option::Option::Some(
                                    crate::model::model::double_hparam_search_space::SearchSpace::Range(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::model::double_hparam_search_space::DoubleRange>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__candidates => {
                                if !fields.insert(__FieldTag::__candidates) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for candidates",
                                    ));
                                }
                                if result.search_space.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `search_space`, a oneof with full ID .google.cloud.bigquery.v2.Model.DoubleHparamSearchSpace.candidates, latest field was candidates",
                                    ));
                                }
                                result.search_space = std::option::Option::Some(
                                    crate::model::model::double_hparam_search_space::SearchSpace::Candidates(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::model::double_hparam_search_space::DoubleCandidates>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for DoubleHparamSearchSpace {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.range() {
                state.serialize_entry("range", value)?;
            }
            if let Some(value) = self.candidates() {
                state.serialize_entry("candidates", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [DoubleHparamSearchSpace].
    pub mod double_hparam_search_space {
        #[allow(unused_imports)]
        use super::*;

        /// Range of a double hyperparameter.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct DoubleRange {
            /// Min value of the double parameter.
            pub min: std::option::Option<wkt::DoubleValue>,

            /// Max value of the double parameter.
            pub max: std::option::Option<wkt::DoubleValue>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl DoubleRange {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [min][crate::model::model::double_hparam_search_space::DoubleRange::min].
            pub fn set_min<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::DoubleValue>,
            {
                self.min = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [min][crate::model::model::double_hparam_search_space::DoubleRange::min].
            pub fn set_or_clear_min<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::DoubleValue>,
            {
                self.min = v.map(|x| x.into());
                self
            }

            /// Sets the value of [max][crate::model::model::double_hparam_search_space::DoubleRange::max].
            pub fn set_max<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::DoubleValue>,
            {
                self.max = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [max][crate::model::model::double_hparam_search_space::DoubleRange::max].
            pub fn set_or_clear_max<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::DoubleValue>,
            {
                self.max = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for DoubleRange {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.bigquery.v2.Model.DoubleHparamSearchSpace.DoubleRange"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for DoubleRange {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __min,
                    __max,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for DoubleRange")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "min" => Ok(__FieldTag::__min),
                                    "max" => Ok(__FieldTag::__max),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = DoubleRange;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct DoubleRange")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__min => {
                                    if !fields.insert(__FieldTag::__min) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for min"),
                                        );
                                    }
                                    struct __With(std::option::Option<wkt::DoubleValue>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.min = map.next_value::<__With>()?.0;
                                }
                                __FieldTag::__max => {
                                    if !fields.insert(__FieldTag::__max) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for max"),
                                        );
                                    }
                                    struct __With(std::option::Option<wkt::DoubleValue>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.max = map.next_value::<__With>()?.0;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for DoubleRange {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if self.min.is_some() {
                    struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                                self.0, serializer,
                            )
                        }
                    }
                    state.serialize_entry("min", &__With(&self.min))?;
                }
                if self.max.is_some() {
                    struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                                self.0, serializer,
                            )
                        }
                    }
                    state.serialize_entry("max", &__With(&self.max))?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Discrete candidates of a double hyperparameter.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct DoubleCandidates {
            /// Candidates for the double parameter in increasing order.
            pub candidates: std::vec::Vec<wkt::DoubleValue>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl DoubleCandidates {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [candidates][crate::model::model::double_hparam_search_space::DoubleCandidates::candidates].
            pub fn set_candidates<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<wkt::DoubleValue>,
            {
                use std::iter::Iterator;
                self.candidates = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for DoubleCandidates {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.bigquery.v2.Model.DoubleHparamSearchSpace.DoubleCandidates"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for DoubleCandidates {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __candidates,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for DoubleCandidates")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "candidates" => Ok(__FieldTag::__candidates),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = DoubleCandidates;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct DoubleCandidates")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__candidates => {
                                    if !fields.insert(__FieldTag::__candidates) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for candidates",
                                            ),
                                        );
                                    }
                                    struct __With(
                                        std::option::Option<std::vec::Vec<wkt::DoubleValue>>,
                                    );
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::<
                                                std::option::Option<
                                                    std::vec::Vec<wkt::internal::F64>,
                                                >,
                                            >::deserialize(
                                                deserializer
                                            )
                                            .map(__With)
                                        }
                                    }
                                    result.candidates =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for DoubleCandidates {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.candidates.is_empty() {
                    struct __With<'a>(&'a std::vec::Vec<wkt::DoubleValue>);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<std::vec::Vec<wkt::internal::F64>>::serialize(
                                self.0, serializer,
                            )
                        }
                    }
                    state.serialize_entry("candidates", &__With(&self.candidates))?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Search space.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum SearchSpace {
            /// Range of the double hyperparameter.
            Range(std::boxed::Box<crate::model::model::double_hparam_search_space::DoubleRange>),
            /// Candidates of the double hyperparameter.
            Candidates(
                std::boxed::Box<crate::model::model::double_hparam_search_space::DoubleCandidates>,
            ),
        }
    }

    /// Search space for an int hyperparameter.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct IntHparamSearchSpace {
        /// Search space.
        pub search_space:
            std::option::Option<crate::model::model::int_hparam_search_space::SearchSpace>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl IntHparamSearchSpace {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [search_space][crate::model::model::IntHparamSearchSpace::search_space].
        ///
        /// Note that all the setters affecting `search_space` are mutually
        /// exclusive.
        pub fn set_search_space<
            T: std::convert::Into<
                    std::option::Option<crate::model::model::int_hparam_search_space::SearchSpace>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.search_space = v.into();
            self
        }

        /// The value of [search_space][crate::model::model::IntHparamSearchSpace::search_space]
        /// if it holds a `Range`, `None` if the field is not set or
        /// holds a different branch.
        pub fn range(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::model::int_hparam_search_space::IntRange>,
        > {
            #[allow(unreachable_patterns)]
            self.search_space.as_ref().and_then(|v| match v {
                crate::model::model::int_hparam_search_space::SearchSpace::Range(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [search_space][crate::model::model::IntHparamSearchSpace::search_space]
        /// to hold a `Range`.
        ///
        /// Note that all the setters affecting `search_space` are
        /// mutually exclusive.
        pub fn set_range<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::model::int_hparam_search_space::IntRange>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.search_space = std::option::Option::Some(
                crate::model::model::int_hparam_search_space::SearchSpace::Range(v.into()),
            );
            self
        }

        /// The value of [search_space][crate::model::model::IntHparamSearchSpace::search_space]
        /// if it holds a `Candidates`, `None` if the field is not set or
        /// holds a different branch.
        pub fn candidates(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::model::int_hparam_search_space::IntCandidates>,
        > {
            #[allow(unreachable_patterns)]
            self.search_space.as_ref().and_then(|v| match v {
                crate::model::model::int_hparam_search_space::SearchSpace::Candidates(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [search_space][crate::model::model::IntHparamSearchSpace::search_space]
        /// to hold a `Candidates`.
        ///
        /// Note that all the setters affecting `search_space` are
        /// mutually exclusive.
        pub fn set_candidates<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::model::int_hparam_search_space::IntCandidates>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.search_space = std::option::Option::Some(
                crate::model::model::int_hparam_search_space::SearchSpace::Candidates(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for IntHparamSearchSpace {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.IntHparamSearchSpace"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for IntHparamSearchSpace {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __range,
                __candidates,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for IntHparamSearchSpace")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "range" => Ok(__FieldTag::__range),
                                "candidates" => Ok(__FieldTag::__candidates),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = IntHparamSearchSpace;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct IntHparamSearchSpace")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__range => {
                                if !fields.insert(__FieldTag::__range) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for range",
                                    ));
                                }
                                if result.search_space.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `search_space`, a oneof with full ID .google.cloud.bigquery.v2.Model.IntHparamSearchSpace.range, latest field was range",
                                    ));
                                }
                                result.search_space = std::option::Option::Some(
                                    crate::model::model::int_hparam_search_space::SearchSpace::Range(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::model::int_hparam_search_space::IntRange>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__candidates => {
                                if !fields.insert(__FieldTag::__candidates) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for candidates",
                                    ));
                                }
                                if result.search_space.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `search_space`, a oneof with full ID .google.cloud.bigquery.v2.Model.IntHparamSearchSpace.candidates, latest field was candidates",
                                    ));
                                }
                                result.search_space = std::option::Option::Some(
                                    crate::model::model::int_hparam_search_space::SearchSpace::Candidates(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::model::int_hparam_search_space::IntCandidates>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for IntHparamSearchSpace {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.range() {
                state.serialize_entry("range", value)?;
            }
            if let Some(value) = self.candidates() {
                state.serialize_entry("candidates", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [IntHparamSearchSpace].
    pub mod int_hparam_search_space {
        #[allow(unused_imports)]
        use super::*;

        /// Range of an int hyperparameter.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct IntRange {
            /// Min value of the int parameter.
            pub min: std::option::Option<wkt::Int64Value>,

            /// Max value of the int parameter.
            pub max: std::option::Option<wkt::Int64Value>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl IntRange {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [min][crate::model::model::int_hparam_search_space::IntRange::min].
            pub fn set_min<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::Int64Value>,
            {
                self.min = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [min][crate::model::model::int_hparam_search_space::IntRange::min].
            pub fn set_or_clear_min<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::Int64Value>,
            {
                self.min = v.map(|x| x.into());
                self
            }

            /// Sets the value of [max][crate::model::model::int_hparam_search_space::IntRange::max].
            pub fn set_max<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::Int64Value>,
            {
                self.max = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [max][crate::model::model::int_hparam_search_space::IntRange::max].
            pub fn set_or_clear_max<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::Int64Value>,
            {
                self.max = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for IntRange {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.bigquery.v2.Model.IntHparamSearchSpace.IntRange"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for IntRange {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __min,
                    __max,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for IntRange")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "min" => Ok(__FieldTag::__min),
                                    "max" => Ok(__FieldTag::__max),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = IntRange;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct IntRange")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__min => {
                                    if !fields.insert(__FieldTag::__min) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for min"),
                                        );
                                    }
                                    struct __With(std::option::Option<wkt::Int64Value>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.min = map.next_value::<__With>()?.0;
                                }
                                __FieldTag::__max => {
                                    if !fields.insert(__FieldTag::__max) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for max"),
                                        );
                                    }
                                    struct __With(std::option::Option<wkt::Int64Value>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.max = map.next_value::<__With>()?.0;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for IntRange {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if self.min.is_some() {
                    struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                                self.0, serializer,
                            )
                        }
                    }
                    state.serialize_entry("min", &__With(&self.min))?;
                }
                if self.max.is_some() {
                    struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                                self.0, serializer,
                            )
                        }
                    }
                    state.serialize_entry("max", &__With(&self.max))?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Discrete candidates of an int hyperparameter.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct IntCandidates {
            /// Candidates for the int parameter in increasing order.
            pub candidates: std::vec::Vec<wkt::Int64Value>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl IntCandidates {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [candidates][crate::model::model::int_hparam_search_space::IntCandidates::candidates].
            pub fn set_candidates<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<wkt::Int64Value>,
            {
                use std::iter::Iterator;
                self.candidates = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for IntCandidates {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.bigquery.v2.Model.IntHparamSearchSpace.IntCandidates"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for IntCandidates {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __candidates,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for IntCandidates")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "candidates" => Ok(__FieldTag::__candidates),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = IntCandidates;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct IntCandidates")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__candidates => {
                                    if !fields.insert(__FieldTag::__candidates) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for candidates",
                                            ),
                                        );
                                    }
                                    struct __With(
                                        std::option::Option<std::vec::Vec<wkt::Int64Value>>,
                                    );
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::<
                                                std::option::Option<
                                                    std::vec::Vec<wkt::internal::I64>,
                                                >,
                                            >::deserialize(
                                                deserializer
                                            )
                                            .map(__With)
                                        }
                                    }
                                    result.candidates =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for IntCandidates {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.candidates.is_empty() {
                    struct __With<'a>(&'a std::vec::Vec<wkt::Int64Value>);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<std::vec::Vec<wkt::internal::I64>>::serialize(
                                self.0, serializer,
                            )
                        }
                    }
                    state.serialize_entry("candidates", &__With(&self.candidates))?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Search space.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum SearchSpace {
            /// Range of the int hyperparameter.
            Range(std::boxed::Box<crate::model::model::int_hparam_search_space::IntRange>),
            /// Candidates of the int hyperparameter.
            Candidates(
                std::boxed::Box<crate::model::model::int_hparam_search_space::IntCandidates>,
            ),
        }
    }

    /// Search space for string and enum.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct StringHparamSearchSpace {
        /// Canididates for the string or enum parameter in lower case.
        pub candidates: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl StringHparamSearchSpace {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [candidates][crate::model::model::StringHparamSearchSpace::candidates].
        pub fn set_candidates<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.candidates = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for StringHparamSearchSpace {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.StringHparamSearchSpace"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for StringHparamSearchSpace {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __candidates,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for StringHparamSearchSpace")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "candidates" => Ok(__FieldTag::__candidates),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = StringHparamSearchSpace;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct StringHparamSearchSpace")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__candidates => {
                                if !fields.insert(__FieldTag::__candidates) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for candidates",
                                    ));
                                }
                                result.candidates = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for StringHparamSearchSpace {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.candidates.is_empty() {
                state.serialize_entry("candidates", &self.candidates)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Search space for int array.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct IntArrayHparamSearchSpace {
        /// Candidates for the int array parameter.
        pub candidates: std::vec::Vec<crate::model::model::int_array_hparam_search_space::IntArray>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl IntArrayHparamSearchSpace {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [candidates][crate::model::model::IntArrayHparamSearchSpace::candidates].
        pub fn set_candidates<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::model::int_array_hparam_search_space::IntArray>,
        {
            use std::iter::Iterator;
            self.candidates = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for IntArrayHparamSearchSpace {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.IntArrayHparamSearchSpace"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for IntArrayHparamSearchSpace {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __candidates,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for IntArrayHparamSearchSpace")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "candidates" => Ok(__FieldTag::__candidates),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = IntArrayHparamSearchSpace;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct IntArrayHparamSearchSpace")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__candidates => {
                                if !fields.insert(__FieldTag::__candidates) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for candidates",
                                    ));
                                }
                                result.candidates = map.next_value::<std::option::Option<std::vec::Vec<crate::model::model::int_array_hparam_search_space::IntArray>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for IntArrayHparamSearchSpace {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.candidates.is_empty() {
                state.serialize_entry("candidates", &self.candidates)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [IntArrayHparamSearchSpace].
    pub mod int_array_hparam_search_space {
        #[allow(unused_imports)]
        use super::*;

        /// An array of int.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct IntArray {
            /// Elements in the int array.
            pub elements: std::vec::Vec<i64>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl IntArray {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [elements][crate::model::model::int_array_hparam_search_space::IntArray::elements].
            pub fn set_elements<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<i64>,
            {
                use std::iter::Iterator;
                self.elements = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for IntArray {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.bigquery.v2.Model.IntArrayHparamSearchSpace.IntArray"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for IntArray {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __elements,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for IntArray")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "elements" => Ok(__FieldTag::__elements),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = IntArray;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct IntArray")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__elements => {
                                    if !fields.insert(__FieldTag::__elements) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for elements",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<std::vec::Vec<i64>>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::<
                                                std::option::Option<
                                                    std::vec::Vec<wkt::internal::I64>,
                                                >,
                                            >::deserialize(
                                                deserializer
                                            )
                                            .map(__With)
                                        }
                                    }
                                    result.elements =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for IntArray {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.elements.is_empty() {
                    struct __With<'a>(&'a std::vec::Vec<i64>);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<std::vec::Vec<wkt::internal::I64>>::serialize(
                                self.0, serializer,
                            )
                        }
                    }
                    state.serialize_entry("elements", &__With(&self.elements))?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }
    }

    /// Hyperparameter search spaces.
    /// These should be a subset of training_options.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct HparamSearchSpaces {
        /// Learning rate of training jobs.
        pub learn_rate: std::option::Option<crate::model::model::DoubleHparamSearchSpace>,

        /// L1 regularization coefficient.
        pub l1_reg: std::option::Option<crate::model::model::DoubleHparamSearchSpace>,

        /// L2 regularization coefficient.
        pub l2_reg: std::option::Option<crate::model::model::DoubleHparamSearchSpace>,

        /// Number of clusters for k-means.
        pub num_clusters: std::option::Option<crate::model::model::IntHparamSearchSpace>,

        /// Number of latent factors to train on.
        pub num_factors: std::option::Option<crate::model::model::IntHparamSearchSpace>,

        /// Hidden units for neural network models.
        pub hidden_units: std::option::Option<crate::model::model::IntArrayHparamSearchSpace>,

        /// Mini batch sample size.
        pub batch_size: std::option::Option<crate::model::model::IntHparamSearchSpace>,

        /// Dropout probability for dnn model training and boosted tree models
        /// using dart booster.
        pub dropout: std::option::Option<crate::model::model::DoubleHparamSearchSpace>,

        /// Maximum depth of a tree for boosted tree models.
        pub max_tree_depth: std::option::Option<crate::model::model::IntHparamSearchSpace>,

        /// Subsample the training data to grow tree to prevent overfitting for
        /// boosted tree models.
        pub subsample: std::option::Option<crate::model::model::DoubleHparamSearchSpace>,

        /// Minimum split loss for boosted tree models.
        pub min_split_loss: std::option::Option<crate::model::model::DoubleHparamSearchSpace>,

        /// Hyperparameter for matrix factoration when implicit feedback type is
        /// specified.
        pub wals_alpha: std::option::Option<crate::model::model::DoubleHparamSearchSpace>,

        /// Booster type for boosted tree models.
        pub booster_type: std::option::Option<crate::model::model::StringHparamSearchSpace>,

        /// Number of parallel trees for boosted tree models.
        pub num_parallel_tree: std::option::Option<crate::model::model::IntHparamSearchSpace>,

        /// Dart normalization type for boosted tree models.
        pub dart_normalize_type: std::option::Option<crate::model::model::StringHparamSearchSpace>,

        /// Tree construction algorithm for boosted tree models.
        pub tree_method: std::option::Option<crate::model::model::StringHparamSearchSpace>,

        /// Minimum sum of instance weight needed in a child for boosted tree models.
        pub min_tree_child_weight: std::option::Option<crate::model::model::IntHparamSearchSpace>,

        /// Subsample ratio of columns when constructing each tree for boosted tree
        /// models.
        pub colsample_bytree: std::option::Option<crate::model::model::DoubleHparamSearchSpace>,

        /// Subsample ratio of columns for each level for boosted tree models.
        pub colsample_bylevel: std::option::Option<crate::model::model::DoubleHparamSearchSpace>,

        /// Subsample ratio of columns for each node(split) for boosted tree models.
        pub colsample_bynode: std::option::Option<crate::model::model::DoubleHparamSearchSpace>,

        /// Activation functions of neural network models.
        pub activation_fn: std::option::Option<crate::model::model::StringHparamSearchSpace>,

        /// Optimizer of TF models.
        pub optimizer: std::option::Option<crate::model::model::StringHparamSearchSpace>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl HparamSearchSpaces {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [learn_rate][crate::model::model::HparamSearchSpaces::learn_rate].
        pub fn set_learn_rate<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::model::DoubleHparamSearchSpace>,
        {
            self.learn_rate = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [learn_rate][crate::model::model::HparamSearchSpaces::learn_rate].
        pub fn set_or_clear_learn_rate<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::model::DoubleHparamSearchSpace>,
        {
            self.learn_rate = v.map(|x| x.into());
            self
        }

        /// Sets the value of [l1_reg][crate::model::model::HparamSearchSpaces::l1_reg].
        pub fn set_l1_reg<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::model::DoubleHparamSearchSpace>,
        {
            self.l1_reg = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [l1_reg][crate::model::model::HparamSearchSpaces::l1_reg].
        pub fn set_or_clear_l1_reg<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::model::DoubleHparamSearchSpace>,
        {
            self.l1_reg = v.map(|x| x.into());
            self
        }

        /// Sets the value of [l2_reg][crate::model::model::HparamSearchSpaces::l2_reg].
        pub fn set_l2_reg<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::model::DoubleHparamSearchSpace>,
        {
            self.l2_reg = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [l2_reg][crate::model::model::HparamSearchSpaces::l2_reg].
        pub fn set_or_clear_l2_reg<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::model::DoubleHparamSearchSpace>,
        {
            self.l2_reg = v.map(|x| x.into());
            self
        }

        /// Sets the value of [num_clusters][crate::model::model::HparamSearchSpaces::num_clusters].
        pub fn set_num_clusters<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::model::IntHparamSearchSpace>,
        {
            self.num_clusters = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [num_clusters][crate::model::model::HparamSearchSpaces::num_clusters].
        pub fn set_or_clear_num_clusters<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::model::IntHparamSearchSpace>,
        {
            self.num_clusters = v.map(|x| x.into());
            self
        }

        /// Sets the value of [num_factors][crate::model::model::HparamSearchSpaces::num_factors].
        pub fn set_num_factors<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::model::IntHparamSearchSpace>,
        {
            self.num_factors = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [num_factors][crate::model::model::HparamSearchSpaces::num_factors].
        pub fn set_or_clear_num_factors<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::model::IntHparamSearchSpace>,
        {
            self.num_factors = v.map(|x| x.into());
            self
        }

        /// Sets the value of [hidden_units][crate::model::model::HparamSearchSpaces::hidden_units].
        pub fn set_hidden_units<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::model::IntArrayHparamSearchSpace>,
        {
            self.hidden_units = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [hidden_units][crate::model::model::HparamSearchSpaces::hidden_units].
        pub fn set_or_clear_hidden_units<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::model::IntArrayHparamSearchSpace>,
        {
            self.hidden_units = v.map(|x| x.into());
            self
        }

        /// Sets the value of [batch_size][crate::model::model::HparamSearchSpaces::batch_size].
        pub fn set_batch_size<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::model::IntHparamSearchSpace>,
        {
            self.batch_size = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [batch_size][crate::model::model::HparamSearchSpaces::batch_size].
        pub fn set_or_clear_batch_size<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::model::IntHparamSearchSpace>,
        {
            self.batch_size = v.map(|x| x.into());
            self
        }

        /// Sets the value of [dropout][crate::model::model::HparamSearchSpaces::dropout].
        pub fn set_dropout<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::model::DoubleHparamSearchSpace>,
        {
            self.dropout = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [dropout][crate::model::model::HparamSearchSpaces::dropout].
        pub fn set_or_clear_dropout<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::model::DoubleHparamSearchSpace>,
        {
            self.dropout = v.map(|x| x.into());
            self
        }

        /// Sets the value of [max_tree_depth][crate::model::model::HparamSearchSpaces::max_tree_depth].
        pub fn set_max_tree_depth<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::model::IntHparamSearchSpace>,
        {
            self.max_tree_depth = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [max_tree_depth][crate::model::model::HparamSearchSpaces::max_tree_depth].
        pub fn set_or_clear_max_tree_depth<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::model::IntHparamSearchSpace>,
        {
            self.max_tree_depth = v.map(|x| x.into());
            self
        }

        /// Sets the value of [subsample][crate::model::model::HparamSearchSpaces::subsample].
        pub fn set_subsample<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::model::DoubleHparamSearchSpace>,
        {
            self.subsample = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [subsample][crate::model::model::HparamSearchSpaces::subsample].
        pub fn set_or_clear_subsample<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::model::DoubleHparamSearchSpace>,
        {
            self.subsample = v.map(|x| x.into());
            self
        }

        /// Sets the value of [min_split_loss][crate::model::model::HparamSearchSpaces::min_split_loss].
        pub fn set_min_split_loss<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::model::DoubleHparamSearchSpace>,
        {
            self.min_split_loss = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [min_split_loss][crate::model::model::HparamSearchSpaces::min_split_loss].
        pub fn set_or_clear_min_split_loss<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::model::DoubleHparamSearchSpace>,
        {
            self.min_split_loss = v.map(|x| x.into());
            self
        }

        /// Sets the value of [wals_alpha][crate::model::model::HparamSearchSpaces::wals_alpha].
        pub fn set_wals_alpha<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::model::DoubleHparamSearchSpace>,
        {
            self.wals_alpha = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [wals_alpha][crate::model::model::HparamSearchSpaces::wals_alpha].
        pub fn set_or_clear_wals_alpha<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::model::DoubleHparamSearchSpace>,
        {
            self.wals_alpha = v.map(|x| x.into());
            self
        }

        /// Sets the value of [booster_type][crate::model::model::HparamSearchSpaces::booster_type].
        pub fn set_booster_type<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::model::StringHparamSearchSpace>,
        {
            self.booster_type = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [booster_type][crate::model::model::HparamSearchSpaces::booster_type].
        pub fn set_or_clear_booster_type<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::model::StringHparamSearchSpace>,
        {
            self.booster_type = v.map(|x| x.into());
            self
        }

        /// Sets the value of [num_parallel_tree][crate::model::model::HparamSearchSpaces::num_parallel_tree].
        pub fn set_num_parallel_tree<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::model::IntHparamSearchSpace>,
        {
            self.num_parallel_tree = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [num_parallel_tree][crate::model::model::HparamSearchSpaces::num_parallel_tree].
        pub fn set_or_clear_num_parallel_tree<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::model::IntHparamSearchSpace>,
        {
            self.num_parallel_tree = v.map(|x| x.into());
            self
        }

        /// Sets the value of [dart_normalize_type][crate::model::model::HparamSearchSpaces::dart_normalize_type].
        pub fn set_dart_normalize_type<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::model::StringHparamSearchSpace>,
        {
            self.dart_normalize_type = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [dart_normalize_type][crate::model::model::HparamSearchSpaces::dart_normalize_type].
        pub fn set_or_clear_dart_normalize_type<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::model::StringHparamSearchSpace>,
        {
            self.dart_normalize_type = v.map(|x| x.into());
            self
        }

        /// Sets the value of [tree_method][crate::model::model::HparamSearchSpaces::tree_method].
        pub fn set_tree_method<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::model::StringHparamSearchSpace>,
        {
            self.tree_method = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [tree_method][crate::model::model::HparamSearchSpaces::tree_method].
        pub fn set_or_clear_tree_method<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::model::StringHparamSearchSpace>,
        {
            self.tree_method = v.map(|x| x.into());
            self
        }

        /// Sets the value of [min_tree_child_weight][crate::model::model::HparamSearchSpaces::min_tree_child_weight].
        pub fn set_min_tree_child_weight<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::model::IntHparamSearchSpace>,
        {
            self.min_tree_child_weight = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [min_tree_child_weight][crate::model::model::HparamSearchSpaces::min_tree_child_weight].
        pub fn set_or_clear_min_tree_child_weight<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::model::IntHparamSearchSpace>,
        {
            self.min_tree_child_weight = v.map(|x| x.into());
            self
        }

        /// Sets the value of [colsample_bytree][crate::model::model::HparamSearchSpaces::colsample_bytree].
        pub fn set_colsample_bytree<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::model::DoubleHparamSearchSpace>,
        {
            self.colsample_bytree = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [colsample_bytree][crate::model::model::HparamSearchSpaces::colsample_bytree].
        pub fn set_or_clear_colsample_bytree<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::model::DoubleHparamSearchSpace>,
        {
            self.colsample_bytree = v.map(|x| x.into());
            self
        }

        /// Sets the value of [colsample_bylevel][crate::model::model::HparamSearchSpaces::colsample_bylevel].
        pub fn set_colsample_bylevel<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::model::DoubleHparamSearchSpace>,
        {
            self.colsample_bylevel = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [colsample_bylevel][crate::model::model::HparamSearchSpaces::colsample_bylevel].
        pub fn set_or_clear_colsample_bylevel<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::model::DoubleHparamSearchSpace>,
        {
            self.colsample_bylevel = v.map(|x| x.into());
            self
        }

        /// Sets the value of [colsample_bynode][crate::model::model::HparamSearchSpaces::colsample_bynode].
        pub fn set_colsample_bynode<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::model::DoubleHparamSearchSpace>,
        {
            self.colsample_bynode = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [colsample_bynode][crate::model::model::HparamSearchSpaces::colsample_bynode].
        pub fn set_or_clear_colsample_bynode<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::model::DoubleHparamSearchSpace>,
        {
            self.colsample_bynode = v.map(|x| x.into());
            self
        }

        /// Sets the value of [activation_fn][crate::model::model::HparamSearchSpaces::activation_fn].
        pub fn set_activation_fn<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::model::StringHparamSearchSpace>,
        {
            self.activation_fn = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [activation_fn][crate::model::model::HparamSearchSpaces::activation_fn].
        pub fn set_or_clear_activation_fn<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::model::StringHparamSearchSpace>,
        {
            self.activation_fn = v.map(|x| x.into());
            self
        }

        /// Sets the value of [optimizer][crate::model::model::HparamSearchSpaces::optimizer].
        pub fn set_optimizer<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::model::StringHparamSearchSpace>,
        {
            self.optimizer = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [optimizer][crate::model::model::HparamSearchSpaces::optimizer].
        pub fn set_or_clear_optimizer<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::model::StringHparamSearchSpace>,
        {
            self.optimizer = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for HparamSearchSpaces {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.HparamSearchSpaces"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for HparamSearchSpaces {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __learn_rate,
                __l1_reg,
                __l2_reg,
                __num_clusters,
                __num_factors,
                __hidden_units,
                __batch_size,
                __dropout,
                __max_tree_depth,
                __subsample,
                __min_split_loss,
                __wals_alpha,
                __booster_type,
                __num_parallel_tree,
                __dart_normalize_type,
                __tree_method,
                __min_tree_child_weight,
                __colsample_bytree,
                __colsample_bylevel,
                __colsample_bynode,
                __activation_fn,
                __optimizer,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for HparamSearchSpaces")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "learnRate" => Ok(__FieldTag::__learn_rate),
                                "learn_rate" => Ok(__FieldTag::__learn_rate),
                                "l1Reg" => Ok(__FieldTag::__l1_reg),
                                "l1_reg" => Ok(__FieldTag::__l1_reg),
                                "l2Reg" => Ok(__FieldTag::__l2_reg),
                                "l2_reg" => Ok(__FieldTag::__l2_reg),
                                "numClusters" => Ok(__FieldTag::__num_clusters),
                                "num_clusters" => Ok(__FieldTag::__num_clusters),
                                "numFactors" => Ok(__FieldTag::__num_factors),
                                "num_factors" => Ok(__FieldTag::__num_factors),
                                "hiddenUnits" => Ok(__FieldTag::__hidden_units),
                                "hidden_units" => Ok(__FieldTag::__hidden_units),
                                "batchSize" => Ok(__FieldTag::__batch_size),
                                "batch_size" => Ok(__FieldTag::__batch_size),
                                "dropout" => Ok(__FieldTag::__dropout),
                                "maxTreeDepth" => Ok(__FieldTag::__max_tree_depth),
                                "max_tree_depth" => Ok(__FieldTag::__max_tree_depth),
                                "subsample" => Ok(__FieldTag::__subsample),
                                "minSplitLoss" => Ok(__FieldTag::__min_split_loss),
                                "min_split_loss" => Ok(__FieldTag::__min_split_loss),
                                "walsAlpha" => Ok(__FieldTag::__wals_alpha),
                                "wals_alpha" => Ok(__FieldTag::__wals_alpha),
                                "boosterType" => Ok(__FieldTag::__booster_type),
                                "booster_type" => Ok(__FieldTag::__booster_type),
                                "numParallelTree" => Ok(__FieldTag::__num_parallel_tree),
                                "num_parallel_tree" => Ok(__FieldTag::__num_parallel_tree),
                                "dartNormalizeType" => Ok(__FieldTag::__dart_normalize_type),
                                "dart_normalize_type" => Ok(__FieldTag::__dart_normalize_type),
                                "treeMethod" => Ok(__FieldTag::__tree_method),
                                "tree_method" => Ok(__FieldTag::__tree_method),
                                "minTreeChildWeight" => Ok(__FieldTag::__min_tree_child_weight),
                                "min_tree_child_weight" => Ok(__FieldTag::__min_tree_child_weight),
                                "colsampleBytree" => Ok(__FieldTag::__colsample_bytree),
                                "colsample_bytree" => Ok(__FieldTag::__colsample_bytree),
                                "colsampleBylevel" => Ok(__FieldTag::__colsample_bylevel),
                                "colsample_bylevel" => Ok(__FieldTag::__colsample_bylevel),
                                "colsampleBynode" => Ok(__FieldTag::__colsample_bynode),
                                "colsample_bynode" => Ok(__FieldTag::__colsample_bynode),
                                "activationFn" => Ok(__FieldTag::__activation_fn),
                                "activation_fn" => Ok(__FieldTag::__activation_fn),
                                "optimizer" => Ok(__FieldTag::__optimizer),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = HparamSearchSpaces;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct HparamSearchSpaces")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__learn_rate => {
                                if !fields.insert(__FieldTag::__learn_rate) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for learn_rate",
                                    ));
                                }
                                result.learn_rate = map.next_value::<std::option::Option<
                                    crate::model::model::DoubleHparamSearchSpace,
                                >>()?;
                            }
                            __FieldTag::__l1_reg => {
                                if !fields.insert(__FieldTag::__l1_reg) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for l1_reg",
                                    ));
                                }
                                result.l1_reg = map.next_value::<std::option::Option<
                                    crate::model::model::DoubleHparamSearchSpace,
                                >>()?;
                            }
                            __FieldTag::__l2_reg => {
                                if !fields.insert(__FieldTag::__l2_reg) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for l2_reg",
                                    ));
                                }
                                result.l2_reg = map.next_value::<std::option::Option<
                                    crate::model::model::DoubleHparamSearchSpace,
                                >>()?;
                            }
                            __FieldTag::__num_clusters => {
                                if !fields.insert(__FieldTag::__num_clusters) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for num_clusters",
                                    ));
                                }
                                result.num_clusters = map.next_value::<std::option::Option<
                                    crate::model::model::IntHparamSearchSpace,
                                >>()?;
                            }
                            __FieldTag::__num_factors => {
                                if !fields.insert(__FieldTag::__num_factors) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for num_factors",
                                    ));
                                }
                                result.num_factors = map.next_value::<std::option::Option<
                                    crate::model::model::IntHparamSearchSpace,
                                >>()?;
                            }
                            __FieldTag::__hidden_units => {
                                if !fields.insert(__FieldTag::__hidden_units) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for hidden_units",
                                    ));
                                }
                                result.hidden_units = map.next_value::<std::option::Option<
                                    crate::model::model::IntArrayHparamSearchSpace,
                                >>()?;
                            }
                            __FieldTag::__batch_size => {
                                if !fields.insert(__FieldTag::__batch_size) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for batch_size",
                                    ));
                                }
                                result.batch_size = map.next_value::<std::option::Option<
                                    crate::model::model::IntHparamSearchSpace,
                                >>()?;
                            }
                            __FieldTag::__dropout => {
                                if !fields.insert(__FieldTag::__dropout) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for dropout",
                                    ));
                                }
                                result.dropout = map.next_value::<std::option::Option<
                                    crate::model::model::DoubleHparamSearchSpace,
                                >>()?;
                            }
                            __FieldTag::__max_tree_depth => {
                                if !fields.insert(__FieldTag::__max_tree_depth) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for max_tree_depth",
                                    ));
                                }
                                result.max_tree_depth = map.next_value::<std::option::Option<
                                    crate::model::model::IntHparamSearchSpace,
                                >>()?;
                            }
                            __FieldTag::__subsample => {
                                if !fields.insert(__FieldTag::__subsample) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for subsample",
                                    ));
                                }
                                result.subsample = map.next_value::<std::option::Option<
                                    crate::model::model::DoubleHparamSearchSpace,
                                >>()?;
                            }
                            __FieldTag::__min_split_loss => {
                                if !fields.insert(__FieldTag::__min_split_loss) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for min_split_loss",
                                    ));
                                }
                                result.min_split_loss = map.next_value::<std::option::Option<
                                    crate::model::model::DoubleHparamSearchSpace,
                                >>()?;
                            }
                            __FieldTag::__wals_alpha => {
                                if !fields.insert(__FieldTag::__wals_alpha) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for wals_alpha",
                                    ));
                                }
                                result.wals_alpha = map.next_value::<std::option::Option<
                                    crate::model::model::DoubleHparamSearchSpace,
                                >>()?;
                            }
                            __FieldTag::__booster_type => {
                                if !fields.insert(__FieldTag::__booster_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for booster_type",
                                    ));
                                }
                                result.booster_type = map.next_value::<std::option::Option<
                                    crate::model::model::StringHparamSearchSpace,
                                >>()?;
                            }
                            __FieldTag::__num_parallel_tree => {
                                if !fields.insert(__FieldTag::__num_parallel_tree) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for num_parallel_tree",
                                    ));
                                }
                                result.num_parallel_tree = map
                                    .next_value::<std::option::Option<
                                        crate::model::model::IntHparamSearchSpace,
                                    >>()?;
                            }
                            __FieldTag::__dart_normalize_type => {
                                if !fields.insert(__FieldTag::__dart_normalize_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for dart_normalize_type",
                                    ));
                                }
                                result.dart_normalize_type = map
                                    .next_value::<std::option::Option<
                                        crate::model::model::StringHparamSearchSpace,
                                    >>()?;
                            }
                            __FieldTag::__tree_method => {
                                if !fields.insert(__FieldTag::__tree_method) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for tree_method",
                                    ));
                                }
                                result.tree_method = map.next_value::<std::option::Option<
                                    crate::model::model::StringHparamSearchSpace,
                                >>()?;
                            }
                            __FieldTag::__min_tree_child_weight => {
                                if !fields.insert(__FieldTag::__min_tree_child_weight) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for min_tree_child_weight",
                                    ));
                                }
                                result.min_tree_child_weight = map
                                    .next_value::<std::option::Option<
                                        crate::model::model::IntHparamSearchSpace,
                                    >>()?;
                            }
                            __FieldTag::__colsample_bytree => {
                                if !fields.insert(__FieldTag::__colsample_bytree) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for colsample_bytree",
                                    ));
                                }
                                result.colsample_bytree = map
                                    .next_value::<std::option::Option<
                                        crate::model::model::DoubleHparamSearchSpace,
                                    >>()?;
                            }
                            __FieldTag::__colsample_bylevel => {
                                if !fields.insert(__FieldTag::__colsample_bylevel) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for colsample_bylevel",
                                    ));
                                }
                                result.colsample_bylevel = map
                                    .next_value::<std::option::Option<
                                        crate::model::model::DoubleHparamSearchSpace,
                                    >>()?;
                            }
                            __FieldTag::__colsample_bynode => {
                                if !fields.insert(__FieldTag::__colsample_bynode) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for colsample_bynode",
                                    ));
                                }
                                result.colsample_bynode = map
                                    .next_value::<std::option::Option<
                                        crate::model::model::DoubleHparamSearchSpace,
                                    >>()?;
                            }
                            __FieldTag::__activation_fn => {
                                if !fields.insert(__FieldTag::__activation_fn) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for activation_fn",
                                    ));
                                }
                                result.activation_fn = map.next_value::<std::option::Option<
                                    crate::model::model::StringHparamSearchSpace,
                                >>()?;
                            }
                            __FieldTag::__optimizer => {
                                if !fields.insert(__FieldTag::__optimizer) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for optimizer",
                                    ));
                                }
                                result.optimizer = map.next_value::<std::option::Option<
                                    crate::model::model::StringHparamSearchSpace,
                                >>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for HparamSearchSpaces {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.learn_rate.is_some() {
                state.serialize_entry("learnRate", &self.learn_rate)?;
            }
            if self.l1_reg.is_some() {
                state.serialize_entry("l1Reg", &self.l1_reg)?;
            }
            if self.l2_reg.is_some() {
                state.serialize_entry("l2Reg", &self.l2_reg)?;
            }
            if self.num_clusters.is_some() {
                state.serialize_entry("numClusters", &self.num_clusters)?;
            }
            if self.num_factors.is_some() {
                state.serialize_entry("numFactors", &self.num_factors)?;
            }
            if self.hidden_units.is_some() {
                state.serialize_entry("hiddenUnits", &self.hidden_units)?;
            }
            if self.batch_size.is_some() {
                state.serialize_entry("batchSize", &self.batch_size)?;
            }
            if self.dropout.is_some() {
                state.serialize_entry("dropout", &self.dropout)?;
            }
            if self.max_tree_depth.is_some() {
                state.serialize_entry("maxTreeDepth", &self.max_tree_depth)?;
            }
            if self.subsample.is_some() {
                state.serialize_entry("subsample", &self.subsample)?;
            }
            if self.min_split_loss.is_some() {
                state.serialize_entry("minSplitLoss", &self.min_split_loss)?;
            }
            if self.wals_alpha.is_some() {
                state.serialize_entry("walsAlpha", &self.wals_alpha)?;
            }
            if self.booster_type.is_some() {
                state.serialize_entry("boosterType", &self.booster_type)?;
            }
            if self.num_parallel_tree.is_some() {
                state.serialize_entry("numParallelTree", &self.num_parallel_tree)?;
            }
            if self.dart_normalize_type.is_some() {
                state.serialize_entry("dartNormalizeType", &self.dart_normalize_type)?;
            }
            if self.tree_method.is_some() {
                state.serialize_entry("treeMethod", &self.tree_method)?;
            }
            if self.min_tree_child_weight.is_some() {
                state.serialize_entry("minTreeChildWeight", &self.min_tree_child_weight)?;
            }
            if self.colsample_bytree.is_some() {
                state.serialize_entry("colsampleBytree", &self.colsample_bytree)?;
            }
            if self.colsample_bylevel.is_some() {
                state.serialize_entry("colsampleBylevel", &self.colsample_bylevel)?;
            }
            if self.colsample_bynode.is_some() {
                state.serialize_entry("colsampleBynode", &self.colsample_bynode)?;
            }
            if self.activation_fn.is_some() {
                state.serialize_entry("activationFn", &self.activation_fn)?;
            }
            if self.optimizer.is_some() {
                state.serialize_entry("optimizer", &self.optimizer)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Training info of a trial in [hyperparameter
    /// tuning](https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-hp-tuning-overview)
    /// models.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct HparamTuningTrial {
        /// 1-based index of the trial.
        pub trial_id: i64,

        /// Starting time of the trial.
        pub start_time_ms: i64,

        /// Ending time of the trial.
        pub end_time_ms: i64,

        /// The hyperprameters selected for this trial.
        pub hparams: std::option::Option<crate::model::model::training_run::TrainingOptions>,

        /// Evaluation metrics of this trial calculated on the test data.
        /// Empty in Job API.
        pub evaluation_metrics: std::option::Option<crate::model::model::EvaluationMetrics>,

        /// The status of the trial.
        pub status: crate::model::model::hparam_tuning_trial::TrialStatus,

        /// Error message for FAILED and INFEASIBLE trial.
        pub error_message: std::string::String,

        /// Loss computed on the training data at the end of trial.
        pub training_loss: std::option::Option<wkt::DoubleValue>,

        /// Loss computed on the eval data at the end of trial.
        pub eval_loss: std::option::Option<wkt::DoubleValue>,

        /// Hyperparameter tuning evaluation metrics of this trial calculated on the
        /// eval data. Unlike evaluation_metrics, only the fields corresponding to
        /// the hparam_tuning_objectives are set.
        pub hparam_tuning_evaluation_metrics:
            std::option::Option<crate::model::model::EvaluationMetrics>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl HparamTuningTrial {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [trial_id][crate::model::model::HparamTuningTrial::trial_id].
        pub fn set_trial_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.trial_id = v.into();
            self
        }

        /// Sets the value of [start_time_ms][crate::model::model::HparamTuningTrial::start_time_ms].
        pub fn set_start_time_ms<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.start_time_ms = v.into();
            self
        }

        /// Sets the value of [end_time_ms][crate::model::model::HparamTuningTrial::end_time_ms].
        pub fn set_end_time_ms<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.end_time_ms = v.into();
            self
        }

        /// Sets the value of [hparams][crate::model::model::HparamTuningTrial::hparams].
        pub fn set_hparams<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::model::training_run::TrainingOptions>,
        {
            self.hparams = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [hparams][crate::model::model::HparamTuningTrial::hparams].
        pub fn set_or_clear_hparams<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::model::training_run::TrainingOptions>,
        {
            self.hparams = v.map(|x| x.into());
            self
        }

        /// Sets the value of [evaluation_metrics][crate::model::model::HparamTuningTrial::evaluation_metrics].
        pub fn set_evaluation_metrics<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::model::EvaluationMetrics>,
        {
            self.evaluation_metrics = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [evaluation_metrics][crate::model::model::HparamTuningTrial::evaluation_metrics].
        pub fn set_or_clear_evaluation_metrics<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::model::EvaluationMetrics>,
        {
            self.evaluation_metrics = v.map(|x| x.into());
            self
        }

        /// Sets the value of [status][crate::model::model::HparamTuningTrial::status].
        pub fn set_status<
            T: std::convert::Into<crate::model::model::hparam_tuning_trial::TrialStatus>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.status = v.into();
            self
        }

        /// Sets the value of [error_message][crate::model::model::HparamTuningTrial::error_message].
        pub fn set_error_message<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.error_message = v.into();
            self
        }

        /// Sets the value of [training_loss][crate::model::model::HparamTuningTrial::training_loss].
        pub fn set_training_loss<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::DoubleValue>,
        {
            self.training_loss = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [training_loss][crate::model::model::HparamTuningTrial::training_loss].
        pub fn set_or_clear_training_loss<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::DoubleValue>,
        {
            self.training_loss = v.map(|x| x.into());
            self
        }

        /// Sets the value of [eval_loss][crate::model::model::HparamTuningTrial::eval_loss].
        pub fn set_eval_loss<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::DoubleValue>,
        {
            self.eval_loss = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [eval_loss][crate::model::model::HparamTuningTrial::eval_loss].
        pub fn set_or_clear_eval_loss<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::DoubleValue>,
        {
            self.eval_loss = v.map(|x| x.into());
            self
        }

        /// Sets the value of [hparam_tuning_evaluation_metrics][crate::model::model::HparamTuningTrial::hparam_tuning_evaluation_metrics].
        pub fn set_hparam_tuning_evaluation_metrics<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::model::EvaluationMetrics>,
        {
            self.hparam_tuning_evaluation_metrics = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [hparam_tuning_evaluation_metrics][crate::model::model::HparamTuningTrial::hparam_tuning_evaluation_metrics].
        pub fn set_or_clear_hparam_tuning_evaluation_metrics<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<crate::model::model::EvaluationMetrics>,
        {
            self.hparam_tuning_evaluation_metrics = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for HparamTuningTrial {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Model.HparamTuningTrial"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for HparamTuningTrial {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __trial_id,
                __start_time_ms,
                __end_time_ms,
                __hparams,
                __evaluation_metrics,
                __status,
                __error_message,
                __training_loss,
                __eval_loss,
                __hparam_tuning_evaluation_metrics,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for HparamTuningTrial")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "trialId" => Ok(__FieldTag::__trial_id),
                                "trial_id" => Ok(__FieldTag::__trial_id),
                                "startTimeMs" => Ok(__FieldTag::__start_time_ms),
                                "start_time_ms" => Ok(__FieldTag::__start_time_ms),
                                "endTimeMs" => Ok(__FieldTag::__end_time_ms),
                                "end_time_ms" => Ok(__FieldTag::__end_time_ms),
                                "hparams" => Ok(__FieldTag::__hparams),
                                "evaluationMetrics" => Ok(__FieldTag::__evaluation_metrics),
                                "evaluation_metrics" => Ok(__FieldTag::__evaluation_metrics),
                                "status" => Ok(__FieldTag::__status),
                                "errorMessage" => Ok(__FieldTag::__error_message),
                                "error_message" => Ok(__FieldTag::__error_message),
                                "trainingLoss" => Ok(__FieldTag::__training_loss),
                                "training_loss" => Ok(__FieldTag::__training_loss),
                                "evalLoss" => Ok(__FieldTag::__eval_loss),
                                "eval_loss" => Ok(__FieldTag::__eval_loss),
                                "hparamTuningEvaluationMetrics" => {
                                    Ok(__FieldTag::__hparam_tuning_evaluation_metrics)
                                }
                                "hparam_tuning_evaluation_metrics" => {
                                    Ok(__FieldTag::__hparam_tuning_evaluation_metrics)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = HparamTuningTrial;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct HparamTuningTrial")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__trial_id => {
                                if !fields.insert(__FieldTag::__trial_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for trial_id",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.trial_id = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__start_time_ms => {
                                if !fields.insert(__FieldTag::__start_time_ms) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for start_time_ms",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.start_time_ms =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__end_time_ms => {
                                if !fields.insert(__FieldTag::__end_time_ms) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for end_time_ms",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.end_time_ms =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__hparams => {
                                if !fields.insert(__FieldTag::__hparams) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for hparams",
                                    ));
                                }
                                result.hparams = map.next_value::<std::option::Option<
                                    crate::model::model::training_run::TrainingOptions,
                                >>()?;
                            }
                            __FieldTag::__evaluation_metrics => {
                                if !fields.insert(__FieldTag::__evaluation_metrics) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for evaluation_metrics",
                                    ));
                                }
                                result.evaluation_metrics = map.next_value::<std::option::Option<crate::model::model::EvaluationMetrics>>()?
                                    ;
                            }
                            __FieldTag::__status => {
                                if !fields.insert(__FieldTag::__status) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for status",
                                    ));
                                }
                                result.status = map
                                    .next_value::<std::option::Option<
                                        crate::model::model::hparam_tuning_trial::TrialStatus,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__error_message => {
                                if !fields.insert(__FieldTag::__error_message) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for error_message",
                                    ));
                                }
                                result.error_message = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__training_loss => {
                                if !fields.insert(__FieldTag::__training_loss) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for training_loss",
                                    ));
                                }
                                struct __With(std::option::Option<wkt::DoubleValue>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.training_loss = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::__eval_loss => {
                                if !fields.insert(__FieldTag::__eval_loss) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for eval_loss",
                                    ));
                                }
                                struct __With(std::option::Option<wkt::DoubleValue>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.eval_loss = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::__hparam_tuning_evaluation_metrics => {
                                if !fields.insert(__FieldTag::__hparam_tuning_evaluation_metrics) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for hparam_tuning_evaluation_metrics",
                                    ));
                                }
                                result.hparam_tuning_evaluation_metrics = map.next_value::<std::option::Option<crate::model::model::EvaluationMetrics>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for HparamTuningTrial {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.trial_id) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("trialId", &__With(&self.trial_id))?;
            }
            if !wkt::internal::is_default(&self.start_time_ms) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("startTimeMs", &__With(&self.start_time_ms))?;
            }
            if !wkt::internal::is_default(&self.end_time_ms) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("endTimeMs", &__With(&self.end_time_ms))?;
            }
            if self.hparams.is_some() {
                state.serialize_entry("hparams", &self.hparams)?;
            }
            if self.evaluation_metrics.is_some() {
                state.serialize_entry("evaluationMetrics", &self.evaluation_metrics)?;
            }
            if !wkt::internal::is_default(&self.status) {
                state.serialize_entry("status", &self.status)?;
            }
            if !self.error_message.is_empty() {
                state.serialize_entry("errorMessage", &self.error_message)?;
            }
            if self.training_loss.is_some() {
                struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("trainingLoss", &__With(&self.training_loss))?;
            }
            if self.eval_loss.is_some() {
                struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("evalLoss", &__With(&self.eval_loss))?;
            }
            if self.hparam_tuning_evaluation_metrics.is_some() {
                state.serialize_entry(
                    "hparamTuningEvaluationMetrics",
                    &self.hparam_tuning_evaluation_metrics,
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [HparamTuningTrial].
    pub mod hparam_tuning_trial {
        #[allow(unused_imports)]
        use super::*;

        /// Current status of the trial.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum TrialStatus {
            /// Default value.
            Unspecified,
            /// Scheduled but not started.
            NotStarted,
            /// Running state.
            Running,
            /// The trial succeeded.
            Succeeded,
            /// The trial failed.
            Failed,
            /// The trial is infeasible due to the invalid params.
            Infeasible,
            /// Trial stopped early because it's not promising.
            StoppedEarly,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [TrialStatus::value] or
            /// [TrialStatus::name].
            UnknownValue(trial_status::UnknownValue),
        }

        #[doc(hidden)]
        pub mod trial_status {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl TrialStatus {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::NotStarted => std::option::Option::Some(1),
                    Self::Running => std::option::Option::Some(2),
                    Self::Succeeded => std::option::Option::Some(3),
                    Self::Failed => std::option::Option::Some(4),
                    Self::Infeasible => std::option::Option::Some(5),
                    Self::StoppedEarly => std::option::Option::Some(6),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("TRIAL_STATUS_UNSPECIFIED"),
                    Self::NotStarted => std::option::Option::Some("NOT_STARTED"),
                    Self::Running => std::option::Option::Some("RUNNING"),
                    Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                    Self::Failed => std::option::Option::Some("FAILED"),
                    Self::Infeasible => std::option::Option::Some("INFEASIBLE"),
                    Self::StoppedEarly => std::option::Option::Some("STOPPED_EARLY"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for TrialStatus {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for TrialStatus {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for TrialStatus {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::NotStarted,
                    2 => Self::Running,
                    3 => Self::Succeeded,
                    4 => Self::Failed,
                    5 => Self::Infeasible,
                    6 => Self::StoppedEarly,
                    _ => Self::UnknownValue(trial_status::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for TrialStatus {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "TRIAL_STATUS_UNSPECIFIED" => Self::Unspecified,
                    "NOT_STARTED" => Self::NotStarted,
                    "RUNNING" => Self::Running,
                    "SUCCEEDED" => Self::Succeeded,
                    "FAILED" => Self::Failed,
                    "INFEASIBLE" => Self::Infeasible,
                    "STOPPED_EARLY" => Self::StoppedEarly,
                    _ => Self::UnknownValue(trial_status::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for TrialStatus {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::NotStarted => serializer.serialize_i32(1),
                    Self::Running => serializer.serialize_i32(2),
                    Self::Succeeded => serializer.serialize_i32(3),
                    Self::Failed => serializer.serialize_i32(4),
                    Self::Infeasible => serializer.serialize_i32(5),
                    Self::StoppedEarly => serializer.serialize_i32(6),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for TrialStatus {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<TrialStatus>::new(
                    ".google.cloud.bigquery.v2.Model.HparamTuningTrial.TrialStatus",
                ))
            }
        }
    }

    /// Indicates the type of the Model.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ModelType {
        /// Default value.
        Unspecified,
        /// Linear regression model.
        LinearRegression,
        /// Logistic regression based classification model.
        LogisticRegression,
        /// K-means clustering model.
        Kmeans,
        /// Matrix factorization model.
        MatrixFactorization,
        /// DNN classifier model.
        DnnClassifier,
        /// An imported TensorFlow model.
        Tensorflow,
        /// DNN regressor model.
        DnnRegressor,
        /// An imported XGBoost model.
        Xgboost,
        /// Boosted tree regressor model.
        BoostedTreeRegressor,
        /// Boosted tree classifier model.
        BoostedTreeClassifier,
        /// ARIMA model.
        Arima,
        /// AutoML Tables regression model.
        AutomlRegressor,
        /// AutoML Tables classification model.
        AutomlClassifier,
        /// Prinpical Component Analysis model.
        Pca,
        /// Wide-and-deep classifier model.
        DnnLinearCombinedClassifier,
        /// Wide-and-deep regressor model.
        DnnLinearCombinedRegressor,
        /// Autoencoder model.
        Autoencoder,
        /// New name for the ARIMA model.
        ArimaPlus,
        /// ARIMA with external regressors.
        ArimaPlusXreg,
        /// Random forest regressor model.
        RandomForestRegressor,
        /// Random forest classifier model.
        RandomForestClassifier,
        /// An imported TensorFlow Lite model.
        TensorflowLite,
        /// An imported ONNX model.
        Onnx,
        /// Model to capture the columns and logic in the TRANSFORM clause along with
        /// statistics useful for ML analytic functions.
        TransformOnly,
        /// The contribution analysis model.
        ContributionAnalysis,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ModelType::value] or
        /// [ModelType::name].
        UnknownValue(model_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod model_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ModelType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::LinearRegression => std::option::Option::Some(1),
                Self::LogisticRegression => std::option::Option::Some(2),
                Self::Kmeans => std::option::Option::Some(3),
                Self::MatrixFactorization => std::option::Option::Some(4),
                Self::DnnClassifier => std::option::Option::Some(5),
                Self::Tensorflow => std::option::Option::Some(6),
                Self::DnnRegressor => std::option::Option::Some(7),
                Self::Xgboost => std::option::Option::Some(8),
                Self::BoostedTreeRegressor => std::option::Option::Some(9),
                Self::BoostedTreeClassifier => std::option::Option::Some(10),
                Self::Arima => std::option::Option::Some(11),
                Self::AutomlRegressor => std::option::Option::Some(12),
                Self::AutomlClassifier => std::option::Option::Some(13),
                Self::Pca => std::option::Option::Some(14),
                Self::DnnLinearCombinedClassifier => std::option::Option::Some(16),
                Self::DnnLinearCombinedRegressor => std::option::Option::Some(17),
                Self::Autoencoder => std::option::Option::Some(18),
                Self::ArimaPlus => std::option::Option::Some(19),
                Self::ArimaPlusXreg => std::option::Option::Some(23),
                Self::RandomForestRegressor => std::option::Option::Some(24),
                Self::RandomForestClassifier => std::option::Option::Some(25),
                Self::TensorflowLite => std::option::Option::Some(26),
                Self::Onnx => std::option::Option::Some(28),
                Self::TransformOnly => std::option::Option::Some(29),
                Self::ContributionAnalysis => std::option::Option::Some(37),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MODEL_TYPE_UNSPECIFIED"),
                Self::LinearRegression => std::option::Option::Some("LINEAR_REGRESSION"),
                Self::LogisticRegression => std::option::Option::Some("LOGISTIC_REGRESSION"),
                Self::Kmeans => std::option::Option::Some("KMEANS"),
                Self::MatrixFactorization => std::option::Option::Some("MATRIX_FACTORIZATION"),
                Self::DnnClassifier => std::option::Option::Some("DNN_CLASSIFIER"),
                Self::Tensorflow => std::option::Option::Some("TENSORFLOW"),
                Self::DnnRegressor => std::option::Option::Some("DNN_REGRESSOR"),
                Self::Xgboost => std::option::Option::Some("XGBOOST"),
                Self::BoostedTreeRegressor => std::option::Option::Some("BOOSTED_TREE_REGRESSOR"),
                Self::BoostedTreeClassifier => std::option::Option::Some("BOOSTED_TREE_CLASSIFIER"),
                Self::Arima => std::option::Option::Some("ARIMA"),
                Self::AutomlRegressor => std::option::Option::Some("AUTOML_REGRESSOR"),
                Self::AutomlClassifier => std::option::Option::Some("AUTOML_CLASSIFIER"),
                Self::Pca => std::option::Option::Some("PCA"),
                Self::DnnLinearCombinedClassifier => {
                    std::option::Option::Some("DNN_LINEAR_COMBINED_CLASSIFIER")
                }
                Self::DnnLinearCombinedRegressor => {
                    std::option::Option::Some("DNN_LINEAR_COMBINED_REGRESSOR")
                }
                Self::Autoencoder => std::option::Option::Some("AUTOENCODER"),
                Self::ArimaPlus => std::option::Option::Some("ARIMA_PLUS"),
                Self::ArimaPlusXreg => std::option::Option::Some("ARIMA_PLUS_XREG"),
                Self::RandomForestRegressor => std::option::Option::Some("RANDOM_FOREST_REGRESSOR"),
                Self::RandomForestClassifier => {
                    std::option::Option::Some("RANDOM_FOREST_CLASSIFIER")
                }
                Self::TensorflowLite => std::option::Option::Some("TENSORFLOW_LITE"),
                Self::Onnx => std::option::Option::Some("ONNX"),
                Self::TransformOnly => std::option::Option::Some("TRANSFORM_ONLY"),
                Self::ContributionAnalysis => std::option::Option::Some("CONTRIBUTION_ANALYSIS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ModelType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ModelType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ModelType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::LinearRegression,
                2 => Self::LogisticRegression,
                3 => Self::Kmeans,
                4 => Self::MatrixFactorization,
                5 => Self::DnnClassifier,
                6 => Self::Tensorflow,
                7 => Self::DnnRegressor,
                8 => Self::Xgboost,
                9 => Self::BoostedTreeRegressor,
                10 => Self::BoostedTreeClassifier,
                11 => Self::Arima,
                12 => Self::AutomlRegressor,
                13 => Self::AutomlClassifier,
                14 => Self::Pca,
                16 => Self::DnnLinearCombinedClassifier,
                17 => Self::DnnLinearCombinedRegressor,
                18 => Self::Autoencoder,
                19 => Self::ArimaPlus,
                23 => Self::ArimaPlusXreg,
                24 => Self::RandomForestRegressor,
                25 => Self::RandomForestClassifier,
                26 => Self::TensorflowLite,
                28 => Self::Onnx,
                29 => Self::TransformOnly,
                37 => Self::ContributionAnalysis,
                _ => Self::UnknownValue(model_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ModelType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MODEL_TYPE_UNSPECIFIED" => Self::Unspecified,
                "LINEAR_REGRESSION" => Self::LinearRegression,
                "LOGISTIC_REGRESSION" => Self::LogisticRegression,
                "KMEANS" => Self::Kmeans,
                "MATRIX_FACTORIZATION" => Self::MatrixFactorization,
                "DNN_CLASSIFIER" => Self::DnnClassifier,
                "TENSORFLOW" => Self::Tensorflow,
                "DNN_REGRESSOR" => Self::DnnRegressor,
                "XGBOOST" => Self::Xgboost,
                "BOOSTED_TREE_REGRESSOR" => Self::BoostedTreeRegressor,
                "BOOSTED_TREE_CLASSIFIER" => Self::BoostedTreeClassifier,
                "ARIMA" => Self::Arima,
                "AUTOML_REGRESSOR" => Self::AutomlRegressor,
                "AUTOML_CLASSIFIER" => Self::AutomlClassifier,
                "PCA" => Self::Pca,
                "DNN_LINEAR_COMBINED_CLASSIFIER" => Self::DnnLinearCombinedClassifier,
                "DNN_LINEAR_COMBINED_REGRESSOR" => Self::DnnLinearCombinedRegressor,
                "AUTOENCODER" => Self::Autoencoder,
                "ARIMA_PLUS" => Self::ArimaPlus,
                "ARIMA_PLUS_XREG" => Self::ArimaPlusXreg,
                "RANDOM_FOREST_REGRESSOR" => Self::RandomForestRegressor,
                "RANDOM_FOREST_CLASSIFIER" => Self::RandomForestClassifier,
                "TENSORFLOW_LITE" => Self::TensorflowLite,
                "ONNX" => Self::Onnx,
                "TRANSFORM_ONLY" => Self::TransformOnly,
                "CONTRIBUTION_ANALYSIS" => Self::ContributionAnalysis,
                _ => Self::UnknownValue(model_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ModelType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::LinearRegression => serializer.serialize_i32(1),
                Self::LogisticRegression => serializer.serialize_i32(2),
                Self::Kmeans => serializer.serialize_i32(3),
                Self::MatrixFactorization => serializer.serialize_i32(4),
                Self::DnnClassifier => serializer.serialize_i32(5),
                Self::Tensorflow => serializer.serialize_i32(6),
                Self::DnnRegressor => serializer.serialize_i32(7),
                Self::Xgboost => serializer.serialize_i32(8),
                Self::BoostedTreeRegressor => serializer.serialize_i32(9),
                Self::BoostedTreeClassifier => serializer.serialize_i32(10),
                Self::Arima => serializer.serialize_i32(11),
                Self::AutomlRegressor => serializer.serialize_i32(12),
                Self::AutomlClassifier => serializer.serialize_i32(13),
                Self::Pca => serializer.serialize_i32(14),
                Self::DnnLinearCombinedClassifier => serializer.serialize_i32(16),
                Self::DnnLinearCombinedRegressor => serializer.serialize_i32(17),
                Self::Autoencoder => serializer.serialize_i32(18),
                Self::ArimaPlus => serializer.serialize_i32(19),
                Self::ArimaPlusXreg => serializer.serialize_i32(23),
                Self::RandomForestRegressor => serializer.serialize_i32(24),
                Self::RandomForestClassifier => serializer.serialize_i32(25),
                Self::TensorflowLite => serializer.serialize_i32(26),
                Self::Onnx => serializer.serialize_i32(28),
                Self::TransformOnly => serializer.serialize_i32(29),
                Self::ContributionAnalysis => serializer.serialize_i32(37),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ModelType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ModelType>::new(
                ".google.cloud.bigquery.v2.Model.ModelType",
            ))
        }
    }

    /// Loss metric to evaluate model training performance.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LossType {
        /// Default value.
        Unspecified,
        /// Mean squared loss, used for linear regression.
        MeanSquaredLoss,
        /// Mean log loss, used for logistic regression.
        MeanLogLoss,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [LossType::value] or
        /// [LossType::name].
        UnknownValue(loss_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod loss_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl LossType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::MeanSquaredLoss => std::option::Option::Some(1),
                Self::MeanLogLoss => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("LOSS_TYPE_UNSPECIFIED"),
                Self::MeanSquaredLoss => std::option::Option::Some("MEAN_SQUARED_LOSS"),
                Self::MeanLogLoss => std::option::Option::Some("MEAN_LOG_LOSS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for LossType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for LossType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for LossType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::MeanSquaredLoss,
                2 => Self::MeanLogLoss,
                _ => Self::UnknownValue(loss_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for LossType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LOSS_TYPE_UNSPECIFIED" => Self::Unspecified,
                "MEAN_SQUARED_LOSS" => Self::MeanSquaredLoss,
                "MEAN_LOG_LOSS" => Self::MeanLogLoss,
                _ => Self::UnknownValue(loss_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for LossType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::MeanSquaredLoss => serializer.serialize_i32(1),
                Self::MeanLogLoss => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for LossType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<LossType>::new(
                ".google.cloud.bigquery.v2.Model.LossType",
            ))
        }
    }

    /// Distance metric used to compute the distance between two points.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DistanceType {
        /// Default value.
        Unspecified,
        /// Eculidean distance.
        Euclidean,
        /// Cosine distance.
        Cosine,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DistanceType::value] or
        /// [DistanceType::name].
        UnknownValue(distance_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod distance_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DistanceType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Euclidean => std::option::Option::Some(1),
                Self::Cosine => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DISTANCE_TYPE_UNSPECIFIED"),
                Self::Euclidean => std::option::Option::Some("EUCLIDEAN"),
                Self::Cosine => std::option::Option::Some("COSINE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DistanceType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DistanceType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DistanceType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Euclidean,
                2 => Self::Cosine,
                _ => Self::UnknownValue(distance_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DistanceType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DISTANCE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "EUCLIDEAN" => Self::Euclidean,
                "COSINE" => Self::Cosine,
                _ => Self::UnknownValue(distance_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DistanceType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Euclidean => serializer.serialize_i32(1),
                Self::Cosine => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DistanceType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DistanceType>::new(
                ".google.cloud.bigquery.v2.Model.DistanceType",
            ))
        }
    }

    /// Indicates the method to split input data into multiple tables.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DataSplitMethod {
        /// Default value.
        Unspecified,
        /// Splits data randomly.
        Random,
        /// Splits data with the user provided tags.
        Custom,
        /// Splits data sequentially.
        Sequential,
        /// Data split will be skipped.
        NoSplit,
        /// Splits data automatically: Uses NO_SPLIT if the data size is small.
        /// Otherwise uses RANDOM.
        AutoSplit,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DataSplitMethod::value] or
        /// [DataSplitMethod::name].
        UnknownValue(data_split_method::UnknownValue),
    }

    #[doc(hidden)]
    pub mod data_split_method {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DataSplitMethod {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Random => std::option::Option::Some(1),
                Self::Custom => std::option::Option::Some(2),
                Self::Sequential => std::option::Option::Some(3),
                Self::NoSplit => std::option::Option::Some(4),
                Self::AutoSplit => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DATA_SPLIT_METHOD_UNSPECIFIED"),
                Self::Random => std::option::Option::Some("RANDOM"),
                Self::Custom => std::option::Option::Some("CUSTOM"),
                Self::Sequential => std::option::Option::Some("SEQUENTIAL"),
                Self::NoSplit => std::option::Option::Some("NO_SPLIT"),
                Self::AutoSplit => std::option::Option::Some("AUTO_SPLIT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DataSplitMethod {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DataSplitMethod {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DataSplitMethod {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Random,
                2 => Self::Custom,
                3 => Self::Sequential,
                4 => Self::NoSplit,
                5 => Self::AutoSplit,
                _ => Self::UnknownValue(data_split_method::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DataSplitMethod {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DATA_SPLIT_METHOD_UNSPECIFIED" => Self::Unspecified,
                "RANDOM" => Self::Random,
                "CUSTOM" => Self::Custom,
                "SEQUENTIAL" => Self::Sequential,
                "NO_SPLIT" => Self::NoSplit,
                "AUTO_SPLIT" => Self::AutoSplit,
                _ => Self::UnknownValue(data_split_method::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DataSplitMethod {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Random => serializer.serialize_i32(1),
                Self::Custom => serializer.serialize_i32(2),
                Self::Sequential => serializer.serialize_i32(3),
                Self::NoSplit => serializer.serialize_i32(4),
                Self::AutoSplit => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DataSplitMethod {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DataSplitMethod>::new(
                ".google.cloud.bigquery.v2.Model.DataSplitMethod",
            ))
        }
    }

    /// Type of supported data frequency for time series forecasting models.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DataFrequency {
        /// Default value.
        Unspecified,
        /// Automatically inferred from timestamps.
        AutoFrequency,
        /// Yearly data.
        Yearly,
        /// Quarterly data.
        Quarterly,
        /// Monthly data.
        Monthly,
        /// Weekly data.
        Weekly,
        /// Daily data.
        Daily,
        /// Hourly data.
        Hourly,
        /// Per-minute data.
        PerMinute,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DataFrequency::value] or
        /// [DataFrequency::name].
        UnknownValue(data_frequency::UnknownValue),
    }

    #[doc(hidden)]
    pub mod data_frequency {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DataFrequency {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::AutoFrequency => std::option::Option::Some(1),
                Self::Yearly => std::option::Option::Some(2),
                Self::Quarterly => std::option::Option::Some(3),
                Self::Monthly => std::option::Option::Some(4),
                Self::Weekly => std::option::Option::Some(5),
                Self::Daily => std::option::Option::Some(6),
                Self::Hourly => std::option::Option::Some(7),
                Self::PerMinute => std::option::Option::Some(8),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DATA_FREQUENCY_UNSPECIFIED"),
                Self::AutoFrequency => std::option::Option::Some("AUTO_FREQUENCY"),
                Self::Yearly => std::option::Option::Some("YEARLY"),
                Self::Quarterly => std::option::Option::Some("QUARTERLY"),
                Self::Monthly => std::option::Option::Some("MONTHLY"),
                Self::Weekly => std::option::Option::Some("WEEKLY"),
                Self::Daily => std::option::Option::Some("DAILY"),
                Self::Hourly => std::option::Option::Some("HOURLY"),
                Self::PerMinute => std::option::Option::Some("PER_MINUTE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DataFrequency {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DataFrequency {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DataFrequency {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::AutoFrequency,
                2 => Self::Yearly,
                3 => Self::Quarterly,
                4 => Self::Monthly,
                5 => Self::Weekly,
                6 => Self::Daily,
                7 => Self::Hourly,
                8 => Self::PerMinute,
                _ => Self::UnknownValue(data_frequency::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DataFrequency {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DATA_FREQUENCY_UNSPECIFIED" => Self::Unspecified,
                "AUTO_FREQUENCY" => Self::AutoFrequency,
                "YEARLY" => Self::Yearly,
                "QUARTERLY" => Self::Quarterly,
                "MONTHLY" => Self::Monthly,
                "WEEKLY" => Self::Weekly,
                "DAILY" => Self::Daily,
                "HOURLY" => Self::Hourly,
                "PER_MINUTE" => Self::PerMinute,
                _ => Self::UnknownValue(data_frequency::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DataFrequency {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::AutoFrequency => serializer.serialize_i32(1),
                Self::Yearly => serializer.serialize_i32(2),
                Self::Quarterly => serializer.serialize_i32(3),
                Self::Monthly => serializer.serialize_i32(4),
                Self::Weekly => serializer.serialize_i32(5),
                Self::Daily => serializer.serialize_i32(6),
                Self::Hourly => serializer.serialize_i32(7),
                Self::PerMinute => serializer.serialize_i32(8),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DataFrequency {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DataFrequency>::new(
                ".google.cloud.bigquery.v2.Model.DataFrequency",
            ))
        }
    }

    /// Type of supported holiday regions for time series forecasting models.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum HolidayRegion {
        /// Holiday region unspecified.
        Unspecified,
        /// Global.
        Global,
        /// North America.
        Na,
        /// Japan and Asia Pacific: Korea, Greater China, India, Australia, and New
        /// Zealand.
        Japac,
        /// Europe, the Middle East and Africa.
        Emea,
        /// Latin America and the Caribbean.
        Lac,
        /// United Arab Emirates
        Ae,
        /// Argentina
        Ar,
        /// Austria
        At,
        /// Australia
        Au,
        /// Belgium
        Be,
        /// Brazil
        Br,
        /// Canada
        Ca,
        /// Switzerland
        Ch,
        /// Chile
        Cl,
        /// China
        Cn,
        /// Colombia
        Co,
        /// Czechoslovakia
        Cs,
        /// Czech Republic
        Cz,
        /// Germany
        De,
        /// Denmark
        Dk,
        /// Algeria
        Dz,
        /// Ecuador
        Ec,
        /// Estonia
        Ee,
        /// Egypt
        Eg,
        /// Spain
        Es,
        /// Finland
        Fi,
        /// France
        Fr,
        /// Great Britain (United Kingdom)
        Gb,
        /// Greece
        Gr,
        /// Hong Kong
        Hk,
        /// Hungary
        Hu,
        /// Indonesia
        Id,
        /// Ireland
        Ie,
        /// Israel
        Il,
        /// India
        In,
        /// Iran
        Ir,
        /// Italy
        It,
        /// Japan
        Jp,
        /// Korea (South)
        Kr,
        /// Latvia
        Lv,
        /// Morocco
        Ma,
        /// Mexico
        Mx,
        /// Malaysia
        My,
        /// Nigeria
        Ng,
        /// Netherlands
        Nl,
        /// Norway
        No,
        /// New Zealand
        Nz,
        /// Peru
        Pe,
        /// Philippines
        Ph,
        /// Pakistan
        Pk,
        /// Poland
        Pl,
        /// Portugal
        Pt,
        /// Romania
        Ro,
        /// Serbia
        Rs,
        /// Russian Federation
        Ru,
        /// Saudi Arabia
        Sa,
        /// Sweden
        Se,
        /// Singapore
        Sg,
        /// Slovenia
        Si,
        /// Slovakia
        Sk,
        /// Thailand
        Th,
        /// Turkey
        Tr,
        /// Taiwan
        Tw,
        /// Ukraine
        Ua,
        /// United States
        Us,
        /// Venezuela
        Ve,
        /// Vietnam
        Vn,
        /// South Africa
        Za,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [HolidayRegion::value] or
        /// [HolidayRegion::name].
        UnknownValue(holiday_region::UnknownValue),
    }

    #[doc(hidden)]
    pub mod holiday_region {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl HolidayRegion {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Global => std::option::Option::Some(1),
                Self::Na => std::option::Option::Some(2),
                Self::Japac => std::option::Option::Some(3),
                Self::Emea => std::option::Option::Some(4),
                Self::Lac => std::option::Option::Some(5),
                Self::Ae => std::option::Option::Some(6),
                Self::Ar => std::option::Option::Some(7),
                Self::At => std::option::Option::Some(8),
                Self::Au => std::option::Option::Some(9),
                Self::Be => std::option::Option::Some(10),
                Self::Br => std::option::Option::Some(11),
                Self::Ca => std::option::Option::Some(12),
                Self::Ch => std::option::Option::Some(13),
                Self::Cl => std::option::Option::Some(14),
                Self::Cn => std::option::Option::Some(15),
                Self::Co => std::option::Option::Some(16),
                Self::Cs => std::option::Option::Some(17),
                Self::Cz => std::option::Option::Some(18),
                Self::De => std::option::Option::Some(19),
                Self::Dk => std::option::Option::Some(20),
                Self::Dz => std::option::Option::Some(21),
                Self::Ec => std::option::Option::Some(22),
                Self::Ee => std::option::Option::Some(23),
                Self::Eg => std::option::Option::Some(24),
                Self::Es => std::option::Option::Some(25),
                Self::Fi => std::option::Option::Some(26),
                Self::Fr => std::option::Option::Some(27),
                Self::Gb => std::option::Option::Some(28),
                Self::Gr => std::option::Option::Some(29),
                Self::Hk => std::option::Option::Some(30),
                Self::Hu => std::option::Option::Some(31),
                Self::Id => std::option::Option::Some(32),
                Self::Ie => std::option::Option::Some(33),
                Self::Il => std::option::Option::Some(34),
                Self::In => std::option::Option::Some(35),
                Self::Ir => std::option::Option::Some(36),
                Self::It => std::option::Option::Some(37),
                Self::Jp => std::option::Option::Some(38),
                Self::Kr => std::option::Option::Some(39),
                Self::Lv => std::option::Option::Some(40),
                Self::Ma => std::option::Option::Some(41),
                Self::Mx => std::option::Option::Some(42),
                Self::My => std::option::Option::Some(43),
                Self::Ng => std::option::Option::Some(44),
                Self::Nl => std::option::Option::Some(45),
                Self::No => std::option::Option::Some(46),
                Self::Nz => std::option::Option::Some(47),
                Self::Pe => std::option::Option::Some(48),
                Self::Ph => std::option::Option::Some(49),
                Self::Pk => std::option::Option::Some(50),
                Self::Pl => std::option::Option::Some(51),
                Self::Pt => std::option::Option::Some(52),
                Self::Ro => std::option::Option::Some(53),
                Self::Rs => std::option::Option::Some(54),
                Self::Ru => std::option::Option::Some(55),
                Self::Sa => std::option::Option::Some(56),
                Self::Se => std::option::Option::Some(57),
                Self::Sg => std::option::Option::Some(58),
                Self::Si => std::option::Option::Some(59),
                Self::Sk => std::option::Option::Some(60),
                Self::Th => std::option::Option::Some(61),
                Self::Tr => std::option::Option::Some(62),
                Self::Tw => std::option::Option::Some(63),
                Self::Ua => std::option::Option::Some(64),
                Self::Us => std::option::Option::Some(65),
                Self::Ve => std::option::Option::Some(66),
                Self::Vn => std::option::Option::Some(67),
                Self::Za => std::option::Option::Some(68),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("HOLIDAY_REGION_UNSPECIFIED"),
                Self::Global => std::option::Option::Some("GLOBAL"),
                Self::Na => std::option::Option::Some("NA"),
                Self::Japac => std::option::Option::Some("JAPAC"),
                Self::Emea => std::option::Option::Some("EMEA"),
                Self::Lac => std::option::Option::Some("LAC"),
                Self::Ae => std::option::Option::Some("AE"),
                Self::Ar => std::option::Option::Some("AR"),
                Self::At => std::option::Option::Some("AT"),
                Self::Au => std::option::Option::Some("AU"),
                Self::Be => std::option::Option::Some("BE"),
                Self::Br => std::option::Option::Some("BR"),
                Self::Ca => std::option::Option::Some("CA"),
                Self::Ch => std::option::Option::Some("CH"),
                Self::Cl => std::option::Option::Some("CL"),
                Self::Cn => std::option::Option::Some("CN"),
                Self::Co => std::option::Option::Some("CO"),
                Self::Cs => std::option::Option::Some("CS"),
                Self::Cz => std::option::Option::Some("CZ"),
                Self::De => std::option::Option::Some("DE"),
                Self::Dk => std::option::Option::Some("DK"),
                Self::Dz => std::option::Option::Some("DZ"),
                Self::Ec => std::option::Option::Some("EC"),
                Self::Ee => std::option::Option::Some("EE"),
                Self::Eg => std::option::Option::Some("EG"),
                Self::Es => std::option::Option::Some("ES"),
                Self::Fi => std::option::Option::Some("FI"),
                Self::Fr => std::option::Option::Some("FR"),
                Self::Gb => std::option::Option::Some("GB"),
                Self::Gr => std::option::Option::Some("GR"),
                Self::Hk => std::option::Option::Some("HK"),
                Self::Hu => std::option::Option::Some("HU"),
                Self::Id => std::option::Option::Some("ID"),
                Self::Ie => std::option::Option::Some("IE"),
                Self::Il => std::option::Option::Some("IL"),
                Self::In => std::option::Option::Some("IN"),
                Self::Ir => std::option::Option::Some("IR"),
                Self::It => std::option::Option::Some("IT"),
                Self::Jp => std::option::Option::Some("JP"),
                Self::Kr => std::option::Option::Some("KR"),
                Self::Lv => std::option::Option::Some("LV"),
                Self::Ma => std::option::Option::Some("MA"),
                Self::Mx => std::option::Option::Some("MX"),
                Self::My => std::option::Option::Some("MY"),
                Self::Ng => std::option::Option::Some("NG"),
                Self::Nl => std::option::Option::Some("NL"),
                Self::No => std::option::Option::Some("NO"),
                Self::Nz => std::option::Option::Some("NZ"),
                Self::Pe => std::option::Option::Some("PE"),
                Self::Ph => std::option::Option::Some("PH"),
                Self::Pk => std::option::Option::Some("PK"),
                Self::Pl => std::option::Option::Some("PL"),
                Self::Pt => std::option::Option::Some("PT"),
                Self::Ro => std::option::Option::Some("RO"),
                Self::Rs => std::option::Option::Some("RS"),
                Self::Ru => std::option::Option::Some("RU"),
                Self::Sa => std::option::Option::Some("SA"),
                Self::Se => std::option::Option::Some("SE"),
                Self::Sg => std::option::Option::Some("SG"),
                Self::Si => std::option::Option::Some("SI"),
                Self::Sk => std::option::Option::Some("SK"),
                Self::Th => std::option::Option::Some("TH"),
                Self::Tr => std::option::Option::Some("TR"),
                Self::Tw => std::option::Option::Some("TW"),
                Self::Ua => std::option::Option::Some("UA"),
                Self::Us => std::option::Option::Some("US"),
                Self::Ve => std::option::Option::Some("VE"),
                Self::Vn => std::option::Option::Some("VN"),
                Self::Za => std::option::Option::Some("ZA"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for HolidayRegion {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for HolidayRegion {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for HolidayRegion {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Global,
                2 => Self::Na,
                3 => Self::Japac,
                4 => Self::Emea,
                5 => Self::Lac,
                6 => Self::Ae,
                7 => Self::Ar,
                8 => Self::At,
                9 => Self::Au,
                10 => Self::Be,
                11 => Self::Br,
                12 => Self::Ca,
                13 => Self::Ch,
                14 => Self::Cl,
                15 => Self::Cn,
                16 => Self::Co,
                17 => Self::Cs,
                18 => Self::Cz,
                19 => Self::De,
                20 => Self::Dk,
                21 => Self::Dz,
                22 => Self::Ec,
                23 => Self::Ee,
                24 => Self::Eg,
                25 => Self::Es,
                26 => Self::Fi,
                27 => Self::Fr,
                28 => Self::Gb,
                29 => Self::Gr,
                30 => Self::Hk,
                31 => Self::Hu,
                32 => Self::Id,
                33 => Self::Ie,
                34 => Self::Il,
                35 => Self::In,
                36 => Self::Ir,
                37 => Self::It,
                38 => Self::Jp,
                39 => Self::Kr,
                40 => Self::Lv,
                41 => Self::Ma,
                42 => Self::Mx,
                43 => Self::My,
                44 => Self::Ng,
                45 => Self::Nl,
                46 => Self::No,
                47 => Self::Nz,
                48 => Self::Pe,
                49 => Self::Ph,
                50 => Self::Pk,
                51 => Self::Pl,
                52 => Self::Pt,
                53 => Self::Ro,
                54 => Self::Rs,
                55 => Self::Ru,
                56 => Self::Sa,
                57 => Self::Se,
                58 => Self::Sg,
                59 => Self::Si,
                60 => Self::Sk,
                61 => Self::Th,
                62 => Self::Tr,
                63 => Self::Tw,
                64 => Self::Ua,
                65 => Self::Us,
                66 => Self::Ve,
                67 => Self::Vn,
                68 => Self::Za,
                _ => Self::UnknownValue(holiday_region::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for HolidayRegion {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "HOLIDAY_REGION_UNSPECIFIED" => Self::Unspecified,
                "GLOBAL" => Self::Global,
                "NA" => Self::Na,
                "JAPAC" => Self::Japac,
                "EMEA" => Self::Emea,
                "LAC" => Self::Lac,
                "AE" => Self::Ae,
                "AR" => Self::Ar,
                "AT" => Self::At,
                "AU" => Self::Au,
                "BE" => Self::Be,
                "BR" => Self::Br,
                "CA" => Self::Ca,
                "CH" => Self::Ch,
                "CL" => Self::Cl,
                "CN" => Self::Cn,
                "CO" => Self::Co,
                "CS" => Self::Cs,
                "CZ" => Self::Cz,
                "DE" => Self::De,
                "DK" => Self::Dk,
                "DZ" => Self::Dz,
                "EC" => Self::Ec,
                "EE" => Self::Ee,
                "EG" => Self::Eg,
                "ES" => Self::Es,
                "FI" => Self::Fi,
                "FR" => Self::Fr,
                "GB" => Self::Gb,
                "GR" => Self::Gr,
                "HK" => Self::Hk,
                "HU" => Self::Hu,
                "ID" => Self::Id,
                "IE" => Self::Ie,
                "IL" => Self::Il,
                "IN" => Self::In,
                "IR" => Self::Ir,
                "IT" => Self::It,
                "JP" => Self::Jp,
                "KR" => Self::Kr,
                "LV" => Self::Lv,
                "MA" => Self::Ma,
                "MX" => Self::Mx,
                "MY" => Self::My,
                "NG" => Self::Ng,
                "NL" => Self::Nl,
                "NO" => Self::No,
                "NZ" => Self::Nz,
                "PE" => Self::Pe,
                "PH" => Self::Ph,
                "PK" => Self::Pk,
                "PL" => Self::Pl,
                "PT" => Self::Pt,
                "RO" => Self::Ro,
                "RS" => Self::Rs,
                "RU" => Self::Ru,
                "SA" => Self::Sa,
                "SE" => Self::Se,
                "SG" => Self::Sg,
                "SI" => Self::Si,
                "SK" => Self::Sk,
                "TH" => Self::Th,
                "TR" => Self::Tr,
                "TW" => Self::Tw,
                "UA" => Self::Ua,
                "US" => Self::Us,
                "VE" => Self::Ve,
                "VN" => Self::Vn,
                "ZA" => Self::Za,
                _ => Self::UnknownValue(holiday_region::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for HolidayRegion {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Global => serializer.serialize_i32(1),
                Self::Na => serializer.serialize_i32(2),
                Self::Japac => serializer.serialize_i32(3),
                Self::Emea => serializer.serialize_i32(4),
                Self::Lac => serializer.serialize_i32(5),
                Self::Ae => serializer.serialize_i32(6),
                Self::Ar => serializer.serialize_i32(7),
                Self::At => serializer.serialize_i32(8),
                Self::Au => serializer.serialize_i32(9),
                Self::Be => serializer.serialize_i32(10),
                Self::Br => serializer.serialize_i32(11),
                Self::Ca => serializer.serialize_i32(12),
                Self::Ch => serializer.serialize_i32(13),
                Self::Cl => serializer.serialize_i32(14),
                Self::Cn => serializer.serialize_i32(15),
                Self::Co => serializer.serialize_i32(16),
                Self::Cs => serializer.serialize_i32(17),
                Self::Cz => serializer.serialize_i32(18),
                Self::De => serializer.serialize_i32(19),
                Self::Dk => serializer.serialize_i32(20),
                Self::Dz => serializer.serialize_i32(21),
                Self::Ec => serializer.serialize_i32(22),
                Self::Ee => serializer.serialize_i32(23),
                Self::Eg => serializer.serialize_i32(24),
                Self::Es => serializer.serialize_i32(25),
                Self::Fi => serializer.serialize_i32(26),
                Self::Fr => serializer.serialize_i32(27),
                Self::Gb => serializer.serialize_i32(28),
                Self::Gr => serializer.serialize_i32(29),
                Self::Hk => serializer.serialize_i32(30),
                Self::Hu => serializer.serialize_i32(31),
                Self::Id => serializer.serialize_i32(32),
                Self::Ie => serializer.serialize_i32(33),
                Self::Il => serializer.serialize_i32(34),
                Self::In => serializer.serialize_i32(35),
                Self::Ir => serializer.serialize_i32(36),
                Self::It => serializer.serialize_i32(37),
                Self::Jp => serializer.serialize_i32(38),
                Self::Kr => serializer.serialize_i32(39),
                Self::Lv => serializer.serialize_i32(40),
                Self::Ma => serializer.serialize_i32(41),
                Self::Mx => serializer.serialize_i32(42),
                Self::My => serializer.serialize_i32(43),
                Self::Ng => serializer.serialize_i32(44),
                Self::Nl => serializer.serialize_i32(45),
                Self::No => serializer.serialize_i32(46),
                Self::Nz => serializer.serialize_i32(47),
                Self::Pe => serializer.serialize_i32(48),
                Self::Ph => serializer.serialize_i32(49),
                Self::Pk => serializer.serialize_i32(50),
                Self::Pl => serializer.serialize_i32(51),
                Self::Pt => serializer.serialize_i32(52),
                Self::Ro => serializer.serialize_i32(53),
                Self::Rs => serializer.serialize_i32(54),
                Self::Ru => serializer.serialize_i32(55),
                Self::Sa => serializer.serialize_i32(56),
                Self::Se => serializer.serialize_i32(57),
                Self::Sg => serializer.serialize_i32(58),
                Self::Si => serializer.serialize_i32(59),
                Self::Sk => serializer.serialize_i32(60),
                Self::Th => serializer.serialize_i32(61),
                Self::Tr => serializer.serialize_i32(62),
                Self::Tw => serializer.serialize_i32(63),
                Self::Ua => serializer.serialize_i32(64),
                Self::Us => serializer.serialize_i32(65),
                Self::Ve => serializer.serialize_i32(66),
                Self::Vn => serializer.serialize_i32(67),
                Self::Za => serializer.serialize_i32(68),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for HolidayRegion {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<HolidayRegion>::new(
                ".google.cloud.bigquery.v2.Model.HolidayRegion",
            ))
        }
    }

    /// Enums for color space, used for processing images in Object Table.
    /// See more details at
    /// <https://www.tensorflow.org/io/tutorials/colorspace>.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ColorSpace {
        /// Unspecified color space
        Unspecified,
        /// RGB
        Rgb,
        /// HSV
        Hsv,
        /// YIQ
        Yiq,
        /// YUV
        Yuv,
        /// GRAYSCALE
        Grayscale,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ColorSpace::value] or
        /// [ColorSpace::name].
        UnknownValue(color_space::UnknownValue),
    }

    #[doc(hidden)]
    pub mod color_space {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ColorSpace {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Rgb => std::option::Option::Some(1),
                Self::Hsv => std::option::Option::Some(2),
                Self::Yiq => std::option::Option::Some(3),
                Self::Yuv => std::option::Option::Some(4),
                Self::Grayscale => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("COLOR_SPACE_UNSPECIFIED"),
                Self::Rgb => std::option::Option::Some("RGB"),
                Self::Hsv => std::option::Option::Some("HSV"),
                Self::Yiq => std::option::Option::Some("YIQ"),
                Self::Yuv => std::option::Option::Some("YUV"),
                Self::Grayscale => std::option::Option::Some("GRAYSCALE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ColorSpace {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ColorSpace {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ColorSpace {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Rgb,
                2 => Self::Hsv,
                3 => Self::Yiq,
                4 => Self::Yuv,
                5 => Self::Grayscale,
                _ => Self::UnknownValue(color_space::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ColorSpace {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "COLOR_SPACE_UNSPECIFIED" => Self::Unspecified,
                "RGB" => Self::Rgb,
                "HSV" => Self::Hsv,
                "YIQ" => Self::Yiq,
                "YUV" => Self::Yuv,
                "GRAYSCALE" => Self::Grayscale,
                _ => Self::UnknownValue(color_space::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ColorSpace {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Rgb => serializer.serialize_i32(1),
                Self::Hsv => serializer.serialize_i32(2),
                Self::Yiq => serializer.serialize_i32(3),
                Self::Yuv => serializer.serialize_i32(4),
                Self::Grayscale => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ColorSpace {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ColorSpace>::new(
                ".google.cloud.bigquery.v2.Model.ColorSpace",
            ))
        }
    }

    /// Indicates the learning rate optimization strategy to use.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LearnRateStrategy {
        /// Default value.
        Unspecified,
        /// Use line search to determine learning rate.
        LineSearch,
        /// Use a constant learning rate.
        Constant,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [LearnRateStrategy::value] or
        /// [LearnRateStrategy::name].
        UnknownValue(learn_rate_strategy::UnknownValue),
    }

    #[doc(hidden)]
    pub mod learn_rate_strategy {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl LearnRateStrategy {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::LineSearch => std::option::Option::Some(1),
                Self::Constant => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("LEARN_RATE_STRATEGY_UNSPECIFIED"),
                Self::LineSearch => std::option::Option::Some("LINE_SEARCH"),
                Self::Constant => std::option::Option::Some("CONSTANT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for LearnRateStrategy {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for LearnRateStrategy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for LearnRateStrategy {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::LineSearch,
                2 => Self::Constant,
                _ => Self::UnknownValue(learn_rate_strategy::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for LearnRateStrategy {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LEARN_RATE_STRATEGY_UNSPECIFIED" => Self::Unspecified,
                "LINE_SEARCH" => Self::LineSearch,
                "CONSTANT" => Self::Constant,
                _ => Self::UnknownValue(learn_rate_strategy::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for LearnRateStrategy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::LineSearch => serializer.serialize_i32(1),
                Self::Constant => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for LearnRateStrategy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<LearnRateStrategy>::new(
                ".google.cloud.bigquery.v2.Model.LearnRateStrategy",
            ))
        }
    }

    /// Indicates the optimization strategy used for training.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum OptimizationStrategy {
        /// Default value.
        Unspecified,
        /// Uses an iterative batch gradient descent algorithm.
        BatchGradientDescent,
        /// Uses a normal equation to solve linear regression problem.
        NormalEquation,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [OptimizationStrategy::value] or
        /// [OptimizationStrategy::name].
        UnknownValue(optimization_strategy::UnknownValue),
    }

    #[doc(hidden)]
    pub mod optimization_strategy {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl OptimizationStrategy {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::BatchGradientDescent => std::option::Option::Some(1),
                Self::NormalEquation => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("OPTIMIZATION_STRATEGY_UNSPECIFIED"),
                Self::BatchGradientDescent => std::option::Option::Some("BATCH_GRADIENT_DESCENT"),
                Self::NormalEquation => std::option::Option::Some("NORMAL_EQUATION"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for OptimizationStrategy {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for OptimizationStrategy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for OptimizationStrategy {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::BatchGradientDescent,
                2 => Self::NormalEquation,
                _ => Self::UnknownValue(optimization_strategy::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for OptimizationStrategy {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "OPTIMIZATION_STRATEGY_UNSPECIFIED" => Self::Unspecified,
                "BATCH_GRADIENT_DESCENT" => Self::BatchGradientDescent,
                "NORMAL_EQUATION" => Self::NormalEquation,
                _ => Self::UnknownValue(optimization_strategy::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for OptimizationStrategy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::BatchGradientDescent => serializer.serialize_i32(1),
                Self::NormalEquation => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for OptimizationStrategy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<OptimizationStrategy>::new(
                ".google.cloud.bigquery.v2.Model.OptimizationStrategy",
            ))
        }
    }

    /// Indicates the training algorithm to use for matrix factorization models.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum FeedbackType {
        /// Default value.
        Unspecified,
        /// Use weighted-als for implicit feedback problems.
        Implicit,
        /// Use nonweighted-als for explicit feedback problems.
        Explicit,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [FeedbackType::value] or
        /// [FeedbackType::name].
        UnknownValue(feedback_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod feedback_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl FeedbackType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Implicit => std::option::Option::Some(1),
                Self::Explicit => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("FEEDBACK_TYPE_UNSPECIFIED"),
                Self::Implicit => std::option::Option::Some("IMPLICIT"),
                Self::Explicit => std::option::Option::Some("EXPLICIT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for FeedbackType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for FeedbackType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for FeedbackType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Implicit,
                2 => Self::Explicit,
                _ => Self::UnknownValue(feedback_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for FeedbackType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FEEDBACK_TYPE_UNSPECIFIED" => Self::Unspecified,
                "IMPLICIT" => Self::Implicit,
                "EXPLICIT" => Self::Explicit,
                _ => Self::UnknownValue(feedback_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for FeedbackType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Implicit => serializer.serialize_i32(1),
                Self::Explicit => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for FeedbackType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<FeedbackType>::new(
                ".google.cloud.bigquery.v2.Model.FeedbackType",
            ))
        }
    }
}

/// Request format for getting information about a BigQuery ML model.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetModelRequest {
    /// Required. Project ID of the requested model.
    pub project_id: std::string::String,

    /// Required. Dataset ID of the requested model.
    pub dataset_id: std::string::String,

    /// Required. Model ID of the requested model.
    pub model_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::GetModelRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::GetModelRequest::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [model_id][crate::model::GetModelRequest::model_id].
    pub fn set_model_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model_id = v.into();
        self
    }
}

impl wkt::message::Message for GetModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.GetModelRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetModelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __model_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetModelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "modelId" => Ok(__FieldTag::__model_id),
                            "model_id" => Ok(__FieldTag::__model_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetModelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetModelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__model_id => {
                            if !fields.insert(__FieldTag::__model_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model_id",
                                ));
                            }
                            result.model_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetModelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.dataset_id.is_empty() {
            state.serialize_entry("datasetId", &self.dataset_id)?;
        }
        if !self.model_id.is_empty() {
            state.serialize_entry("modelId", &self.model_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PatchModelRequest {
    /// Required. Project ID of the model to patch.
    pub project_id: std::string::String,

    /// Required. Dataset ID of the model to patch.
    pub dataset_id: std::string::String,

    /// Required. Model ID of the model to patch.
    pub model_id: std::string::String,

    /// Required. Patched model.
    /// Follows RFC5789 patch semantics. Missing fields are not updated.
    /// To clear a field, explicitly set to default value.
    pub model: std::option::Option<crate::model::Model>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PatchModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::PatchModelRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::PatchModelRequest::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [model_id][crate::model::PatchModelRequest::model_id].
    pub fn set_model_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model_id = v.into();
        self
    }

    /// Sets the value of [model][crate::model::PatchModelRequest::model].
    pub fn set_model<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Model>,
    {
        self.model = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [model][crate::model::PatchModelRequest::model].
    pub fn set_or_clear_model<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Model>,
    {
        self.model = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PatchModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.PatchModelRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PatchModelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __model_id,
            __model,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PatchModelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "modelId" => Ok(__FieldTag::__model_id),
                            "model_id" => Ok(__FieldTag::__model_id),
                            "model" => Ok(__FieldTag::__model),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PatchModelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PatchModelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__model_id => {
                            if !fields.insert(__FieldTag::__model_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model_id",
                                ));
                            }
                            result.model_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__model => {
                            if !fields.insert(__FieldTag::__model) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model",
                                ));
                            }
                            result.model =
                                map.next_value::<std::option::Option<crate::model::Model>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PatchModelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.dataset_id.is_empty() {
            state.serialize_entry("datasetId", &self.dataset_id)?;
        }
        if !self.model_id.is_empty() {
            state.serialize_entry("modelId", &self.model_id)?;
        }
        if self.model.is_some() {
            state.serialize_entry("model", &self.model)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request format for deleting BigQuery ML models.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteModelRequest {
    /// Required. Project ID of the model to delete.
    pub project_id: std::string::String,

    /// Required. Dataset ID of the model to delete.
    pub dataset_id: std::string::String,

    /// Required. Model ID of the model to delete.
    pub model_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::DeleteModelRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::DeleteModelRequest::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [model_id][crate::model::DeleteModelRequest::model_id].
    pub fn set_model_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.DeleteModelRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteModelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __model_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteModelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "modelId" => Ok(__FieldTag::__model_id),
                            "model_id" => Ok(__FieldTag::__model_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteModelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteModelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__model_id => {
                            if !fields.insert(__FieldTag::__model_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model_id",
                                ));
                            }
                            result.model_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteModelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.dataset_id.is_empty() {
            state.serialize_entry("datasetId", &self.dataset_id)?;
        }
        if !self.model_id.is_empty() {
            state.serialize_entry("modelId", &self.model_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request format for listing BigQuery ML models.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListModelsRequest {
    /// Required. Project ID of the models to list.
    pub project_id: std::string::String,

    /// Required. Dataset ID of the models to list.
    pub dataset_id: std::string::String,

    /// The maximum number of results to return in a single response page.
    /// Leverage the page tokens to iterate through the entire collection.
    pub max_results: std::option::Option<wkt::UInt32Value>,

    /// Page token, returned by a previous call to request the next page of
    /// results
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListModelsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::ListModelsRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::ListModelsRequest::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [max_results][crate::model::ListModelsRequest::max_results].
    pub fn set_max_results<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::UInt32Value>,
    {
        self.max_results = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [max_results][crate::model::ListModelsRequest::max_results].
    pub fn set_or_clear_max_results<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::UInt32Value>,
    {
        self.max_results = v.map(|x| x.into());
        self
    }

    /// Sets the value of [page_token][crate::model::ListModelsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListModelsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ListModelsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListModelsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __max_results,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListModelsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "maxResults" => Ok(__FieldTag::__max_results),
                            "max_results" => Ok(__FieldTag::__max_results),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListModelsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListModelsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__max_results => {
                            if !fields.insert(__FieldTag::__max_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_results",
                                ));
                            }
                            struct __With(std::option::Option<wkt::UInt32Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_results = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListModelsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.dataset_id.is_empty() {
            state.serialize_entry("datasetId", &self.dataset_id)?;
        }
        if self.max_results.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::UInt32Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("maxResults", &__With(&self.max_results))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response format for a single page when listing BigQuery ML models.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListModelsResponse {
    /// Models in the requested dataset. Only the following fields are populated:
    /// model_reference, model_type, creation_time, last_modified_time and
    /// labels.
    pub models: std::vec::Vec<crate::model::Model>,

    /// A token to request the next page of results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListModelsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [models][crate::model::ListModelsResponse::models].
    pub fn set_models<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Model>,
    {
        use std::iter::Iterator;
        self.models = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListModelsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListModelsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ListModelsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListModelsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __models,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListModelsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "models" => Ok(__FieldTag::__models),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListModelsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListModelsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__models => {
                            if !fields.insert(__FieldTag::__models) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for models",
                                ));
                            }
                            result.models = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Model>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListModelsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.models.is_empty() {
            state.serialize_entry("models", &self.models)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Id path of a model.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ModelReference {
    /// Required. The ID of the project containing this model.
    pub project_id: std::string::String,

    /// Required. The ID of the dataset containing this model.
    pub dataset_id: std::string::String,

    /// Required. The ID of the model. The ID must contain only
    /// letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum
    /// length is 1,024 characters.
    pub model_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ModelReference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::ModelReference::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::ModelReference::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [model_id][crate::model::ModelReference::model_id].
    pub fn set_model_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model_id = v.into();
        self
    }
}

impl wkt::message::Message for ModelReference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ModelReference"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ModelReference {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __model_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ModelReference")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "modelId" => Ok(__FieldTag::__model_id),
                            "model_id" => Ok(__FieldTag::__model_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ModelReference;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ModelReference")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__model_id => {
                            if !fields.insert(__FieldTag::__model_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model_id",
                                ));
                            }
                            result.model_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ModelReference {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.dataset_id.is_empty() {
            state.serialize_entry("datasetId", &self.dataset_id)?;
        }
        if !self.model_id.is_empty() {
            state.serialize_entry("modelId", &self.model_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The partitioning information, which includes managed table, external table
/// and metastore partitioned table partition information.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PartitioningDefinition {
    /// Optional. Details about each partitioning column. This field is output only
    /// for all partitioning types other than metastore partitioned tables.
    /// BigQuery native tables only support 1 partitioning column. Other table
    /// types may support 0, 1 or more partitioning columns.
    /// For metastore partitioned tables, the order must match the definition order
    /// in the Hive Metastore, where it must match the physical layout of the
    /// table. For example,
    ///
    /// CREATE TABLE a_table(id BIGINT, name STRING)
    /// PARTITIONED BY (city STRING, state STRING).
    ///
    /// In this case the values must be ['city', 'state'] in that order.
    pub partitioned_column: std::vec::Vec<crate::model::PartitionedColumn>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PartitioningDefinition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [partitioned_column][crate::model::PartitioningDefinition::partitioned_column].
    pub fn set_partitioned_column<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PartitionedColumn>,
    {
        use std::iter::Iterator;
        self.partitioned_column = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PartitioningDefinition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.PartitioningDefinition"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PartitioningDefinition {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __partitioned_column,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PartitioningDefinition")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "partitionedColumn" => Ok(__FieldTag::__partitioned_column),
                            "partitioned_column" => Ok(__FieldTag::__partitioned_column),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PartitioningDefinition;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PartitioningDefinition")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__partitioned_column => {
                            if !fields.insert(__FieldTag::__partitioned_column) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for partitioned_column",
                                ));
                            }
                            result.partitioned_column =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::PartitionedColumn>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PartitioningDefinition {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.partitioned_column.is_empty() {
            state.serialize_entry("partitionedColumn", &self.partitioned_column)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The partitioning column information.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PartitionedColumn {
    /// Required. The name of the partition column.
    pub field: std::option::Option<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PartitionedColumn {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [field][crate::model::PartitionedColumn::field].
    pub fn set_field<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.field = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [field][crate::model::PartitionedColumn::field].
    pub fn set_or_clear_field<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.field = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PartitionedColumn {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.PartitionedColumn"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PartitionedColumn {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __field,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PartitionedColumn")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "field" => Ok(__FieldTag::__field),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PartitionedColumn;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PartitionedColumn")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__field => {
                            if !fields.insert(__FieldTag::__field) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field",
                                ));
                            }
                            result.field =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PartitionedColumn {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.field.is_some() {
            state.serialize_entry("field", &self.field)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents privacy policy associated with "aggregation threshold" method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AggregationThresholdPolicy {
    /// Optional. The threshold for the "aggregation threshold" policy.
    pub threshold: std::option::Option<i64>,

    /// Optional. The privacy unit column(s) associated with this policy.
    /// For now, only one column per data source object (table, view) is allowed as
    /// a privacy unit column.
    /// Representing as a repeated field in metadata for extensibility to
    /// multiple columns in future.
    /// Duplicates and Repeated struct fields are not allowed.
    /// For nested fields, use dot notation ("outer.inner")
    pub privacy_unit_columns: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AggregationThresholdPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [threshold][crate::model::AggregationThresholdPolicy::threshold].
    pub fn set_threshold<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.threshold = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [threshold][crate::model::AggregationThresholdPolicy::threshold].
    pub fn set_or_clear_threshold<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.threshold = v.map(|x| x.into());
        self
    }

    /// Sets the value of [privacy_unit_columns][crate::model::AggregationThresholdPolicy::privacy_unit_columns].
    pub fn set_privacy_unit_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.privacy_unit_columns = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AggregationThresholdPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.AggregationThresholdPolicy"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AggregationThresholdPolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __threshold,
            __privacy_unit_columns,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AggregationThresholdPolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "threshold" => Ok(__FieldTag::__threshold),
                            "privacyUnitColumns" => Ok(__FieldTag::__privacy_unit_columns),
                            "privacy_unit_columns" => Ok(__FieldTag::__privacy_unit_columns),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AggregationThresholdPolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AggregationThresholdPolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__threshold => {
                            if !fields.insert(__FieldTag::__threshold) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for threshold",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.threshold = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__privacy_unit_columns => {
                            if !fields.insert(__FieldTag::__privacy_unit_columns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for privacy_unit_columns",
                                ));
                            }
                            result.privacy_unit_columns = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AggregationThresholdPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.threshold.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("threshold", &__With(&self.threshold))?;
        }
        if !self.privacy_unit_columns.is_empty() {
            state.serialize_entry("privacyUnitColumns", &self.privacy_unit_columns)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents privacy policy associated with "differential privacy" method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DifferentialPrivacyPolicy {
    /// Optional. The maximum epsilon value that a query can consume. If the
    /// subscriber specifies epsilon as a parameter in a SELECT query, it must be
    /// less than or equal to this value. The epsilon parameter controls the amount
    /// of noise that is added to the groups — a higher epsilon means less noise.
    pub max_epsilon_per_query: std::option::Option<f64>,

    /// Optional. The delta value that is used per query. Delta represents the
    /// probability that any row will fail to be epsilon differentially private.
    /// Indicates the risk associated with exposing aggregate rows in the result of
    /// a query.
    pub delta_per_query: std::option::Option<f64>,

    /// Optional. The maximum groups contributed value that is used per query.
    /// Represents the maximum number of groups to which each protected entity can
    /// contribute. Changing this value does not improve or worsen privacy. The
    /// best value for accuracy and utility depends on the query and data.
    pub max_groups_contributed: std::option::Option<i64>,

    /// Optional. The privacy unit column associated with this policy. Differential
    /// privacy policies can only have one privacy unit column per data source
    /// object (table, view).
    pub privacy_unit_column: std::option::Option<std::string::String>,

    /// Optional. The total epsilon budget for all queries against the
    /// privacy-protected view. Each subscriber query against this view charges the
    /// amount of epsilon they request in their query. If there is sufficient
    /// budget, then the subscriber query attempts to complete. It might still fail
    /// due to other reasons, in which case the charge is refunded. If there is
    /// insufficient budget the query is rejected. There might be multiple charge
    /// attempts if a single query references multiple views. In this case there
    /// must be sufficient budget for all charges or the query is rejected and
    /// charges are refunded in best effort. The budget does not have a refresh
    /// policy and can only be updated via ALTER VIEW or circumvented by creating a
    /// new view that can be queried with a fresh budget.
    pub epsilon_budget: std::option::Option<f64>,

    /// Optional. The total delta budget for all queries against the
    /// privacy-protected view. Each subscriber query against this view charges the
    /// amount of delta that is pre-defined by the contributor through the privacy
    /// policy delta_per_query field. If there is sufficient budget, then the
    /// subscriber query attempts to complete. It might still fail due to other
    /// reasons, in which case the charge is refunded. If there is insufficient
    /// budget the query is rejected. There might be multiple charge attempts if a
    /// single query references multiple views. In this case there must be
    /// sufficient budget for all charges or the query is rejected and charges are
    /// refunded in best effort. The budget does not have a refresh policy and can
    /// only be updated via ALTER VIEW or circumvented by creating a new view that
    /// can be queried with a fresh budget.
    pub delta_budget: std::option::Option<f64>,

    /// Output only. The epsilon budget remaining. If budget is exhausted, no more
    /// queries are allowed. Note that the budget for queries that are in progress
    /// is deducted before the query executes. If the query fails or is cancelled
    /// then the budget is refunded. In this case the amount of budget remaining
    /// can increase.
    pub epsilon_budget_remaining: std::option::Option<f64>,

    /// Output only. The delta budget remaining. If budget is exhausted, no more
    /// queries are allowed. Note that the budget for queries that are in progress
    /// is deducted before the query executes. If the query fails or is cancelled
    /// then the budget is refunded. In this case the amount of budget remaining
    /// can increase.
    pub delta_budget_remaining: std::option::Option<f64>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DifferentialPrivacyPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [max_epsilon_per_query][crate::model::DifferentialPrivacyPolicy::max_epsilon_per_query].
    pub fn set_max_epsilon_per_query<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.max_epsilon_per_query = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [max_epsilon_per_query][crate::model::DifferentialPrivacyPolicy::max_epsilon_per_query].
    pub fn set_or_clear_max_epsilon_per_query<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.max_epsilon_per_query = v.map(|x| x.into());
        self
    }

    /// Sets the value of [delta_per_query][crate::model::DifferentialPrivacyPolicy::delta_per_query].
    pub fn set_delta_per_query<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.delta_per_query = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [delta_per_query][crate::model::DifferentialPrivacyPolicy::delta_per_query].
    pub fn set_or_clear_delta_per_query<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.delta_per_query = v.map(|x| x.into());
        self
    }

    /// Sets the value of [max_groups_contributed][crate::model::DifferentialPrivacyPolicy::max_groups_contributed].
    pub fn set_max_groups_contributed<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.max_groups_contributed = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [max_groups_contributed][crate::model::DifferentialPrivacyPolicy::max_groups_contributed].
    pub fn set_or_clear_max_groups_contributed<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.max_groups_contributed = v.map(|x| x.into());
        self
    }

    /// Sets the value of [privacy_unit_column][crate::model::DifferentialPrivacyPolicy::privacy_unit_column].
    pub fn set_privacy_unit_column<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.privacy_unit_column = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [privacy_unit_column][crate::model::DifferentialPrivacyPolicy::privacy_unit_column].
    pub fn set_or_clear_privacy_unit_column<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.privacy_unit_column = v.map(|x| x.into());
        self
    }

    /// Sets the value of [epsilon_budget][crate::model::DifferentialPrivacyPolicy::epsilon_budget].
    pub fn set_epsilon_budget<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.epsilon_budget = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [epsilon_budget][crate::model::DifferentialPrivacyPolicy::epsilon_budget].
    pub fn set_or_clear_epsilon_budget<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.epsilon_budget = v.map(|x| x.into());
        self
    }

    /// Sets the value of [delta_budget][crate::model::DifferentialPrivacyPolicy::delta_budget].
    pub fn set_delta_budget<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.delta_budget = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [delta_budget][crate::model::DifferentialPrivacyPolicy::delta_budget].
    pub fn set_or_clear_delta_budget<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.delta_budget = v.map(|x| x.into());
        self
    }

    /// Sets the value of [epsilon_budget_remaining][crate::model::DifferentialPrivacyPolicy::epsilon_budget_remaining].
    pub fn set_epsilon_budget_remaining<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.epsilon_budget_remaining = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [epsilon_budget_remaining][crate::model::DifferentialPrivacyPolicy::epsilon_budget_remaining].
    pub fn set_or_clear_epsilon_budget_remaining<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.epsilon_budget_remaining = v.map(|x| x.into());
        self
    }

    /// Sets the value of [delta_budget_remaining][crate::model::DifferentialPrivacyPolicy::delta_budget_remaining].
    pub fn set_delta_budget_remaining<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.delta_budget_remaining = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [delta_budget_remaining][crate::model::DifferentialPrivacyPolicy::delta_budget_remaining].
    pub fn set_or_clear_delta_budget_remaining<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.delta_budget_remaining = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DifferentialPrivacyPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.DifferentialPrivacyPolicy"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DifferentialPrivacyPolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __max_epsilon_per_query,
            __delta_per_query,
            __max_groups_contributed,
            __privacy_unit_column,
            __epsilon_budget,
            __delta_budget,
            __epsilon_budget_remaining,
            __delta_budget_remaining,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DifferentialPrivacyPolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "maxEpsilonPerQuery" => Ok(__FieldTag::__max_epsilon_per_query),
                            "max_epsilon_per_query" => Ok(__FieldTag::__max_epsilon_per_query),
                            "deltaPerQuery" => Ok(__FieldTag::__delta_per_query),
                            "delta_per_query" => Ok(__FieldTag::__delta_per_query),
                            "maxGroupsContributed" => Ok(__FieldTag::__max_groups_contributed),
                            "max_groups_contributed" => Ok(__FieldTag::__max_groups_contributed),
                            "privacyUnitColumn" => Ok(__FieldTag::__privacy_unit_column),
                            "privacy_unit_column" => Ok(__FieldTag::__privacy_unit_column),
                            "epsilonBudget" => Ok(__FieldTag::__epsilon_budget),
                            "epsilon_budget" => Ok(__FieldTag::__epsilon_budget),
                            "deltaBudget" => Ok(__FieldTag::__delta_budget),
                            "delta_budget" => Ok(__FieldTag::__delta_budget),
                            "epsilonBudgetRemaining" => Ok(__FieldTag::__epsilon_budget_remaining),
                            "epsilon_budget_remaining" => {
                                Ok(__FieldTag::__epsilon_budget_remaining)
                            }
                            "deltaBudgetRemaining" => Ok(__FieldTag::__delta_budget_remaining),
                            "delta_budget_remaining" => Ok(__FieldTag::__delta_budget_remaining),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DifferentialPrivacyPolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DifferentialPrivacyPolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__max_epsilon_per_query => {
                            if !fields.insert(__FieldTag::__max_epsilon_per_query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_epsilon_per_query",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_epsilon_per_query = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__delta_per_query => {
                            if !fields.insert(__FieldTag::__delta_per_query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delta_per_query",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.delta_per_query = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__max_groups_contributed => {
                            if !fields.insert(__FieldTag::__max_groups_contributed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_groups_contributed",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_groups_contributed = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__privacy_unit_column => {
                            if !fields.insert(__FieldTag::__privacy_unit_column) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for privacy_unit_column",
                                ));
                            }
                            result.privacy_unit_column =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__epsilon_budget => {
                            if !fields.insert(__FieldTag::__epsilon_budget) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for epsilon_budget",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.epsilon_budget = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__delta_budget => {
                            if !fields.insert(__FieldTag::__delta_budget) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delta_budget",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.delta_budget = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__epsilon_budget_remaining => {
                            if !fields.insert(__FieldTag::__epsilon_budget_remaining) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for epsilon_budget_remaining",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.epsilon_budget_remaining = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__delta_budget_remaining => {
                            if !fields.insert(__FieldTag::__delta_budget_remaining) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delta_budget_remaining",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.delta_budget_remaining = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DifferentialPrivacyPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.max_epsilon_per_query.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("maxEpsilonPerQuery", &__With(&self.max_epsilon_per_query))?;
        }
        if self.delta_per_query.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("deltaPerQuery", &__With(&self.delta_per_query))?;
        }
        if self.max_groups_contributed.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "maxGroupsContributed",
                &__With(&self.max_groups_contributed),
            )?;
        }
        if self.privacy_unit_column.is_some() {
            state.serialize_entry("privacyUnitColumn", &self.privacy_unit_column)?;
        }
        if self.epsilon_budget.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("epsilonBudget", &__With(&self.epsilon_budget))?;
        }
        if self.delta_budget.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("deltaBudget", &__With(&self.delta_budget))?;
        }
        if self.epsilon_budget_remaining.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "epsilonBudgetRemaining",
                &__With(&self.epsilon_budget_remaining),
            )?;
        }
        if self.delta_budget_remaining.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "deltaBudgetRemaining",
                &__With(&self.delta_budget_remaining),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents privacy policy associated with "join restrictions". Join
/// restriction gives data providers the ability to enforce joins on the
/// 'join_allowed_columns' when data is queried from a privacy protected view.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct JoinRestrictionPolicy {
    /// Optional. Specifies if a join is required or not on queries for the view.
    /// Default is JOIN_CONDITION_UNSPECIFIED.
    pub join_condition: std::option::Option<crate::model::join_restriction_policy::JoinCondition>,

    /// Optional. The only columns that joins are allowed on.
    /// This field is must be specified for join_conditions JOIN_ANY and JOIN_ALL
    /// and it cannot be set for JOIN_BLOCKED.
    pub join_allowed_columns: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl JoinRestrictionPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [join_condition][crate::model::JoinRestrictionPolicy::join_condition].
    pub fn set_join_condition<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::join_restriction_policy::JoinCondition>,
    {
        self.join_condition = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [join_condition][crate::model::JoinRestrictionPolicy::join_condition].
    pub fn set_or_clear_join_condition<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::join_restriction_policy::JoinCondition>,
    {
        self.join_condition = v.map(|x| x.into());
        self
    }

    /// Sets the value of [join_allowed_columns][crate::model::JoinRestrictionPolicy::join_allowed_columns].
    pub fn set_join_allowed_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.join_allowed_columns = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for JoinRestrictionPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.JoinRestrictionPolicy"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for JoinRestrictionPolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __join_condition,
            __join_allowed_columns,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for JoinRestrictionPolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "joinCondition" => Ok(__FieldTag::__join_condition),
                            "join_condition" => Ok(__FieldTag::__join_condition),
                            "joinAllowedColumns" => Ok(__FieldTag::__join_allowed_columns),
                            "join_allowed_columns" => Ok(__FieldTag::__join_allowed_columns),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = JoinRestrictionPolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct JoinRestrictionPolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__join_condition => {
                            if !fields.insert(__FieldTag::__join_condition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for join_condition",
                                ));
                            }
                            result.join_condition = map.next_value::<std::option::Option<
                                crate::model::join_restriction_policy::JoinCondition,
                            >>()?;
                        }
                        __FieldTag::__join_allowed_columns => {
                            if !fields.insert(__FieldTag::__join_allowed_columns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for join_allowed_columns",
                                ));
                            }
                            result.join_allowed_columns = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for JoinRestrictionPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.join_condition.is_some() {
            state.serialize_entry("joinCondition", &self.join_condition)?;
        }
        if !self.join_allowed_columns.is_empty() {
            state.serialize_entry("joinAllowedColumns", &self.join_allowed_columns)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [JoinRestrictionPolicy].
pub mod join_restriction_policy {
    #[allow(unused_imports)]
    use super::*;

    /// Enum for Join Restrictions policy.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum JoinCondition {
        /// A join is neither required nor restricted on any column. Default value.
        Unspecified,
        /// A join is required on at least one of the specified columns.
        JoinAny,
        /// A join is required on all specified columns.
        JoinAll,
        /// A join is not required, but if present it is only permitted on
        /// 'join_allowed_columns'
        JoinNotRequired,
        /// Joins are blocked for all queries.
        JoinBlocked,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [JoinCondition::value] or
        /// [JoinCondition::name].
        UnknownValue(join_condition::UnknownValue),
    }

    #[doc(hidden)]
    pub mod join_condition {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl JoinCondition {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::JoinAny => std::option::Option::Some(1),
                Self::JoinAll => std::option::Option::Some(2),
                Self::JoinNotRequired => std::option::Option::Some(3),
                Self::JoinBlocked => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("JOIN_CONDITION_UNSPECIFIED"),
                Self::JoinAny => std::option::Option::Some("JOIN_ANY"),
                Self::JoinAll => std::option::Option::Some("JOIN_ALL"),
                Self::JoinNotRequired => std::option::Option::Some("JOIN_NOT_REQUIRED"),
                Self::JoinBlocked => std::option::Option::Some("JOIN_BLOCKED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for JoinCondition {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for JoinCondition {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for JoinCondition {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::JoinAny,
                2 => Self::JoinAll,
                3 => Self::JoinNotRequired,
                4 => Self::JoinBlocked,
                _ => Self::UnknownValue(join_condition::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for JoinCondition {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "JOIN_CONDITION_UNSPECIFIED" => Self::Unspecified,
                "JOIN_ANY" => Self::JoinAny,
                "JOIN_ALL" => Self::JoinAll,
                "JOIN_NOT_REQUIRED" => Self::JoinNotRequired,
                "JOIN_BLOCKED" => Self::JoinBlocked,
                _ => Self::UnknownValue(join_condition::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for JoinCondition {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::JoinAny => serializer.serialize_i32(1),
                Self::JoinAll => serializer.serialize_i32(2),
                Self::JoinNotRequired => serializer.serialize_i32(3),
                Self::JoinBlocked => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for JoinCondition {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<JoinCondition>::new(
                ".google.cloud.bigquery.v2.JoinRestrictionPolicy.JoinCondition",
            ))
        }
    }
}

/// Represents privacy policy that contains the privacy requirements specified by
/// the data owner. Currently, this is only supported on views.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PrivacyPolicy {
    /// Optional. Join restriction policy is outside of the one of policies, since
    /// this policy can be set along with other policies. This policy gives data
    /// providers the ability to enforce joins on the 'join_allowed_columns' when
    /// data is queried from a privacy protected view.
    pub join_restriction_policy: std::option::Option<crate::model::JoinRestrictionPolicy>,

    /// Privacy policy associated with this requirement specification. Only one of
    /// the privacy methods is allowed per data source object.
    pub privacy_policy: std::option::Option<crate::model::privacy_policy::PrivacyPolicy>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PrivacyPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [join_restriction_policy][crate::model::PrivacyPolicy::join_restriction_policy].
    pub fn set_join_restriction_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::JoinRestrictionPolicy>,
    {
        self.join_restriction_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [join_restriction_policy][crate::model::PrivacyPolicy::join_restriction_policy].
    pub fn set_or_clear_join_restriction_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::JoinRestrictionPolicy>,
    {
        self.join_restriction_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [privacy_policy][crate::model::PrivacyPolicy::privacy_policy].
    ///
    /// Note that all the setters affecting `privacy_policy` are mutually
    /// exclusive.
    pub fn set_privacy_policy<
        T: std::convert::Into<std::option::Option<crate::model::privacy_policy::PrivacyPolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.privacy_policy = v.into();
        self
    }

    /// The value of [privacy_policy][crate::model::PrivacyPolicy::privacy_policy]
    /// if it holds a `AggregationThresholdPolicy`, `None` if the field is not set or
    /// holds a different branch.
    pub fn aggregation_threshold_policy(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AggregationThresholdPolicy>> {
        #[allow(unreachable_patterns)]
        self.privacy_policy.as_ref().and_then(|v| match v {
            crate::model::privacy_policy::PrivacyPolicy::AggregationThresholdPolicy(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [privacy_policy][crate::model::PrivacyPolicy::privacy_policy]
    /// to hold a `AggregationThresholdPolicy`.
    ///
    /// Note that all the setters affecting `privacy_policy` are
    /// mutually exclusive.
    pub fn set_aggregation_threshold_policy<
        T: std::convert::Into<std::boxed::Box<crate::model::AggregationThresholdPolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.privacy_policy = std::option::Option::Some(
            crate::model::privacy_policy::PrivacyPolicy::AggregationThresholdPolicy(v.into()),
        );
        self
    }

    /// The value of [privacy_policy][crate::model::PrivacyPolicy::privacy_policy]
    /// if it holds a `DifferentialPrivacyPolicy`, `None` if the field is not set or
    /// holds a different branch.
    pub fn differential_privacy_policy(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DifferentialPrivacyPolicy>> {
        #[allow(unreachable_patterns)]
        self.privacy_policy.as_ref().and_then(|v| match v {
            crate::model::privacy_policy::PrivacyPolicy::DifferentialPrivacyPolicy(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [privacy_policy][crate::model::PrivacyPolicy::privacy_policy]
    /// to hold a `DifferentialPrivacyPolicy`.
    ///
    /// Note that all the setters affecting `privacy_policy` are
    /// mutually exclusive.
    pub fn set_differential_privacy_policy<
        T: std::convert::Into<std::boxed::Box<crate::model::DifferentialPrivacyPolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.privacy_policy = std::option::Option::Some(
            crate::model::privacy_policy::PrivacyPolicy::DifferentialPrivacyPolicy(v.into()),
        );
        self
    }
}

impl wkt::message::Message for PrivacyPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.PrivacyPolicy"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PrivacyPolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __aggregation_threshold_policy,
            __differential_privacy_policy,
            __join_restriction_policy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PrivacyPolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "aggregationThresholdPolicy" => {
                                Ok(__FieldTag::__aggregation_threshold_policy)
                            }
                            "aggregation_threshold_policy" => {
                                Ok(__FieldTag::__aggregation_threshold_policy)
                            }
                            "differentialPrivacyPolicy" => {
                                Ok(__FieldTag::__differential_privacy_policy)
                            }
                            "differential_privacy_policy" => {
                                Ok(__FieldTag::__differential_privacy_policy)
                            }
                            "joinRestrictionPolicy" => Ok(__FieldTag::__join_restriction_policy),
                            "join_restriction_policy" => Ok(__FieldTag::__join_restriction_policy),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PrivacyPolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PrivacyPolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__aggregation_threshold_policy => {
                            if !fields.insert(__FieldTag::__aggregation_threshold_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aggregation_threshold_policy",
                                ));
                            }
                            if result.privacy_policy.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `privacy_policy`, a oneof with full ID .google.cloud.bigquery.v2.PrivacyPolicy.aggregation_threshold_policy, latest field was aggregationThresholdPolicy",
                                ));
                            }
                            result.privacy_policy = std::option::Option::Some(
                                crate::model::privacy_policy::PrivacyPolicy::AggregationThresholdPolicy(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::AggregationThresholdPolicy>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__differential_privacy_policy => {
                            if !fields.insert(__FieldTag::__differential_privacy_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for differential_privacy_policy",
                                ));
                            }
                            if result.privacy_policy.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `privacy_policy`, a oneof with full ID .google.cloud.bigquery.v2.PrivacyPolicy.differential_privacy_policy, latest field was differentialPrivacyPolicy",
                                ));
                            }
                            result.privacy_policy = std::option::Option::Some(
                                crate::model::privacy_policy::PrivacyPolicy::DifferentialPrivacyPolicy(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::DifferentialPrivacyPolicy>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__join_restriction_policy => {
                            if !fields.insert(__FieldTag::__join_restriction_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for join_restriction_policy",
                                ));
                            }
                            result.join_restriction_policy = map.next_value::<std::option::Option<crate::model::JoinRestrictionPolicy>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PrivacyPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.aggregation_threshold_policy() {
            state.serialize_entry("aggregationThresholdPolicy", value)?;
        }
        if let Some(value) = self.differential_privacy_policy() {
            state.serialize_entry("differentialPrivacyPolicy", value)?;
        }
        if self.join_restriction_policy.is_some() {
            state.serialize_entry("joinRestrictionPolicy", &self.join_restriction_policy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [PrivacyPolicy].
pub mod privacy_policy {
    #[allow(unused_imports)]
    use super::*;

    /// Privacy policy associated with this requirement specification. Only one of
    /// the privacy methods is allowed per data source object.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PrivacyPolicy {
        /// Optional. Policy used for aggregation thresholds.
        AggregationThresholdPolicy(std::boxed::Box<crate::model::AggregationThresholdPolicy>),
        /// Optional. Policy used for differential privacy.
        DifferentialPrivacyPolicy(std::boxed::Box<crate::model::DifferentialPrivacyPolicy>),
    }
}

/// Request object of GetServiceAccount
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetServiceAccountRequest {
    /// Required. ID of the project.
    pub project_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetServiceAccountRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::GetServiceAccountRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }
}

impl wkt::message::Message for GetServiceAccountRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.GetServiceAccountRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetServiceAccountRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetServiceAccountRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetServiceAccountRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetServiceAccountRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetServiceAccountRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response object of GetServiceAccount
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetServiceAccountResponse {
    /// The resource type of the response.
    pub kind: std::string::String,

    /// The service account email address.
    pub email: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetServiceAccountResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::GetServiceAccountResponse::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [email][crate::model::GetServiceAccountResponse::email].
    pub fn set_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.email = v.into();
        self
    }
}

impl wkt::message::Message for GetServiceAccountResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.GetServiceAccountResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetServiceAccountResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __email,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetServiceAccountResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "email" => Ok(__FieldTag::__email),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetServiceAccountResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetServiceAccountResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__email => {
                            if !fields.insert(__FieldTag::__email) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for email",
                                ));
                            }
                            result.email = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetServiceAccountResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self.email.is_empty() {
            state.serialize_entry("email", &self.email)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The type of a struct parameter.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct QueryParameterStructType {
    /// Optional. The name of this field.
    pub name: std::string::String,

    /// Required. The type of this field.
    pub r#type: std::option::Option<std::boxed::Box<crate::model::QueryParameterType>>,

    /// Optional. Human-oriented description of the field.
    pub description: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QueryParameterStructType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::QueryParameterStructType::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::QueryParameterStructType::type].
    pub fn set_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::QueryParameterType>,
    {
        self.r#type = std::option::Option::Some(std::boxed::Box::new(v.into()));
        self
    }

    /// Sets or clears the value of [r#type][crate::model::QueryParameterStructType::type].
    pub fn set_or_clear_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::QueryParameterType>,
    {
        self.r#type = v.map(|x| std::boxed::Box::new(x.into()));
        self
    }

    /// Sets the value of [description][crate::model::QueryParameterStructType::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }
}

impl wkt::message::Message for QueryParameterStructType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.QueryParameterStructType"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for QueryParameterStructType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __type,
            __description,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QueryParameterStructType")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "type" => Ok(__FieldTag::__type),
                            "description" => Ok(__FieldTag::__description),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = QueryParameterStructType;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QueryParameterStructType")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<
                                std::boxed::Box<crate::model::QueryParameterType>,
                            >>()?;
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for QueryParameterStructType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.r#type.is_some() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The type of a query parameter.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct QueryParameterType {
    /// Required. The top level type of this field.
    pub r#type: std::string::String,

    /// Optional. The type of the array's elements, if this is an array.
    pub array_type: std::option::Option<std::boxed::Box<crate::model::QueryParameterType>>,

    /// Optional. The types of the fields of this struct, in order, if this is a
    /// struct.
    pub struct_types: std::vec::Vec<crate::model::QueryParameterStructType>,

    /// Optional. The element type of the range, if this is a range.
    pub range_element_type: std::option::Option<std::boxed::Box<crate::model::QueryParameterType>>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QueryParameterType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::QueryParameterType::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [array_type][crate::model::QueryParameterType::array_type].
    pub fn set_array_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::QueryParameterType>,
    {
        self.array_type = std::option::Option::Some(std::boxed::Box::new(v.into()));
        self
    }

    /// Sets or clears the value of [array_type][crate::model::QueryParameterType::array_type].
    pub fn set_or_clear_array_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::QueryParameterType>,
    {
        self.array_type = v.map(|x| std::boxed::Box::new(x.into()));
        self
    }

    /// Sets the value of [struct_types][crate::model::QueryParameterType::struct_types].
    pub fn set_struct_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::QueryParameterStructType>,
    {
        use std::iter::Iterator;
        self.struct_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [range_element_type][crate::model::QueryParameterType::range_element_type].
    pub fn set_range_element_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::QueryParameterType>,
    {
        self.range_element_type = std::option::Option::Some(std::boxed::Box::new(v.into()));
        self
    }

    /// Sets or clears the value of [range_element_type][crate::model::QueryParameterType::range_element_type].
    pub fn set_or_clear_range_element_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::QueryParameterType>,
    {
        self.range_element_type = v.map(|x| std::boxed::Box::new(x.into()));
        self
    }
}

impl wkt::message::Message for QueryParameterType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.QueryParameterType"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for QueryParameterType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __array_type,
            __struct_types,
            __range_element_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QueryParameterType")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "arrayType" => Ok(__FieldTag::__array_type),
                            "array_type" => Ok(__FieldTag::__array_type),
                            "structTypes" => Ok(__FieldTag::__struct_types),
                            "struct_types" => Ok(__FieldTag::__struct_types),
                            "rangeElementType" => Ok(__FieldTag::__range_element_type),
                            "range_element_type" => Ok(__FieldTag::__range_element_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = QueryParameterType;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QueryParameterType")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__array_type => {
                            if !fields.insert(__FieldTag::__array_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for array_type",
                                ));
                            }
                            result.array_type = map.next_value::<std::option::Option<
                                std::boxed::Box<crate::model::QueryParameterType>,
                            >>()?;
                        }
                        __FieldTag::__struct_types => {
                            if !fields.insert(__FieldTag::__struct_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for struct_types",
                                ));
                            }
                            result.struct_types = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::QueryParameterStructType>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__range_element_type => {
                            if !fields.insert(__FieldTag::__range_element_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for range_element_type",
                                ));
                            }
                            result.range_element_type = map.next_value::<std::option::Option<
                                std::boxed::Box<crate::model::QueryParameterType>,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for QueryParameterType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.r#type.is_empty() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if self.array_type.is_some() {
            state.serialize_entry("arrayType", &self.array_type)?;
        }
        if !self.struct_types.is_empty() {
            state.serialize_entry("structTypes", &self.struct_types)?;
        }
        if self.range_element_type.is_some() {
            state.serialize_entry("rangeElementType", &self.range_element_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents the value of a range.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RangeValue {
    /// Optional. The start value of the range. A missing value represents an
    /// unbounded start.
    pub start: std::option::Option<std::boxed::Box<crate::model::QueryParameterValue>>,

    /// Optional. The end value of the range. A missing value represents an
    /// unbounded end.
    pub end: std::option::Option<std::boxed::Box<crate::model::QueryParameterValue>>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RangeValue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start][crate::model::RangeValue::start].
    pub fn set_start<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::QueryParameterValue>,
    {
        self.start = std::option::Option::Some(std::boxed::Box::new(v.into()));
        self
    }

    /// Sets or clears the value of [start][crate::model::RangeValue::start].
    pub fn set_or_clear_start<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::QueryParameterValue>,
    {
        self.start = v.map(|x| std::boxed::Box::new(x.into()));
        self
    }

    /// Sets the value of [end][crate::model::RangeValue::end].
    pub fn set_end<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::QueryParameterValue>,
    {
        self.end = std::option::Option::Some(std::boxed::Box::new(v.into()));
        self
    }

    /// Sets or clears the value of [end][crate::model::RangeValue::end].
    pub fn set_or_clear_end<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::QueryParameterValue>,
    {
        self.end = v.map(|x| std::boxed::Box::new(x.into()));
        self
    }
}

impl wkt::message::Message for RangeValue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.RangeValue"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RangeValue {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __start,
            __end,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RangeValue")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "start" => Ok(__FieldTag::__start),
                            "end" => Ok(__FieldTag::__end),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RangeValue;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RangeValue")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__start => {
                            if !fields.insert(__FieldTag::__start) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start",
                                ));
                            }
                            result.start = map.next_value::<std::option::Option<
                                std::boxed::Box<crate::model::QueryParameterValue>,
                            >>()?;
                        }
                        __FieldTag::__end => {
                            if !fields.insert(__FieldTag::__end) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end",
                                ));
                            }
                            result.end = map.next_value::<std::option::Option<
                                std::boxed::Box<crate::model::QueryParameterValue>,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RangeValue {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.start.is_some() {
            state.serialize_entry("start", &self.start)?;
        }
        if self.end.is_some() {
            state.serialize_entry("end", &self.end)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The value of a query parameter.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct QueryParameterValue {
    /// Optional. The value of this value, if a simple scalar type.
    pub value: std::option::Option<wkt::StringValue>,

    /// Optional. The array values, if this is an array type.
    pub array_values: std::vec::Vec<crate::model::QueryParameterValue>,

    /// The struct field values.
    pub struct_values:
        std::collections::HashMap<std::string::String, crate::model::QueryParameterValue>,

    /// Optional. The range value, if this is a range type.
    pub range_value: std::option::Option<std::boxed::Box<crate::model::RangeValue>>,

    /// This field should not be used.
    pub alt_struct_values: std::vec::Vec<wkt::Value>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QueryParameterValue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [value][crate::model::QueryParameterValue::value].
    pub fn set_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.value = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [value][crate::model::QueryParameterValue::value].
    pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.value = v.map(|x| x.into());
        self
    }

    /// Sets the value of [array_values][crate::model::QueryParameterValue::array_values].
    pub fn set_array_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::QueryParameterValue>,
    {
        use std::iter::Iterator;
        self.array_values = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [struct_values][crate::model::QueryParameterValue::struct_values].
    pub fn set_struct_values<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::QueryParameterValue>,
    {
        use std::iter::Iterator;
        self.struct_values = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [range_value][crate::model::QueryParameterValue::range_value].
    pub fn set_range_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RangeValue>,
    {
        self.range_value = std::option::Option::Some(std::boxed::Box::new(v.into()));
        self
    }

    /// Sets or clears the value of [range_value][crate::model::QueryParameterValue::range_value].
    pub fn set_or_clear_range_value<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RangeValue>,
    {
        self.range_value = v.map(|x| std::boxed::Box::new(x.into()));
        self
    }

    /// Sets the value of [alt_struct_values][crate::model::QueryParameterValue::alt_struct_values].
    pub fn set_alt_struct_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Value>,
    {
        use std::iter::Iterator;
        self.alt_struct_values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for QueryParameterValue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.QueryParameterValue"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for QueryParameterValue {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __value,
            __array_values,
            __struct_values,
            __range_value,
            __alt_struct_values,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QueryParameterValue")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "value" => Ok(__FieldTag::__value),
                            "arrayValues" => Ok(__FieldTag::__array_values),
                            "array_values" => Ok(__FieldTag::__array_values),
                            "structValues" => Ok(__FieldTag::__struct_values),
                            "struct_values" => Ok(__FieldTag::__struct_values),
                            "rangeValue" => Ok(__FieldTag::__range_value),
                            "range_value" => Ok(__FieldTag::__range_value),
                            "altStructValues" => Ok(__FieldTag::__alt_struct_values),
                            "alt_struct_values" => Ok(__FieldTag::__alt_struct_values),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = QueryParameterValue;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QueryParameterValue")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            result.value =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::__array_values => {
                            if !fields.insert(__FieldTag::__array_values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for array_values",
                                ));
                            }
                            result.array_values = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::QueryParameterValue>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__struct_values => {
                            if !fields.insert(__FieldTag::__struct_values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for struct_values",
                                ));
                            }
                            result.struct_values = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::QueryParameterValue,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__range_value => {
                            if !fields.insert(__FieldTag::__range_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for range_value",
                                ));
                            }
                            result.range_value = map.next_value::<std::option::Option<std::boxed::Box<crate::model::RangeValue>>>()?
                                ;
                        }
                        __FieldTag::__alt_struct_values => {
                            if !fields.insert(__FieldTag::__alt_struct_values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for alt_struct_values",
                                ));
                            }
                            result.alt_struct_values = map
                                .next_value::<std::option::Option<std::vec::Vec<wkt::Value>>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for QueryParameterValue {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self.array_values.is_empty() {
            state.serialize_entry("arrayValues", &self.array_values)?;
        }
        if !self.struct_values.is_empty() {
            state.serialize_entry("structValues", &self.struct_values)?;
        }
        if self.range_value.is_some() {
            state.serialize_entry("rangeValue", &self.range_value)?;
        }
        if !self.alt_struct_values.is_empty() {
            state.serialize_entry("altStructValues", &self.alt_struct_values)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A parameter given to a query.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct QueryParameter {
    /// Optional. If unset, this is a positional parameter. Otherwise, should be
    /// unique within a query.
    pub name: std::string::String,

    /// Required. The type of this parameter.
    pub parameter_type: std::option::Option<crate::model::QueryParameterType>,

    /// Required. The value of this parameter.
    pub parameter_value: std::option::Option<crate::model::QueryParameterValue>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QueryParameter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::QueryParameter::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [parameter_type][crate::model::QueryParameter::parameter_type].
    pub fn set_parameter_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::QueryParameterType>,
    {
        self.parameter_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [parameter_type][crate::model::QueryParameter::parameter_type].
    pub fn set_or_clear_parameter_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::QueryParameterType>,
    {
        self.parameter_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [parameter_value][crate::model::QueryParameter::parameter_value].
    pub fn set_parameter_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::QueryParameterValue>,
    {
        self.parameter_value = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [parameter_value][crate::model::QueryParameter::parameter_value].
    pub fn set_or_clear_parameter_value<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::QueryParameterValue>,
    {
        self.parameter_value = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for QueryParameter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.QueryParameter"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for QueryParameter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __parameter_type,
            __parameter_value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QueryParameter")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "parameterType" => Ok(__FieldTag::__parameter_type),
                            "parameter_type" => Ok(__FieldTag::__parameter_type),
                            "parameterValue" => Ok(__FieldTag::__parameter_value),
                            "parameter_value" => Ok(__FieldTag::__parameter_value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = QueryParameter;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QueryParameter")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parameter_type => {
                            if !fields.insert(__FieldTag::__parameter_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parameter_type",
                                ));
                            }
                            result.parameter_type = map.next_value::<std::option::Option<crate::model::QueryParameterType>>()?
                                ;
                        }
                        __FieldTag::__parameter_value => {
                            if !fields.insert(__FieldTag::__parameter_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parameter_value",
                                ));
                            }
                            result.parameter_value = map.next_value::<std::option::Option<crate::model::QueryParameterValue>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for QueryParameter {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.parameter_type.is_some() {
            state.serialize_entry("parameterType", &self.parameter_type)?;
        }
        if self.parameter_value.is_some() {
            state.serialize_entry("parameterValue", &self.parameter_value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RangePartitioning {
    /// Required. The name of the column to partition the table on. It must be a
    /// top-level, INT64 column whose mode is NULLABLE or REQUIRED.
    pub field: std::string::String,

    /// Defines the ranges for range partitioning.
    pub range: std::option::Option<crate::model::range_partitioning::Range>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RangePartitioning {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [field][crate::model::RangePartitioning::field].
    pub fn set_field<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.field = v.into();
        self
    }

    /// Sets the value of [range][crate::model::RangePartitioning::range].
    pub fn set_range<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::range_partitioning::Range>,
    {
        self.range = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [range][crate::model::RangePartitioning::range].
    pub fn set_or_clear_range<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::range_partitioning::Range>,
    {
        self.range = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RangePartitioning {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.RangePartitioning"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RangePartitioning {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __field,
            __range,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RangePartitioning")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "field" => Ok(__FieldTag::__field),
                            "range" => Ok(__FieldTag::__range),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RangePartitioning;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RangePartitioning")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__field => {
                            if !fields.insert(__FieldTag::__field) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field",
                                ));
                            }
                            result.field = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__range => {
                            if !fields.insert(__FieldTag::__range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for range",
                                ));
                            }
                            result.range = map.next_value::<std::option::Option<crate::model::range_partitioning::Range>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RangePartitioning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.field.is_empty() {
            state.serialize_entry("field", &self.field)?;
        }
        if self.range.is_some() {
            state.serialize_entry("range", &self.range)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [RangePartitioning].
pub mod range_partitioning {
    #[allow(unused_imports)]
    use super::*;

    /// Defines the ranges for range partitioning.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Range {
        /// Required. The start of range partitioning, inclusive. This field is an
        /// INT64 value represented as a string.
        pub start: std::string::String,

        /// Required. The end of range partitioning, exclusive. This field is an
        /// INT64 value represented as a string.
        pub end: std::string::String,

        /// Required. The width of each interval. This field is an INT64 value
        /// represented as a string.
        pub interval: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Range {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [start][crate::model::range_partitioning::Range::start].
        pub fn set_start<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.start = v.into();
            self
        }

        /// Sets the value of [end][crate::model::range_partitioning::Range::end].
        pub fn set_end<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.end = v.into();
            self
        }

        /// Sets the value of [interval][crate::model::range_partitioning::Range::interval].
        pub fn set_interval<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.interval = v.into();
            self
        }
    }

    impl wkt::message::Message for Range {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.RangePartitioning.Range"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Range {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __start,
                __end,
                __interval,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Range")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "start" => Ok(__FieldTag::__start),
                                "end" => Ok(__FieldTag::__end),
                                "interval" => Ok(__FieldTag::__interval),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Range;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Range")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__start => {
                                if !fields.insert(__FieldTag::__start) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for start",
                                    ));
                                }
                                result.start = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__end => {
                                if !fields.insert(__FieldTag::__end) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for end",
                                    ));
                                }
                                result.end = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__interval => {
                                if !fields.insert(__FieldTag::__interval) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for interval",
                                    ));
                                }
                                result.interval = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Range {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.start.is_empty() {
                state.serialize_entry("start", &self.start)?;
            }
            if !self.end.is_empty() {
                state.serialize_entry("end", &self.end)?;
            }
            if !self.interval.is_empty() {
                state.serialize_entry("interval", &self.interval)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RestrictionConfig {
    /// Output only. Specifies the type of dataset/table restriction.
    pub r#type: crate::model::restriction_config::RestrictionType,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RestrictionConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::RestrictionConfig::type].
    pub fn set_type<T: std::convert::Into<crate::model::restriction_config::RestrictionType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }
}

impl wkt::message::Message for RestrictionConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.RestrictionConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RestrictionConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RestrictionConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RestrictionConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RestrictionConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<
                                    crate::model::restriction_config::RestrictionType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RestrictionConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [RestrictionConfig].
pub mod restriction_config {
    #[allow(unused_imports)]
    use super::*;

    /// RestrictionType specifies the type of dataset/table restriction.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RestrictionType {
        /// Should never be used.
        Unspecified,
        /// Restrict data egress. See [Data
        /// egress](https://cloud.google.com/bigquery/docs/analytics-hub-introduction#data_egress)
        /// for more details.
        RestrictedDataEgress,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RestrictionType::value] or
        /// [RestrictionType::name].
        UnknownValue(restriction_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod restriction_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RestrictionType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::RestrictedDataEgress => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RESTRICTION_TYPE_UNSPECIFIED"),
                Self::RestrictedDataEgress => std::option::Option::Some("RESTRICTED_DATA_EGRESS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RestrictionType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RestrictionType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RestrictionType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::RestrictedDataEgress,
                _ => Self::UnknownValue(restriction_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RestrictionType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RESTRICTION_TYPE_UNSPECIFIED" => Self::Unspecified,
                "RESTRICTED_DATA_EGRESS" => Self::RestrictedDataEgress,
                _ => Self::UnknownValue(restriction_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RestrictionType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::RestrictedDataEgress => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RestrictionType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RestrictionType>::new(
                ".google.cloud.bigquery.v2.RestrictionConfig.RestrictionType",
            ))
        }
    }
}

/// A user-defined function or a stored procedure.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Routine {
    /// Output only. A hash of this resource.
    pub etag: std::string::String,

    /// Required. Reference describing the ID of this routine.
    pub routine_reference: std::option::Option<crate::model::RoutineReference>,

    /// Required. The type of routine.
    pub routine_type: crate::model::routine::RoutineType,

    /// Output only. The time when this routine was created, in milliseconds since
    /// the epoch.
    pub creation_time: i64,

    /// Output only. The time when this routine was last modified, in milliseconds
    /// since the epoch.
    pub last_modified_time: i64,

    /// Optional. Defaults to "SQL" if remote_function_options field is absent, not
    /// set otherwise.
    pub language: crate::model::routine::Language,

    /// Optional.
    pub arguments: std::vec::Vec<crate::model::routine::Argument>,

    /// Optional if language = "SQL"; required otherwise.
    /// Cannot be set if routine_type = "TABLE_VALUED_FUNCTION".
    ///
    /// If absent, the return type is inferred from definition_body at query time
    /// in each query that references this routine. If present, then the evaluated
    /// result will be cast to the specified returned type at query time.
    ///
    /// For example, for the functions created with the following statements:
    ///
    /// * `CREATE FUNCTION Add(x FLOAT64, y FLOAT64) RETURNS FLOAT64 AS (x + y);`
    ///
    /// * `CREATE FUNCTION Increment(x FLOAT64) AS (Add(x, 1));`
    ///
    /// * `CREATE FUNCTION Decrement(x FLOAT64) RETURNS FLOAT64 AS (Add(x, -1));`
    ///
    ///
    /// The return_type is `{type_kind: "FLOAT64"}` for `Add` and `Decrement`, and
    /// is absent for `Increment` (inferred as FLOAT64 at query time).
    ///
    /// Suppose the function `Add` is replaced by
    /// `CREATE OR REPLACE FUNCTION Add(x INT64, y INT64) AS (x + y);`
    ///
    /// Then the inferred return type of `Increment` is automatically changed to
    /// INT64 at query time, while the return type of `Decrement` remains FLOAT64.
    pub return_type: std::option::Option<crate::model::StandardSqlDataType>,

    /// Optional. Can be set only if routine_type = "TABLE_VALUED_FUNCTION".
    ///
    /// If absent, the return table type is inferred from definition_body at query
    /// time in each query that references this routine. If present, then the
    /// columns in the evaluated table result will be cast to match the column
    /// types specified in return table type, at query time.
    pub return_table_type: std::option::Option<crate::model::StandardSqlTableType>,

    /// Optional. If language = "JAVASCRIPT", this field stores the path of the
    /// imported JAVASCRIPT libraries.
    pub imported_libraries: std::vec::Vec<std::string::String>,

    /// Required. The body of the routine.
    ///
    /// For functions, this is the expression in the AS clause.
    ///
    /// If language=SQL, it is the substring inside (but excluding) the
    /// parentheses. For example, for the function created with the following
    /// statement:
    ///
    /// `CREATE FUNCTION JoinLines(x string, y string) as (concat(x, "\n", y))`
    ///
    /// The definition_body is `concat(x, "\n", y)` (\n is not replaced with
    /// linebreak).
    ///
    /// If language=JAVASCRIPT, it is the evaluated string in the AS clause.
    /// For example, for the function created with the following statement:
    ///
    /// `CREATE FUNCTION f() RETURNS STRING LANGUAGE js AS 'return "\n";\n'`
    ///
    /// The definition_body is
    ///
    /// `return "\n";\n`
    ///
    /// Note that both \n are replaced with linebreaks.
    pub definition_body: std::string::String,

    /// Optional. The description of the routine, if defined.
    pub description: std::string::String,

    /// Optional. The determinism level of the JavaScript UDF, if defined.
    pub determinism_level: crate::model::routine::DeterminismLevel,

    /// Optional. The security mode of the routine, if defined. If not defined, the
    /// security mode is automatically determined from the routine's configuration.
    pub security_mode: crate::model::routine::SecurityMode,

    /// Optional. Use this option to catch many common errors. Error checking is
    /// not exhaustive, and successfully creating a procedure doesn't guarantee
    /// that the procedure will successfully execute at runtime. If `strictMode` is
    /// set to `TRUE`, the procedure body is further checked for errors such as
    /// non-existent tables or columns. The `CREATE PROCEDURE` statement fails if
    /// the body fails any of these checks.
    ///
    /// If `strictMode` is set to `FALSE`, the procedure body is checked only for
    /// syntax. For procedures that invoke themselves recursively, specify
    /// `strictMode=FALSE` to avoid non-existent procedure errors during
    /// validation.
    ///
    /// Default value is `TRUE`.
    pub strict_mode: std::option::Option<wkt::BoolValue>,

    /// Optional. Remote function specific options.
    pub remote_function_options: std::option::Option<crate::model::routine::RemoteFunctionOptions>,

    /// Optional. Spark specific options.
    pub spark_options: std::option::Option<crate::model::SparkOptions>,

    /// Optional. If set to `DATA_MASKING`, the function is validated and made
    /// available as a masking function. For more information, see [Create custom
    /// masking
    /// routines](https://cloud.google.com/bigquery/docs/user-defined-functions#custom-mask).
    pub data_governance_type: crate::model::routine::DataGovernanceType,

    /// Optional. Options for Python UDF.
    /// [Preview](https://cloud.google.com/products/#product-launch-stages)
    pub python_options: std::option::Option<crate::model::PythonOptions>,

    /// Optional. Options for the runtime of the external system executing the
    /// routine. This field is only applicable for Python UDFs.
    /// [Preview](https://cloud.google.com/products/#product-launch-stages)
    pub external_runtime_options: std::option::Option<crate::model::ExternalRuntimeOptions>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Routine {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [etag][crate::model::Routine::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [routine_reference][crate::model::Routine::routine_reference].
    pub fn set_routine_reference<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RoutineReference>,
    {
        self.routine_reference = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [routine_reference][crate::model::Routine::routine_reference].
    pub fn set_or_clear_routine_reference<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RoutineReference>,
    {
        self.routine_reference = v.map(|x| x.into());
        self
    }

    /// Sets the value of [routine_type][crate::model::Routine::routine_type].
    pub fn set_routine_type<T: std::convert::Into<crate::model::routine::RoutineType>>(
        mut self,
        v: T,
    ) -> Self {
        self.routine_type = v.into();
        self
    }

    /// Sets the value of [creation_time][crate::model::Routine::creation_time].
    pub fn set_creation_time<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.creation_time = v.into();
        self
    }

    /// Sets the value of [last_modified_time][crate::model::Routine::last_modified_time].
    pub fn set_last_modified_time<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.last_modified_time = v.into();
        self
    }

    /// Sets the value of [language][crate::model::Routine::language].
    pub fn set_language<T: std::convert::Into<crate::model::routine::Language>>(
        mut self,
        v: T,
    ) -> Self {
        self.language = v.into();
        self
    }

    /// Sets the value of [arguments][crate::model::Routine::arguments].
    pub fn set_arguments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::routine::Argument>,
    {
        use std::iter::Iterator;
        self.arguments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [return_type][crate::model::Routine::return_type].
    pub fn set_return_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::StandardSqlDataType>,
    {
        self.return_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [return_type][crate::model::Routine::return_type].
    pub fn set_or_clear_return_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::StandardSqlDataType>,
    {
        self.return_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [return_table_type][crate::model::Routine::return_table_type].
    pub fn set_return_table_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::StandardSqlTableType>,
    {
        self.return_table_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [return_table_type][crate::model::Routine::return_table_type].
    pub fn set_or_clear_return_table_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::StandardSqlTableType>,
    {
        self.return_table_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [imported_libraries][crate::model::Routine::imported_libraries].
    pub fn set_imported_libraries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.imported_libraries = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [definition_body][crate::model::Routine::definition_body].
    pub fn set_definition_body<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.definition_body = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Routine::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [determinism_level][crate::model::Routine::determinism_level].
    pub fn set_determinism_level<T: std::convert::Into<crate::model::routine::DeterminismLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.determinism_level = v.into();
        self
    }

    /// Sets the value of [security_mode][crate::model::Routine::security_mode].
    pub fn set_security_mode<T: std::convert::Into<crate::model::routine::SecurityMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.security_mode = v.into();
        self
    }

    /// Sets the value of [strict_mode][crate::model::Routine::strict_mode].
    pub fn set_strict_mode<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.strict_mode = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [strict_mode][crate::model::Routine::strict_mode].
    pub fn set_or_clear_strict_mode<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.strict_mode = v.map(|x| x.into());
        self
    }

    /// Sets the value of [remote_function_options][crate::model::Routine::remote_function_options].
    pub fn set_remote_function_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::routine::RemoteFunctionOptions>,
    {
        self.remote_function_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [remote_function_options][crate::model::Routine::remote_function_options].
    pub fn set_or_clear_remote_function_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::routine::RemoteFunctionOptions>,
    {
        self.remote_function_options = v.map(|x| x.into());
        self
    }

    /// Sets the value of [spark_options][crate::model::Routine::spark_options].
    pub fn set_spark_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SparkOptions>,
    {
        self.spark_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [spark_options][crate::model::Routine::spark_options].
    pub fn set_or_clear_spark_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SparkOptions>,
    {
        self.spark_options = v.map(|x| x.into());
        self
    }

    /// Sets the value of [data_governance_type][crate::model::Routine::data_governance_type].
    pub fn set_data_governance_type<
        T: std::convert::Into<crate::model::routine::DataGovernanceType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_governance_type = v.into();
        self
    }

    /// Sets the value of [python_options][crate::model::Routine::python_options].
    pub fn set_python_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PythonOptions>,
    {
        self.python_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [python_options][crate::model::Routine::python_options].
    pub fn set_or_clear_python_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PythonOptions>,
    {
        self.python_options = v.map(|x| x.into());
        self
    }

    /// Sets the value of [external_runtime_options][crate::model::Routine::external_runtime_options].
    pub fn set_external_runtime_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ExternalRuntimeOptions>,
    {
        self.external_runtime_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [external_runtime_options][crate::model::Routine::external_runtime_options].
    pub fn set_or_clear_external_runtime_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ExternalRuntimeOptions>,
    {
        self.external_runtime_options = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Routine {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.Routine"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Routine {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __etag,
            __routine_reference,
            __routine_type,
            __creation_time,
            __last_modified_time,
            __language,
            __arguments,
            __return_type,
            __return_table_type,
            __imported_libraries,
            __definition_body,
            __description,
            __determinism_level,
            __security_mode,
            __strict_mode,
            __remote_function_options,
            __spark_options,
            __data_governance_type,
            __python_options,
            __external_runtime_options,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Routine")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "etag" => Ok(__FieldTag::__etag),
                            "routineReference" => Ok(__FieldTag::__routine_reference),
                            "routine_reference" => Ok(__FieldTag::__routine_reference),
                            "routineType" => Ok(__FieldTag::__routine_type),
                            "routine_type" => Ok(__FieldTag::__routine_type),
                            "creationTime" => Ok(__FieldTag::__creation_time),
                            "creation_time" => Ok(__FieldTag::__creation_time),
                            "lastModifiedTime" => Ok(__FieldTag::__last_modified_time),
                            "last_modified_time" => Ok(__FieldTag::__last_modified_time),
                            "language" => Ok(__FieldTag::__language),
                            "arguments" => Ok(__FieldTag::__arguments),
                            "returnType" => Ok(__FieldTag::__return_type),
                            "return_type" => Ok(__FieldTag::__return_type),
                            "returnTableType" => Ok(__FieldTag::__return_table_type),
                            "return_table_type" => Ok(__FieldTag::__return_table_type),
                            "importedLibraries" => Ok(__FieldTag::__imported_libraries),
                            "imported_libraries" => Ok(__FieldTag::__imported_libraries),
                            "definitionBody" => Ok(__FieldTag::__definition_body),
                            "definition_body" => Ok(__FieldTag::__definition_body),
                            "description" => Ok(__FieldTag::__description),
                            "determinismLevel" => Ok(__FieldTag::__determinism_level),
                            "determinism_level" => Ok(__FieldTag::__determinism_level),
                            "securityMode" => Ok(__FieldTag::__security_mode),
                            "security_mode" => Ok(__FieldTag::__security_mode),
                            "strictMode" => Ok(__FieldTag::__strict_mode),
                            "strict_mode" => Ok(__FieldTag::__strict_mode),
                            "remoteFunctionOptions" => Ok(__FieldTag::__remote_function_options),
                            "remote_function_options" => Ok(__FieldTag::__remote_function_options),
                            "sparkOptions" => Ok(__FieldTag::__spark_options),
                            "spark_options" => Ok(__FieldTag::__spark_options),
                            "dataGovernanceType" => Ok(__FieldTag::__data_governance_type),
                            "data_governance_type" => Ok(__FieldTag::__data_governance_type),
                            "pythonOptions" => Ok(__FieldTag::__python_options),
                            "python_options" => Ok(__FieldTag::__python_options),
                            "externalRuntimeOptions" => Ok(__FieldTag::__external_runtime_options),
                            "external_runtime_options" => {
                                Ok(__FieldTag::__external_runtime_options)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Routine;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Routine")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__routine_reference => {
                            if !fields.insert(__FieldTag::__routine_reference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for routine_reference",
                                ));
                            }
                            result.routine_reference = map
                                .next_value::<std::option::Option<crate::model::RoutineReference>>(
                                )?;
                        }
                        __FieldTag::__routine_type => {
                            if !fields.insert(__FieldTag::__routine_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for routine_type",
                                ));
                            }
                            result.routine_type = map.next_value::<std::option::Option<crate::model::routine::RoutineType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__creation_time => {
                            if !fields.insert(__FieldTag::__creation_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for creation_time",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.creation_time =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__last_modified_time => {
                            if !fields.insert(__FieldTag::__last_modified_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_modified_time",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.last_modified_time =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__language => {
                            if !fields.insert(__FieldTag::__language) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language",
                                ));
                            }
                            result.language = map
                                .next_value::<std::option::Option<crate::model::routine::Language>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__arguments => {
                            if !fields.insert(__FieldTag::__arguments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for arguments",
                                ));
                            }
                            result.arguments =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::routine::Argument>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__return_type => {
                            if !fields.insert(__FieldTag::__return_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for return_type",
                                ));
                            }
                            result.return_type = map.next_value::<std::option::Option<crate::model::StandardSqlDataType>>()?
                                ;
                        }
                        __FieldTag::__return_table_type => {
                            if !fields.insert(__FieldTag::__return_table_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for return_table_type",
                                ));
                            }
                            result.return_table_type = map.next_value::<std::option::Option<crate::model::StandardSqlTableType>>()?
                                ;
                        }
                        __FieldTag::__imported_libraries => {
                            if !fields.insert(__FieldTag::__imported_libraries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for imported_libraries",
                                ));
                            }
                            result.imported_libraries = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__definition_body => {
                            if !fields.insert(__FieldTag::__definition_body) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for definition_body",
                                ));
                            }
                            result.definition_body = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__determinism_level => {
                            if !fields.insert(__FieldTag::__determinism_level) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for determinism_level",
                                ));
                            }
                            result.determinism_level = map.next_value::<std::option::Option<crate::model::routine::DeterminismLevel>>()?.unwrap_or_default();
                        }
                        __FieldTag::__security_mode => {
                            if !fields.insert(__FieldTag::__security_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for security_mode",
                                ));
                            }
                            result.security_mode = map.next_value::<std::option::Option<crate::model::routine::SecurityMode>>()?.unwrap_or_default();
                        }
                        __FieldTag::__strict_mode => {
                            if !fields.insert(__FieldTag::__strict_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for strict_mode",
                                ));
                            }
                            result.strict_mode =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__remote_function_options => {
                            if !fields.insert(__FieldTag::__remote_function_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for remote_function_options",
                                ));
                            }
                            result.remote_function_options =
                                map.next_value::<std::option::Option<
                                    crate::model::routine::RemoteFunctionOptions,
                                >>()?;
                        }
                        __FieldTag::__spark_options => {
                            if !fields.insert(__FieldTag::__spark_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for spark_options",
                                ));
                            }
                            result.spark_options = map
                                .next_value::<std::option::Option<crate::model::SparkOptions>>()?;
                        }
                        __FieldTag::__data_governance_type => {
                            if !fields.insert(__FieldTag::__data_governance_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_governance_type",
                                ));
                            }
                            result.data_governance_type = map.next_value::<std::option::Option<crate::model::routine::DataGovernanceType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__python_options => {
                            if !fields.insert(__FieldTag::__python_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for python_options",
                                ));
                            }
                            result.python_options = map
                                .next_value::<std::option::Option<crate::model::PythonOptions>>()?;
                        }
                        __FieldTag::__external_runtime_options => {
                            if !fields.insert(__FieldTag::__external_runtime_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_runtime_options",
                                ));
                            }
                            result.external_runtime_options = map.next_value::<std::option::Option<crate::model::ExternalRuntimeOptions>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Routine {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.routine_reference.is_some() {
            state.serialize_entry("routineReference", &self.routine_reference)?;
        }
        if !wkt::internal::is_default(&self.routine_type) {
            state.serialize_entry("routineType", &self.routine_type)?;
        }
        if !wkt::internal::is_default(&self.creation_time) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("creationTime", &__With(&self.creation_time))?;
        }
        if !wkt::internal::is_default(&self.last_modified_time) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("lastModifiedTime", &__With(&self.last_modified_time))?;
        }
        if !wkt::internal::is_default(&self.language) {
            state.serialize_entry("language", &self.language)?;
        }
        if !self.arguments.is_empty() {
            state.serialize_entry("arguments", &self.arguments)?;
        }
        if self.return_type.is_some() {
            state.serialize_entry("returnType", &self.return_type)?;
        }
        if self.return_table_type.is_some() {
            state.serialize_entry("returnTableType", &self.return_table_type)?;
        }
        if !self.imported_libraries.is_empty() {
            state.serialize_entry("importedLibraries", &self.imported_libraries)?;
        }
        if !self.definition_body.is_empty() {
            state.serialize_entry("definitionBody", &self.definition_body)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !wkt::internal::is_default(&self.determinism_level) {
            state.serialize_entry("determinismLevel", &self.determinism_level)?;
        }
        if !wkt::internal::is_default(&self.security_mode) {
            state.serialize_entry("securityMode", &self.security_mode)?;
        }
        if self.strict_mode.is_some() {
            state.serialize_entry("strictMode", &self.strict_mode)?;
        }
        if self.remote_function_options.is_some() {
            state.serialize_entry("remoteFunctionOptions", &self.remote_function_options)?;
        }
        if self.spark_options.is_some() {
            state.serialize_entry("sparkOptions", &self.spark_options)?;
        }
        if !wkt::internal::is_default(&self.data_governance_type) {
            state.serialize_entry("dataGovernanceType", &self.data_governance_type)?;
        }
        if self.python_options.is_some() {
            state.serialize_entry("pythonOptions", &self.python_options)?;
        }
        if self.external_runtime_options.is_some() {
            state.serialize_entry("externalRuntimeOptions", &self.external_runtime_options)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Routine].
pub mod routine {
    #[allow(unused_imports)]
    use super::*;

    /// Input/output argument of a function or a stored procedure.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Argument {
        /// Optional. The name of this argument. Can be absent for function return
        /// argument.
        pub name: std::string::String,

        /// Optional. Defaults to FIXED_TYPE.
        pub argument_kind: crate::model::routine::argument::ArgumentKind,

        /// Optional. Specifies whether the argument is input or output.
        /// Can be set for procedures only.
        pub mode: crate::model::routine::argument::Mode,

        /// Set if argument_kind == FIXED_TYPE.
        pub data_type: std::option::Option<crate::model::StandardSqlDataType>,

        /// Optional. Whether the argument is an aggregate function parameter.
        /// Must be Unset for routine types other than AGGREGATE_FUNCTION.
        /// For AGGREGATE_FUNCTION, if set to false, it is equivalent to adding "NOT
        /// AGGREGATE" clause in DDL; Otherwise, it is equivalent to omitting "NOT
        /// AGGREGATE" clause in DDL.
        pub is_aggregate: std::option::Option<wkt::BoolValue>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Argument {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::routine::Argument::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [argument_kind][crate::model::routine::Argument::argument_kind].
        pub fn set_argument_kind<
            T: std::convert::Into<crate::model::routine::argument::ArgumentKind>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.argument_kind = v.into();
            self
        }

        /// Sets the value of [mode][crate::model::routine::Argument::mode].
        pub fn set_mode<T: std::convert::Into<crate::model::routine::argument::Mode>>(
            mut self,
            v: T,
        ) -> Self {
            self.mode = v.into();
            self
        }

        /// Sets the value of [data_type][crate::model::routine::Argument::data_type].
        pub fn set_data_type<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::StandardSqlDataType>,
        {
            self.data_type = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [data_type][crate::model::routine::Argument::data_type].
        pub fn set_or_clear_data_type<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::StandardSqlDataType>,
        {
            self.data_type = v.map(|x| x.into());
            self
        }

        /// Sets the value of [is_aggregate][crate::model::routine::Argument::is_aggregate].
        pub fn set_is_aggregate<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::BoolValue>,
        {
            self.is_aggregate = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [is_aggregate][crate::model::routine::Argument::is_aggregate].
        pub fn set_or_clear_is_aggregate<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::BoolValue>,
        {
            self.is_aggregate = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for Argument {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Routine.Argument"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Argument {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __name,
                __argument_kind,
                __mode,
                __data_type,
                __is_aggregate,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Argument")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "name" => Ok(__FieldTag::__name),
                                "argumentKind" => Ok(__FieldTag::__argument_kind),
                                "argument_kind" => Ok(__FieldTag::__argument_kind),
                                "mode" => Ok(__FieldTag::__mode),
                                "dataType" => Ok(__FieldTag::__data_type),
                                "data_type" => Ok(__FieldTag::__data_type),
                                "isAggregate" => Ok(__FieldTag::__is_aggregate),
                                "is_aggregate" => Ok(__FieldTag::__is_aggregate),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Argument;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Argument")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__argument_kind => {
                                if !fields.insert(__FieldTag::__argument_kind) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for argument_kind",
                                    ));
                                }
                                result.argument_kind = map
                                    .next_value::<std::option::Option<
                                        crate::model::routine::argument::ArgumentKind,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__mode => {
                                if !fields.insert(__FieldTag::__mode) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for mode",
                                    ));
                                }
                                result.mode = map.next_value::<std::option::Option<crate::model::routine::argument::Mode>>()?.unwrap_or_default();
                            }
                            __FieldTag::__data_type => {
                                if !fields.insert(__FieldTag::__data_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for data_type",
                                    ));
                                }
                                result.data_type = map.next_value::<std::option::Option<crate::model::StandardSqlDataType>>()?
                                    ;
                            }
                            __FieldTag::__is_aggregate => {
                                if !fields.insert(__FieldTag::__is_aggregate) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for is_aggregate",
                                    ));
                                }
                                result.is_aggregate =
                                    map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Argument {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !wkt::internal::is_default(&self.argument_kind) {
                state.serialize_entry("argumentKind", &self.argument_kind)?;
            }
            if !wkt::internal::is_default(&self.mode) {
                state.serialize_entry("mode", &self.mode)?;
            }
            if self.data_type.is_some() {
                state.serialize_entry("dataType", &self.data_type)?;
            }
            if self.is_aggregate.is_some() {
                state.serialize_entry("isAggregate", &self.is_aggregate)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [Argument].
    pub mod argument {
        #[allow(unused_imports)]
        use super::*;

        /// Represents the kind of a given argument.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum ArgumentKind {
            /// Default value.
            Unspecified,
            /// The argument is a variable with fully specified type, which can be a
            /// struct or an array, but not a table.
            FixedType,
            /// The argument is any type, including struct or array, but not a table.
            AnyType,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [ArgumentKind::value] or
            /// [ArgumentKind::name].
            UnknownValue(argument_kind::UnknownValue),
        }

        #[doc(hidden)]
        pub mod argument_kind {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl ArgumentKind {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::FixedType => std::option::Option::Some(1),
                    Self::AnyType => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("ARGUMENT_KIND_UNSPECIFIED"),
                    Self::FixedType => std::option::Option::Some("FIXED_TYPE"),
                    Self::AnyType => std::option::Option::Some("ANY_TYPE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for ArgumentKind {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for ArgumentKind {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for ArgumentKind {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::FixedType,
                    2 => Self::AnyType,
                    _ => Self::UnknownValue(argument_kind::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for ArgumentKind {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "ARGUMENT_KIND_UNSPECIFIED" => Self::Unspecified,
                    "FIXED_TYPE" => Self::FixedType,
                    "ANY_TYPE" => Self::AnyType,
                    _ => Self::UnknownValue(argument_kind::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for ArgumentKind {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::FixedType => serializer.serialize_i32(1),
                    Self::AnyType => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for ArgumentKind {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<ArgumentKind>::new(
                    ".google.cloud.bigquery.v2.Routine.Argument.ArgumentKind",
                ))
            }
        }

        /// The input/output mode of the argument.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Mode {
            /// Default value.
            Unspecified,
            /// The argument is input-only.
            In,
            /// The argument is output-only.
            Out,
            /// The argument is both an input and an output.
            Inout,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Mode::value] or
            /// [Mode::name].
            UnknownValue(mode::UnknownValue),
        }

        #[doc(hidden)]
        pub mod mode {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Mode {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::In => std::option::Option::Some(1),
                    Self::Out => std::option::Option::Some(2),
                    Self::Inout => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("MODE_UNSPECIFIED"),
                    Self::In => std::option::Option::Some("IN"),
                    Self::Out => std::option::Option::Some("OUT"),
                    Self::Inout => std::option::Option::Some("INOUT"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Mode {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Mode {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Mode {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::In,
                    2 => Self::Out,
                    3 => Self::Inout,
                    _ => Self::UnknownValue(mode::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Mode {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "MODE_UNSPECIFIED" => Self::Unspecified,
                    "IN" => Self::In,
                    "OUT" => Self::Out,
                    "INOUT" => Self::Inout,
                    _ => Self::UnknownValue(mode::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Mode {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::In => serializer.serialize_i32(1),
                    Self::Out => serializer.serialize_i32(2),
                    Self::Inout => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Mode {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Mode>::new(
                    ".google.cloud.bigquery.v2.Routine.Argument.Mode",
                ))
            }
        }
    }

    /// Options for a remote user-defined function.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct RemoteFunctionOptions {
        /// Endpoint of the user-provided remote service, e.g.
        /// ```<https://us-east1-my_gcf_project.cloudfunctions.net/remote_add>```
        pub endpoint: std::string::String,

        /// Fully qualified name of the user-provided connection object which holds
        /// the authentication information to send requests to the remote service.
        /// Format:
        /// ```"projects/{projectId}/locations/{locationId}/connections/{connectionId}"```
        pub connection: std::string::String,

        /// User-defined context as a set of key/value pairs, which will be sent as
        /// function invocation context together with batched arguments in the
        /// requests to the remote service. The total number of bytes of keys and
        /// values must be less than 8KB.
        pub user_defined_context:
            std::collections::HashMap<std::string::String, std::string::String>,

        /// Max number of rows in each batch sent to the remote service.
        /// If absent or if 0, BigQuery dynamically decides the number of rows in a
        /// batch.
        pub max_batching_rows: i64,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RemoteFunctionOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [endpoint][crate::model::routine::RemoteFunctionOptions::endpoint].
        pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.endpoint = v.into();
            self
        }

        /// Sets the value of [connection][crate::model::routine::RemoteFunctionOptions::connection].
        pub fn set_connection<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.connection = v.into();
            self
        }

        /// Sets the value of [user_defined_context][crate::model::routine::RemoteFunctionOptions::user_defined_context].
        pub fn set_user_defined_context<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.user_defined_context = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [max_batching_rows][crate::model::routine::RemoteFunctionOptions::max_batching_rows].
        pub fn set_max_batching_rows<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.max_batching_rows = v.into();
            self
        }
    }

    impl wkt::message::Message for RemoteFunctionOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.Routine.RemoteFunctionOptions"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for RemoteFunctionOptions {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __endpoint,
                __connection,
                __user_defined_context,
                __max_batching_rows,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for RemoteFunctionOptions")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "endpoint" => Ok(__FieldTag::__endpoint),
                                "connection" => Ok(__FieldTag::__connection),
                                "userDefinedContext" => Ok(__FieldTag::__user_defined_context),
                                "user_defined_context" => Ok(__FieldTag::__user_defined_context),
                                "maxBatchingRows" => Ok(__FieldTag::__max_batching_rows),
                                "max_batching_rows" => Ok(__FieldTag::__max_batching_rows),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = RemoteFunctionOptions;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct RemoteFunctionOptions")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__endpoint => {
                                if !fields.insert(__FieldTag::__endpoint) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for endpoint",
                                    ));
                                }
                                result.endpoint = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__connection => {
                                if !fields.insert(__FieldTag::__connection) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for connection",
                                    ));
                                }
                                result.connection = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__user_defined_context => {
                                if !fields.insert(__FieldTag::__user_defined_context) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for user_defined_context",
                                    ));
                                }
                                result.user_defined_context = map
                                    .next_value::<std::option::Option<
                                        std::collections::HashMap<
                                            std::string::String,
                                            std::string::String,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__max_batching_rows => {
                                if !fields.insert(__FieldTag::__max_batching_rows) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for max_batching_rows",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.max_batching_rows =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for RemoteFunctionOptions {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.endpoint.is_empty() {
                state.serialize_entry("endpoint", &self.endpoint)?;
            }
            if !self.connection.is_empty() {
                state.serialize_entry("connection", &self.connection)?;
            }
            if !self.user_defined_context.is_empty() {
                state.serialize_entry("userDefinedContext", &self.user_defined_context)?;
            }
            if !wkt::internal::is_default(&self.max_batching_rows) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("maxBatchingRows", &__With(&self.max_batching_rows))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// The fine-grained type of the routine.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RoutineType {
        /// Default value.
        Unspecified,
        /// Non-built-in persistent scalar function.
        ScalarFunction,
        /// Stored procedure.
        Procedure,
        /// Non-built-in persistent TVF.
        TableValuedFunction,
        /// Non-built-in persistent aggregate function.
        AggregateFunction,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RoutineType::value] or
        /// [RoutineType::name].
        UnknownValue(routine_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod routine_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RoutineType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ScalarFunction => std::option::Option::Some(1),
                Self::Procedure => std::option::Option::Some(2),
                Self::TableValuedFunction => std::option::Option::Some(3),
                Self::AggregateFunction => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ROUTINE_TYPE_UNSPECIFIED"),
                Self::ScalarFunction => std::option::Option::Some("SCALAR_FUNCTION"),
                Self::Procedure => std::option::Option::Some("PROCEDURE"),
                Self::TableValuedFunction => std::option::Option::Some("TABLE_VALUED_FUNCTION"),
                Self::AggregateFunction => std::option::Option::Some("AGGREGATE_FUNCTION"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RoutineType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RoutineType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RoutineType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ScalarFunction,
                2 => Self::Procedure,
                3 => Self::TableValuedFunction,
                4 => Self::AggregateFunction,
                _ => Self::UnknownValue(routine_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RoutineType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ROUTINE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "SCALAR_FUNCTION" => Self::ScalarFunction,
                "PROCEDURE" => Self::Procedure,
                "TABLE_VALUED_FUNCTION" => Self::TableValuedFunction,
                "AGGREGATE_FUNCTION" => Self::AggregateFunction,
                _ => Self::UnknownValue(routine_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RoutineType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ScalarFunction => serializer.serialize_i32(1),
                Self::Procedure => serializer.serialize_i32(2),
                Self::TableValuedFunction => serializer.serialize_i32(3),
                Self::AggregateFunction => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RoutineType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RoutineType>::new(
                ".google.cloud.bigquery.v2.Routine.RoutineType",
            ))
        }
    }

    /// The language of the routine.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Language {
        /// Default value.
        Unspecified,
        /// SQL language.
        Sql,
        /// JavaScript language.
        Javascript,
        /// Python language.
        Python,
        /// Java language.
        Java,
        /// Scala language.
        Scala,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Language::value] or
        /// [Language::name].
        UnknownValue(language::UnknownValue),
    }

    #[doc(hidden)]
    pub mod language {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Language {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Sql => std::option::Option::Some(1),
                Self::Javascript => std::option::Option::Some(2),
                Self::Python => std::option::Option::Some(3),
                Self::Java => std::option::Option::Some(4),
                Self::Scala => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("LANGUAGE_UNSPECIFIED"),
                Self::Sql => std::option::Option::Some("SQL"),
                Self::Javascript => std::option::Option::Some("JAVASCRIPT"),
                Self::Python => std::option::Option::Some("PYTHON"),
                Self::Java => std::option::Option::Some("JAVA"),
                Self::Scala => std::option::Option::Some("SCALA"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Language {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Language {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Language {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Sql,
                2 => Self::Javascript,
                3 => Self::Python,
                4 => Self::Java,
                5 => Self::Scala,
                _ => Self::UnknownValue(language::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Language {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LANGUAGE_UNSPECIFIED" => Self::Unspecified,
                "SQL" => Self::Sql,
                "JAVASCRIPT" => Self::Javascript,
                "PYTHON" => Self::Python,
                "JAVA" => Self::Java,
                "SCALA" => Self::Scala,
                _ => Self::UnknownValue(language::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Language {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Sql => serializer.serialize_i32(1),
                Self::Javascript => serializer.serialize_i32(2),
                Self::Python => serializer.serialize_i32(3),
                Self::Java => serializer.serialize_i32(4),
                Self::Scala => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Language {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Language>::new(
                ".google.cloud.bigquery.v2.Routine.Language",
            ))
        }
    }

    /// JavaScript UDF determinism levels.
    ///
    /// If all JavaScript UDFs are DETERMINISTIC, the query result is
    /// potentially cacheable (see below). If any JavaScript UDF is
    /// NOT_DETERMINISTIC, the query result is not cacheable.
    ///
    /// Even if a JavaScript UDF is deterministic, many other factors can prevent
    /// usage of cached query results. Example factors include but not limited to:
    /// DDL/DML, non-deterministic SQL function calls, update of referenced
    /// tables/views/UDFs or imported JavaScript libraries.
    ///
    /// SQL UDFs cannot have determinism specified. Their determinism is
    /// automatically determined.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DeterminismLevel {
        /// The determinism of the UDF is unspecified.
        Unspecified,
        /// The UDF is deterministic, meaning that 2 function calls with the same
        /// inputs always produce the same result, even across 2 query runs.
        Deterministic,
        /// The UDF is not deterministic.
        NotDeterministic,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DeterminismLevel::value] or
        /// [DeterminismLevel::name].
        UnknownValue(determinism_level::UnknownValue),
    }

    #[doc(hidden)]
    pub mod determinism_level {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DeterminismLevel {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Deterministic => std::option::Option::Some(1),
                Self::NotDeterministic => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DETERMINISM_LEVEL_UNSPECIFIED"),
                Self::Deterministic => std::option::Option::Some("DETERMINISTIC"),
                Self::NotDeterministic => std::option::Option::Some("NOT_DETERMINISTIC"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DeterminismLevel {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DeterminismLevel {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DeterminismLevel {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Deterministic,
                2 => Self::NotDeterministic,
                _ => Self::UnknownValue(determinism_level::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DeterminismLevel {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DETERMINISM_LEVEL_UNSPECIFIED" => Self::Unspecified,
                "DETERMINISTIC" => Self::Deterministic,
                "NOT_DETERMINISTIC" => Self::NotDeterministic,
                _ => Self::UnknownValue(determinism_level::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DeterminismLevel {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Deterministic => serializer.serialize_i32(1),
                Self::NotDeterministic => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DeterminismLevel {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DeterminismLevel>::new(
                ".google.cloud.bigquery.v2.Routine.DeterminismLevel",
            ))
        }
    }

    /// Security mode.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SecurityMode {
        /// The security mode of the routine is unspecified.
        Unspecified,
        /// The routine is to be executed with the privileges of the user who
        /// defines it.
        Definer,
        /// The routine is to be executed with the privileges of the user who
        /// invokes it.
        Invoker,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SecurityMode::value] or
        /// [SecurityMode::name].
        UnknownValue(security_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod security_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SecurityMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Definer => std::option::Option::Some(1),
                Self::Invoker => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SECURITY_MODE_UNSPECIFIED"),
                Self::Definer => std::option::Option::Some("DEFINER"),
                Self::Invoker => std::option::Option::Some("INVOKER"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SecurityMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SecurityMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SecurityMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Definer,
                2 => Self::Invoker,
                _ => Self::UnknownValue(security_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SecurityMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SECURITY_MODE_UNSPECIFIED" => Self::Unspecified,
                "DEFINER" => Self::Definer,
                "INVOKER" => Self::Invoker,
                _ => Self::UnknownValue(security_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SecurityMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Definer => serializer.serialize_i32(1),
                Self::Invoker => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SecurityMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SecurityMode>::new(
                ".google.cloud.bigquery.v2.Routine.SecurityMode",
            ))
        }
    }

    /// Data governance type values. Only supports `DATA_MASKING`.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DataGovernanceType {
        /// The data governance type is unspecified.
        Unspecified,
        /// The data governance type is data masking.
        DataMasking,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DataGovernanceType::value] or
        /// [DataGovernanceType::name].
        UnknownValue(data_governance_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod data_governance_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DataGovernanceType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::DataMasking => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DATA_GOVERNANCE_TYPE_UNSPECIFIED"),
                Self::DataMasking => std::option::Option::Some("DATA_MASKING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DataGovernanceType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DataGovernanceType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DataGovernanceType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::DataMasking,
                _ => Self::UnknownValue(data_governance_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DataGovernanceType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DATA_GOVERNANCE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "DATA_MASKING" => Self::DataMasking,
                _ => Self::UnknownValue(data_governance_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DataGovernanceType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::DataMasking => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DataGovernanceType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DataGovernanceType>::new(
                ".google.cloud.bigquery.v2.Routine.DataGovernanceType",
            ))
        }
    }
}

/// Options for a user-defined Python function.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PythonOptions {
    /// Required. The entry point function in the user's Python code.
    pub entry_point: std::string::String,

    /// Optional. A list of package names along with versions to be installed.
    /// Follows requirements.txt syntax (e.g. numpy==2.0, permutation,
    /// urllib3<2.2.1)
    pub packages: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PythonOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entry_point][crate::model::PythonOptions::entry_point].
    pub fn set_entry_point<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entry_point = v.into();
        self
    }

    /// Sets the value of [packages][crate::model::PythonOptions::packages].
    pub fn set_packages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.packages = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PythonOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.PythonOptions"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PythonOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entry_point,
            __packages,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PythonOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entryPoint" => Ok(__FieldTag::__entry_point),
                            "entry_point" => Ok(__FieldTag::__entry_point),
                            "packages" => Ok(__FieldTag::__packages),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PythonOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PythonOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entry_point => {
                            if !fields.insert(__FieldTag::__entry_point) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entry_point",
                                ));
                            }
                            result.entry_point = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__packages => {
                            if !fields.insert(__FieldTag::__packages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for packages",
                                ));
                            }
                            result.packages = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PythonOptions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.entry_point.is_empty() {
            state.serialize_entry("entryPoint", &self.entry_point)?;
        }
        if !self.packages.is_empty() {
            state.serialize_entry("packages", &self.packages)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Options for the runtime of the external system.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ExternalRuntimeOptions {
    /// Optional. Amount of memory provisioned for the container instance. Format:
    /// {number}{unit} where unit is one of "M", "G", "Mi" and "Gi" (e.g. 1G,
    /// 512Mi). If not specified, the default value is 512Mi.
    pub container_memory: std::string::String,

    /// Optional. Amount of CPU provisioned for the container instance. If not
    /// specified, the default value is 0.33 vCPUs.
    pub container_cpu: f64,

    /// Optional. Fully qualified name of the connection whose service account will
    /// be used to execute the code in the container. Format:
    /// ```"projects/{project_id}/locations/{location_id}/connections/{connection_id}"```
    pub runtime_connection: std::string::String,

    /// Optional. Maximum number of rows in each batch sent to the external
    /// runtime. If absent or if 0, BigQuery dynamically decides the number of rows
    /// in a batch.
    pub max_batching_rows: i64,

    /// Optional. Language runtime version (e.g. python-3.11).
    pub runtime_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExternalRuntimeOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [container_memory][crate::model::ExternalRuntimeOptions::container_memory].
    pub fn set_container_memory<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.container_memory = v.into();
        self
    }

    /// Sets the value of [container_cpu][crate::model::ExternalRuntimeOptions::container_cpu].
    pub fn set_container_cpu<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.container_cpu = v.into();
        self
    }

    /// Sets the value of [runtime_connection][crate::model::ExternalRuntimeOptions::runtime_connection].
    pub fn set_runtime_connection<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.runtime_connection = v.into();
        self
    }

    /// Sets the value of [max_batching_rows][crate::model::ExternalRuntimeOptions::max_batching_rows].
    pub fn set_max_batching_rows<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.max_batching_rows = v.into();
        self
    }

    /// Sets the value of [runtime_version][crate::model::ExternalRuntimeOptions::runtime_version].
    pub fn set_runtime_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.runtime_version = v.into();
        self
    }
}

impl wkt::message::Message for ExternalRuntimeOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ExternalRuntimeOptions"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExternalRuntimeOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __container_memory,
            __container_cpu,
            __runtime_connection,
            __max_batching_rows,
            __runtime_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExternalRuntimeOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "containerMemory" => Ok(__FieldTag::__container_memory),
                            "container_memory" => Ok(__FieldTag::__container_memory),
                            "containerCpu" => Ok(__FieldTag::__container_cpu),
                            "container_cpu" => Ok(__FieldTag::__container_cpu),
                            "runtimeConnection" => Ok(__FieldTag::__runtime_connection),
                            "runtime_connection" => Ok(__FieldTag::__runtime_connection),
                            "maxBatchingRows" => Ok(__FieldTag::__max_batching_rows),
                            "max_batching_rows" => Ok(__FieldTag::__max_batching_rows),
                            "runtimeVersion" => Ok(__FieldTag::__runtime_version),
                            "runtime_version" => Ok(__FieldTag::__runtime_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExternalRuntimeOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExternalRuntimeOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__container_memory => {
                            if !fields.insert(__FieldTag::__container_memory) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for container_memory",
                                ));
                            }
                            result.container_memory = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__container_cpu => {
                            if !fields.insert(__FieldTag::__container_cpu) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for container_cpu",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.container_cpu =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__runtime_connection => {
                            if !fields.insert(__FieldTag::__runtime_connection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for runtime_connection",
                                ));
                            }
                            result.runtime_connection = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__max_batching_rows => {
                            if !fields.insert(__FieldTag::__max_batching_rows) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_batching_rows",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_batching_rows =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__runtime_version => {
                            if !fields.insert(__FieldTag::__runtime_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for runtime_version",
                                ));
                            }
                            result.runtime_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExternalRuntimeOptions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.container_memory.is_empty() {
            state.serialize_entry("containerMemory", &self.container_memory)?;
        }
        if !wkt::internal::is_default(&self.container_cpu) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("containerCpu", &__With(&self.container_cpu))?;
        }
        if !self.runtime_connection.is_empty() {
            state.serialize_entry("runtimeConnection", &self.runtime_connection)?;
        }
        if !wkt::internal::is_default(&self.max_batching_rows) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxBatchingRows", &__With(&self.max_batching_rows))?;
        }
        if !self.runtime_version.is_empty() {
            state.serialize_entry("runtimeVersion", &self.runtime_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Options for a user-defined Spark routine.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SparkOptions {
    /// Fully qualified name of the user-provided Spark connection object. Format:
    /// ```"projects/{project_id}/locations/{location_id}/connections/{connection_id}"```
    pub connection: std::string::String,

    /// Runtime version. If not specified, the default runtime version is used.
    pub runtime_version: std::string::String,

    /// Custom container image for the runtime environment.
    pub container_image: std::string::String,

    /// Configuration properties as a set of key/value pairs, which will be passed
    /// on to the Spark application. For more information, see
    /// [Apache Spark](https://spark.apache.org/docs/latest/index.html) and the
    /// [procedure option
    /// list](https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language#procedure_option_list).
    pub properties: std::collections::HashMap<std::string::String, std::string::String>,

    /// The main file/jar URI of the Spark application. Exactly one of the
    /// definition_body field and the main_file_uri field must be set for Python.
    /// Exactly one of main_class and main_file_uri field
    /// should be set for Java/Scala language type.
    pub main_file_uri: std::string::String,

    /// Python files to be placed on the PYTHONPATH for PySpark application.
    /// Supported file types: `.py`, `.egg`, and `.zip`. For more information
    /// about Apache Spark, see
    /// [Apache Spark](https://spark.apache.org/docs/latest/index.html).
    pub py_file_uris: std::vec::Vec<std::string::String>,

    /// JARs to include on the driver and executor CLASSPATH.
    /// For more information about Apache Spark, see
    /// [Apache Spark](https://spark.apache.org/docs/latest/index.html).
    pub jar_uris: std::vec::Vec<std::string::String>,

    /// Files to be placed in the working directory of each executor.
    /// For more information about Apache Spark, see
    /// [Apache Spark](https://spark.apache.org/docs/latest/index.html).
    pub file_uris: std::vec::Vec<std::string::String>,

    /// Archive files to be extracted into the working directory of each executor.
    /// For more information about Apache Spark, see
    /// [Apache Spark](https://spark.apache.org/docs/latest/index.html).
    pub archive_uris: std::vec::Vec<std::string::String>,

    /// The fully qualified name of a class in jar_uris, for example,
    /// com.example.wordcount. Exactly one of main_class and main_jar_uri field
    /// should be set for Java/Scala language type.
    pub main_class: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SparkOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [connection][crate::model::SparkOptions::connection].
    pub fn set_connection<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.connection = v.into();
        self
    }

    /// Sets the value of [runtime_version][crate::model::SparkOptions::runtime_version].
    pub fn set_runtime_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.runtime_version = v.into();
        self
    }

    /// Sets the value of [container_image][crate::model::SparkOptions::container_image].
    pub fn set_container_image<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.container_image = v.into();
        self
    }

    /// Sets the value of [properties][crate::model::SparkOptions::properties].
    pub fn set_properties<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.properties = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [main_file_uri][crate::model::SparkOptions::main_file_uri].
    pub fn set_main_file_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.main_file_uri = v.into();
        self
    }

    /// Sets the value of [py_file_uris][crate::model::SparkOptions::py_file_uris].
    pub fn set_py_file_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.py_file_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [jar_uris][crate::model::SparkOptions::jar_uris].
    pub fn set_jar_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.jar_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [file_uris][crate::model::SparkOptions::file_uris].
    pub fn set_file_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.file_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [archive_uris][crate::model::SparkOptions::archive_uris].
    pub fn set_archive_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.archive_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [main_class][crate::model::SparkOptions::main_class].
    pub fn set_main_class<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.main_class = v.into();
        self
    }
}

impl wkt::message::Message for SparkOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.SparkOptions"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SparkOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __connection,
            __runtime_version,
            __container_image,
            __properties,
            __main_file_uri,
            __py_file_uris,
            __jar_uris,
            __file_uris,
            __archive_uris,
            __main_class,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SparkOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "connection" => Ok(__FieldTag::__connection),
                            "runtimeVersion" => Ok(__FieldTag::__runtime_version),
                            "runtime_version" => Ok(__FieldTag::__runtime_version),
                            "containerImage" => Ok(__FieldTag::__container_image),
                            "container_image" => Ok(__FieldTag::__container_image),
                            "properties" => Ok(__FieldTag::__properties),
                            "mainFileUri" => Ok(__FieldTag::__main_file_uri),
                            "main_file_uri" => Ok(__FieldTag::__main_file_uri),
                            "pyFileUris" => Ok(__FieldTag::__py_file_uris),
                            "py_file_uris" => Ok(__FieldTag::__py_file_uris),
                            "jarUris" => Ok(__FieldTag::__jar_uris),
                            "jar_uris" => Ok(__FieldTag::__jar_uris),
                            "fileUris" => Ok(__FieldTag::__file_uris),
                            "file_uris" => Ok(__FieldTag::__file_uris),
                            "archiveUris" => Ok(__FieldTag::__archive_uris),
                            "archive_uris" => Ok(__FieldTag::__archive_uris),
                            "mainClass" => Ok(__FieldTag::__main_class),
                            "main_class" => Ok(__FieldTag::__main_class),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SparkOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SparkOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__connection => {
                            if !fields.insert(__FieldTag::__connection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection",
                                ));
                            }
                            result.connection = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__runtime_version => {
                            if !fields.insert(__FieldTag::__runtime_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for runtime_version",
                                ));
                            }
                            result.runtime_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__container_image => {
                            if !fields.insert(__FieldTag::__container_image) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for container_image",
                                ));
                            }
                            result.container_image = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__properties => {
                            if !fields.insert(__FieldTag::__properties) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for properties",
                                ));
                            }
                            result.properties = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__main_file_uri => {
                            if !fields.insert(__FieldTag::__main_file_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for main_file_uri",
                                ));
                            }
                            result.main_file_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__py_file_uris => {
                            if !fields.insert(__FieldTag::__py_file_uris) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for py_file_uris",
                                ));
                            }
                            result.py_file_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__jar_uris => {
                            if !fields.insert(__FieldTag::__jar_uris) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for jar_uris",
                                ));
                            }
                            result.jar_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__file_uris => {
                            if !fields.insert(__FieldTag::__file_uris) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_uris",
                                ));
                            }
                            result.file_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__archive_uris => {
                            if !fields.insert(__FieldTag::__archive_uris) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for archive_uris",
                                ));
                            }
                            result.archive_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__main_class => {
                            if !fields.insert(__FieldTag::__main_class) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for main_class",
                                ));
                            }
                            result.main_class = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SparkOptions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.connection.is_empty() {
            state.serialize_entry("connection", &self.connection)?;
        }
        if !self.runtime_version.is_empty() {
            state.serialize_entry("runtimeVersion", &self.runtime_version)?;
        }
        if !self.container_image.is_empty() {
            state.serialize_entry("containerImage", &self.container_image)?;
        }
        if !self.properties.is_empty() {
            state.serialize_entry("properties", &self.properties)?;
        }
        if !self.main_file_uri.is_empty() {
            state.serialize_entry("mainFileUri", &self.main_file_uri)?;
        }
        if !self.py_file_uris.is_empty() {
            state.serialize_entry("pyFileUris", &self.py_file_uris)?;
        }
        if !self.jar_uris.is_empty() {
            state.serialize_entry("jarUris", &self.jar_uris)?;
        }
        if !self.file_uris.is_empty() {
            state.serialize_entry("fileUris", &self.file_uris)?;
        }
        if !self.archive_uris.is_empty() {
            state.serialize_entry("archiveUris", &self.archive_uris)?;
        }
        if !self.main_class.is_empty() {
            state.serialize_entry("mainClass", &self.main_class)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Describes the format for getting information about a routine.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetRoutineRequest {
    /// Required. Project ID of the requested routine
    pub project_id: std::string::String,

    /// Required. Dataset ID of the requested routine
    pub dataset_id: std::string::String,

    /// Required. Routine ID of the requested routine
    pub routine_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetRoutineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::GetRoutineRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::GetRoutineRequest::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [routine_id][crate::model::GetRoutineRequest::routine_id].
    pub fn set_routine_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.routine_id = v.into();
        self
    }
}

impl wkt::message::Message for GetRoutineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.GetRoutineRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetRoutineRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __routine_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetRoutineRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "routineId" => Ok(__FieldTag::__routine_id),
                            "routine_id" => Ok(__FieldTag::__routine_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetRoutineRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetRoutineRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__routine_id => {
                            if !fields.insert(__FieldTag::__routine_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for routine_id",
                                ));
                            }
                            result.routine_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetRoutineRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.dataset_id.is_empty() {
            state.serialize_entry("datasetId", &self.dataset_id)?;
        }
        if !self.routine_id.is_empty() {
            state.serialize_entry("routineId", &self.routine_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Describes the format for inserting a routine.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InsertRoutineRequest {
    /// Required. Project ID of the new routine
    pub project_id: std::string::String,

    /// Required. Dataset ID of the new routine
    pub dataset_id: std::string::String,

    /// Required. A routine resource to insert
    pub routine: std::option::Option<crate::model::Routine>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InsertRoutineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::InsertRoutineRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::InsertRoutineRequest::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [routine][crate::model::InsertRoutineRequest::routine].
    pub fn set_routine<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Routine>,
    {
        self.routine = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [routine][crate::model::InsertRoutineRequest::routine].
    pub fn set_or_clear_routine<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Routine>,
    {
        self.routine = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for InsertRoutineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.InsertRoutineRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InsertRoutineRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __routine,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InsertRoutineRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "routine" => Ok(__FieldTag::__routine),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InsertRoutineRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InsertRoutineRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__routine => {
                            if !fields.insert(__FieldTag::__routine) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for routine",
                                ));
                            }
                            result.routine =
                                map.next_value::<std::option::Option<crate::model::Routine>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InsertRoutineRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.dataset_id.is_empty() {
            state.serialize_entry("datasetId", &self.dataset_id)?;
        }
        if self.routine.is_some() {
            state.serialize_entry("routine", &self.routine)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Describes the format for updating a routine.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateRoutineRequest {
    /// Required. Project ID of the routine to update
    pub project_id: std::string::String,

    /// Required. Dataset ID of the routine to update
    pub dataset_id: std::string::String,

    /// Required. Routine ID of the routine to update
    pub routine_id: std::string::String,

    /// Required. A routine resource which will replace the specified routine
    pub routine: std::option::Option<crate::model::Routine>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateRoutineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::UpdateRoutineRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::UpdateRoutineRequest::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [routine_id][crate::model::UpdateRoutineRequest::routine_id].
    pub fn set_routine_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.routine_id = v.into();
        self
    }

    /// Sets the value of [routine][crate::model::UpdateRoutineRequest::routine].
    pub fn set_routine<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Routine>,
    {
        self.routine = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [routine][crate::model::UpdateRoutineRequest::routine].
    pub fn set_or_clear_routine<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Routine>,
    {
        self.routine = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateRoutineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.UpdateRoutineRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateRoutineRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __routine_id,
            __routine,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateRoutineRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "routineId" => Ok(__FieldTag::__routine_id),
                            "routine_id" => Ok(__FieldTag::__routine_id),
                            "routine" => Ok(__FieldTag::__routine),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateRoutineRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateRoutineRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__routine_id => {
                            if !fields.insert(__FieldTag::__routine_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for routine_id",
                                ));
                            }
                            result.routine_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__routine => {
                            if !fields.insert(__FieldTag::__routine) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for routine",
                                ));
                            }
                            result.routine =
                                map.next_value::<std::option::Option<crate::model::Routine>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateRoutineRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.dataset_id.is_empty() {
            state.serialize_entry("datasetId", &self.dataset_id)?;
        }
        if !self.routine_id.is_empty() {
            state.serialize_entry("routineId", &self.routine_id)?;
        }
        if self.routine.is_some() {
            state.serialize_entry("routine", &self.routine)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Describes the format for the partial update (patch) of a routine.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PatchRoutineRequest {
    /// Required. Project ID of the routine to update
    pub project_id: std::string::String,

    /// Required. Dataset ID of the routine to update
    pub dataset_id: std::string::String,

    /// Required. Routine ID of the routine to update
    pub routine_id: std::string::String,

    /// Required. A routine resource which will be used to partially
    /// update the specified routine
    pub routine: std::option::Option<crate::model::Routine>,

    /// Only the Routine fields in the field mask are updated
    /// by the given routine. Repeated routine fields will be fully replaced
    /// if contained in the field mask.
    pub field_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PatchRoutineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::PatchRoutineRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::PatchRoutineRequest::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [routine_id][crate::model::PatchRoutineRequest::routine_id].
    pub fn set_routine_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.routine_id = v.into();
        self
    }

    /// Sets the value of [routine][crate::model::PatchRoutineRequest::routine].
    pub fn set_routine<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Routine>,
    {
        self.routine = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [routine][crate::model::PatchRoutineRequest::routine].
    pub fn set_or_clear_routine<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Routine>,
    {
        self.routine = v.map(|x| x.into());
        self
    }

    /// Sets the value of [field_mask][crate::model::PatchRoutineRequest::field_mask].
    pub fn set_field_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.field_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [field_mask][crate::model::PatchRoutineRequest::field_mask].
    pub fn set_or_clear_field_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.field_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PatchRoutineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.PatchRoutineRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PatchRoutineRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __routine_id,
            __routine,
            __field_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PatchRoutineRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "routineId" => Ok(__FieldTag::__routine_id),
                            "routine_id" => Ok(__FieldTag::__routine_id),
                            "routine" => Ok(__FieldTag::__routine),
                            "fieldMask" => Ok(__FieldTag::__field_mask),
                            "field_mask" => Ok(__FieldTag::__field_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PatchRoutineRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PatchRoutineRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__routine_id => {
                            if !fields.insert(__FieldTag::__routine_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for routine_id",
                                ));
                            }
                            result.routine_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__routine => {
                            if !fields.insert(__FieldTag::__routine) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for routine",
                                ));
                            }
                            result.routine =
                                map.next_value::<std::option::Option<crate::model::Routine>>()?;
                        }
                        __FieldTag::__field_mask => {
                            if !fields.insert(__FieldTag::__field_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field_mask",
                                ));
                            }
                            result.field_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PatchRoutineRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.dataset_id.is_empty() {
            state.serialize_entry("datasetId", &self.dataset_id)?;
        }
        if !self.routine_id.is_empty() {
            state.serialize_entry("routineId", &self.routine_id)?;
        }
        if self.routine.is_some() {
            state.serialize_entry("routine", &self.routine)?;
        }
        if self.field_mask.is_some() {
            state.serialize_entry("fieldMask", &self.field_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Describes the format for deleting a routine.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteRoutineRequest {
    /// Required. Project ID of the routine to delete
    pub project_id: std::string::String,

    /// Required. Dataset ID of the routine to delete
    pub dataset_id: std::string::String,

    /// Required. Routine ID of the routine to delete
    pub routine_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteRoutineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::DeleteRoutineRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::DeleteRoutineRequest::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [routine_id][crate::model::DeleteRoutineRequest::routine_id].
    pub fn set_routine_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.routine_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteRoutineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.DeleteRoutineRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteRoutineRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __routine_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteRoutineRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "routineId" => Ok(__FieldTag::__routine_id),
                            "routine_id" => Ok(__FieldTag::__routine_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteRoutineRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteRoutineRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__routine_id => {
                            if !fields.insert(__FieldTag::__routine_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for routine_id",
                                ));
                            }
                            result.routine_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteRoutineRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.dataset_id.is_empty() {
            state.serialize_entry("datasetId", &self.dataset_id)?;
        }
        if !self.routine_id.is_empty() {
            state.serialize_entry("routineId", &self.routine_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Describes the format for listing routines.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListRoutinesRequest {
    /// Required. Project ID of the routines to list
    pub project_id: std::string::String,

    /// Required. Dataset ID of the routines to list
    pub dataset_id: std::string::String,

    /// The maximum number of results to return in a single response page.
    /// Leverage the page tokens to iterate through the entire collection.
    pub max_results: std::option::Option<wkt::UInt32Value>,

    /// Page token, returned by a previous call, to request the next page of
    /// results
    pub page_token: std::string::String,

    /// If set, then only the Routines matching this filter are returned.
    /// The supported format is `routineType:{RoutineType}`, where `{RoutineType}`
    /// is a RoutineType enum. For example: `routineType:SCALAR_FUNCTION`.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRoutinesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::ListRoutinesRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::ListRoutinesRequest::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [max_results][crate::model::ListRoutinesRequest::max_results].
    pub fn set_max_results<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::UInt32Value>,
    {
        self.max_results = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [max_results][crate::model::ListRoutinesRequest::max_results].
    pub fn set_or_clear_max_results<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::UInt32Value>,
    {
        self.max_results = v.map(|x| x.into());
        self
    }

    /// Sets the value of [page_token][crate::model::ListRoutinesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListRoutinesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListRoutinesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ListRoutinesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListRoutinesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __max_results,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListRoutinesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "maxResults" => Ok(__FieldTag::__max_results),
                            "max_results" => Ok(__FieldTag::__max_results),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListRoutinesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListRoutinesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__max_results => {
                            if !fields.insert(__FieldTag::__max_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_results",
                                ));
                            }
                            struct __With(std::option::Option<wkt::UInt32Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_results = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListRoutinesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.dataset_id.is_empty() {
            state.serialize_entry("datasetId", &self.dataset_id)?;
        }
        if self.max_results.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::UInt32Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("maxResults", &__With(&self.max_results))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Describes the format of a single result page when listing routines.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListRoutinesResponse {
    /// Routines in the requested dataset. Unless read_mask is set in the request,
    /// only the following fields are populated:
    /// etag, project_id, dataset_id, routine_id, routine_type, creation_time,
    /// last_modified_time, language, and remote_function_options.
    pub routines: std::vec::Vec<crate::model::Routine>,

    /// A token to request the next page of results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRoutinesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [routines][crate::model::ListRoutinesResponse::routines].
    pub fn set_routines<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Routine>,
    {
        use std::iter::Iterator;
        self.routines = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListRoutinesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListRoutinesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ListRoutinesResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListRoutinesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __routines,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListRoutinesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "routines" => Ok(__FieldTag::__routines),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListRoutinesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListRoutinesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__routines => {
                            if !fields.insert(__FieldTag::__routines) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for routines",
                                ));
                            }
                            result.routines = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Routine>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListRoutinesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.routines.is_empty() {
            state.serialize_entry("routines", &self.routines)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Id path of a routine.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RoutineReference {
    /// Required. The ID of the project containing this routine.
    pub project_id: std::string::String,

    /// Required. The ID of the dataset containing this routine.
    pub dataset_id: std::string::String,

    /// Required. The ID of the routine. The ID must contain only
    /// letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum
    /// length is 256 characters.
    pub routine_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RoutineReference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::RoutineReference::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::RoutineReference::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [routine_id][crate::model::RoutineReference::routine_id].
    pub fn set_routine_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.routine_id = v.into();
        self
    }
}

impl wkt::message::Message for RoutineReference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.RoutineReference"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RoutineReference {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __routine_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RoutineReference")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "routineId" => Ok(__FieldTag::__routine_id),
                            "routine_id" => Ok(__FieldTag::__routine_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RoutineReference;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RoutineReference")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__routine_id => {
                            if !fields.insert(__FieldTag::__routine_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for routine_id",
                                ));
                            }
                            result.routine_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RoutineReference {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.dataset_id.is_empty() {
            state.serialize_entry("datasetId", &self.dataset_id)?;
        }
        if !self.routine_id.is_empty() {
            state.serialize_entry("routineId", &self.routine_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for the ListRowAccessPolicies method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListRowAccessPoliciesRequest {
    /// Required. Project ID of the row access policies to list.
    pub project_id: std::string::String,

    /// Required. Dataset ID of row access policies to list.
    pub dataset_id: std::string::String,

    /// Required. Table ID of the table to list row access policies.
    pub table_id: std::string::String,

    /// Page token, returned by a previous call, to request the next page of
    /// results.
    pub page_token: std::string::String,

    /// The maximum number of results to return in a single response page. Leverage
    /// the page tokens to iterate through the entire collection.
    pub page_size: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRowAccessPoliciesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::ListRowAccessPoliciesRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::ListRowAccessPoliciesRequest::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [table_id][crate::model::ListRowAccessPoliciesRequest::table_id].
    pub fn set_table_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_id = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListRowAccessPoliciesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListRowAccessPoliciesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }
}

impl wkt::message::Message for ListRowAccessPoliciesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ListRowAccessPoliciesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListRowAccessPoliciesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __table_id,
            __page_token,
            __page_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListRowAccessPoliciesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "tableId" => Ok(__FieldTag::__table_id),
                            "table_id" => Ok(__FieldTag::__table_id),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListRowAccessPoliciesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListRowAccessPoliciesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table_id => {
                            if !fields.insert(__FieldTag::__table_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_id",
                                ));
                            }
                            result.table_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListRowAccessPoliciesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.dataset_id.is_empty() {
            state.serialize_entry("datasetId", &self.dataset_id)?;
        }
        if !self.table_id.is_empty() {
            state.serialize_entry("tableId", &self.table_id)?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for the ListRowAccessPolicies method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListRowAccessPoliciesResponse {
    /// Row access policies on the requested table.
    pub row_access_policies: std::vec::Vec<crate::model::RowAccessPolicy>,

    /// A token to request the next page of results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRowAccessPoliciesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [row_access_policies][crate::model::ListRowAccessPoliciesResponse::row_access_policies].
    pub fn set_row_access_policies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RowAccessPolicy>,
    {
        use std::iter::Iterator;
        self.row_access_policies = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListRowAccessPoliciesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListRowAccessPoliciesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ListRowAccessPoliciesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListRowAccessPoliciesResponse {
    type PageItem = crate::model::RowAccessPolicy;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.row_access_policies
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListRowAccessPoliciesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __row_access_policies,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListRowAccessPoliciesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rowAccessPolicies" => Ok(__FieldTag::__row_access_policies),
                            "row_access_policies" => Ok(__FieldTag::__row_access_policies),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListRowAccessPoliciesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListRowAccessPoliciesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__row_access_policies => {
                            if !fields.insert(__FieldTag::__row_access_policies) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for row_access_policies",
                                ));
                            }
                            result.row_access_policies =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::RowAccessPolicy>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListRowAccessPoliciesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.row_access_policies.is_empty() {
            state.serialize_entry("rowAccessPolicies", &self.row_access_policies)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for the GetRowAccessPolicy method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetRowAccessPolicyRequest {
    /// Required. Project ID of the table to get the row access policy.
    pub project_id: std::string::String,

    /// Required. Dataset ID of the table to get the row access policy.
    pub dataset_id: std::string::String,

    /// Required. Table ID of the table to get the row access policy.
    pub table_id: std::string::String,

    /// Required. Policy ID of the row access policy.
    pub policy_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetRowAccessPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::GetRowAccessPolicyRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::GetRowAccessPolicyRequest::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [table_id][crate::model::GetRowAccessPolicyRequest::table_id].
    pub fn set_table_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_id = v.into();
        self
    }

    /// Sets the value of [policy_id][crate::model::GetRowAccessPolicyRequest::policy_id].
    pub fn set_policy_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.policy_id = v.into();
        self
    }
}

impl wkt::message::Message for GetRowAccessPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.GetRowAccessPolicyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetRowAccessPolicyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __table_id,
            __policy_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetRowAccessPolicyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "tableId" => Ok(__FieldTag::__table_id),
                            "table_id" => Ok(__FieldTag::__table_id),
                            "policyId" => Ok(__FieldTag::__policy_id),
                            "policy_id" => Ok(__FieldTag::__policy_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetRowAccessPolicyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetRowAccessPolicyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table_id => {
                            if !fields.insert(__FieldTag::__table_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_id",
                                ));
                            }
                            result.table_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__policy_id => {
                            if !fields.insert(__FieldTag::__policy_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy_id",
                                ));
                            }
                            result.policy_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetRowAccessPolicyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.dataset_id.is_empty() {
            state.serialize_entry("datasetId", &self.dataset_id)?;
        }
        if !self.table_id.is_empty() {
            state.serialize_entry("tableId", &self.table_id)?;
        }
        if !self.policy_id.is_empty() {
            state.serialize_entry("policyId", &self.policy_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for the CreateRowAccessPolicy method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateRowAccessPolicyRequest {
    /// Required. Project ID of the table to get the row access policy.
    pub project_id: std::string::String,

    /// Required. Dataset ID of the table to get the row access policy.
    pub dataset_id: std::string::String,

    /// Required. Table ID of the table to get the row access policy.
    pub table_id: std::string::String,

    /// Required. The row access policy to create.
    pub row_access_policy: std::option::Option<crate::model::RowAccessPolicy>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateRowAccessPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::CreateRowAccessPolicyRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::CreateRowAccessPolicyRequest::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [table_id][crate::model::CreateRowAccessPolicyRequest::table_id].
    pub fn set_table_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_id = v.into();
        self
    }

    /// Sets the value of [row_access_policy][crate::model::CreateRowAccessPolicyRequest::row_access_policy].
    pub fn set_row_access_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RowAccessPolicy>,
    {
        self.row_access_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [row_access_policy][crate::model::CreateRowAccessPolicyRequest::row_access_policy].
    pub fn set_or_clear_row_access_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RowAccessPolicy>,
    {
        self.row_access_policy = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateRowAccessPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.CreateRowAccessPolicyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateRowAccessPolicyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __table_id,
            __row_access_policy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateRowAccessPolicyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "tableId" => Ok(__FieldTag::__table_id),
                            "table_id" => Ok(__FieldTag::__table_id),
                            "rowAccessPolicy" => Ok(__FieldTag::__row_access_policy),
                            "row_access_policy" => Ok(__FieldTag::__row_access_policy),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateRowAccessPolicyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateRowAccessPolicyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table_id => {
                            if !fields.insert(__FieldTag::__table_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_id",
                                ));
                            }
                            result.table_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__row_access_policy => {
                            if !fields.insert(__FieldTag::__row_access_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for row_access_policy",
                                ));
                            }
                            result.row_access_policy = map
                                .next_value::<std::option::Option<crate::model::RowAccessPolicy>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateRowAccessPolicyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.dataset_id.is_empty() {
            state.serialize_entry("datasetId", &self.dataset_id)?;
        }
        if !self.table_id.is_empty() {
            state.serialize_entry("tableId", &self.table_id)?;
        }
        if self.row_access_policy.is_some() {
            state.serialize_entry("rowAccessPolicy", &self.row_access_policy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for the UpdateRowAccessPolicy method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateRowAccessPolicyRequest {
    /// Required. Project ID of the table to get the row access policy.
    pub project_id: std::string::String,

    /// Required. Dataset ID of the table to get the row access policy.
    pub dataset_id: std::string::String,

    /// Required. Table ID of the table to get the row access policy.
    pub table_id: std::string::String,

    /// Required. Policy ID of the row access policy.
    pub policy_id: std::string::String,

    /// Required. The row access policy to update.
    pub row_access_policy: std::option::Option<crate::model::RowAccessPolicy>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateRowAccessPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::UpdateRowAccessPolicyRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::UpdateRowAccessPolicyRequest::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [table_id][crate::model::UpdateRowAccessPolicyRequest::table_id].
    pub fn set_table_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_id = v.into();
        self
    }

    /// Sets the value of [policy_id][crate::model::UpdateRowAccessPolicyRequest::policy_id].
    pub fn set_policy_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.policy_id = v.into();
        self
    }

    /// Sets the value of [row_access_policy][crate::model::UpdateRowAccessPolicyRequest::row_access_policy].
    pub fn set_row_access_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RowAccessPolicy>,
    {
        self.row_access_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [row_access_policy][crate::model::UpdateRowAccessPolicyRequest::row_access_policy].
    pub fn set_or_clear_row_access_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RowAccessPolicy>,
    {
        self.row_access_policy = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateRowAccessPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.UpdateRowAccessPolicyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateRowAccessPolicyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __table_id,
            __policy_id,
            __row_access_policy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateRowAccessPolicyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "tableId" => Ok(__FieldTag::__table_id),
                            "table_id" => Ok(__FieldTag::__table_id),
                            "policyId" => Ok(__FieldTag::__policy_id),
                            "policy_id" => Ok(__FieldTag::__policy_id),
                            "rowAccessPolicy" => Ok(__FieldTag::__row_access_policy),
                            "row_access_policy" => Ok(__FieldTag::__row_access_policy),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateRowAccessPolicyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateRowAccessPolicyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table_id => {
                            if !fields.insert(__FieldTag::__table_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_id",
                                ));
                            }
                            result.table_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__policy_id => {
                            if !fields.insert(__FieldTag::__policy_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy_id",
                                ));
                            }
                            result.policy_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__row_access_policy => {
                            if !fields.insert(__FieldTag::__row_access_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for row_access_policy",
                                ));
                            }
                            result.row_access_policy = map
                                .next_value::<std::option::Option<crate::model::RowAccessPolicy>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateRowAccessPolicyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.dataset_id.is_empty() {
            state.serialize_entry("datasetId", &self.dataset_id)?;
        }
        if !self.table_id.is_empty() {
            state.serialize_entry("tableId", &self.table_id)?;
        }
        if !self.policy_id.is_empty() {
            state.serialize_entry("policyId", &self.policy_id)?;
        }
        if self.row_access_policy.is_some() {
            state.serialize_entry("rowAccessPolicy", &self.row_access_policy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for the DeleteRowAccessPolicy method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteRowAccessPolicyRequest {
    /// Required. Project ID of the table to delete the row access policy.
    pub project_id: std::string::String,

    /// Required. Dataset ID of the table to delete the row access policy.
    pub dataset_id: std::string::String,

    /// Required. Table ID of the table to delete the row access policy.
    pub table_id: std::string::String,

    /// Required. Policy ID of the row access policy.
    pub policy_id: std::string::String,

    /// If set to true, it deletes the row access policy even if it's the last row
    /// access policy on the table and the deletion will widen the access rather
    /// narrowing it.
    pub force: std::option::Option<bool>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteRowAccessPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::DeleteRowAccessPolicyRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::DeleteRowAccessPolicyRequest::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [table_id][crate::model::DeleteRowAccessPolicyRequest::table_id].
    pub fn set_table_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_id = v.into();
        self
    }

    /// Sets the value of [policy_id][crate::model::DeleteRowAccessPolicyRequest::policy_id].
    pub fn set_policy_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.policy_id = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteRowAccessPolicyRequest::force].
    pub fn set_force<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.force = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [force][crate::model::DeleteRowAccessPolicyRequest::force].
    pub fn set_or_clear_force<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.force = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DeleteRowAccessPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.DeleteRowAccessPolicyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteRowAccessPolicyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __table_id,
            __policy_id,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteRowAccessPolicyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "tableId" => Ok(__FieldTag::__table_id),
                            "table_id" => Ok(__FieldTag::__table_id),
                            "policyId" => Ok(__FieldTag::__policy_id),
                            "policy_id" => Ok(__FieldTag::__policy_id),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteRowAccessPolicyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteRowAccessPolicyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table_id => {
                            if !fields.insert(__FieldTag::__table_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_id",
                                ));
                            }
                            result.table_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__policy_id => {
                            if !fields.insert(__FieldTag::__policy_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy_id",
                                ));
                            }
                            result.policy_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteRowAccessPolicyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.dataset_id.is_empty() {
            state.serialize_entry("datasetId", &self.dataset_id)?;
        }
        if !self.table_id.is_empty() {
            state.serialize_entry("tableId", &self.table_id)?;
        }
        if !self.policy_id.is_empty() {
            state.serialize_entry("policyId", &self.policy_id)?;
        }
        if self.force.is_some() {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for the BatchDeleteRowAccessPoliciesRequest method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchDeleteRowAccessPoliciesRequest {
    /// Required. Project ID of the table to delete the row access policies.
    pub project_id: std::string::String,

    /// Required. Dataset ID of the table to delete the row access policies.
    pub dataset_id: std::string::String,

    /// Required. Table ID of the table to delete the row access policies.
    pub table_id: std::string::String,

    /// Required. Policy IDs of the row access policies.
    pub policy_ids: std::vec::Vec<std::string::String>,

    /// If set to true, it deletes the row access policy even if it's the last row
    /// access policy on the table and the deletion will widen the access rather
    /// narrowing it.
    pub force: std::option::Option<bool>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchDeleteRowAccessPoliciesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::BatchDeleteRowAccessPoliciesRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::BatchDeleteRowAccessPoliciesRequest::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [table_id][crate::model::BatchDeleteRowAccessPoliciesRequest::table_id].
    pub fn set_table_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_id = v.into();
        self
    }

    /// Sets the value of [policy_ids][crate::model::BatchDeleteRowAccessPoliciesRequest::policy_ids].
    pub fn set_policy_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.policy_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [force][crate::model::BatchDeleteRowAccessPoliciesRequest::force].
    pub fn set_force<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.force = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [force][crate::model::BatchDeleteRowAccessPoliciesRequest::force].
    pub fn set_or_clear_force<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.force = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for BatchDeleteRowAccessPoliciesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.BatchDeleteRowAccessPoliciesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchDeleteRowAccessPoliciesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __table_id,
            __policy_ids,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchDeleteRowAccessPoliciesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "tableId" => Ok(__FieldTag::__table_id),
                            "table_id" => Ok(__FieldTag::__table_id),
                            "policyIds" => Ok(__FieldTag::__policy_ids),
                            "policy_ids" => Ok(__FieldTag::__policy_ids),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchDeleteRowAccessPoliciesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchDeleteRowAccessPoliciesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table_id => {
                            if !fields.insert(__FieldTag::__table_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_id",
                                ));
                            }
                            result.table_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__policy_ids => {
                            if !fields.insert(__FieldTag::__policy_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy_ids",
                                ));
                            }
                            result.policy_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchDeleteRowAccessPoliciesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.dataset_id.is_empty() {
            state.serialize_entry("datasetId", &self.dataset_id)?;
        }
        if !self.table_id.is_empty() {
            state.serialize_entry("tableId", &self.table_id)?;
        }
        if !self.policy_ids.is_empty() {
            state.serialize_entry("policyIds", &self.policy_ids)?;
        }
        if self.force.is_some() {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents access on a subset of rows on the specified table, defined by its
/// filter predicate. Access to the subset of rows is controlled by its IAM
/// policy.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RowAccessPolicy {
    /// Output only. A hash of this resource.
    pub etag: std::string::String,

    /// Required. Reference describing the ID of this row access policy.
    pub row_access_policy_reference: std::option::Option<crate::model::RowAccessPolicyReference>,

    /// Required. A SQL boolean expression that represents the rows defined by this
    /// row access policy, similar to the boolean expression in a WHERE clause of a
    /// SELECT query on a table.
    /// References to other tables, routines, and temporary functions are not
    /// supported.
    ///
    /// Examples: region="EU"
    /// date_field = CAST('2019-9-27' as DATE)
    /// nullable_field is not NULL
    /// numeric_field BETWEEN 1.0 AND 5.0
    pub filter_predicate: std::string::String,

    /// Output only. The time when this row access policy was created, in
    /// milliseconds since the epoch.
    pub creation_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when this row access policy was last modified, in
    /// milliseconds since the epoch.
    pub last_modified_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Input only. The optional list of iam_member users or groups that
    /// specifies the initial members that the row-level access policy should be
    /// created with.
    ///
    /// grantees types:
    ///
    /// - "user:alice@example.com": An email address that represents a specific
    ///   Google account.
    /// - "serviceAccount:my-other-app@appspot.gserviceaccount.com": An email
    ///   address that represents a service account.
    /// - "group:admins@example.com": An email address that represents a Google
    ///   group.
    /// - "domain:example.com":The Google Workspace domain (primary) that
    ///   represents all the users of that domain.
    /// - "allAuthenticatedUsers": A special identifier that represents all service
    ///   accounts and all users on the internet who have authenticated with a Google
    ///   Account. This identifier includes accounts that aren't connected to a
    ///   Google Workspace or Cloud Identity domain, such as personal Gmail accounts.
    ///   Users who aren't authenticated, such as anonymous visitors, aren't
    ///   included.
    /// - "allUsers":A special identifier that represents anyone who is on
    ///   the internet, including authenticated and unauthenticated users. Because
    ///   BigQuery requires authentication before a user can access the service,
    ///   allUsers includes only authenticated users.
    pub grantees: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RowAccessPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [etag][crate::model::RowAccessPolicy::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [row_access_policy_reference][crate::model::RowAccessPolicy::row_access_policy_reference].
    pub fn set_row_access_policy_reference<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RowAccessPolicyReference>,
    {
        self.row_access_policy_reference = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [row_access_policy_reference][crate::model::RowAccessPolicy::row_access_policy_reference].
    pub fn set_or_clear_row_access_policy_reference<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RowAccessPolicyReference>,
    {
        self.row_access_policy_reference = v.map(|x| x.into());
        self
    }

    /// Sets the value of [filter_predicate][crate::model::RowAccessPolicy::filter_predicate].
    pub fn set_filter_predicate<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.filter_predicate = v.into();
        self
    }

    /// Sets the value of [creation_time][crate::model::RowAccessPolicy::creation_time].
    pub fn set_creation_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.creation_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [creation_time][crate::model::RowAccessPolicy::creation_time].
    pub fn set_or_clear_creation_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.creation_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_modified_time][crate::model::RowAccessPolicy::last_modified_time].
    pub fn set_last_modified_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_modified_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_modified_time][crate::model::RowAccessPolicy::last_modified_time].
    pub fn set_or_clear_last_modified_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_modified_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [grantees][crate::model::RowAccessPolicy::grantees].
    pub fn set_grantees<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.grantees = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RowAccessPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.RowAccessPolicy"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RowAccessPolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __etag,
            __row_access_policy_reference,
            __filter_predicate,
            __creation_time,
            __last_modified_time,
            __grantees,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RowAccessPolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "etag" => Ok(__FieldTag::__etag),
                            "rowAccessPolicyReference" => {
                                Ok(__FieldTag::__row_access_policy_reference)
                            }
                            "row_access_policy_reference" => {
                                Ok(__FieldTag::__row_access_policy_reference)
                            }
                            "filterPredicate" => Ok(__FieldTag::__filter_predicate),
                            "filter_predicate" => Ok(__FieldTag::__filter_predicate),
                            "creationTime" => Ok(__FieldTag::__creation_time),
                            "creation_time" => Ok(__FieldTag::__creation_time),
                            "lastModifiedTime" => Ok(__FieldTag::__last_modified_time),
                            "last_modified_time" => Ok(__FieldTag::__last_modified_time),
                            "grantees" => Ok(__FieldTag::__grantees),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RowAccessPolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RowAccessPolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__row_access_policy_reference => {
                            if !fields.insert(__FieldTag::__row_access_policy_reference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for row_access_policy_reference",
                                ));
                            }
                            result.row_access_policy_reference = map.next_value::<std::option::Option<crate::model::RowAccessPolicyReference>>()?
                                ;
                        }
                        __FieldTag::__filter_predicate => {
                            if !fields.insert(__FieldTag::__filter_predicate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter_predicate",
                                ));
                            }
                            result.filter_predicate = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__creation_time => {
                            if !fields.insert(__FieldTag::__creation_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for creation_time",
                                ));
                            }
                            result.creation_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__last_modified_time => {
                            if !fields.insert(__FieldTag::__last_modified_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_modified_time",
                                ));
                            }
                            result.last_modified_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__grantees => {
                            if !fields.insert(__FieldTag::__grantees) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for grantees",
                                ));
                            }
                            result.grantees = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RowAccessPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.row_access_policy_reference.is_some() {
            state.serialize_entry(
                "rowAccessPolicyReference",
                &self.row_access_policy_reference,
            )?;
        }
        if !self.filter_predicate.is_empty() {
            state.serialize_entry("filterPredicate", &self.filter_predicate)?;
        }
        if self.creation_time.is_some() {
            state.serialize_entry("creationTime", &self.creation_time)?;
        }
        if self.last_modified_time.is_some() {
            state.serialize_entry("lastModifiedTime", &self.last_modified_time)?;
        }
        if !self.grantees.is_empty() {
            state.serialize_entry("grantees", &self.grantees)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Id path of a row access policy.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RowAccessPolicyReference {
    /// Required. The ID of the project containing this row access policy.
    pub project_id: std::string::String,

    /// Required. The ID of the dataset containing this row access policy.
    pub dataset_id: std::string::String,

    /// Required. The ID of the table containing this row access policy.
    pub table_id: std::string::String,

    /// Required. The ID of the row access policy. The ID must contain only
    /// letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum
    /// length is 256 characters.
    pub policy_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RowAccessPolicyReference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::RowAccessPolicyReference::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::RowAccessPolicyReference::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [table_id][crate::model::RowAccessPolicyReference::table_id].
    pub fn set_table_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_id = v.into();
        self
    }

    /// Sets the value of [policy_id][crate::model::RowAccessPolicyReference::policy_id].
    pub fn set_policy_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.policy_id = v.into();
        self
    }
}

impl wkt::message::Message for RowAccessPolicyReference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.RowAccessPolicyReference"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RowAccessPolicyReference {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __table_id,
            __policy_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RowAccessPolicyReference")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "tableId" => Ok(__FieldTag::__table_id),
                            "table_id" => Ok(__FieldTag::__table_id),
                            "policyId" => Ok(__FieldTag::__policy_id),
                            "policy_id" => Ok(__FieldTag::__policy_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RowAccessPolicyReference;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RowAccessPolicyReference")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table_id => {
                            if !fields.insert(__FieldTag::__table_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_id",
                                ));
                            }
                            result.table_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__policy_id => {
                            if !fields.insert(__FieldTag::__policy_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy_id",
                                ));
                            }
                            result.policy_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RowAccessPolicyReference {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.dataset_id.is_empty() {
            state.serialize_entry("datasetId", &self.dataset_id)?;
        }
        if !self.table_id.is_empty() {
            state.serialize_entry("tableId", &self.table_id)?;
        }
        if !self.policy_id.is_empty() {
            state.serialize_entry("policyId", &self.policy_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The data type of a variable such as a function argument.
/// Examples include:
///
/// * INT64: `{"typeKind": "INT64"}`
///
/// * ARRAY\<STRING\>:
///
///   {
///   "typeKind": "ARRAY",
///   "arrayElementType": {"typeKind": "STRING"}
///   }
///
/// * STRUCT<x STRING, y ARRAY\<DATE\>>:
///
///   {
///   "typeKind": "STRUCT",
///   "structType":
///   {
///   "fields":
///   [
///   {
///   "name": "x",
///   "type": {"typeKind": "STRING"}
///   },
///   {
///   "name": "y",
///   "type":
///   {
///   "typeKind": "ARRAY",
///   "arrayElementType": {"typeKind": "DATE"}
///   }
///   }
///   ]
///   }
///   }
///
/// * RANGE\<DATE\>:
///
///   {
///   "typeKind": "RANGE",
///   "rangeElementType": {"typeKind": "DATE"}
///   }
///
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StandardSqlDataType {
    /// Required. The top level type of this field.
    /// Can be any GoogleSQL data type (e.g., "INT64", "DATE", "ARRAY").
    pub type_kind: crate::model::standard_sql_data_type::TypeKind,

    /// For complex types, the sub type information.
    pub sub_type: std::option::Option<crate::model::standard_sql_data_type::SubType>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StandardSqlDataType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [type_kind][crate::model::StandardSqlDataType::type_kind].
    pub fn set_type_kind<T: std::convert::Into<crate::model::standard_sql_data_type::TypeKind>>(
        mut self,
        v: T,
    ) -> Self {
        self.type_kind = v.into();
        self
    }

    /// Sets the value of [sub_type][crate::model::StandardSqlDataType::sub_type].
    ///
    /// Note that all the setters affecting `sub_type` are mutually
    /// exclusive.
    pub fn set_sub_type<
        T: std::convert::Into<std::option::Option<crate::model::standard_sql_data_type::SubType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sub_type = v.into();
        self
    }

    /// The value of [sub_type][crate::model::StandardSqlDataType::sub_type]
    /// if it holds a `ArrayElementType`, `None` if the field is not set or
    /// holds a different branch.
    pub fn array_element_type(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StandardSqlDataType>> {
        #[allow(unreachable_patterns)]
        self.sub_type.as_ref().and_then(|v| match v {
            crate::model::standard_sql_data_type::SubType::ArrayElementType(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [sub_type][crate::model::StandardSqlDataType::sub_type]
    /// to hold a `ArrayElementType`.
    ///
    /// Note that all the setters affecting `sub_type` are
    /// mutually exclusive.
    pub fn set_array_element_type<
        T: std::convert::Into<std::boxed::Box<crate::model::StandardSqlDataType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sub_type = std::option::Option::Some(
            crate::model::standard_sql_data_type::SubType::ArrayElementType(v.into()),
        );
        self
    }

    /// The value of [sub_type][crate::model::StandardSqlDataType::sub_type]
    /// if it holds a `StructType`, `None` if the field is not set or
    /// holds a different branch.
    pub fn struct_type(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StandardSqlStructType>> {
        #[allow(unreachable_patterns)]
        self.sub_type.as_ref().and_then(|v| match v {
            crate::model::standard_sql_data_type::SubType::StructType(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [sub_type][crate::model::StandardSqlDataType::sub_type]
    /// to hold a `StructType`.
    ///
    /// Note that all the setters affecting `sub_type` are
    /// mutually exclusive.
    pub fn set_struct_type<
        T: std::convert::Into<std::boxed::Box<crate::model::StandardSqlStructType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sub_type = std::option::Option::Some(
            crate::model::standard_sql_data_type::SubType::StructType(v.into()),
        );
        self
    }

    /// The value of [sub_type][crate::model::StandardSqlDataType::sub_type]
    /// if it holds a `RangeElementType`, `None` if the field is not set or
    /// holds a different branch.
    pub fn range_element_type(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StandardSqlDataType>> {
        #[allow(unreachable_patterns)]
        self.sub_type.as_ref().and_then(|v| match v {
            crate::model::standard_sql_data_type::SubType::RangeElementType(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [sub_type][crate::model::StandardSqlDataType::sub_type]
    /// to hold a `RangeElementType`.
    ///
    /// Note that all the setters affecting `sub_type` are
    /// mutually exclusive.
    pub fn set_range_element_type<
        T: std::convert::Into<std::boxed::Box<crate::model::StandardSqlDataType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sub_type = std::option::Option::Some(
            crate::model::standard_sql_data_type::SubType::RangeElementType(v.into()),
        );
        self
    }
}

impl wkt::message::Message for StandardSqlDataType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.StandardSqlDataType"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StandardSqlDataType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type_kind,
            __array_element_type,
            __struct_type,
            __range_element_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StandardSqlDataType")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "typeKind" => Ok(__FieldTag::__type_kind),
                            "type_kind" => Ok(__FieldTag::__type_kind),
                            "arrayElementType" => Ok(__FieldTag::__array_element_type),
                            "array_element_type" => Ok(__FieldTag::__array_element_type),
                            "structType" => Ok(__FieldTag::__struct_type),
                            "struct_type" => Ok(__FieldTag::__struct_type),
                            "rangeElementType" => Ok(__FieldTag::__range_element_type),
                            "range_element_type" => Ok(__FieldTag::__range_element_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StandardSqlDataType;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StandardSqlDataType")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type_kind => {
                            if !fields.insert(__FieldTag::__type_kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type_kind",
                                ));
                            }
                            result.type_kind =
                                map.next_value::<std::option::Option<
                                    crate::model::standard_sql_data_type::TypeKind,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__array_element_type => {
                            if !fields.insert(__FieldTag::__array_element_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for array_element_type",
                                ));
                            }
                            if result.sub_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `sub_type`, a oneof with full ID .google.cloud.bigquery.v2.StandardSqlDataType.array_element_type, latest field was arrayElementType",
                                ));
                            }
                            result.sub_type = std::option::Option::Some(
                                crate::model::standard_sql_data_type::SubType::ArrayElementType(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::StandardSqlDataType>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__struct_type => {
                            if !fields.insert(__FieldTag::__struct_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for struct_type",
                                ));
                            }
                            if result.sub_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `sub_type`, a oneof with full ID .google.cloud.bigquery.v2.StandardSqlDataType.struct_type, latest field was structType",
                                ));
                            }
                            result.sub_type = std::option::Option::Some(
                                crate::model::standard_sql_data_type::SubType::StructType(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::StandardSqlStructType>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__range_element_type => {
                            if !fields.insert(__FieldTag::__range_element_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for range_element_type",
                                ));
                            }
                            if result.sub_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `sub_type`, a oneof with full ID .google.cloud.bigquery.v2.StandardSqlDataType.range_element_type, latest field was rangeElementType",
                                ));
                            }
                            result.sub_type = std::option::Option::Some(
                                crate::model::standard_sql_data_type::SubType::RangeElementType(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::StandardSqlDataType>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StandardSqlDataType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.type_kind) {
            state.serialize_entry("typeKind", &self.type_kind)?;
        }
        if let Some(value) = self.array_element_type() {
            state.serialize_entry("arrayElementType", value)?;
        }
        if let Some(value) = self.struct_type() {
            state.serialize_entry("structType", value)?;
        }
        if let Some(value) = self.range_element_type() {
            state.serialize_entry("rangeElementType", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [StandardSqlDataType].
pub mod standard_sql_data_type {
    #[allow(unused_imports)]
    use super::*;

    /// The kind of the datatype.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TypeKind {
        /// Invalid type.
        Unspecified,
        /// Encoded as a string in decimal format.
        Int64,
        /// Encoded as a boolean "false" or "true".
        Bool,
        /// Encoded as a number, or string "NaN", "Infinity" or "-Infinity".
        Float64,
        /// Encoded as a string value.
        String,
        /// Encoded as a base64 string per RFC 4648, section 4.
        Bytes,
        /// Encoded as an RFC 3339 timestamp with mandatory "Z" time zone string:
        /// 1985-04-12T23:20:50.52Z
        Timestamp,
        /// Encoded as RFC 3339 full-date format string: 1985-04-12
        Date,
        /// Encoded as RFC 3339 partial-time format string: 23:20:50.52
        Time,
        /// Encoded as RFC 3339 full-date "T" partial-time: 1985-04-12T23:20:50.52
        Datetime,
        /// Encoded as fully qualified 3 part: 0-5 15 2:30:45.6
        Interval,
        /// Encoded as WKT
        Geography,
        /// Encoded as a decimal string.
        Numeric,
        /// Encoded as a decimal string.
        Bignumeric,
        /// Encoded as a string.
        Json,
        /// Encoded as a list with types matching Type.array_type.
        Array,
        /// Encoded as a list with fields of type Type.struct_type[i]. List is used
        /// because a JSON object cannot have duplicate field names.
        Struct,
        /// Encoded as a pair with types matching range_element_type. Pairs must
        /// begin with "[", end with ")", and be separated by ", ".
        Range,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TypeKind::value] or
        /// [TypeKind::name].
        UnknownValue(type_kind::UnknownValue),
    }

    #[doc(hidden)]
    pub mod type_kind {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TypeKind {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Int64 => std::option::Option::Some(2),
                Self::Bool => std::option::Option::Some(5),
                Self::Float64 => std::option::Option::Some(7),
                Self::String => std::option::Option::Some(8),
                Self::Bytes => std::option::Option::Some(9),
                Self::Timestamp => std::option::Option::Some(19),
                Self::Date => std::option::Option::Some(10),
                Self::Time => std::option::Option::Some(20),
                Self::Datetime => std::option::Option::Some(21),
                Self::Interval => std::option::Option::Some(26),
                Self::Geography => std::option::Option::Some(22),
                Self::Numeric => std::option::Option::Some(23),
                Self::Bignumeric => std::option::Option::Some(24),
                Self::Json => std::option::Option::Some(25),
                Self::Array => std::option::Option::Some(16),
                Self::Struct => std::option::Option::Some(17),
                Self::Range => std::option::Option::Some(29),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_KIND_UNSPECIFIED"),
                Self::Int64 => std::option::Option::Some("INT64"),
                Self::Bool => std::option::Option::Some("BOOL"),
                Self::Float64 => std::option::Option::Some("FLOAT64"),
                Self::String => std::option::Option::Some("STRING"),
                Self::Bytes => std::option::Option::Some("BYTES"),
                Self::Timestamp => std::option::Option::Some("TIMESTAMP"),
                Self::Date => std::option::Option::Some("DATE"),
                Self::Time => std::option::Option::Some("TIME"),
                Self::Datetime => std::option::Option::Some("DATETIME"),
                Self::Interval => std::option::Option::Some("INTERVAL"),
                Self::Geography => std::option::Option::Some("GEOGRAPHY"),
                Self::Numeric => std::option::Option::Some("NUMERIC"),
                Self::Bignumeric => std::option::Option::Some("BIGNUMERIC"),
                Self::Json => std::option::Option::Some("JSON"),
                Self::Array => std::option::Option::Some("ARRAY"),
                Self::Struct => std::option::Option::Some("STRUCT"),
                Self::Range => std::option::Option::Some("RANGE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TypeKind {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TypeKind {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TypeKind {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                2 => Self::Int64,
                5 => Self::Bool,
                7 => Self::Float64,
                8 => Self::String,
                9 => Self::Bytes,
                10 => Self::Date,
                16 => Self::Array,
                17 => Self::Struct,
                19 => Self::Timestamp,
                20 => Self::Time,
                21 => Self::Datetime,
                22 => Self::Geography,
                23 => Self::Numeric,
                24 => Self::Bignumeric,
                25 => Self::Json,
                26 => Self::Interval,
                29 => Self::Range,
                _ => Self::UnknownValue(type_kind::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TypeKind {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_KIND_UNSPECIFIED" => Self::Unspecified,
                "INT64" => Self::Int64,
                "BOOL" => Self::Bool,
                "FLOAT64" => Self::Float64,
                "STRING" => Self::String,
                "BYTES" => Self::Bytes,
                "TIMESTAMP" => Self::Timestamp,
                "DATE" => Self::Date,
                "TIME" => Self::Time,
                "DATETIME" => Self::Datetime,
                "INTERVAL" => Self::Interval,
                "GEOGRAPHY" => Self::Geography,
                "NUMERIC" => Self::Numeric,
                "BIGNUMERIC" => Self::Bignumeric,
                "JSON" => Self::Json,
                "ARRAY" => Self::Array,
                "STRUCT" => Self::Struct,
                "RANGE" => Self::Range,
                _ => Self::UnknownValue(type_kind::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TypeKind {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Int64 => serializer.serialize_i32(2),
                Self::Bool => serializer.serialize_i32(5),
                Self::Float64 => serializer.serialize_i32(7),
                Self::String => serializer.serialize_i32(8),
                Self::Bytes => serializer.serialize_i32(9),
                Self::Timestamp => serializer.serialize_i32(19),
                Self::Date => serializer.serialize_i32(10),
                Self::Time => serializer.serialize_i32(20),
                Self::Datetime => serializer.serialize_i32(21),
                Self::Interval => serializer.serialize_i32(26),
                Self::Geography => serializer.serialize_i32(22),
                Self::Numeric => serializer.serialize_i32(23),
                Self::Bignumeric => serializer.serialize_i32(24),
                Self::Json => serializer.serialize_i32(25),
                Self::Array => serializer.serialize_i32(16),
                Self::Struct => serializer.serialize_i32(17),
                Self::Range => serializer.serialize_i32(29),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TypeKind {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TypeKind>::new(
                ".google.cloud.bigquery.v2.StandardSqlDataType.TypeKind",
            ))
        }
    }

    /// For complex types, the sub type information.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SubType {
        /// The type of the array's elements, if type_kind = "ARRAY".
        ArrayElementType(std::boxed::Box<crate::model::StandardSqlDataType>),
        /// The fields of this struct, in order, if type_kind = "STRUCT".
        StructType(std::boxed::Box<crate::model::StandardSqlStructType>),
        /// The type of the range's elements, if type_kind = "RANGE".
        RangeElementType(std::boxed::Box<crate::model::StandardSqlDataType>),
    }
}

/// A field or a column.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StandardSqlField {
    /// Optional. The name of this field. Can be absent for struct fields.
    pub name: std::string::String,

    /// Optional. The type of this parameter. Absent if not explicitly
    /// specified (e.g., CREATE FUNCTION statement can omit the return type;
    /// in this case the output parameter does not have this "type" field).
    pub r#type: std::option::Option<std::boxed::Box<crate::model::StandardSqlDataType>>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StandardSqlField {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StandardSqlField::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::StandardSqlField::type].
    pub fn set_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::StandardSqlDataType>,
    {
        self.r#type = std::option::Option::Some(std::boxed::Box::new(v.into()));
        self
    }

    /// Sets or clears the value of [r#type][crate::model::StandardSqlField::type].
    pub fn set_or_clear_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::StandardSqlDataType>,
    {
        self.r#type = v.map(|x| std::boxed::Box::new(x.into()));
        self
    }
}

impl wkt::message::Message for StandardSqlField {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.StandardSqlField"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StandardSqlField {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StandardSqlField")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "type" => Ok(__FieldTag::__type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StandardSqlField;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StandardSqlField")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<
                                std::boxed::Box<crate::model::StandardSqlDataType>,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StandardSqlField {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.r#type.is_some() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The representation of a SQL STRUCT type.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StandardSqlStructType {
    /// Fields within the struct.
    pub fields: std::vec::Vec<crate::model::StandardSqlField>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StandardSqlStructType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [fields][crate::model::StandardSqlStructType::fields].
    pub fn set_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::StandardSqlField>,
    {
        use std::iter::Iterator;
        self.fields = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for StandardSqlStructType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.StandardSqlStructType"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StandardSqlStructType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __fields,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StandardSqlStructType")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fields" => Ok(__FieldTag::__fields),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StandardSqlStructType;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StandardSqlStructType")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__fields => {
                            if !fields.insert(__FieldTag::__fields) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fields",
                                ));
                            }
                            result.fields =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::StandardSqlField>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StandardSqlStructType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.fields.is_empty() {
            state.serialize_entry("fields", &self.fields)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A table type
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StandardSqlTableType {
    /// The columns in this table type
    pub columns: std::vec::Vec<crate::model::StandardSqlField>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StandardSqlTableType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [columns][crate::model::StandardSqlTableType::columns].
    pub fn set_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::StandardSqlField>,
    {
        use std::iter::Iterator;
        self.columns = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for StandardSqlTableType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.StandardSqlTableType"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StandardSqlTableType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __columns,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StandardSqlTableType")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "columns" => Ok(__FieldTag::__columns),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StandardSqlTableType;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StandardSqlTableType")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__columns => {
                            if !fields.insert(__FieldTag::__columns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for columns",
                                ));
                            }
                            result.columns =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::StandardSqlField>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StandardSqlTableType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.columns.is_empty() {
            state.serialize_entry("columns", &self.columns)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// System variables given to a query.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SystemVariables {
    /// Output only. Data type for each system variable.
    pub types: std::collections::HashMap<std::string::String, crate::model::StandardSqlDataType>,

    /// Output only. Value for each system variable.
    pub values: std::option::Option<wkt::Struct>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SystemVariables {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [types][crate::model::SystemVariables::types].
    pub fn set_types<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::StandardSqlDataType>,
    {
        use std::iter::Iterator;
        self.types = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [values][crate::model::SystemVariables::values].
    pub fn set_values<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.values = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [values][crate::model::SystemVariables::values].
    pub fn set_or_clear_values<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.values = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SystemVariables {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.SystemVariables"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SystemVariables {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __types,
            __values,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SystemVariables")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "types" => Ok(__FieldTag::__types),
                            "values" => Ok(__FieldTag::__values),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SystemVariables;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SystemVariables")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__types => {
                            if !fields.insert(__FieldTag::__types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for types",
                                ));
                            }
                            result.types = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::StandardSqlDataType,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__values => {
                            if !fields.insert(__FieldTag::__values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for values",
                                ));
                            }
                            result.values = map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SystemVariables {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.types.is_empty() {
            state.serialize_entry("types", &self.types)?;
        }
        if self.values.is_some() {
            state.serialize_entry("values", &self.values)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Replication info of a table created using `AS REPLICA` DDL like:
/// `CREATE MATERIALIZED VIEW mv1 AS REPLICA OF src_mv`
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TableReplicationInfo {
    /// Required. Source table reference that is replicated.
    pub source_table: std::option::Option<crate::model::TableReference>,

    /// Optional. Specifies the interval at which the source table is polled for
    /// updates.
    /// It's Optional. If not specified, default replication interval would be
    /// applied.
    pub replication_interval_ms: i64,

    /// Optional. Output only. If source is a materialized view, this field
    /// signifies the last refresh time of the source.
    pub replicated_source_last_refresh_time: i64,

    /// Optional. Output only. Replication status of configured replication.
    pub replication_status: crate::model::table_replication_info::ReplicationStatus,

    /// Optional. Output only. Replication error that will permanently stopped
    /// table replication.
    pub replication_error: std::option::Option<crate::model::ErrorProto>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TableReplicationInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_table][crate::model::TableReplicationInfo::source_table].
    pub fn set_source_table<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TableReference>,
    {
        self.source_table = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_table][crate::model::TableReplicationInfo::source_table].
    pub fn set_or_clear_source_table<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TableReference>,
    {
        self.source_table = v.map(|x| x.into());
        self
    }

    /// Sets the value of [replication_interval_ms][crate::model::TableReplicationInfo::replication_interval_ms].
    pub fn set_replication_interval_ms<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.replication_interval_ms = v.into();
        self
    }

    /// Sets the value of [replicated_source_last_refresh_time][crate::model::TableReplicationInfo::replicated_source_last_refresh_time].
    pub fn set_replicated_source_last_refresh_time<T: std::convert::Into<i64>>(
        mut self,
        v: T,
    ) -> Self {
        self.replicated_source_last_refresh_time = v.into();
        self
    }

    /// Sets the value of [replication_status][crate::model::TableReplicationInfo::replication_status].
    pub fn set_replication_status<
        T: std::convert::Into<crate::model::table_replication_info::ReplicationStatus>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.replication_status = v.into();
        self
    }

    /// Sets the value of [replication_error][crate::model::TableReplicationInfo::replication_error].
    pub fn set_replication_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ErrorProto>,
    {
        self.replication_error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [replication_error][crate::model::TableReplicationInfo::replication_error].
    pub fn set_or_clear_replication_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ErrorProto>,
    {
        self.replication_error = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for TableReplicationInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.TableReplicationInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TableReplicationInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source_table,
            __replication_interval_ms,
            __replicated_source_last_refresh_time,
            __replication_status,
            __replication_error,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TableReplicationInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sourceTable" => Ok(__FieldTag::__source_table),
                            "source_table" => Ok(__FieldTag::__source_table),
                            "replicationIntervalMs" => Ok(__FieldTag::__replication_interval_ms),
                            "replication_interval_ms" => Ok(__FieldTag::__replication_interval_ms),
                            "replicatedSourceLastRefreshTime" => {
                                Ok(__FieldTag::__replicated_source_last_refresh_time)
                            }
                            "replicated_source_last_refresh_time" => {
                                Ok(__FieldTag::__replicated_source_last_refresh_time)
                            }
                            "replicationStatus" => Ok(__FieldTag::__replication_status),
                            "replication_status" => Ok(__FieldTag::__replication_status),
                            "replicationError" => Ok(__FieldTag::__replication_error),
                            "replication_error" => Ok(__FieldTag::__replication_error),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TableReplicationInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TableReplicationInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source_table => {
                            if !fields.insert(__FieldTag::__source_table) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_table",
                                ));
                            }
                            result.source_table = map
                                .next_value::<std::option::Option<crate::model::TableReference>>(
                                )?;
                        }
                        __FieldTag::__replication_interval_ms => {
                            if !fields.insert(__FieldTag::__replication_interval_ms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for replication_interval_ms",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.replication_interval_ms =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__replicated_source_last_refresh_time => {
                            if !fields.insert(__FieldTag::__replicated_source_last_refresh_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for replicated_source_last_refresh_time",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.replicated_source_last_refresh_time =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__replication_status => {
                            if !fields.insert(__FieldTag::__replication_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for replication_status",
                                ));
                            }
                            result.replication_status = map
                                .next_value::<std::option::Option<
                                    crate::model::table_replication_info::ReplicationStatus,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__replication_error => {
                            if !fields.insert(__FieldTag::__replication_error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for replication_error",
                                ));
                            }
                            result.replication_error =
                                map.next_value::<std::option::Option<crate::model::ErrorProto>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TableReplicationInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.source_table.is_some() {
            state.serialize_entry("sourceTable", &self.source_table)?;
        }
        if !wkt::internal::is_default(&self.replication_interval_ms) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "replicationIntervalMs",
                &__With(&self.replication_interval_ms),
            )?;
        }
        if !wkt::internal::is_default(&self.replicated_source_last_refresh_time) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "replicatedSourceLastRefreshTime",
                &__With(&self.replicated_source_last_refresh_time),
            )?;
        }
        if !wkt::internal::is_default(&self.replication_status) {
            state.serialize_entry("replicationStatus", &self.replication_status)?;
        }
        if self.replication_error.is_some() {
            state.serialize_entry("replicationError", &self.replication_error)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [TableReplicationInfo].
pub mod table_replication_info {
    #[allow(unused_imports)]
    use super::*;

    /// Replication status of the table created using `AS REPLICA` like:
    /// `CREATE MATERIALIZED VIEW mv1 AS REPLICA OF src_mv`
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ReplicationStatus {
        /// Default value.
        Unspecified,
        /// Replication is Active with no errors.
        Active,
        /// Source object is deleted.
        SourceDeleted,
        /// Source revoked replication permissions.
        PermissionDenied,
        /// Source configuration doesn’t allow replication.
        UnsupportedConfiguration,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ReplicationStatus::value] or
        /// [ReplicationStatus::name].
        UnknownValue(replication_status::UnknownValue),
    }

    #[doc(hidden)]
    pub mod replication_status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ReplicationStatus {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Active => std::option::Option::Some(1),
                Self::SourceDeleted => std::option::Option::Some(2),
                Self::PermissionDenied => std::option::Option::Some(3),
                Self::UnsupportedConfiguration => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("REPLICATION_STATUS_UNSPECIFIED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::SourceDeleted => std::option::Option::Some("SOURCE_DELETED"),
                Self::PermissionDenied => std::option::Option::Some("PERMISSION_DENIED"),
                Self::UnsupportedConfiguration => {
                    std::option::Option::Some("UNSUPPORTED_CONFIGURATION")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ReplicationStatus {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ReplicationStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ReplicationStatus {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Active,
                2 => Self::SourceDeleted,
                3 => Self::PermissionDenied,
                4 => Self::UnsupportedConfiguration,
                _ => Self::UnknownValue(replication_status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ReplicationStatus {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "REPLICATION_STATUS_UNSPECIFIED" => Self::Unspecified,
                "ACTIVE" => Self::Active,
                "SOURCE_DELETED" => Self::SourceDeleted,
                "PERMISSION_DENIED" => Self::PermissionDenied,
                "UNSUPPORTED_CONFIGURATION" => Self::UnsupportedConfiguration,
                _ => Self::UnknownValue(replication_status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ReplicationStatus {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Active => serializer.serialize_i32(1),
                Self::SourceDeleted => serializer.serialize_i32(2),
                Self::PermissionDenied => serializer.serialize_i32(3),
                Self::UnsupportedConfiguration => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ReplicationStatus {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ReplicationStatus>::new(
                ".google.cloud.bigquery.v2.TableReplicationInfo.ReplicationStatus",
            ))
        }
    }
}

/// Describes the definition of a logical view.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ViewDefinition {
    /// Required. A query that BigQuery executes when the view is referenced.
    pub query: std::string::String,

    /// Describes user-defined function resources used in the query.
    pub user_defined_function_resources: std::vec::Vec<crate::model::UserDefinedFunctionResource>,

    /// Specifies whether to use BigQuery's legacy SQL for this view.
    /// The default value is true. If set to false, the view will use
    /// BigQuery's GoogleSQL:
    /// <https://cloud.google.com/bigquery/sql-reference/>
    ///
    /// Queries and views that reference this view must use the same flag value.
    /// A wrapper is used here because the default value is True.
    pub use_legacy_sql: std::option::Option<wkt::BoolValue>,

    /// True if the column names are explicitly specified. For example by using the
    /// 'CREATE VIEW v(c1, c2) AS ...' syntax.
    /// Can only be set for GoogleSQL views.
    pub use_explicit_column_names: bool,

    /// Optional. Specifies the privacy policy for the view.
    pub privacy_policy: std::option::Option<crate::model::PrivacyPolicy>,

    /// Optional. Foreign view representations.
    pub foreign_definitions: std::vec::Vec<crate::model::ForeignViewDefinition>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ViewDefinition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [query][crate::model::ViewDefinition::query].
    pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query = v.into();
        self
    }

    /// Sets the value of [user_defined_function_resources][crate::model::ViewDefinition::user_defined_function_resources].
    pub fn set_user_defined_function_resources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UserDefinedFunctionResource>,
    {
        use std::iter::Iterator;
        self.user_defined_function_resources = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [use_legacy_sql][crate::model::ViewDefinition::use_legacy_sql].
    pub fn set_use_legacy_sql<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.use_legacy_sql = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [use_legacy_sql][crate::model::ViewDefinition::use_legacy_sql].
    pub fn set_or_clear_use_legacy_sql<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.use_legacy_sql = v.map(|x| x.into());
        self
    }

    /// Sets the value of [use_explicit_column_names][crate::model::ViewDefinition::use_explicit_column_names].
    pub fn set_use_explicit_column_names<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_explicit_column_names = v.into();
        self
    }

    /// Sets the value of [privacy_policy][crate::model::ViewDefinition::privacy_policy].
    pub fn set_privacy_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PrivacyPolicy>,
    {
        self.privacy_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [privacy_policy][crate::model::ViewDefinition::privacy_policy].
    pub fn set_or_clear_privacy_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PrivacyPolicy>,
    {
        self.privacy_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [foreign_definitions][crate::model::ViewDefinition::foreign_definitions].
    pub fn set_foreign_definitions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ForeignViewDefinition>,
    {
        use std::iter::Iterator;
        self.foreign_definitions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ViewDefinition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ViewDefinition"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ViewDefinition {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __query,
            __user_defined_function_resources,
            __use_legacy_sql,
            __use_explicit_column_names,
            __privacy_policy,
            __foreign_definitions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ViewDefinition")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "query" => Ok(__FieldTag::__query),
                            "userDefinedFunctionResources" => {
                                Ok(__FieldTag::__user_defined_function_resources)
                            }
                            "user_defined_function_resources" => {
                                Ok(__FieldTag::__user_defined_function_resources)
                            }
                            "useLegacySql" => Ok(__FieldTag::__use_legacy_sql),
                            "use_legacy_sql" => Ok(__FieldTag::__use_legacy_sql),
                            "useExplicitColumnNames" => Ok(__FieldTag::__use_explicit_column_names),
                            "use_explicit_column_names" => {
                                Ok(__FieldTag::__use_explicit_column_names)
                            }
                            "privacyPolicy" => Ok(__FieldTag::__privacy_policy),
                            "privacy_policy" => Ok(__FieldTag::__privacy_policy),
                            "foreignDefinitions" => Ok(__FieldTag::__foreign_definitions),
                            "foreign_definitions" => Ok(__FieldTag::__foreign_definitions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ViewDefinition;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ViewDefinition")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__query => {
                            if !fields.insert(__FieldTag::__query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query",
                                ));
                            }
                            result.query = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__user_defined_function_resources => {
                            if !fields.insert(__FieldTag::__user_defined_function_resources) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_defined_function_resources",
                                ));
                            }
                            result.user_defined_function_resources = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::UserDefinedFunctionResource>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__use_legacy_sql => {
                            if !fields.insert(__FieldTag::__use_legacy_sql) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for use_legacy_sql",
                                ));
                            }
                            result.use_legacy_sql =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__use_explicit_column_names => {
                            if !fields.insert(__FieldTag::__use_explicit_column_names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for use_explicit_column_names",
                                ));
                            }
                            result.use_explicit_column_names = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__privacy_policy => {
                            if !fields.insert(__FieldTag::__privacy_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for privacy_policy",
                                ));
                            }
                            result.privacy_policy = map
                                .next_value::<std::option::Option<crate::model::PrivacyPolicy>>()?;
                        }
                        __FieldTag::__foreign_definitions => {
                            if !fields.insert(__FieldTag::__foreign_definitions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for foreign_definitions",
                                ));
                            }
                            result.foreign_definitions = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ForeignViewDefinition>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ViewDefinition {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.query.is_empty() {
            state.serialize_entry("query", &self.query)?;
        }
        if !self.user_defined_function_resources.is_empty() {
            state.serialize_entry(
                "userDefinedFunctionResources",
                &self.user_defined_function_resources,
            )?;
        }
        if self.use_legacy_sql.is_some() {
            state.serialize_entry("useLegacySql", &self.use_legacy_sql)?;
        }
        if !wkt::internal::is_default(&self.use_explicit_column_names) {
            state.serialize_entry("useExplicitColumnNames", &self.use_explicit_column_names)?;
        }
        if self.privacy_policy.is_some() {
            state.serialize_entry("privacyPolicy", &self.privacy_policy)?;
        }
        if !self.foreign_definitions.is_empty() {
            state.serialize_entry("foreignDefinitions", &self.foreign_definitions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A view can be represented in multiple ways. Each representation has its own
/// dialect. This message stores the metadata required for these representations.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ForeignViewDefinition {
    /// Required. The query that defines the view.
    pub query: std::string::String,

    /// Optional. Represents the dialect of the query.
    pub dialect: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ForeignViewDefinition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [query][crate::model::ForeignViewDefinition::query].
    pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query = v.into();
        self
    }

    /// Sets the value of [dialect][crate::model::ForeignViewDefinition::dialect].
    pub fn set_dialect<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dialect = v.into();
        self
    }
}

impl wkt::message::Message for ForeignViewDefinition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ForeignViewDefinition"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ForeignViewDefinition {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __query,
            __dialect,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ForeignViewDefinition")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "query" => Ok(__FieldTag::__query),
                            "dialect" => Ok(__FieldTag::__dialect),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ForeignViewDefinition;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ForeignViewDefinition")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__query => {
                            if !fields.insert(__FieldTag::__query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query",
                                ));
                            }
                            result.query = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dialect => {
                            if !fields.insert(__FieldTag::__dialect) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dialect",
                                ));
                            }
                            result.dialect = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ForeignViewDefinition {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.query.is_empty() {
            state.serialize_entry("query", &self.query)?;
        }
        if !self.dialect.is_empty() {
            state.serialize_entry("dialect", &self.dialect)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Definition and configuration of a materialized view.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct MaterializedViewDefinition {
    /// Required. A query whose results are persisted.
    pub query: std::string::String,

    /// Output only. The time when this materialized view was last refreshed, in
    /// milliseconds since the epoch.
    pub last_refresh_time: i64,

    /// Optional. Enable automatic refresh of the materialized view when the base
    /// table is updated. The default value is "true".
    pub enable_refresh: std::option::Option<wkt::BoolValue>,

    /// Optional. The maximum frequency at which this materialized view will be
    /// refreshed. The default value is "1800000" (30 minutes).
    pub refresh_interval_ms: std::option::Option<wkt::UInt64Value>,

    /// Optional. This option declares the intention to construct a materialized
    /// view that isn't refreshed incrementally. Non-incremental materialized views
    /// support an expanded range of SQL queries. The
    /// `allow_non_incremental_definition` option can't be changed after the
    /// materialized view is created.
    pub allow_non_incremental_definition: std::option::Option<wkt::BoolValue>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MaterializedViewDefinition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [query][crate::model::MaterializedViewDefinition::query].
    pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query = v.into();
        self
    }

    /// Sets the value of [last_refresh_time][crate::model::MaterializedViewDefinition::last_refresh_time].
    pub fn set_last_refresh_time<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.last_refresh_time = v.into();
        self
    }

    /// Sets the value of [enable_refresh][crate::model::MaterializedViewDefinition::enable_refresh].
    pub fn set_enable_refresh<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.enable_refresh = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_refresh][crate::model::MaterializedViewDefinition::enable_refresh].
    pub fn set_or_clear_enable_refresh<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.enable_refresh = v.map(|x| x.into());
        self
    }

    /// Sets the value of [refresh_interval_ms][crate::model::MaterializedViewDefinition::refresh_interval_ms].
    pub fn set_refresh_interval_ms<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::UInt64Value>,
    {
        self.refresh_interval_ms = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [refresh_interval_ms][crate::model::MaterializedViewDefinition::refresh_interval_ms].
    pub fn set_or_clear_refresh_interval_ms<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::UInt64Value>,
    {
        self.refresh_interval_ms = v.map(|x| x.into());
        self
    }

    /// Sets the value of [allow_non_incremental_definition][crate::model::MaterializedViewDefinition::allow_non_incremental_definition].
    pub fn set_allow_non_incremental_definition<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.allow_non_incremental_definition = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [allow_non_incremental_definition][crate::model::MaterializedViewDefinition::allow_non_incremental_definition].
    pub fn set_or_clear_allow_non_incremental_definition<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.allow_non_incremental_definition = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for MaterializedViewDefinition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.MaterializedViewDefinition"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MaterializedViewDefinition {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __query,
            __last_refresh_time,
            __enable_refresh,
            __refresh_interval_ms,
            __allow_non_incremental_definition,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MaterializedViewDefinition")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "query" => Ok(__FieldTag::__query),
                            "lastRefreshTime" => Ok(__FieldTag::__last_refresh_time),
                            "last_refresh_time" => Ok(__FieldTag::__last_refresh_time),
                            "enableRefresh" => Ok(__FieldTag::__enable_refresh),
                            "enable_refresh" => Ok(__FieldTag::__enable_refresh),
                            "refreshIntervalMs" => Ok(__FieldTag::__refresh_interval_ms),
                            "refresh_interval_ms" => Ok(__FieldTag::__refresh_interval_ms),
                            "allowNonIncrementalDefinition" => {
                                Ok(__FieldTag::__allow_non_incremental_definition)
                            }
                            "allow_non_incremental_definition" => {
                                Ok(__FieldTag::__allow_non_incremental_definition)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MaterializedViewDefinition;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MaterializedViewDefinition")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__query => {
                            if !fields.insert(__FieldTag::__query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query",
                                ));
                            }
                            result.query = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__last_refresh_time => {
                            if !fields.insert(__FieldTag::__last_refresh_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_refresh_time",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.last_refresh_time =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__enable_refresh => {
                            if !fields.insert(__FieldTag::__enable_refresh) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_refresh",
                                ));
                            }
                            result.enable_refresh =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__refresh_interval_ms => {
                            if !fields.insert(__FieldTag::__refresh_interval_ms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for refresh_interval_ms",
                                ));
                            }
                            struct __With(std::option::Option<wkt::UInt64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.refresh_interval_ms = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__allow_non_incremental_definition => {
                            if !fields.insert(__FieldTag::__allow_non_incremental_definition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_non_incremental_definition",
                                ));
                            }
                            result.allow_non_incremental_definition =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MaterializedViewDefinition {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.query.is_empty() {
            state.serialize_entry("query", &self.query)?;
        }
        if !wkt::internal::is_default(&self.last_refresh_time) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("lastRefreshTime", &__With(&self.last_refresh_time))?;
        }
        if self.enable_refresh.is_some() {
            state.serialize_entry("enableRefresh", &self.enable_refresh)?;
        }
        if self.refresh_interval_ms.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::UInt64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("refreshIntervalMs", &__With(&self.refresh_interval_ms))?;
        }
        if self.allow_non_incremental_definition.is_some() {
            state.serialize_entry(
                "allowNonIncrementalDefinition",
                &self.allow_non_incremental_definition,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Status of a materialized view.
/// The last refresh timestamp status is omitted here, but is present in the
/// MaterializedViewDefinition message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct MaterializedViewStatus {
    /// Output only. Refresh watermark of materialized view. The base tables' data
    /// were collected into the materialized view cache until this time.
    pub refresh_watermark: std::option::Option<wkt::Timestamp>,

    /// Output only. Error result of the last automatic refresh. If present,
    /// indicates that the last automatic refresh was unsuccessful.
    pub last_refresh_status: std::option::Option<crate::model::ErrorProto>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MaterializedViewStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [refresh_watermark][crate::model::MaterializedViewStatus::refresh_watermark].
    pub fn set_refresh_watermark<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.refresh_watermark = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [refresh_watermark][crate::model::MaterializedViewStatus::refresh_watermark].
    pub fn set_or_clear_refresh_watermark<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.refresh_watermark = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_refresh_status][crate::model::MaterializedViewStatus::last_refresh_status].
    pub fn set_last_refresh_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ErrorProto>,
    {
        self.last_refresh_status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_refresh_status][crate::model::MaterializedViewStatus::last_refresh_status].
    pub fn set_or_clear_last_refresh_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ErrorProto>,
    {
        self.last_refresh_status = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for MaterializedViewStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.MaterializedViewStatus"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MaterializedViewStatus {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __refresh_watermark,
            __last_refresh_status,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MaterializedViewStatus")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "refreshWatermark" => Ok(__FieldTag::__refresh_watermark),
                            "refresh_watermark" => Ok(__FieldTag::__refresh_watermark),
                            "lastRefreshStatus" => Ok(__FieldTag::__last_refresh_status),
                            "last_refresh_status" => Ok(__FieldTag::__last_refresh_status),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MaterializedViewStatus;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MaterializedViewStatus")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__refresh_watermark => {
                            if !fields.insert(__FieldTag::__refresh_watermark) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for refresh_watermark",
                                ));
                            }
                            result.refresh_watermark =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__last_refresh_status => {
                            if !fields.insert(__FieldTag::__last_refresh_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_refresh_status",
                                ));
                            }
                            result.last_refresh_status =
                                map.next_value::<std::option::Option<crate::model::ErrorProto>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MaterializedViewStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.refresh_watermark.is_some() {
            state.serialize_entry("refreshWatermark", &self.refresh_watermark)?;
        }
        if self.last_refresh_status.is_some() {
            state.serialize_entry("lastRefreshStatus", &self.last_refresh_status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Information about base table and snapshot time of the snapshot.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SnapshotDefinition {
    /// Required. Reference describing the ID of the table that was snapshot.
    pub base_table_reference: std::option::Option<crate::model::TableReference>,

    /// Required. The time at which the base table was snapshot. This value is
    /// reported in the JSON response using RFC3339 format.
    pub snapshot_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SnapshotDefinition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [base_table_reference][crate::model::SnapshotDefinition::base_table_reference].
    pub fn set_base_table_reference<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TableReference>,
    {
        self.base_table_reference = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [base_table_reference][crate::model::SnapshotDefinition::base_table_reference].
    pub fn set_or_clear_base_table_reference<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TableReference>,
    {
        self.base_table_reference = v.map(|x| x.into());
        self
    }

    /// Sets the value of [snapshot_time][crate::model::SnapshotDefinition::snapshot_time].
    pub fn set_snapshot_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.snapshot_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [snapshot_time][crate::model::SnapshotDefinition::snapshot_time].
    pub fn set_or_clear_snapshot_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.snapshot_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SnapshotDefinition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.SnapshotDefinition"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SnapshotDefinition {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __base_table_reference,
            __snapshot_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SnapshotDefinition")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "baseTableReference" => Ok(__FieldTag::__base_table_reference),
                            "base_table_reference" => Ok(__FieldTag::__base_table_reference),
                            "snapshotTime" => Ok(__FieldTag::__snapshot_time),
                            "snapshot_time" => Ok(__FieldTag::__snapshot_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SnapshotDefinition;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SnapshotDefinition")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__base_table_reference => {
                            if !fields.insert(__FieldTag::__base_table_reference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for base_table_reference",
                                ));
                            }
                            result.base_table_reference = map
                                .next_value::<std::option::Option<crate::model::TableReference>>(
                                )?;
                        }
                        __FieldTag::__snapshot_time => {
                            if !fields.insert(__FieldTag::__snapshot_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for snapshot_time",
                                ));
                            }
                            result.snapshot_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SnapshotDefinition {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.base_table_reference.is_some() {
            state.serialize_entry("baseTableReference", &self.base_table_reference)?;
        }
        if self.snapshot_time.is_some() {
            state.serialize_entry("snapshotTime", &self.snapshot_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Information about base table and clone time of a table clone.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CloneDefinition {
    /// Required. Reference describing the ID of the table that was cloned.
    pub base_table_reference: std::option::Option<crate::model::TableReference>,

    /// Required. The time at which the base table was cloned. This value is
    /// reported in the JSON response using RFC3339 format.
    pub clone_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloneDefinition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [base_table_reference][crate::model::CloneDefinition::base_table_reference].
    pub fn set_base_table_reference<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TableReference>,
    {
        self.base_table_reference = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [base_table_reference][crate::model::CloneDefinition::base_table_reference].
    pub fn set_or_clear_base_table_reference<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TableReference>,
    {
        self.base_table_reference = v.map(|x| x.into());
        self
    }

    /// Sets the value of [clone_time][crate::model::CloneDefinition::clone_time].
    pub fn set_clone_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.clone_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [clone_time][crate::model::CloneDefinition::clone_time].
    pub fn set_or_clear_clone_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.clone_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CloneDefinition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.CloneDefinition"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloneDefinition {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __base_table_reference,
            __clone_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloneDefinition")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "baseTableReference" => Ok(__FieldTag::__base_table_reference),
                            "base_table_reference" => Ok(__FieldTag::__base_table_reference),
                            "cloneTime" => Ok(__FieldTag::__clone_time),
                            "clone_time" => Ok(__FieldTag::__clone_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloneDefinition;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloneDefinition")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__base_table_reference => {
                            if !fields.insert(__FieldTag::__base_table_reference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for base_table_reference",
                                ));
                            }
                            result.base_table_reference = map
                                .next_value::<std::option::Option<crate::model::TableReference>>(
                                )?;
                        }
                        __FieldTag::__clone_time => {
                            if !fields.insert(__FieldTag::__clone_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for clone_time",
                                ));
                            }
                            result.clone_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloneDefinition {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.base_table_reference.is_some() {
            state.serialize_entry("baseTableReference", &self.base_table_reference)?;
        }
        if self.clone_time.is_some() {
            state.serialize_entry("cloneTime", &self.clone_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Streamingbuffer {
    /// Output only. A lower-bound estimate of the number of bytes currently in
    /// the streaming buffer.
    pub estimated_bytes: u64,

    /// Output only. A lower-bound estimate of the number of rows currently in the
    /// streaming buffer.
    pub estimated_rows: u64,

    /// Output only. Contains the timestamp of the oldest entry in the streaming
    /// buffer, in milliseconds since the epoch, if the streaming buffer is
    /// available.
    pub oldest_entry_time: u64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Streamingbuffer {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [estimated_bytes][crate::model::Streamingbuffer::estimated_bytes].
    pub fn set_estimated_bytes<T: std::convert::Into<u64>>(mut self, v: T) -> Self {
        self.estimated_bytes = v.into();
        self
    }

    /// Sets the value of [estimated_rows][crate::model::Streamingbuffer::estimated_rows].
    pub fn set_estimated_rows<T: std::convert::Into<u64>>(mut self, v: T) -> Self {
        self.estimated_rows = v.into();
        self
    }

    /// Sets the value of [oldest_entry_time][crate::model::Streamingbuffer::oldest_entry_time].
    pub fn set_oldest_entry_time<T: std::convert::Into<u64>>(mut self, v: T) -> Self {
        self.oldest_entry_time = v.into();
        self
    }
}

impl wkt::message::Message for Streamingbuffer {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.Streamingbuffer"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Streamingbuffer {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __estimated_bytes,
            __estimated_rows,
            __oldest_entry_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Streamingbuffer")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "estimatedBytes" => Ok(__FieldTag::__estimated_bytes),
                            "estimated_bytes" => Ok(__FieldTag::__estimated_bytes),
                            "estimatedRows" => Ok(__FieldTag::__estimated_rows),
                            "estimated_rows" => Ok(__FieldTag::__estimated_rows),
                            "oldestEntryTime" => Ok(__FieldTag::__oldest_entry_time),
                            "oldest_entry_time" => Ok(__FieldTag::__oldest_entry_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Streamingbuffer;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Streamingbuffer")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__estimated_bytes => {
                            if !fields.insert(__FieldTag::__estimated_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for estimated_bytes",
                                ));
                            }
                            struct __With(std::option::Option<u64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.estimated_bytes =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__estimated_rows => {
                            if !fields.insert(__FieldTag::__estimated_rows) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for estimated_rows",
                                ));
                            }
                            struct __With(std::option::Option<u64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.estimated_rows =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__oldest_entry_time => {
                            if !fields.insert(__FieldTag::__oldest_entry_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oldest_entry_time",
                                ));
                            }
                            struct __With(std::option::Option<u64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.oldest_entry_time =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Streamingbuffer {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.estimated_bytes) {
            struct __With<'a>(&'a u64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::U64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("estimatedBytes", &__With(&self.estimated_bytes))?;
        }
        if !wkt::internal::is_default(&self.estimated_rows) {
            struct __With<'a>(&'a u64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::U64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("estimatedRows", &__With(&self.estimated_rows))?;
        }
        if !wkt::internal::is_default(&self.oldest_entry_time) {
            struct __With<'a>(&'a u64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::U64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("oldestEntryTime", &__With(&self.oldest_entry_time))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Table {
    /// The type of resource ID.
    pub kind: std::string::String,

    /// Output only. A hash of this resource.
    pub etag: std::string::String,

    /// Output only. An opaque ID uniquely identifying the table.
    pub id: std::string::String,

    /// Output only. A URL that can be used to access this resource again.
    pub self_link: std::string::String,

    /// Required. Reference describing the ID of this table.
    pub table_reference: std::option::Option<crate::model::TableReference>,

    /// Optional. A descriptive name for this table.
    pub friendly_name: std::option::Option<wkt::StringValue>,

    /// Optional. A user-friendly description of this table.
    pub description: std::option::Option<wkt::StringValue>,

    /// The labels associated with this table. You can use these to organize and
    /// group your tables. Label keys and values can be no longer than 63
    /// characters, can only contain lowercase letters, numeric characters,
    /// underscores and dashes. International characters are allowed. Label values
    /// are optional. Label keys must start with a letter and each label in the
    /// list must have a different key.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Describes the schema of this table.
    pub schema: std::option::Option<crate::model::TableSchema>,

    /// If specified, configures time-based partitioning for this table.
    pub time_partitioning: std::option::Option<crate::model::TimePartitioning>,

    /// If specified, configures range partitioning for this table.
    pub range_partitioning: std::option::Option<crate::model::RangePartitioning>,

    /// Clustering specification for the table. Must be specified with time-based
    /// partitioning, data in the table will be first partitioned and subsequently
    /// clustered.
    pub clustering: std::option::Option<crate::model::Clustering>,

    /// Optional. If set to true, queries over this table require
    /// a partition filter that can be used for partition elimination to be
    /// specified.
    pub require_partition_filter: std::option::Option<wkt::BoolValue>,

    /// Optional. The partition information for all table formats, including
    /// managed partitioned tables, hive partitioned tables, iceberg partitioned,
    /// and metastore partitioned tables. This field is only populated for
    /// metastore partitioned tables. For other table formats, this is an output
    /// only field.
    pub partition_definition: std::option::Option<crate::model::PartitioningDefinition>,

    /// Output only. The size of this table in logical bytes, excluding any data in
    /// the streaming buffer.
    pub num_bytes: std::option::Option<wkt::Int64Value>,

    /// Output only. The physical size of this table in bytes. This includes
    /// storage used for time travel.
    pub num_physical_bytes: std::option::Option<wkt::Int64Value>,

    /// Output only. The number of logical bytes in the table that are considered
    /// "long-term storage".
    pub num_long_term_bytes: std::option::Option<wkt::Int64Value>,

    /// Output only. The number of rows of data in this table, excluding any data
    /// in the streaming buffer.
    pub num_rows: std::option::Option<wkt::UInt64Value>,

    /// Output only. The time when this table was created, in milliseconds since
    /// the epoch.
    pub creation_time: i64,

    /// Optional. The time when this table expires, in milliseconds since the
    /// epoch. If not present, the table will persist indefinitely. Expired tables
    /// will be deleted and their storage reclaimed.  The defaultTableExpirationMs
    /// property of the encapsulating dataset can be used to set a default
    /// expirationTime on newly created tables.
    pub expiration_time: std::option::Option<wkt::Int64Value>,

    /// Output only. The time when this table was last modified, in milliseconds
    /// since the epoch.
    pub last_modified_time: u64,

    /// Output only. Describes the table type. The following values are supported:
    ///
    /// * `TABLE`: A normal BigQuery table.
    /// * `VIEW`: A virtual table defined by a SQL query.
    /// * `EXTERNAL`: A table that references data stored in an external storage
    ///   system, such as Google Cloud Storage.
    /// * `MATERIALIZED_VIEW`: A precomputed view defined by a SQL query.
    /// * `SNAPSHOT`: An immutable BigQuery table that preserves the contents of a
    ///   base table at a particular time. See additional information on
    ///   [table
    ///   snapshots](https://cloud.google.com/bigquery/docs/table-snapshots-intro).
    ///
    /// The default value is `TABLE`.
    pub r#type: std::string::String,

    /// Optional. The view definition.
    pub view: std::option::Option<crate::model::ViewDefinition>,

    /// Optional. The materialized view definition.
    pub materialized_view: std::option::Option<crate::model::MaterializedViewDefinition>,

    /// Output only. The materialized view status.
    pub materialized_view_status: std::option::Option<crate::model::MaterializedViewStatus>,

    /// Optional. Describes the data format, location, and other properties of
    /// a table stored outside of BigQuery. By defining these properties, the data
    /// source can then be queried as if it were a standard BigQuery table.
    pub external_data_configuration: std::option::Option<crate::model::ExternalDataConfiguration>,

    /// Optional. Specifies the configuration of a BigQuery table for Apache
    /// Iceberg.
    pub biglake_configuration: std::option::Option<crate::model::BigLakeConfiguration>,

    /// Optional. If set, overrides the default managed table type configured in
    /// the dataset.
    pub managed_table_type: crate::model::ManagedTableType,

    /// Output only. The geographic location where the table resides. This value
    /// is inherited from the dataset.
    pub location: std::string::String,

    /// Output only. Contains information regarding this table's streaming buffer,
    /// if one is present. This field will be absent if the table is not being
    /// streamed to or if there is no data in the streaming buffer.
    pub streaming_buffer: std::option::Option<crate::model::Streamingbuffer>,

    /// Custom encryption configuration (e.g., Cloud KMS keys).
    pub encryption_configuration: std::option::Option<crate::model::EncryptionConfiguration>,

    /// Output only. Contains information about the snapshot. This value is set via
    /// snapshot creation.
    pub snapshot_definition: std::option::Option<crate::model::SnapshotDefinition>,

    /// Optional. Defines the default collation specification of new STRING fields
    /// in the table. During table creation or update, if a STRING field is added
    /// to this table without explicit collation specified, then the table inherits
    /// the table default collation. A change to this field affects only fields
    /// added afterwards, and does not alter the existing fields.
    /// The following values are supported:
    ///
    /// * 'und:ci': undetermined locale, case insensitive.
    /// * '': empty string. Default to case-sensitive behavior.
    pub default_collation: std::option::Option<wkt::StringValue>,

    /// Optional. Defines the default rounding mode specification of new decimal
    /// fields (NUMERIC OR BIGNUMERIC) in the table. During table creation or
    /// update, if a decimal field is added to this table without an explicit
    /// rounding mode specified, then the field inherits the table default
    /// rounding mode. Changing this field doesn't affect existing fields.
    pub default_rounding_mode: crate::model::table_field_schema::RoundingMode,

    /// Output only. Contains information about the clone. This value is set via
    /// the clone operation.
    pub clone_definition: std::option::Option<crate::model::CloneDefinition>,

    /// Output only. Number of physical bytes used by time travel storage (deleted
    /// or changed data). This data is not kept in real time, and might be delayed
    /// by a few seconds to a few minutes.
    pub num_time_travel_physical_bytes: std::option::Option<wkt::Int64Value>,

    /// Output only. Total number of logical bytes in the table or materialized
    /// view.
    pub num_total_logical_bytes: std::option::Option<wkt::Int64Value>,

    /// Output only. Number of logical bytes that are less than 90 days old.
    pub num_active_logical_bytes: std::option::Option<wkt::Int64Value>,

    /// Output only. Number of logical bytes that are more than 90 days old.
    pub num_long_term_logical_bytes: std::option::Option<wkt::Int64Value>,

    /// Output only. Number of physical bytes used by current live data storage.
    /// This data is not kept in real time, and might be delayed by a few seconds
    /// to a few minutes.
    pub num_current_physical_bytes: std::option::Option<wkt::Int64Value>,

    /// Output only. The physical size of this table in bytes. This also includes
    /// storage used for time travel. This data is not kept in real time, and might
    /// be delayed by a few seconds to a few minutes.
    pub num_total_physical_bytes: std::option::Option<wkt::Int64Value>,

    /// Output only. Number of physical bytes less than 90 days old. This data is
    /// not kept in real time, and might be delayed by a few seconds to a few
    /// minutes.
    pub num_active_physical_bytes: std::option::Option<wkt::Int64Value>,

    /// Output only. Number of physical bytes more than 90 days old.
    /// This data is not kept in real time, and might be delayed by a few seconds
    /// to a few minutes.
    pub num_long_term_physical_bytes: std::option::Option<wkt::Int64Value>,

    /// Output only. The number of partitions present in the table or materialized
    /// view. This data is not kept in real time, and might be delayed by a few
    /// seconds to a few minutes.
    pub num_partitions: std::option::Option<wkt::Int64Value>,

    /// Optional. The maximum staleness of data that could be returned when the
    /// table (or stale MV) is queried. Staleness encoded as a string encoding
    /// of sql IntervalValue type.
    pub max_staleness: std::string::String,

    /// Optional. Output only. Restriction config for table. If set, restrict
    /// certain accesses on the table based on the config. See [Data
    /// egress](https://cloud.google.com/bigquery/docs/analytics-hub-introduction#data_egress)
    /// for more details.
    pub restrictions: std::option::Option<crate::model::RestrictionConfig>,

    /// Optional. Tables Primary Key and Foreign Key information
    pub table_constraints: std::option::Option<crate::model::TableConstraints>,

    /// Optional. The [tags](https://cloud.google.com/bigquery/docs/tags) attached
    /// to this table. Tag keys are globally unique. Tag key is expected to be in
    /// the namespaced format, for example "123456789012/environment" where
    /// 123456789012 is the ID of the parent organization or project resource for
    /// this tag key. Tag value is expected to be the short name, for example
    /// "Production". See [Tag
    /// definitions](https://cloud.google.com/iam/docs/tags-access-control#definitions)
    /// for more details.
    pub resource_tags: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Table replication info for table created `AS REPLICA` DDL like:
    /// `CREATE MATERIALIZED VIEW mv1 AS REPLICA OF src_mv`
    pub table_replication_info: std::option::Option<crate::model::TableReplicationInfo>,

    /// Optional. Output only. Table references of all replicas currently active on
    /// the table.
    pub replicas: std::vec::Vec<crate::model::TableReference>,

    /// Optional. Options defining open source compatible table.
    pub external_catalog_table_options:
        std::option::Option<crate::model::ExternalCatalogTableOptions>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Table {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::Table::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Table::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Table::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [self_link][crate::model::Table::self_link].
    pub fn set_self_link<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.self_link = v.into();
        self
    }

    /// Sets the value of [table_reference][crate::model::Table::table_reference].
    pub fn set_table_reference<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TableReference>,
    {
        self.table_reference = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [table_reference][crate::model::Table::table_reference].
    pub fn set_or_clear_table_reference<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TableReference>,
    {
        self.table_reference = v.map(|x| x.into());
        self
    }

    /// Sets the value of [friendly_name][crate::model::Table::friendly_name].
    pub fn set_friendly_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.friendly_name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [friendly_name][crate::model::Table::friendly_name].
    pub fn set_or_clear_friendly_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.friendly_name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::Table::description].
    pub fn set_description<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.description = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [description][crate::model::Table::description].
    pub fn set_or_clear_description<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.description = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Table::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [schema][crate::model::Table::schema].
    pub fn set_schema<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TableSchema>,
    {
        self.schema = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [schema][crate::model::Table::schema].
    pub fn set_or_clear_schema<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TableSchema>,
    {
        self.schema = v.map(|x| x.into());
        self
    }

    /// Sets the value of [time_partitioning][crate::model::Table::time_partitioning].
    pub fn set_time_partitioning<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TimePartitioning>,
    {
        self.time_partitioning = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [time_partitioning][crate::model::Table::time_partitioning].
    pub fn set_or_clear_time_partitioning<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TimePartitioning>,
    {
        self.time_partitioning = v.map(|x| x.into());
        self
    }

    /// Sets the value of [range_partitioning][crate::model::Table::range_partitioning].
    pub fn set_range_partitioning<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RangePartitioning>,
    {
        self.range_partitioning = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [range_partitioning][crate::model::Table::range_partitioning].
    pub fn set_or_clear_range_partitioning<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RangePartitioning>,
    {
        self.range_partitioning = v.map(|x| x.into());
        self
    }

    /// Sets the value of [clustering][crate::model::Table::clustering].
    pub fn set_clustering<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Clustering>,
    {
        self.clustering = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [clustering][crate::model::Table::clustering].
    pub fn set_or_clear_clustering<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Clustering>,
    {
        self.clustering = v.map(|x| x.into());
        self
    }

    /// Sets the value of [require_partition_filter][crate::model::Table::require_partition_filter].
    pub fn set_require_partition_filter<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.require_partition_filter = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [require_partition_filter][crate::model::Table::require_partition_filter].
    pub fn set_or_clear_require_partition_filter<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.require_partition_filter = v.map(|x| x.into());
        self
    }

    /// Sets the value of [partition_definition][crate::model::Table::partition_definition].
    pub fn set_partition_definition<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PartitioningDefinition>,
    {
        self.partition_definition = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [partition_definition][crate::model::Table::partition_definition].
    pub fn set_or_clear_partition_definition<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PartitioningDefinition>,
    {
        self.partition_definition = v.map(|x| x.into());
        self
    }

    /// Sets the value of [num_bytes][crate::model::Table::num_bytes].
    pub fn set_num_bytes<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.num_bytes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [num_bytes][crate::model::Table::num_bytes].
    pub fn set_or_clear_num_bytes<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.num_bytes = v.map(|x| x.into());
        self
    }

    /// Sets the value of [num_physical_bytes][crate::model::Table::num_physical_bytes].
    pub fn set_num_physical_bytes<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.num_physical_bytes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [num_physical_bytes][crate::model::Table::num_physical_bytes].
    pub fn set_or_clear_num_physical_bytes<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.num_physical_bytes = v.map(|x| x.into());
        self
    }

    /// Sets the value of [num_long_term_bytes][crate::model::Table::num_long_term_bytes].
    pub fn set_num_long_term_bytes<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.num_long_term_bytes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [num_long_term_bytes][crate::model::Table::num_long_term_bytes].
    pub fn set_or_clear_num_long_term_bytes<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.num_long_term_bytes = v.map(|x| x.into());
        self
    }

    /// Sets the value of [num_rows][crate::model::Table::num_rows].
    pub fn set_num_rows<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::UInt64Value>,
    {
        self.num_rows = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [num_rows][crate::model::Table::num_rows].
    pub fn set_or_clear_num_rows<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::UInt64Value>,
    {
        self.num_rows = v.map(|x| x.into());
        self
    }

    /// Sets the value of [creation_time][crate::model::Table::creation_time].
    pub fn set_creation_time<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.creation_time = v.into();
        self
    }

    /// Sets the value of [expiration_time][crate::model::Table::expiration_time].
    pub fn set_expiration_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.expiration_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expiration_time][crate::model::Table::expiration_time].
    pub fn set_or_clear_expiration_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.expiration_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_modified_time][crate::model::Table::last_modified_time].
    pub fn set_last_modified_time<T: std::convert::Into<u64>>(mut self, v: T) -> Self {
        self.last_modified_time = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::Table::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [view][crate::model::Table::view].
    pub fn set_view<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ViewDefinition>,
    {
        self.view = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [view][crate::model::Table::view].
    pub fn set_or_clear_view<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ViewDefinition>,
    {
        self.view = v.map(|x| x.into());
        self
    }

    /// Sets the value of [materialized_view][crate::model::Table::materialized_view].
    pub fn set_materialized_view<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MaterializedViewDefinition>,
    {
        self.materialized_view = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [materialized_view][crate::model::Table::materialized_view].
    pub fn set_or_clear_materialized_view<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MaterializedViewDefinition>,
    {
        self.materialized_view = v.map(|x| x.into());
        self
    }

    /// Sets the value of [materialized_view_status][crate::model::Table::materialized_view_status].
    pub fn set_materialized_view_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MaterializedViewStatus>,
    {
        self.materialized_view_status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [materialized_view_status][crate::model::Table::materialized_view_status].
    pub fn set_or_clear_materialized_view_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MaterializedViewStatus>,
    {
        self.materialized_view_status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [external_data_configuration][crate::model::Table::external_data_configuration].
    pub fn set_external_data_configuration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ExternalDataConfiguration>,
    {
        self.external_data_configuration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [external_data_configuration][crate::model::Table::external_data_configuration].
    pub fn set_or_clear_external_data_configuration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ExternalDataConfiguration>,
    {
        self.external_data_configuration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [biglake_configuration][crate::model::Table::biglake_configuration].
    pub fn set_biglake_configuration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BigLakeConfiguration>,
    {
        self.biglake_configuration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [biglake_configuration][crate::model::Table::biglake_configuration].
    pub fn set_or_clear_biglake_configuration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BigLakeConfiguration>,
    {
        self.biglake_configuration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [managed_table_type][crate::model::Table::managed_table_type].
    pub fn set_managed_table_type<T: std::convert::Into<crate::model::ManagedTableType>>(
        mut self,
        v: T,
    ) -> Self {
        self.managed_table_type = v.into();
        self
    }

    /// Sets the value of [location][crate::model::Table::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [streaming_buffer][crate::model::Table::streaming_buffer].
    pub fn set_streaming_buffer<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Streamingbuffer>,
    {
        self.streaming_buffer = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [streaming_buffer][crate::model::Table::streaming_buffer].
    pub fn set_or_clear_streaming_buffer<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Streamingbuffer>,
    {
        self.streaming_buffer = v.map(|x| x.into());
        self
    }

    /// Sets the value of [encryption_configuration][crate::model::Table::encryption_configuration].
    pub fn set_encryption_configuration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionConfiguration>,
    {
        self.encryption_configuration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [encryption_configuration][crate::model::Table::encryption_configuration].
    pub fn set_or_clear_encryption_configuration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionConfiguration>,
    {
        self.encryption_configuration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [snapshot_definition][crate::model::Table::snapshot_definition].
    pub fn set_snapshot_definition<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SnapshotDefinition>,
    {
        self.snapshot_definition = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [snapshot_definition][crate::model::Table::snapshot_definition].
    pub fn set_or_clear_snapshot_definition<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SnapshotDefinition>,
    {
        self.snapshot_definition = v.map(|x| x.into());
        self
    }

    /// Sets the value of [default_collation][crate::model::Table::default_collation].
    pub fn set_default_collation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.default_collation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [default_collation][crate::model::Table::default_collation].
    pub fn set_or_clear_default_collation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.default_collation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [default_rounding_mode][crate::model::Table::default_rounding_mode].
    pub fn set_default_rounding_mode<
        T: std::convert::Into<crate::model::table_field_schema::RoundingMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.default_rounding_mode = v.into();
        self
    }

    /// Sets the value of [clone_definition][crate::model::Table::clone_definition].
    pub fn set_clone_definition<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CloneDefinition>,
    {
        self.clone_definition = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [clone_definition][crate::model::Table::clone_definition].
    pub fn set_or_clear_clone_definition<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CloneDefinition>,
    {
        self.clone_definition = v.map(|x| x.into());
        self
    }

    /// Sets the value of [num_time_travel_physical_bytes][crate::model::Table::num_time_travel_physical_bytes].
    pub fn set_num_time_travel_physical_bytes<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.num_time_travel_physical_bytes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [num_time_travel_physical_bytes][crate::model::Table::num_time_travel_physical_bytes].
    pub fn set_or_clear_num_time_travel_physical_bytes<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.num_time_travel_physical_bytes = v.map(|x| x.into());
        self
    }

    /// Sets the value of [num_total_logical_bytes][crate::model::Table::num_total_logical_bytes].
    pub fn set_num_total_logical_bytes<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.num_total_logical_bytes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [num_total_logical_bytes][crate::model::Table::num_total_logical_bytes].
    pub fn set_or_clear_num_total_logical_bytes<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.num_total_logical_bytes = v.map(|x| x.into());
        self
    }

    /// Sets the value of [num_active_logical_bytes][crate::model::Table::num_active_logical_bytes].
    pub fn set_num_active_logical_bytes<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.num_active_logical_bytes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [num_active_logical_bytes][crate::model::Table::num_active_logical_bytes].
    pub fn set_or_clear_num_active_logical_bytes<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.num_active_logical_bytes = v.map(|x| x.into());
        self
    }

    /// Sets the value of [num_long_term_logical_bytes][crate::model::Table::num_long_term_logical_bytes].
    pub fn set_num_long_term_logical_bytes<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.num_long_term_logical_bytes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [num_long_term_logical_bytes][crate::model::Table::num_long_term_logical_bytes].
    pub fn set_or_clear_num_long_term_logical_bytes<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.num_long_term_logical_bytes = v.map(|x| x.into());
        self
    }

    /// Sets the value of [num_current_physical_bytes][crate::model::Table::num_current_physical_bytes].
    pub fn set_num_current_physical_bytes<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.num_current_physical_bytes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [num_current_physical_bytes][crate::model::Table::num_current_physical_bytes].
    pub fn set_or_clear_num_current_physical_bytes<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.num_current_physical_bytes = v.map(|x| x.into());
        self
    }

    /// Sets the value of [num_total_physical_bytes][crate::model::Table::num_total_physical_bytes].
    pub fn set_num_total_physical_bytes<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.num_total_physical_bytes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [num_total_physical_bytes][crate::model::Table::num_total_physical_bytes].
    pub fn set_or_clear_num_total_physical_bytes<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.num_total_physical_bytes = v.map(|x| x.into());
        self
    }

    /// Sets the value of [num_active_physical_bytes][crate::model::Table::num_active_physical_bytes].
    pub fn set_num_active_physical_bytes<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.num_active_physical_bytes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [num_active_physical_bytes][crate::model::Table::num_active_physical_bytes].
    pub fn set_or_clear_num_active_physical_bytes<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.num_active_physical_bytes = v.map(|x| x.into());
        self
    }

    /// Sets the value of [num_long_term_physical_bytes][crate::model::Table::num_long_term_physical_bytes].
    pub fn set_num_long_term_physical_bytes<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.num_long_term_physical_bytes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [num_long_term_physical_bytes][crate::model::Table::num_long_term_physical_bytes].
    pub fn set_or_clear_num_long_term_physical_bytes<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.num_long_term_physical_bytes = v.map(|x| x.into());
        self
    }

    /// Sets the value of [num_partitions][crate::model::Table::num_partitions].
    pub fn set_num_partitions<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.num_partitions = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [num_partitions][crate::model::Table::num_partitions].
    pub fn set_or_clear_num_partitions<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.num_partitions = v.map(|x| x.into());
        self
    }

    /// Sets the value of [max_staleness][crate::model::Table::max_staleness].
    pub fn set_max_staleness<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.max_staleness = v.into();
        self
    }

    /// Sets the value of [restrictions][crate::model::Table::restrictions].
    pub fn set_restrictions<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RestrictionConfig>,
    {
        self.restrictions = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [restrictions][crate::model::Table::restrictions].
    pub fn set_or_clear_restrictions<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RestrictionConfig>,
    {
        self.restrictions = v.map(|x| x.into());
        self
    }

    /// Sets the value of [table_constraints][crate::model::Table::table_constraints].
    pub fn set_table_constraints<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TableConstraints>,
    {
        self.table_constraints = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [table_constraints][crate::model::Table::table_constraints].
    pub fn set_or_clear_table_constraints<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TableConstraints>,
    {
        self.table_constraints = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resource_tags][crate::model::Table::resource_tags].
    pub fn set_resource_tags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_tags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [table_replication_info][crate::model::Table::table_replication_info].
    pub fn set_table_replication_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TableReplicationInfo>,
    {
        self.table_replication_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [table_replication_info][crate::model::Table::table_replication_info].
    pub fn set_or_clear_table_replication_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TableReplicationInfo>,
    {
        self.table_replication_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [replicas][crate::model::Table::replicas].
    pub fn set_replicas<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TableReference>,
    {
        use std::iter::Iterator;
        self.replicas = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [external_catalog_table_options][crate::model::Table::external_catalog_table_options].
    pub fn set_external_catalog_table_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ExternalCatalogTableOptions>,
    {
        self.external_catalog_table_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [external_catalog_table_options][crate::model::Table::external_catalog_table_options].
    pub fn set_or_clear_external_catalog_table_options<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::ExternalCatalogTableOptions>,
    {
        self.external_catalog_table_options = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Table {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.Table"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Table {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __etag,
            __id,
            __self_link,
            __table_reference,
            __friendly_name,
            __description,
            __labels,
            __schema,
            __time_partitioning,
            __range_partitioning,
            __clustering,
            __require_partition_filter,
            __partition_definition,
            __num_bytes,
            __num_physical_bytes,
            __num_long_term_bytes,
            __num_rows,
            __creation_time,
            __expiration_time,
            __last_modified_time,
            __type,
            __view,
            __materialized_view,
            __materialized_view_status,
            __external_data_configuration,
            __biglake_configuration,
            __managed_table_type,
            __location,
            __streaming_buffer,
            __encryption_configuration,
            __snapshot_definition,
            __default_collation,
            __default_rounding_mode,
            __clone_definition,
            __num_time_travel_physical_bytes,
            __num_total_logical_bytes,
            __num_active_logical_bytes,
            __num_long_term_logical_bytes,
            __num_current_physical_bytes,
            __num_total_physical_bytes,
            __num_active_physical_bytes,
            __num_long_term_physical_bytes,
            __num_partitions,
            __max_staleness,
            __restrictions,
            __table_constraints,
            __resource_tags,
            __table_replication_info,
            __replicas,
            __external_catalog_table_options,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Table")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "etag" => Ok(__FieldTag::__etag),
                            "id" => Ok(__FieldTag::__id),
                            "selfLink" => Ok(__FieldTag::__self_link),
                            "self_link" => Ok(__FieldTag::__self_link),
                            "tableReference" => Ok(__FieldTag::__table_reference),
                            "table_reference" => Ok(__FieldTag::__table_reference),
                            "friendlyName" => Ok(__FieldTag::__friendly_name),
                            "friendly_name" => Ok(__FieldTag::__friendly_name),
                            "description" => Ok(__FieldTag::__description),
                            "labels" => Ok(__FieldTag::__labels),
                            "schema" => Ok(__FieldTag::__schema),
                            "timePartitioning" => Ok(__FieldTag::__time_partitioning),
                            "time_partitioning" => Ok(__FieldTag::__time_partitioning),
                            "rangePartitioning" => Ok(__FieldTag::__range_partitioning),
                            "range_partitioning" => Ok(__FieldTag::__range_partitioning),
                            "clustering" => Ok(__FieldTag::__clustering),
                            "requirePartitionFilter" => Ok(__FieldTag::__require_partition_filter),
                            "require_partition_filter" => {
                                Ok(__FieldTag::__require_partition_filter)
                            }
                            "partitionDefinition" => Ok(__FieldTag::__partition_definition),
                            "partition_definition" => Ok(__FieldTag::__partition_definition),
                            "numBytes" => Ok(__FieldTag::__num_bytes),
                            "num_bytes" => Ok(__FieldTag::__num_bytes),
                            "numPhysicalBytes" => Ok(__FieldTag::__num_physical_bytes),
                            "num_physical_bytes" => Ok(__FieldTag::__num_physical_bytes),
                            "numLongTermBytes" => Ok(__FieldTag::__num_long_term_bytes),
                            "num_long_term_bytes" => Ok(__FieldTag::__num_long_term_bytes),
                            "numRows" => Ok(__FieldTag::__num_rows),
                            "num_rows" => Ok(__FieldTag::__num_rows),
                            "creationTime" => Ok(__FieldTag::__creation_time),
                            "creation_time" => Ok(__FieldTag::__creation_time),
                            "expirationTime" => Ok(__FieldTag::__expiration_time),
                            "expiration_time" => Ok(__FieldTag::__expiration_time),
                            "lastModifiedTime" => Ok(__FieldTag::__last_modified_time),
                            "last_modified_time" => Ok(__FieldTag::__last_modified_time),
                            "type" => Ok(__FieldTag::__type),
                            "view" => Ok(__FieldTag::__view),
                            "materializedView" => Ok(__FieldTag::__materialized_view),
                            "materialized_view" => Ok(__FieldTag::__materialized_view),
                            "materializedViewStatus" => Ok(__FieldTag::__materialized_view_status),
                            "materialized_view_status" => {
                                Ok(__FieldTag::__materialized_view_status)
                            }
                            "externalDataConfiguration" => {
                                Ok(__FieldTag::__external_data_configuration)
                            }
                            "external_data_configuration" => {
                                Ok(__FieldTag::__external_data_configuration)
                            }
                            "biglakeConfiguration" => Ok(__FieldTag::__biglake_configuration),
                            "biglake_configuration" => Ok(__FieldTag::__biglake_configuration),
                            "managedTableType" => Ok(__FieldTag::__managed_table_type),
                            "managed_table_type" => Ok(__FieldTag::__managed_table_type),
                            "location" => Ok(__FieldTag::__location),
                            "streamingBuffer" => Ok(__FieldTag::__streaming_buffer),
                            "streaming_buffer" => Ok(__FieldTag::__streaming_buffer),
                            "encryptionConfiguration" => Ok(__FieldTag::__encryption_configuration),
                            "encryption_configuration" => {
                                Ok(__FieldTag::__encryption_configuration)
                            }
                            "snapshotDefinition" => Ok(__FieldTag::__snapshot_definition),
                            "snapshot_definition" => Ok(__FieldTag::__snapshot_definition),
                            "defaultCollation" => Ok(__FieldTag::__default_collation),
                            "default_collation" => Ok(__FieldTag::__default_collation),
                            "defaultRoundingMode" => Ok(__FieldTag::__default_rounding_mode),
                            "default_rounding_mode" => Ok(__FieldTag::__default_rounding_mode),
                            "cloneDefinition" => Ok(__FieldTag::__clone_definition),
                            "clone_definition" => Ok(__FieldTag::__clone_definition),
                            "numTimeTravelPhysicalBytes" => {
                                Ok(__FieldTag::__num_time_travel_physical_bytes)
                            }
                            "num_time_travel_physical_bytes" => {
                                Ok(__FieldTag::__num_time_travel_physical_bytes)
                            }
                            "numTotalLogicalBytes" => Ok(__FieldTag::__num_total_logical_bytes),
                            "num_total_logical_bytes" => Ok(__FieldTag::__num_total_logical_bytes),
                            "numActiveLogicalBytes" => Ok(__FieldTag::__num_active_logical_bytes),
                            "num_active_logical_bytes" => {
                                Ok(__FieldTag::__num_active_logical_bytes)
                            }
                            "numLongTermLogicalBytes" => {
                                Ok(__FieldTag::__num_long_term_logical_bytes)
                            }
                            "num_long_term_logical_bytes" => {
                                Ok(__FieldTag::__num_long_term_logical_bytes)
                            }
                            "numCurrentPhysicalBytes" => {
                                Ok(__FieldTag::__num_current_physical_bytes)
                            }
                            "num_current_physical_bytes" => {
                                Ok(__FieldTag::__num_current_physical_bytes)
                            }
                            "numTotalPhysicalBytes" => Ok(__FieldTag::__num_total_physical_bytes),
                            "num_total_physical_bytes" => {
                                Ok(__FieldTag::__num_total_physical_bytes)
                            }
                            "numActivePhysicalBytes" => Ok(__FieldTag::__num_active_physical_bytes),
                            "num_active_physical_bytes" => {
                                Ok(__FieldTag::__num_active_physical_bytes)
                            }
                            "numLongTermPhysicalBytes" => {
                                Ok(__FieldTag::__num_long_term_physical_bytes)
                            }
                            "num_long_term_physical_bytes" => {
                                Ok(__FieldTag::__num_long_term_physical_bytes)
                            }
                            "numPartitions" => Ok(__FieldTag::__num_partitions),
                            "num_partitions" => Ok(__FieldTag::__num_partitions),
                            "maxStaleness" => Ok(__FieldTag::__max_staleness),
                            "max_staleness" => Ok(__FieldTag::__max_staleness),
                            "restrictions" => Ok(__FieldTag::__restrictions),
                            "tableConstraints" => Ok(__FieldTag::__table_constraints),
                            "table_constraints" => Ok(__FieldTag::__table_constraints),
                            "resourceTags" => Ok(__FieldTag::__resource_tags),
                            "resource_tags" => Ok(__FieldTag::__resource_tags),
                            "tableReplicationInfo" => Ok(__FieldTag::__table_replication_info),
                            "table_replication_info" => Ok(__FieldTag::__table_replication_info),
                            "replicas" => Ok(__FieldTag::__replicas),
                            "externalCatalogTableOptions" => {
                                Ok(__FieldTag::__external_catalog_table_options)
                            }
                            "external_catalog_table_options" => {
                                Ok(__FieldTag::__external_catalog_table_options)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Table;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Table")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__self_link => {
                            if !fields.insert(__FieldTag::__self_link) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for self_link",
                                ));
                            }
                            result.self_link = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table_reference => {
                            if !fields.insert(__FieldTag::__table_reference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_reference",
                                ));
                            }
                            result.table_reference = map
                                .next_value::<std::option::Option<crate::model::TableReference>>(
                                )?;
                        }
                        __FieldTag::__friendly_name => {
                            if !fields.insert(__FieldTag::__friendly_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for friendly_name",
                                ));
                            }
                            result.friendly_name =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__schema => {
                            if !fields.insert(__FieldTag::__schema) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schema",
                                ));
                            }
                            result.schema =
                                map.next_value::<std::option::Option<crate::model::TableSchema>>()?;
                        }
                        __FieldTag::__time_partitioning => {
                            if !fields.insert(__FieldTag::__time_partitioning) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_partitioning",
                                ));
                            }
                            result.time_partitioning = map
                                .next_value::<std::option::Option<crate::model::TimePartitioning>>(
                                )?;
                        }
                        __FieldTag::__range_partitioning => {
                            if !fields.insert(__FieldTag::__range_partitioning) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for range_partitioning",
                                ));
                            }
                            result.range_partitioning = map
                                .next_value::<std::option::Option<crate::model::RangePartitioning>>(
                                )?;
                        }
                        __FieldTag::__clustering => {
                            if !fields.insert(__FieldTag::__clustering) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for clustering",
                                ));
                            }
                            result.clustering =
                                map.next_value::<std::option::Option<crate::model::Clustering>>()?;
                        }
                        __FieldTag::__require_partition_filter => {
                            if !fields.insert(__FieldTag::__require_partition_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for require_partition_filter",
                                ));
                            }
                            result.require_partition_filter =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__partition_definition => {
                            if !fields.insert(__FieldTag::__partition_definition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for partition_definition",
                                ));
                            }
                            result.partition_definition = map.next_value::<std::option::Option<crate::model::PartitioningDefinition>>()?
                                ;
                        }
                        __FieldTag::__num_bytes => {
                            if !fields.insert(__FieldTag::__num_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for num_bytes",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.num_bytes = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__num_physical_bytes => {
                            if !fields.insert(__FieldTag::__num_physical_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for num_physical_bytes",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.num_physical_bytes = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__num_long_term_bytes => {
                            if !fields.insert(__FieldTag::__num_long_term_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for num_long_term_bytes",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.num_long_term_bytes = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__num_rows => {
                            if !fields.insert(__FieldTag::__num_rows) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for num_rows",
                                ));
                            }
                            struct __With(std::option::Option<wkt::UInt64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.num_rows = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__creation_time => {
                            if !fields.insert(__FieldTag::__creation_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for creation_time",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.creation_time =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__expiration_time => {
                            if !fields.insert(__FieldTag::__expiration_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expiration_time",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.expiration_time = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__last_modified_time => {
                            if !fields.insert(__FieldTag::__last_modified_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_modified_time",
                                ));
                            }
                            struct __With(std::option::Option<u64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.last_modified_time =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<crate::model::ViewDefinition>>(
                                )?;
                        }
                        __FieldTag::__materialized_view => {
                            if !fields.insert(__FieldTag::__materialized_view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for materialized_view",
                                ));
                            }
                            result.materialized_view = map.next_value::<std::option::Option<crate::model::MaterializedViewDefinition>>()?
                                ;
                        }
                        __FieldTag::__materialized_view_status => {
                            if !fields.insert(__FieldTag::__materialized_view_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for materialized_view_status",
                                ));
                            }
                            result.materialized_view_status = map.next_value::<std::option::Option<crate::model::MaterializedViewStatus>>()?
                                ;
                        }
                        __FieldTag::__external_data_configuration => {
                            if !fields.insert(__FieldTag::__external_data_configuration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_data_configuration",
                                ));
                            }
                            result.external_data_configuration = map.next_value::<std::option::Option<crate::model::ExternalDataConfiguration>>()?
                                ;
                        }
                        __FieldTag::__biglake_configuration => {
                            if !fields.insert(__FieldTag::__biglake_configuration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for biglake_configuration",
                                ));
                            }
                            result.biglake_configuration = map.next_value::<std::option::Option<crate::model::BigLakeConfiguration>>()?
                                ;
                        }
                        __FieldTag::__managed_table_type => {
                            if !fields.insert(__FieldTag::__managed_table_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for managed_table_type",
                                ));
                            }
                            result.managed_table_type = map
                                .next_value::<std::option::Option<crate::model::ManagedTableType>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__streaming_buffer => {
                            if !fields.insert(__FieldTag::__streaming_buffer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for streaming_buffer",
                                ));
                            }
                            result.streaming_buffer = map
                                .next_value::<std::option::Option<crate::model::Streamingbuffer>>(
                                )?;
                        }
                        __FieldTag::__encryption_configuration => {
                            if !fields.insert(__FieldTag::__encryption_configuration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption_configuration",
                                ));
                            }
                            result.encryption_configuration = map.next_value::<std::option::Option<crate::model::EncryptionConfiguration>>()?
                                ;
                        }
                        __FieldTag::__snapshot_definition => {
                            if !fields.insert(__FieldTag::__snapshot_definition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for snapshot_definition",
                                ));
                            }
                            result.snapshot_definition = map.next_value::<std::option::Option<crate::model::SnapshotDefinition>>()?
                                ;
                        }
                        __FieldTag::__default_collation => {
                            if !fields.insert(__FieldTag::__default_collation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_collation",
                                ));
                            }
                            result.default_collation =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::__default_rounding_mode => {
                            if !fields.insert(__FieldTag::__default_rounding_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_rounding_mode",
                                ));
                            }
                            result.default_rounding_mode =
                                map.next_value::<std::option::Option<
                                    crate::model::table_field_schema::RoundingMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__clone_definition => {
                            if !fields.insert(__FieldTag::__clone_definition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for clone_definition",
                                ));
                            }
                            result.clone_definition = map
                                .next_value::<std::option::Option<crate::model::CloneDefinition>>(
                                )?;
                        }
                        __FieldTag::__num_time_travel_physical_bytes => {
                            if !fields.insert(__FieldTag::__num_time_travel_physical_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for num_time_travel_physical_bytes",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.num_time_travel_physical_bytes = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__num_total_logical_bytes => {
                            if !fields.insert(__FieldTag::__num_total_logical_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for num_total_logical_bytes",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.num_total_logical_bytes = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__num_active_logical_bytes => {
                            if !fields.insert(__FieldTag::__num_active_logical_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for num_active_logical_bytes",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.num_active_logical_bytes = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__num_long_term_logical_bytes => {
                            if !fields.insert(__FieldTag::__num_long_term_logical_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for num_long_term_logical_bytes",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.num_long_term_logical_bytes = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__num_current_physical_bytes => {
                            if !fields.insert(__FieldTag::__num_current_physical_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for num_current_physical_bytes",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.num_current_physical_bytes = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__num_total_physical_bytes => {
                            if !fields.insert(__FieldTag::__num_total_physical_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for num_total_physical_bytes",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.num_total_physical_bytes = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__num_active_physical_bytes => {
                            if !fields.insert(__FieldTag::__num_active_physical_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for num_active_physical_bytes",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.num_active_physical_bytes = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__num_long_term_physical_bytes => {
                            if !fields.insert(__FieldTag::__num_long_term_physical_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for num_long_term_physical_bytes",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.num_long_term_physical_bytes = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__num_partitions => {
                            if !fields.insert(__FieldTag::__num_partitions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for num_partitions",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.num_partitions = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__max_staleness => {
                            if !fields.insert(__FieldTag::__max_staleness) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_staleness",
                                ));
                            }
                            result.max_staleness = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__restrictions => {
                            if !fields.insert(__FieldTag::__restrictions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for restrictions",
                                ));
                            }
                            result.restrictions = map
                                .next_value::<std::option::Option<crate::model::RestrictionConfig>>(
                                )?;
                        }
                        __FieldTag::__table_constraints => {
                            if !fields.insert(__FieldTag::__table_constraints) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_constraints",
                                ));
                            }
                            result.table_constraints = map
                                .next_value::<std::option::Option<crate::model::TableConstraints>>(
                                )?;
                        }
                        __FieldTag::__resource_tags => {
                            if !fields.insert(__FieldTag::__resource_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_tags",
                                ));
                            }
                            result.resource_tags = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table_replication_info => {
                            if !fields.insert(__FieldTag::__table_replication_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_replication_info",
                                ));
                            }
                            result.table_replication_info = map.next_value::<std::option::Option<crate::model::TableReplicationInfo>>()?
                                ;
                        }
                        __FieldTag::__replicas => {
                            if !fields.insert(__FieldTag::__replicas) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for replicas",
                                ));
                            }
                            result.replicas =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::TableReference>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__external_catalog_table_options => {
                            if !fields.insert(__FieldTag::__external_catalog_table_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_catalog_table_options",
                                ));
                            }
                            result.external_catalog_table_options = map.next_value::<std::option::Option<crate::model::ExternalCatalogTableOptions>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Table {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.self_link.is_empty() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.table_reference.is_some() {
            state.serialize_entry("tableReference", &self.table_reference)?;
        }
        if self.friendly_name.is_some() {
            state.serialize_entry("friendlyName", &self.friendly_name)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.schema.is_some() {
            state.serialize_entry("schema", &self.schema)?;
        }
        if self.time_partitioning.is_some() {
            state.serialize_entry("timePartitioning", &self.time_partitioning)?;
        }
        if self.range_partitioning.is_some() {
            state.serialize_entry("rangePartitioning", &self.range_partitioning)?;
        }
        if self.clustering.is_some() {
            state.serialize_entry("clustering", &self.clustering)?;
        }
        if self.require_partition_filter.is_some() {
            state.serialize_entry("requirePartitionFilter", &self.require_partition_filter)?;
        }
        if self.partition_definition.is_some() {
            state.serialize_entry("partitionDefinition", &self.partition_definition)?;
        }
        if self.num_bytes.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("numBytes", &__With(&self.num_bytes))?;
        }
        if self.num_physical_bytes.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("numPhysicalBytes", &__With(&self.num_physical_bytes))?;
        }
        if self.num_long_term_bytes.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("numLongTermBytes", &__With(&self.num_long_term_bytes))?;
        }
        if self.num_rows.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::UInt64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("numRows", &__With(&self.num_rows))?;
        }
        if !wkt::internal::is_default(&self.creation_time) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("creationTime", &__With(&self.creation_time))?;
        }
        if self.expiration_time.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("expirationTime", &__With(&self.expiration_time))?;
        }
        if !wkt::internal::is_default(&self.last_modified_time) {
            struct __With<'a>(&'a u64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::U64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("lastModifiedTime", &__With(&self.last_modified_time))?;
        }
        if !self.r#type.is_empty() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if self.view.is_some() {
            state.serialize_entry("view", &self.view)?;
        }
        if self.materialized_view.is_some() {
            state.serialize_entry("materializedView", &self.materialized_view)?;
        }
        if self.materialized_view_status.is_some() {
            state.serialize_entry("materializedViewStatus", &self.materialized_view_status)?;
        }
        if self.external_data_configuration.is_some() {
            state.serialize_entry(
                "externalDataConfiguration",
                &self.external_data_configuration,
            )?;
        }
        if self.biglake_configuration.is_some() {
            state.serialize_entry("biglakeConfiguration", &self.biglake_configuration)?;
        }
        if !wkt::internal::is_default(&self.managed_table_type) {
            state.serialize_entry("managedTableType", &self.managed_table_type)?;
        }
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if self.streaming_buffer.is_some() {
            state.serialize_entry("streamingBuffer", &self.streaming_buffer)?;
        }
        if self.encryption_configuration.is_some() {
            state.serialize_entry("encryptionConfiguration", &self.encryption_configuration)?;
        }
        if self.snapshot_definition.is_some() {
            state.serialize_entry("snapshotDefinition", &self.snapshot_definition)?;
        }
        if self.default_collation.is_some() {
            state.serialize_entry("defaultCollation", &self.default_collation)?;
        }
        if !wkt::internal::is_default(&self.default_rounding_mode) {
            state.serialize_entry("defaultRoundingMode", &self.default_rounding_mode)?;
        }
        if self.clone_definition.is_some() {
            state.serialize_entry("cloneDefinition", &self.clone_definition)?;
        }
        if self.num_time_travel_physical_bytes.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "numTimeTravelPhysicalBytes",
                &__With(&self.num_time_travel_physical_bytes),
            )?;
        }
        if self.num_total_logical_bytes.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "numTotalLogicalBytes",
                &__With(&self.num_total_logical_bytes),
            )?;
        }
        if self.num_active_logical_bytes.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "numActiveLogicalBytes",
                &__With(&self.num_active_logical_bytes),
            )?;
        }
        if self.num_long_term_logical_bytes.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "numLongTermLogicalBytes",
                &__With(&self.num_long_term_logical_bytes),
            )?;
        }
        if self.num_current_physical_bytes.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "numCurrentPhysicalBytes",
                &__With(&self.num_current_physical_bytes),
            )?;
        }
        if self.num_total_physical_bytes.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "numTotalPhysicalBytes",
                &__With(&self.num_total_physical_bytes),
            )?;
        }
        if self.num_active_physical_bytes.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "numActivePhysicalBytes",
                &__With(&self.num_active_physical_bytes),
            )?;
        }
        if self.num_long_term_physical_bytes.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "numLongTermPhysicalBytes",
                &__With(&self.num_long_term_physical_bytes),
            )?;
        }
        if self.num_partitions.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("numPartitions", &__With(&self.num_partitions))?;
        }
        if !self.max_staleness.is_empty() {
            state.serialize_entry("maxStaleness", &self.max_staleness)?;
        }
        if self.restrictions.is_some() {
            state.serialize_entry("restrictions", &self.restrictions)?;
        }
        if self.table_constraints.is_some() {
            state.serialize_entry("tableConstraints", &self.table_constraints)?;
        }
        if !self.resource_tags.is_empty() {
            state.serialize_entry("resourceTags", &self.resource_tags)?;
        }
        if self.table_replication_info.is_some() {
            state.serialize_entry("tableReplicationInfo", &self.table_replication_info)?;
        }
        if !self.replicas.is_empty() {
            state.serialize_entry("replicas", &self.replicas)?;
        }
        if self.external_catalog_table_options.is_some() {
            state.serialize_entry(
                "externalCatalogTableOptions",
                &self.external_catalog_table_options,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request format for getting table metadata.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetTableRequest {
    /// Required. Project ID of the requested table
    pub project_id: std::string::String,

    /// Required. Dataset ID of the requested table
    pub dataset_id: std::string::String,

    /// Required. Table ID of the requested table
    pub table_id: std::string::String,

    /// List of table schema fields to return (comma-separated).
    /// If unspecified, all fields are returned.
    /// A fieldMask cannot be used here because the fields will automatically be
    /// converted from camelCase to snake_case and the conversion will fail if
    /// there are underscores. Since these are fields in BigQuery table schemas,
    /// underscores are allowed.
    pub selected_fields: std::string::String,

    /// Optional. Specifies the view that determines which table information is
    /// returned. By default, basic table information and storage statistics
    /// (STORAGE_STATS) are returned.
    pub view: crate::model::get_table_request::TableMetadataView,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetTableRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::GetTableRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::GetTableRequest::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [table_id][crate::model::GetTableRequest::table_id].
    pub fn set_table_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_id = v.into();
        self
    }

    /// Sets the value of [selected_fields][crate::model::GetTableRequest::selected_fields].
    pub fn set_selected_fields<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.selected_fields = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetTableRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::get_table_request::TableMetadataView>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetTableRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.GetTableRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetTableRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __table_id,
            __selected_fields,
            __view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetTableRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "tableId" => Ok(__FieldTag::__table_id),
                            "table_id" => Ok(__FieldTag::__table_id),
                            "selectedFields" => Ok(__FieldTag::__selected_fields),
                            "selected_fields" => Ok(__FieldTag::__selected_fields),
                            "view" => Ok(__FieldTag::__view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetTableRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetTableRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table_id => {
                            if !fields.insert(__FieldTag::__table_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_id",
                                ));
                            }
                            result.table_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__selected_fields => {
                            if !fields.insert(__FieldTag::__selected_fields) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for selected_fields",
                                ));
                            }
                            result.selected_fields = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<
                                    crate::model::get_table_request::TableMetadataView,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetTableRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.dataset_id.is_empty() {
            state.serialize_entry("datasetId", &self.dataset_id)?;
        }
        if !self.table_id.is_empty() {
            state.serialize_entry("tableId", &self.table_id)?;
        }
        if !self.selected_fields.is_empty() {
            state.serialize_entry("selectedFields", &self.selected_fields)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [GetTableRequest].
pub mod get_table_request {
    #[allow(unused_imports)]
    use super::*;

    /// TableMetadataView specifies which table information is returned.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TableMetadataView {
        /// The default value.
        /// Default to the STORAGE_STATS view.
        Unspecified,
        /// Includes basic table information including schema and
        /// partitioning specification. This view does not include storage statistics
        /// such as numRows or numBytes. This view is significantly more efficient
        /// and should be used to support high query rates.
        Basic,
        /// Includes all information in the BASIC view as well as storage statistics
        /// (numBytes, numLongTermBytes, numRows and lastModifiedTime).
        StorageStats,
        /// Includes all table information, including storage statistics.
        /// It returns same information as STORAGE_STATS view, but may contain
        /// additional information in the future.
        Full,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TableMetadataView::value] or
        /// [TableMetadataView::name].
        UnknownValue(table_metadata_view::UnknownValue),
    }

    #[doc(hidden)]
    pub mod table_metadata_view {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TableMetadataView {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Basic => std::option::Option::Some(1),
                Self::StorageStats => std::option::Option::Some(2),
                Self::Full => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TABLE_METADATA_VIEW_UNSPECIFIED"),
                Self::Basic => std::option::Option::Some("BASIC"),
                Self::StorageStats => std::option::Option::Some("STORAGE_STATS"),
                Self::Full => std::option::Option::Some("FULL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TableMetadataView {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TableMetadataView {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TableMetadataView {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Basic,
                2 => Self::StorageStats,
                3 => Self::Full,
                _ => Self::UnknownValue(table_metadata_view::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TableMetadataView {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TABLE_METADATA_VIEW_UNSPECIFIED" => Self::Unspecified,
                "BASIC" => Self::Basic,
                "STORAGE_STATS" => Self::StorageStats,
                "FULL" => Self::Full,
                _ => Self::UnknownValue(table_metadata_view::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TableMetadataView {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Basic => serializer.serialize_i32(1),
                Self::StorageStats => serializer.serialize_i32(2),
                Self::Full => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TableMetadataView {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TableMetadataView>::new(
                ".google.cloud.bigquery.v2.GetTableRequest.TableMetadataView",
            ))
        }
    }
}

/// Request format for inserting table metadata.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InsertTableRequest {
    /// Required. Project ID of the new table
    pub project_id: std::string::String,

    /// Required. Dataset ID of the new table
    pub dataset_id: std::string::String,

    /// Required. A tables resource to insert
    pub table: std::option::Option<crate::model::Table>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InsertTableRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::InsertTableRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::InsertTableRequest::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [table][crate::model::InsertTableRequest::table].
    pub fn set_table<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Table>,
    {
        self.table = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [table][crate::model::InsertTableRequest::table].
    pub fn set_or_clear_table<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Table>,
    {
        self.table = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for InsertTableRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.InsertTableRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InsertTableRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __table,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InsertTableRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "table" => Ok(__FieldTag::__table),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InsertTableRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InsertTableRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table => {
                            if !fields.insert(__FieldTag::__table) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table",
                                ));
                            }
                            result.table =
                                map.next_value::<std::option::Option<crate::model::Table>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InsertTableRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.dataset_id.is_empty() {
            state.serialize_entry("datasetId", &self.dataset_id)?;
        }
        if self.table.is_some() {
            state.serialize_entry("table", &self.table)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateOrPatchTableRequest {
    /// Required. Project ID of the table to update
    pub project_id: std::string::String,

    /// Required. Dataset ID of the table to update
    pub dataset_id: std::string::String,

    /// Required. Table ID of the table to update
    pub table_id: std::string::String,

    /// Required. A tables resource which will replace or patch the specified table
    pub table: std::option::Option<crate::model::Table>,

    /// Optional. When true will autodetect schema, else will keep original schema.
    pub autodetect_schema: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateOrPatchTableRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::UpdateOrPatchTableRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::UpdateOrPatchTableRequest::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [table_id][crate::model::UpdateOrPatchTableRequest::table_id].
    pub fn set_table_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_id = v.into();
        self
    }

    /// Sets the value of [table][crate::model::UpdateOrPatchTableRequest::table].
    pub fn set_table<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Table>,
    {
        self.table = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [table][crate::model::UpdateOrPatchTableRequest::table].
    pub fn set_or_clear_table<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Table>,
    {
        self.table = v.map(|x| x.into());
        self
    }

    /// Sets the value of [autodetect_schema][crate::model::UpdateOrPatchTableRequest::autodetect_schema].
    pub fn set_autodetect_schema<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.autodetect_schema = v.into();
        self
    }
}

impl wkt::message::Message for UpdateOrPatchTableRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.UpdateOrPatchTableRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateOrPatchTableRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __table_id,
            __table,
            __autodetect_schema,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateOrPatchTableRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "tableId" => Ok(__FieldTag::__table_id),
                            "table_id" => Ok(__FieldTag::__table_id),
                            "table" => Ok(__FieldTag::__table),
                            "autodetectSchema" => Ok(__FieldTag::__autodetect_schema),
                            "autodetect_schema" => Ok(__FieldTag::__autodetect_schema),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateOrPatchTableRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateOrPatchTableRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table_id => {
                            if !fields.insert(__FieldTag::__table_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_id",
                                ));
                            }
                            result.table_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table => {
                            if !fields.insert(__FieldTag::__table) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table",
                                ));
                            }
                            result.table =
                                map.next_value::<std::option::Option<crate::model::Table>>()?;
                        }
                        __FieldTag::__autodetect_schema => {
                            if !fields.insert(__FieldTag::__autodetect_schema) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autodetect_schema",
                                ));
                            }
                            result.autodetect_schema = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateOrPatchTableRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.dataset_id.is_empty() {
            state.serialize_entry("datasetId", &self.dataset_id)?;
        }
        if !self.table_id.is_empty() {
            state.serialize_entry("tableId", &self.table_id)?;
        }
        if self.table.is_some() {
            state.serialize_entry("table", &self.table)?;
        }
        if !wkt::internal::is_default(&self.autodetect_schema) {
            state.serialize_entry("autodetectSchema", &self.autodetect_schema)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request format for deleting a table.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteTableRequest {
    /// Required. Project ID of the table to delete
    pub project_id: std::string::String,

    /// Required. Dataset ID of the table to delete
    pub dataset_id: std::string::String,

    /// Required. Table ID of the table to delete
    pub table_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteTableRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::DeleteTableRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::DeleteTableRequest::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [table_id][crate::model::DeleteTableRequest::table_id].
    pub fn set_table_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTableRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.DeleteTableRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteTableRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __table_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteTableRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "tableId" => Ok(__FieldTag::__table_id),
                            "table_id" => Ok(__FieldTag::__table_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteTableRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteTableRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table_id => {
                            if !fields.insert(__FieldTag::__table_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_id",
                                ));
                            }
                            result.table_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteTableRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.dataset_id.is_empty() {
            state.serialize_entry("datasetId", &self.dataset_id)?;
        }
        if !self.table_id.is_empty() {
            state.serialize_entry("tableId", &self.table_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request format for enumerating tables.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTablesRequest {
    /// Required. Project ID of the tables to list
    pub project_id: std::string::String,

    /// Required. Dataset ID of the tables to list
    pub dataset_id: std::string::String,

    /// The maximum number of results to return in a single response page.
    /// Leverage the page tokens to iterate through the entire collection.
    pub max_results: std::option::Option<wkt::UInt32Value>,

    /// Page token, returned by a previous call, to request the next page of
    /// results
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTablesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::ListTablesRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::ListTablesRequest::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [max_results][crate::model::ListTablesRequest::max_results].
    pub fn set_max_results<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::UInt32Value>,
    {
        self.max_results = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [max_results][crate::model::ListTablesRequest::max_results].
    pub fn set_or_clear_max_results<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::UInt32Value>,
    {
        self.max_results = v.map(|x| x.into());
        self
    }

    /// Sets the value of [page_token][crate::model::ListTablesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTablesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ListTablesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTablesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __max_results,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTablesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "maxResults" => Ok(__FieldTag::__max_results),
                            "max_results" => Ok(__FieldTag::__max_results),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTablesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTablesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__max_results => {
                            if !fields.insert(__FieldTag::__max_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_results",
                                ));
                            }
                            struct __With(std::option::Option<wkt::UInt32Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_results = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListTablesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.dataset_id.is_empty() {
            state.serialize_entry("datasetId", &self.dataset_id)?;
        }
        if self.max_results.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::UInt32Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("maxResults", &__With(&self.max_results))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Information about a logical view.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListFormatView {
    /// True if view is defined in legacy SQL dialect,
    /// false if in GoogleSQL.
    pub use_legacy_sql: std::option::Option<wkt::BoolValue>,

    /// Specifies the privacy policy for the view.
    pub privacy_policy: std::option::Option<crate::model::PrivacyPolicy>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListFormatView {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [use_legacy_sql][crate::model::ListFormatView::use_legacy_sql].
    pub fn set_use_legacy_sql<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.use_legacy_sql = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [use_legacy_sql][crate::model::ListFormatView::use_legacy_sql].
    pub fn set_or_clear_use_legacy_sql<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.use_legacy_sql = v.map(|x| x.into());
        self
    }

    /// Sets the value of [privacy_policy][crate::model::ListFormatView::privacy_policy].
    pub fn set_privacy_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PrivacyPolicy>,
    {
        self.privacy_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [privacy_policy][crate::model::ListFormatView::privacy_policy].
    pub fn set_or_clear_privacy_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PrivacyPolicy>,
    {
        self.privacy_policy = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ListFormatView {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ListFormatView"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListFormatView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __use_legacy_sql,
            __privacy_policy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListFormatView")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "useLegacySql" => Ok(__FieldTag::__use_legacy_sql),
                            "use_legacy_sql" => Ok(__FieldTag::__use_legacy_sql),
                            "privacyPolicy" => Ok(__FieldTag::__privacy_policy),
                            "privacy_policy" => Ok(__FieldTag::__privacy_policy),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListFormatView;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListFormatView")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__use_legacy_sql => {
                            if !fields.insert(__FieldTag::__use_legacy_sql) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for use_legacy_sql",
                                ));
                            }
                            result.use_legacy_sql =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__privacy_policy => {
                            if !fields.insert(__FieldTag::__privacy_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for privacy_policy",
                                ));
                            }
                            result.privacy_policy = map
                                .next_value::<std::option::Option<crate::model::PrivacyPolicy>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListFormatView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.use_legacy_sql.is_some() {
            state.serialize_entry("useLegacySql", &self.use_legacy_sql)?;
        }
        if self.privacy_policy.is_some() {
            state.serialize_entry("privacyPolicy", &self.privacy_policy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListFormatTable {
    /// The resource type.
    pub kind: std::string::String,

    /// An opaque ID of the table.
    pub id: std::string::String,

    /// A reference uniquely identifying table.
    pub table_reference: std::option::Option<crate::model::TableReference>,

    /// The user-friendly name for this table.
    pub friendly_name: std::option::Option<wkt::StringValue>,

    /// The type of table.
    pub r#type: std::string::String,

    /// The time-based partitioning for this table.
    pub time_partitioning: std::option::Option<crate::model::TimePartitioning>,

    /// The range partitioning for this table.
    pub range_partitioning: std::option::Option<crate::model::RangePartitioning>,

    /// Clustering specification for this table, if configured.
    pub clustering: std::option::Option<crate::model::Clustering>,

    /// The labels associated with this table. You can use these to organize
    /// and group your tables.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Additional details for a view.
    pub view: std::option::Option<crate::model::ListFormatView>,

    /// Output only. The time when this table was created, in milliseconds since
    /// the epoch.
    pub creation_time: i64,

    /// The time when this table expires, in milliseconds since the
    /// epoch. If not present, the table will persist indefinitely. Expired tables
    /// will be deleted and their storage reclaimed.
    pub expiration_time: i64,

    /// Optional. If set to true, queries including this table must specify a
    /// partition filter. This filter is used for partition elimination.
    pub require_partition_filter: std::option::Option<wkt::BoolValue>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListFormatTable {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::ListFormatTable::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [id][crate::model::ListFormatTable::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [table_reference][crate::model::ListFormatTable::table_reference].
    pub fn set_table_reference<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TableReference>,
    {
        self.table_reference = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [table_reference][crate::model::ListFormatTable::table_reference].
    pub fn set_or_clear_table_reference<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TableReference>,
    {
        self.table_reference = v.map(|x| x.into());
        self
    }

    /// Sets the value of [friendly_name][crate::model::ListFormatTable::friendly_name].
    pub fn set_friendly_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.friendly_name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [friendly_name][crate::model::ListFormatTable::friendly_name].
    pub fn set_or_clear_friendly_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.friendly_name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [r#type][crate::model::ListFormatTable::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [time_partitioning][crate::model::ListFormatTable::time_partitioning].
    pub fn set_time_partitioning<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TimePartitioning>,
    {
        self.time_partitioning = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [time_partitioning][crate::model::ListFormatTable::time_partitioning].
    pub fn set_or_clear_time_partitioning<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TimePartitioning>,
    {
        self.time_partitioning = v.map(|x| x.into());
        self
    }

    /// Sets the value of [range_partitioning][crate::model::ListFormatTable::range_partitioning].
    pub fn set_range_partitioning<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RangePartitioning>,
    {
        self.range_partitioning = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [range_partitioning][crate::model::ListFormatTable::range_partitioning].
    pub fn set_or_clear_range_partitioning<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RangePartitioning>,
    {
        self.range_partitioning = v.map(|x| x.into());
        self
    }

    /// Sets the value of [clustering][crate::model::ListFormatTable::clustering].
    pub fn set_clustering<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Clustering>,
    {
        self.clustering = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [clustering][crate::model::ListFormatTable::clustering].
    pub fn set_or_clear_clustering<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Clustering>,
    {
        self.clustering = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::ListFormatTable::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [view][crate::model::ListFormatTable::view].
    pub fn set_view<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ListFormatView>,
    {
        self.view = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [view][crate::model::ListFormatTable::view].
    pub fn set_or_clear_view<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ListFormatView>,
    {
        self.view = v.map(|x| x.into());
        self
    }

    /// Sets the value of [creation_time][crate::model::ListFormatTable::creation_time].
    pub fn set_creation_time<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.creation_time = v.into();
        self
    }

    /// Sets the value of [expiration_time][crate::model::ListFormatTable::expiration_time].
    pub fn set_expiration_time<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.expiration_time = v.into();
        self
    }

    /// Sets the value of [require_partition_filter][crate::model::ListFormatTable::require_partition_filter].
    pub fn set_require_partition_filter<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.require_partition_filter = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [require_partition_filter][crate::model::ListFormatTable::require_partition_filter].
    pub fn set_or_clear_require_partition_filter<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.require_partition_filter = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ListFormatTable {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ListFormatTable"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListFormatTable {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __id,
            __table_reference,
            __friendly_name,
            __type,
            __time_partitioning,
            __range_partitioning,
            __clustering,
            __labels,
            __view,
            __creation_time,
            __expiration_time,
            __require_partition_filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListFormatTable")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "id" => Ok(__FieldTag::__id),
                            "tableReference" => Ok(__FieldTag::__table_reference),
                            "table_reference" => Ok(__FieldTag::__table_reference),
                            "friendlyName" => Ok(__FieldTag::__friendly_name),
                            "friendly_name" => Ok(__FieldTag::__friendly_name),
                            "type" => Ok(__FieldTag::__type),
                            "timePartitioning" => Ok(__FieldTag::__time_partitioning),
                            "time_partitioning" => Ok(__FieldTag::__time_partitioning),
                            "rangePartitioning" => Ok(__FieldTag::__range_partitioning),
                            "range_partitioning" => Ok(__FieldTag::__range_partitioning),
                            "clustering" => Ok(__FieldTag::__clustering),
                            "labels" => Ok(__FieldTag::__labels),
                            "view" => Ok(__FieldTag::__view),
                            "creationTime" => Ok(__FieldTag::__creation_time),
                            "creation_time" => Ok(__FieldTag::__creation_time),
                            "expirationTime" => Ok(__FieldTag::__expiration_time),
                            "expiration_time" => Ok(__FieldTag::__expiration_time),
                            "requirePartitionFilter" => Ok(__FieldTag::__require_partition_filter),
                            "require_partition_filter" => {
                                Ok(__FieldTag::__require_partition_filter)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListFormatTable;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListFormatTable")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table_reference => {
                            if !fields.insert(__FieldTag::__table_reference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_reference",
                                ));
                            }
                            result.table_reference = map
                                .next_value::<std::option::Option<crate::model::TableReference>>(
                                )?;
                        }
                        __FieldTag::__friendly_name => {
                            if !fields.insert(__FieldTag::__friendly_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for friendly_name",
                                ));
                            }
                            result.friendly_name =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__time_partitioning => {
                            if !fields.insert(__FieldTag::__time_partitioning) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_partitioning",
                                ));
                            }
                            result.time_partitioning = map
                                .next_value::<std::option::Option<crate::model::TimePartitioning>>(
                                )?;
                        }
                        __FieldTag::__range_partitioning => {
                            if !fields.insert(__FieldTag::__range_partitioning) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for range_partitioning",
                                ));
                            }
                            result.range_partitioning = map
                                .next_value::<std::option::Option<crate::model::RangePartitioning>>(
                                )?;
                        }
                        __FieldTag::__clustering => {
                            if !fields.insert(__FieldTag::__clustering) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for clustering",
                                ));
                            }
                            result.clustering =
                                map.next_value::<std::option::Option<crate::model::Clustering>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<crate::model::ListFormatView>>(
                                )?;
                        }
                        __FieldTag::__creation_time => {
                            if !fields.insert(__FieldTag::__creation_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for creation_time",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.creation_time =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__expiration_time => {
                            if !fields.insert(__FieldTag::__expiration_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expiration_time",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.expiration_time =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__require_partition_filter => {
                            if !fields.insert(__FieldTag::__require_partition_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for require_partition_filter",
                                ));
                            }
                            result.require_partition_filter =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListFormatTable {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if self.table_reference.is_some() {
            state.serialize_entry("tableReference", &self.table_reference)?;
        }
        if self.friendly_name.is_some() {
            state.serialize_entry("friendlyName", &self.friendly_name)?;
        }
        if !self.r#type.is_empty() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if self.time_partitioning.is_some() {
            state.serialize_entry("timePartitioning", &self.time_partitioning)?;
        }
        if self.range_partitioning.is_some() {
            state.serialize_entry("rangePartitioning", &self.range_partitioning)?;
        }
        if self.clustering.is_some() {
            state.serialize_entry("clustering", &self.clustering)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.view.is_some() {
            state.serialize_entry("view", &self.view)?;
        }
        if !wkt::internal::is_default(&self.creation_time) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("creationTime", &__With(&self.creation_time))?;
        }
        if !wkt::internal::is_default(&self.expiration_time) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("expirationTime", &__With(&self.expiration_time))?;
        }
        if self.require_partition_filter.is_some() {
            state.serialize_entry("requirePartitionFilter", &self.require_partition_filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Partial projection of the metadata for a given table in a list response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TableList {
    /// The type of list.
    pub kind: std::string::String,

    /// A hash of this page of results.
    pub etag: std::string::String,

    /// A token to request the next page of results.
    pub next_page_token: std::string::String,

    /// Tables in the requested dataset.
    pub tables: std::vec::Vec<crate::model::ListFormatTable>,

    /// The total number of tables in the dataset.
    pub total_items: std::option::Option<wkt::Int32Value>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TableList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::TableList::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::TableList::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [next_page_token][crate::model::TableList::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [tables][crate::model::TableList::tables].
    pub fn set_tables<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ListFormatTable>,
    {
        use std::iter::Iterator;
        self.tables = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [total_items][crate::model::TableList::total_items].
    pub fn set_total_items<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int32Value>,
    {
        self.total_items = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [total_items][crate::model::TableList::total_items].
    pub fn set_or_clear_total_items<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int32Value>,
    {
        self.total_items = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for TableList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.TableList"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TableList {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __etag,
            __next_page_token,
            __tables,
            __total_items,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TableList")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "etag" => Ok(__FieldTag::__etag),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "tables" => Ok(__FieldTag::__tables),
                            "totalItems" => Ok(__FieldTag::__total_items),
                            "total_items" => Ok(__FieldTag::__total_items),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TableList;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TableList")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tables => {
                            if !fields.insert(__FieldTag::__tables) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tables",
                                ));
                            }
                            result.tables =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ListFormatTable>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__total_items => {
                            if !fields.insert(__FieldTag::__total_items) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_items",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int32Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_items = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TableList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.tables.is_empty() {
            state.serialize_entry("tables", &self.tables)?;
        }
        if self.total_items.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int32Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("totalItems", &__With(&self.total_items))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents the primary key constraint on a table's columns.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PrimaryKey {
    /// Required. The columns that are composed of the primary key constraint.
    pub columns: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PrimaryKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [columns][crate::model::PrimaryKey::columns].
    pub fn set_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.columns = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PrimaryKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.PrimaryKey"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PrimaryKey {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __columns,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PrimaryKey")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "columns" => Ok(__FieldTag::__columns),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PrimaryKey;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PrimaryKey")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__columns => {
                            if !fields.insert(__FieldTag::__columns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for columns",
                                ));
                            }
                            result.columns = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PrimaryKey {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.columns.is_empty() {
            state.serialize_entry("columns", &self.columns)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The pair of the foreign key column and primary key column.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ColumnReference {
    /// Required. The column that composes the foreign key.
    pub referencing_column: std::string::String,

    /// Required. The column in the primary key that are referenced by the
    /// referencing_column.
    pub referenced_column: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ColumnReference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [referencing_column][crate::model::ColumnReference::referencing_column].
    pub fn set_referencing_column<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.referencing_column = v.into();
        self
    }

    /// Sets the value of [referenced_column][crate::model::ColumnReference::referenced_column].
    pub fn set_referenced_column<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.referenced_column = v.into();
        self
    }
}

impl wkt::message::Message for ColumnReference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ColumnReference"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ColumnReference {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __referencing_column,
            __referenced_column,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ColumnReference")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "referencingColumn" => Ok(__FieldTag::__referencing_column),
                            "referencing_column" => Ok(__FieldTag::__referencing_column),
                            "referencedColumn" => Ok(__FieldTag::__referenced_column),
                            "referenced_column" => Ok(__FieldTag::__referenced_column),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ColumnReference;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ColumnReference")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__referencing_column => {
                            if !fields.insert(__FieldTag::__referencing_column) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for referencing_column",
                                ));
                            }
                            result.referencing_column = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__referenced_column => {
                            if !fields.insert(__FieldTag::__referenced_column) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for referenced_column",
                                ));
                            }
                            result.referenced_column = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ColumnReference {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.referencing_column.is_empty() {
            state.serialize_entry("referencingColumn", &self.referencing_column)?;
        }
        if !self.referenced_column.is_empty() {
            state.serialize_entry("referencedColumn", &self.referenced_column)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents a foreign key constraint on a table's columns.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ForeignKey {
    /// Optional. Set only if the foreign key constraint is named.
    pub name: std::string::String,

    /// Required. The table that holds the primary key and is referenced by this
    /// foreign key.
    pub referenced_table: std::option::Option<crate::model::TableReference>,

    /// Required. The columns that compose the foreign key.
    pub column_references: std::vec::Vec<crate::model::ColumnReference>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ForeignKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ForeignKey::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [referenced_table][crate::model::ForeignKey::referenced_table].
    pub fn set_referenced_table<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TableReference>,
    {
        self.referenced_table = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [referenced_table][crate::model::ForeignKey::referenced_table].
    pub fn set_or_clear_referenced_table<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TableReference>,
    {
        self.referenced_table = v.map(|x| x.into());
        self
    }

    /// Sets the value of [column_references][crate::model::ForeignKey::column_references].
    pub fn set_column_references<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ColumnReference>,
    {
        use std::iter::Iterator;
        self.column_references = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ForeignKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ForeignKey"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ForeignKey {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __referenced_table,
            __column_references,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ForeignKey")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "referencedTable" => Ok(__FieldTag::__referenced_table),
                            "referenced_table" => Ok(__FieldTag::__referenced_table),
                            "columnReferences" => Ok(__FieldTag::__column_references),
                            "column_references" => Ok(__FieldTag::__column_references),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ForeignKey;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ForeignKey")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__referenced_table => {
                            if !fields.insert(__FieldTag::__referenced_table) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for referenced_table",
                                ));
                            }
                            result.referenced_table = map
                                .next_value::<std::option::Option<crate::model::TableReference>>(
                                )?;
                        }
                        __FieldTag::__column_references => {
                            if !fields.insert(__FieldTag::__column_references) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for column_references",
                                ));
                            }
                            result.column_references =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ColumnReference>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ForeignKey {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.referenced_table.is_some() {
            state.serialize_entry("referencedTable", &self.referenced_table)?;
        }
        if !self.column_references.is_empty() {
            state.serialize_entry("columnReferences", &self.column_references)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The TableConstraints defines the primary key and foreign key.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TableConstraints {
    /// Optional. Represents a primary key constraint on a table's columns.
    /// Present only if the table has a primary key.
    /// The primary key is not enforced.
    pub primary_key: std::option::Option<crate::model::PrimaryKey>,

    /// Optional. Present only if the table has a foreign key.
    /// The foreign key is not enforced.
    pub foreign_keys: std::vec::Vec<crate::model::ForeignKey>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TableConstraints {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [primary_key][crate::model::TableConstraints::primary_key].
    pub fn set_primary_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PrimaryKey>,
    {
        self.primary_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [primary_key][crate::model::TableConstraints::primary_key].
    pub fn set_or_clear_primary_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PrimaryKey>,
    {
        self.primary_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [foreign_keys][crate::model::TableConstraints::foreign_keys].
    pub fn set_foreign_keys<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ForeignKey>,
    {
        use std::iter::Iterator;
        self.foreign_keys = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TableConstraints {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.TableConstraints"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TableConstraints {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __primary_key,
            __foreign_keys,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TableConstraints")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "primaryKey" => Ok(__FieldTag::__primary_key),
                            "primary_key" => Ok(__FieldTag::__primary_key),
                            "foreignKeys" => Ok(__FieldTag::__foreign_keys),
                            "foreign_keys" => Ok(__FieldTag::__foreign_keys),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TableConstraints;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TableConstraints")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__primary_key => {
                            if !fields.insert(__FieldTag::__primary_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for primary_key",
                                ));
                            }
                            result.primary_key =
                                map.next_value::<std::option::Option<crate::model::PrimaryKey>>()?;
                        }
                        __FieldTag::__foreign_keys => {
                            if !fields.insert(__FieldTag::__foreign_keys) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for foreign_keys",
                                ));
                            }
                            result.foreign_keys = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ForeignKey>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TableConstraints {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.primary_key.is_some() {
            state.serialize_entry("primaryKey", &self.primary_key)?;
        }
        if !self.foreign_keys.is_empty() {
            state.serialize_entry("foreignKeys", &self.foreign_keys)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TableReference {
    /// Required. The ID of the project containing this table.
    pub project_id: std::string::String,

    /// Required. The ID of the dataset containing this table.
    pub dataset_id: std::string::String,

    /// Required. The ID of the table. The ID can contain Unicode characters in
    /// category L (letter), M (mark), N (number), Pc (connector, including
    /// underscore), Pd (dash), and Zs (space). For more information, see [General
    /// Category](https://wikipedia.org/wiki/Unicode_character_property#General_Category).
    /// The maximum length is 1,024 characters.  Certain operations allow suffixing
    /// of the table ID with a partition decorator, such as
    /// `sample_table$20190123`.
    pub table_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TableReference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::TableReference::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::TableReference::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [table_id][crate::model::TableReference::table_id].
    pub fn set_table_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_id = v.into();
        self
    }
}

impl wkt::message::Message for TableReference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.TableReference"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TableReference {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __dataset_id,
            __table_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TableReference")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "tableId" => Ok(__FieldTag::__table_id),
                            "table_id" => Ok(__FieldTag::__table_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TableReference;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TableReference")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table_id => {
                            if !fields.insert(__FieldTag::__table_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_id",
                                ));
                            }
                            result.table_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TableReference {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.dataset_id.is_empty() {
            state.serialize_entry("datasetId", &self.dataset_id)?;
        }
        if !self.table_id.is_empty() {
            state.serialize_entry("tableId", &self.table_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Schema of a table
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TableSchema {
    /// Describes the fields in a table.
    pub fields: std::vec::Vec<crate::model::TableFieldSchema>,

    /// Optional. Specifies metadata of the foreign data type definition in field
    /// schema
    /// ([TableFieldSchema.foreign_type_definition][google.cloud.bigquery.v2.TableFieldSchema.foreign_type_definition]).
    ///
    /// [google.cloud.bigquery.v2.TableFieldSchema.foreign_type_definition]: crate::model::TableFieldSchema::foreign_type_definition
    pub foreign_type_info: std::option::Option<crate::model::ForeignTypeInfo>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TableSchema {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [fields][crate::model::TableSchema::fields].
    pub fn set_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TableFieldSchema>,
    {
        use std::iter::Iterator;
        self.fields = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [foreign_type_info][crate::model::TableSchema::foreign_type_info].
    pub fn set_foreign_type_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ForeignTypeInfo>,
    {
        self.foreign_type_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [foreign_type_info][crate::model::TableSchema::foreign_type_info].
    pub fn set_or_clear_foreign_type_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ForeignTypeInfo>,
    {
        self.foreign_type_info = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for TableSchema {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.TableSchema"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TableSchema {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __fields,
            __foreign_type_info,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TableSchema")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fields" => Ok(__FieldTag::__fields),
                            "foreignTypeInfo" => Ok(__FieldTag::__foreign_type_info),
                            "foreign_type_info" => Ok(__FieldTag::__foreign_type_info),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TableSchema;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TableSchema")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__fields => {
                            if !fields.insert(__FieldTag::__fields) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fields",
                                ));
                            }
                            result.fields =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::TableFieldSchema>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__foreign_type_info => {
                            if !fields.insert(__FieldTag::__foreign_type_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for foreign_type_info",
                                ));
                            }
                            result.foreign_type_info = map
                                .next_value::<std::option::Option<crate::model::ForeignTypeInfo>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TableSchema {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.fields.is_empty() {
            state.serialize_entry("fields", &self.fields)?;
        }
        if self.foreign_type_info.is_some() {
            state.serialize_entry("foreignTypeInfo", &self.foreign_type_info)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata about the foreign data type definition such as the system
/// in which the type is defined.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ForeignTypeInfo {
    /// Required. Specifies the system which defines the foreign data type.
    pub type_system: crate::model::foreign_type_info::TypeSystem,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ForeignTypeInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [type_system][crate::model::ForeignTypeInfo::type_system].
    pub fn set_type_system<T: std::convert::Into<crate::model::foreign_type_info::TypeSystem>>(
        mut self,
        v: T,
    ) -> Self {
        self.type_system = v.into();
        self
    }
}

impl wkt::message::Message for ForeignTypeInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.ForeignTypeInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ForeignTypeInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type_system,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ForeignTypeInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "typeSystem" => Ok(__FieldTag::__type_system),
                            "type_system" => Ok(__FieldTag::__type_system),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ForeignTypeInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ForeignTypeInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type_system => {
                            if !fields.insert(__FieldTag::__type_system) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type_system",
                                ));
                            }
                            result.type_system =
                                map.next_value::<std::option::Option<
                                    crate::model::foreign_type_info::TypeSystem,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ForeignTypeInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.type_system) {
            state.serialize_entry("typeSystem", &self.type_system)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ForeignTypeInfo].
pub mod foreign_type_info {
    #[allow(unused_imports)]
    use super::*;

    /// External systems, such as query engines or table formats, that have their
    /// own data types.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TypeSystem {
        /// TypeSystem not specified.
        Unspecified,
        /// Represents Hive data types.
        Hive,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TypeSystem::value] or
        /// [TypeSystem::name].
        UnknownValue(type_system::UnknownValue),
    }

    #[doc(hidden)]
    pub mod type_system {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TypeSystem {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Hive => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_SYSTEM_UNSPECIFIED"),
                Self::Hive => std::option::Option::Some("HIVE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TypeSystem {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TypeSystem {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TypeSystem {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Hive,
                _ => Self::UnknownValue(type_system::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TypeSystem {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_SYSTEM_UNSPECIFIED" => Self::Unspecified,
                "HIVE" => Self::Hive,
                _ => Self::UnknownValue(type_system::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TypeSystem {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Hive => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TypeSystem {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TypeSystem>::new(
                ".google.cloud.bigquery.v2.ForeignTypeInfo.TypeSystem",
            ))
        }
    }
}

/// Data policy option proto, it currently supports name only, will support
/// precedence later.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DataPolicyOption {
    /// Data policy resource name in the form of
    /// projects/project_id/locations/location_id/dataPolicies/data_policy_id.
    pub name: std::option::Option<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataPolicyOption {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DataPolicyOption::name].
    pub fn set_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [name][crate::model::DataPolicyOption::name].
    pub fn set_or_clear_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DataPolicyOption {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.DataPolicyOption"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataPolicyOption {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataPolicyOption")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataPolicyOption;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataPolicyOption")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataPolicyOption {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A field in TableSchema
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TableFieldSchema {
    /// Required. The field name. The name must contain only letters (a-z, A-Z),
    /// numbers (0-9), or underscores (_), and must start with a letter or
    /// underscore. The maximum length is 300 characters.
    pub name: std::string::String,

    /// Required. The field data type. Possible values include:
    ///
    /// * STRING
    /// * BYTES
    /// * INTEGER (or INT64)
    /// * FLOAT (or FLOAT64)
    /// * BOOLEAN (or BOOL)
    /// * TIMESTAMP
    /// * DATE
    /// * TIME
    /// * DATETIME
    /// * GEOGRAPHY
    /// * NUMERIC
    /// * BIGNUMERIC
    /// * JSON
    /// * RECORD (or STRUCT)
    /// * RANGE
    ///
    /// Use of RECORD/STRUCT indicates that the field contains a nested schema.
    pub r#type: std::string::String,

    /// Optional. The field mode. Possible values include NULLABLE, REQUIRED and
    /// REPEATED. The default value is NULLABLE.
    pub mode: std::string::String,

    /// Optional. Describes the nested schema fields if the type property is set
    /// to RECORD.
    pub fields: std::vec::Vec<crate::model::TableFieldSchema>,

    /// Optional. The field description. The maximum length is 1,024 characters.
    pub description: std::option::Option<wkt::StringValue>,

    /// Optional. The policy tags attached to this field, used for field-level
    /// access control. If not set, defaults to empty policy_tags.
    pub policy_tags: std::option::Option<crate::model::table_field_schema::PolicyTagList>,

    /// Optional. Data policy options, will replace the data_policies.
    pub data_policies: std::vec::Vec<crate::model::DataPolicyOption>,

    /// Optional. Maximum length of values of this field for STRINGS or BYTES.
    ///
    /// If max_length is not specified, no maximum length constraint is imposed
    /// on this field.
    ///
    /// If type = "STRING", then max_length represents the maximum UTF-8
    /// length of strings in this field.
    ///
    /// If type = "BYTES", then max_length represents the maximum number of
    /// bytes in this field.
    ///
    /// It is invalid to set this field if type &ne; "STRING" and &ne; "BYTES".
    pub max_length: i64,

    /// Optional. Precision (maximum number of total digits in base 10) and scale
    /// (maximum number of digits in the fractional part in base 10) constraints
    /// for values of this field for NUMERIC or BIGNUMERIC.
    ///
    /// It is invalid to set precision or scale if type &ne; "NUMERIC" and &ne;
    /// "BIGNUMERIC".
    ///
    /// If precision and scale are not specified, no value range constraint is
    /// imposed on this field insofar as values are permitted by the type.
    ///
    /// Values of this NUMERIC or BIGNUMERIC field must be in this range when:
    ///
    /// * Precision (\<var\>P\</var\>) and scale (\<var\>S\</var\>) are specified:
    ///   [-10\<sup\>\<var\>P\</var\>-\<var\>S\</var\>\</sup\> + 10\<sup\>-\<var\>S\</var\>\</sup\>,
    ///   10\<sup\>\<var\>P\</var\>-\<var\>S\</var\>\</sup\> - 10\<sup\>-\<var\>S\</var\>\</sup\>]
    /// * Precision (\<var\>P\</var\>) is specified but not scale (and thus scale is
    ///   interpreted to be equal to zero):
    ///   [-10\<sup\>\<var\>P\</var\>\</sup\> + 1, 10\<sup\>\<var\>P\</var\>\</sup\> - 1].
    ///
    /// Acceptable values for precision and scale if both are specified:
    ///
    /// * If type = "NUMERIC":
    ///   1 &le; precision - scale &le; 29 and 0 &le; scale &le; 9.
    /// * If type = "BIGNUMERIC":
    ///   1 &le; precision - scale &le; 38 and 0 &le; scale &le; 38.
    ///
    /// Acceptable values for precision if only precision is specified but not
    /// scale (and thus scale is interpreted to be equal to zero):
    ///
    /// * If type = "NUMERIC": 1 &le; precision &le; 29.
    /// * If type = "BIGNUMERIC": 1 &le; precision &le; 38.
    ///
    /// If scale is specified but not precision, then it is invalid.
    pub precision: i64,

    /// Optional. See documentation for precision.
    pub scale: i64,

    /// Optional. Specifies the rounding mode to be used when storing values of
    /// NUMERIC and BIGNUMERIC type.
    pub rounding_mode: crate::model::table_field_schema::RoundingMode,

    /// Optional. Field collation can be set only when the type of field is STRING.
    /// The following values are supported:
    ///
    /// * 'und:ci': undetermined locale, case insensitive.
    /// * '': empty string. Default to case-sensitive behavior.
    pub collation: std::option::Option<wkt::StringValue>,

    /// Optional. A SQL expression to specify the [default value]
    /// (<https://cloud.google.com/bigquery/docs/default-values>) for this field.
    pub default_value_expression: std::option::Option<wkt::StringValue>,

    /// Optional. The subtype of the RANGE, if the type of this field is RANGE. If
    /// the type is RANGE, this field is required. Values for the field element
    /// type can be the following:
    ///
    /// * DATE
    /// * DATETIME
    /// * TIMESTAMP
    pub range_element_type: std::option::Option<crate::model::table_field_schema::FieldElementType>,

    /// Optional. Definition of the foreign data type.
    /// Only valid for top-level schema fields (not nested fields).
    /// If the type is FOREIGN, this field is required.
    pub foreign_type_definition: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TableFieldSchema {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TableFieldSchema::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::TableFieldSchema::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [mode][crate::model::TableFieldSchema::mode].
    pub fn set_mode<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mode = v.into();
        self
    }

    /// Sets the value of [fields][crate::model::TableFieldSchema::fields].
    pub fn set_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TableFieldSchema>,
    {
        use std::iter::Iterator;
        self.fields = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [description][crate::model::TableFieldSchema::description].
    pub fn set_description<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.description = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [description][crate::model::TableFieldSchema::description].
    pub fn set_or_clear_description<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.description = v.map(|x| x.into());
        self
    }

    /// Sets the value of [policy_tags][crate::model::TableFieldSchema::policy_tags].
    pub fn set_policy_tags<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::table_field_schema::PolicyTagList>,
    {
        self.policy_tags = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [policy_tags][crate::model::TableFieldSchema::policy_tags].
    pub fn set_or_clear_policy_tags<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::table_field_schema::PolicyTagList>,
    {
        self.policy_tags = v.map(|x| x.into());
        self
    }

    /// Sets the value of [data_policies][crate::model::TableFieldSchema::data_policies].
    pub fn set_data_policies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataPolicyOption>,
    {
        use std::iter::Iterator;
        self.data_policies = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [max_length][crate::model::TableFieldSchema::max_length].
    pub fn set_max_length<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.max_length = v.into();
        self
    }

    /// Sets the value of [precision][crate::model::TableFieldSchema::precision].
    pub fn set_precision<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.precision = v.into();
        self
    }

    /// Sets the value of [scale][crate::model::TableFieldSchema::scale].
    pub fn set_scale<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.scale = v.into();
        self
    }

    /// Sets the value of [rounding_mode][crate::model::TableFieldSchema::rounding_mode].
    pub fn set_rounding_mode<
        T: std::convert::Into<crate::model::table_field_schema::RoundingMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rounding_mode = v.into();
        self
    }

    /// Sets the value of [collation][crate::model::TableFieldSchema::collation].
    pub fn set_collation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.collation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [collation][crate::model::TableFieldSchema::collation].
    pub fn set_or_clear_collation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.collation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [default_value_expression][crate::model::TableFieldSchema::default_value_expression].
    pub fn set_default_value_expression<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.default_value_expression = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [default_value_expression][crate::model::TableFieldSchema::default_value_expression].
    pub fn set_or_clear_default_value_expression<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.default_value_expression = v.map(|x| x.into());
        self
    }

    /// Sets the value of [range_element_type][crate::model::TableFieldSchema::range_element_type].
    pub fn set_range_element_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::table_field_schema::FieldElementType>,
    {
        self.range_element_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [range_element_type][crate::model::TableFieldSchema::range_element_type].
    pub fn set_or_clear_range_element_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::table_field_schema::FieldElementType>,
    {
        self.range_element_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [foreign_type_definition][crate::model::TableFieldSchema::foreign_type_definition].
    pub fn set_foreign_type_definition<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.foreign_type_definition = v.into();
        self
    }
}

impl wkt::message::Message for TableFieldSchema {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.TableFieldSchema"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TableFieldSchema {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __type,
            __mode,
            __fields,
            __description,
            __policy_tags,
            __data_policies,
            __max_length,
            __precision,
            __scale,
            __rounding_mode,
            __collation,
            __default_value_expression,
            __range_element_type,
            __foreign_type_definition,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TableFieldSchema")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "type" => Ok(__FieldTag::__type),
                            "mode" => Ok(__FieldTag::__mode),
                            "fields" => Ok(__FieldTag::__fields),
                            "description" => Ok(__FieldTag::__description),
                            "policyTags" => Ok(__FieldTag::__policy_tags),
                            "policy_tags" => Ok(__FieldTag::__policy_tags),
                            "dataPolicies" => Ok(__FieldTag::__data_policies),
                            "data_policies" => Ok(__FieldTag::__data_policies),
                            "maxLength" => Ok(__FieldTag::__max_length),
                            "max_length" => Ok(__FieldTag::__max_length),
                            "precision" => Ok(__FieldTag::__precision),
                            "scale" => Ok(__FieldTag::__scale),
                            "roundingMode" => Ok(__FieldTag::__rounding_mode),
                            "rounding_mode" => Ok(__FieldTag::__rounding_mode),
                            "collation" => Ok(__FieldTag::__collation),
                            "defaultValueExpression" => Ok(__FieldTag::__default_value_expression),
                            "default_value_expression" => {
                                Ok(__FieldTag::__default_value_expression)
                            }
                            "rangeElementType" => Ok(__FieldTag::__range_element_type),
                            "range_element_type" => Ok(__FieldTag::__range_element_type),
                            "foreignTypeDefinition" => Ok(__FieldTag::__foreign_type_definition),
                            "foreign_type_definition" => Ok(__FieldTag::__foreign_type_definition),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TableFieldSchema;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TableFieldSchema")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mode => {
                            if !fields.insert(__FieldTag::__mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mode",
                                ));
                            }
                            result.mode = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__fields => {
                            if !fields.insert(__FieldTag::__fields) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fields",
                                ));
                            }
                            result.fields =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::TableFieldSchema>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::__policy_tags => {
                            if !fields.insert(__FieldTag::__policy_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy_tags",
                                ));
                            }
                            result.policy_tags = map.next_value::<std::option::Option<
                                crate::model::table_field_schema::PolicyTagList,
                            >>()?;
                        }
                        __FieldTag::__data_policies => {
                            if !fields.insert(__FieldTag::__data_policies) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_policies",
                                ));
                            }
                            result.data_policies =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::DataPolicyOption>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__max_length => {
                            if !fields.insert(__FieldTag::__max_length) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_length",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_length = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__precision => {
                            if !fields.insert(__FieldTag::__precision) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for precision",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.precision = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__scale => {
                            if !fields.insert(__FieldTag::__scale) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scale",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.scale = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__rounding_mode => {
                            if !fields.insert(__FieldTag::__rounding_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rounding_mode",
                                ));
                            }
                            result.rounding_mode =
                                map.next_value::<std::option::Option<
                                    crate::model::table_field_schema::RoundingMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__collation => {
                            if !fields.insert(__FieldTag::__collation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for collation",
                                ));
                            }
                            result.collation =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::__default_value_expression => {
                            if !fields.insert(__FieldTag::__default_value_expression) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_value_expression",
                                ));
                            }
                            result.default_value_expression =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::__range_element_type => {
                            if !fields.insert(__FieldTag::__range_element_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for range_element_type",
                                ));
                            }
                            result.range_element_type = map.next_value::<std::option::Option<
                                crate::model::table_field_schema::FieldElementType,
                            >>()?;
                        }
                        __FieldTag::__foreign_type_definition => {
                            if !fields.insert(__FieldTag::__foreign_type_definition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for foreign_type_definition",
                                ));
                            }
                            result.foreign_type_definition = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TableFieldSchema {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.r#type.is_empty() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.mode.is_empty() {
            state.serialize_entry("mode", &self.mode)?;
        }
        if !self.fields.is_empty() {
            state.serialize_entry("fields", &self.fields)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.policy_tags.is_some() {
            state.serialize_entry("policyTags", &self.policy_tags)?;
        }
        if !self.data_policies.is_empty() {
            state.serialize_entry("dataPolicies", &self.data_policies)?;
        }
        if !wkt::internal::is_default(&self.max_length) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxLength", &__With(&self.max_length))?;
        }
        if !wkt::internal::is_default(&self.precision) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("precision", &__With(&self.precision))?;
        }
        if !wkt::internal::is_default(&self.scale) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("scale", &__With(&self.scale))?;
        }
        if !wkt::internal::is_default(&self.rounding_mode) {
            state.serialize_entry("roundingMode", &self.rounding_mode)?;
        }
        if self.collation.is_some() {
            state.serialize_entry("collation", &self.collation)?;
        }
        if self.default_value_expression.is_some() {
            state.serialize_entry("defaultValueExpression", &self.default_value_expression)?;
        }
        if self.range_element_type.is_some() {
            state.serialize_entry("rangeElementType", &self.range_element_type)?;
        }
        if !self.foreign_type_definition.is_empty() {
            state.serialize_entry("foreignTypeDefinition", &self.foreign_type_definition)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [TableFieldSchema].
pub mod table_field_schema {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PolicyTagList {
        /// A list of policy tag resource names. For example,
        /// "projects/1/locations/eu/taxonomies/2/policyTags/3". At most 1 policy tag
        /// is currently allowed.
        pub names: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PolicyTagList {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [names][crate::model::table_field_schema::PolicyTagList::names].
        pub fn set_names<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.names = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for PolicyTagList {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.TableFieldSchema.PolicyTagList"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PolicyTagList {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __names,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PolicyTagList")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "names" => Ok(__FieldTag::__names),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PolicyTagList;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PolicyTagList")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__names => {
                                if !fields.insert(__FieldTag::__names) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for names",
                                    ));
                                }
                                result.names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PolicyTagList {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.names.is_empty() {
                state.serialize_entry("names", &self.names)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Represents the type of a field element.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct FieldElementType {
        /// Required. The type of a field element. For more information, see
        /// [TableFieldSchema.type][google.cloud.bigquery.v2.TableFieldSchema.type].
        ///
        /// [google.cloud.bigquery.v2.TableFieldSchema.type]: crate::model::TableFieldSchema::type
        pub r#type: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl FieldElementType {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [r#type][crate::model::table_field_schema::FieldElementType::type].
        pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.r#type = v.into();
            self
        }
    }

    impl wkt::message::Message for FieldElementType {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.bigquery.v2.TableFieldSchema.FieldElementType"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for FieldElementType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __type,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for FieldElementType")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "type" => Ok(__FieldTag::__type),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = FieldElementType;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct FieldElementType")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__type => {
                                if !fields.insert(__FieldTag::__type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for type",
                                    ));
                                }
                                result.r#type = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for FieldElementType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.r#type.is_empty() {
                state.serialize_entry("type", &self.r#type)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Rounding mode options that can be used when storing NUMERIC
    /// or BIGNUMERIC values.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RoundingMode {
        /// Unspecified will default to using ROUND_HALF_AWAY_FROM_ZERO.
        Unspecified,
        /// ROUND_HALF_AWAY_FROM_ZERO rounds half values away from zero
        /// when applying precision and scale upon writing of NUMERIC and BIGNUMERIC
        /// values.
        /// For Scale: 0
        /// 1.1, 1.2, 1.3, 1.4 => 1
        /// 1.5, 1.6, 1.7, 1.8, 1.9 => 2
        RoundHalfAwayFromZero,
        /// ROUND_HALF_EVEN rounds half values to the nearest even value
        /// when applying precision and scale upon writing of NUMERIC and BIGNUMERIC
        /// values.
        /// For Scale: 0
        /// 1.1, 1.2, 1.3, 1.4 => 1
        /// 1.5 => 2
        /// 1.6, 1.7, 1.8, 1.9 => 2
        /// 2.5 => 2
        RoundHalfEven,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RoundingMode::value] or
        /// [RoundingMode::name].
        UnknownValue(rounding_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod rounding_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RoundingMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::RoundHalfAwayFromZero => std::option::Option::Some(1),
                Self::RoundHalfEven => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ROUNDING_MODE_UNSPECIFIED"),
                Self::RoundHalfAwayFromZero => {
                    std::option::Option::Some("ROUND_HALF_AWAY_FROM_ZERO")
                }
                Self::RoundHalfEven => std::option::Option::Some("ROUND_HALF_EVEN"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RoundingMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RoundingMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RoundingMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::RoundHalfAwayFromZero,
                2 => Self::RoundHalfEven,
                _ => Self::UnknownValue(rounding_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RoundingMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ROUNDING_MODE_UNSPECIFIED" => Self::Unspecified,
                "ROUND_HALF_AWAY_FROM_ZERO" => Self::RoundHalfAwayFromZero,
                "ROUND_HALF_EVEN" => Self::RoundHalfEven,
                _ => Self::UnknownValue(rounding_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RoundingMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::RoundHalfAwayFromZero => serializer.serialize_i32(1),
                Self::RoundHalfEven => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RoundingMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RoundingMode>::new(
                ".google.cloud.bigquery.v2.TableFieldSchema.RoundingMode",
            ))
        }
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TimePartitioning {
    /// Required. The supported types are DAY, HOUR, MONTH, and YEAR, which will
    /// generate one partition per day, hour, month, and year, respectively.
    pub r#type: std::string::String,

    /// Optional. Number of milliseconds for which to keep the storage for a
    /// partition.
    /// A wrapper is used here because 0 is an invalid value.
    pub expiration_ms: std::option::Option<wkt::Int64Value>,

    /// Optional. If not set, the table is partitioned by pseudo
    /// column '_PARTITIONTIME'; if set, the table is partitioned by this field.
    /// The field must be a top-level TIMESTAMP or DATE field. Its mode must be
    /// NULLABLE or REQUIRED.
    /// A wrapper is used here because an empty string is an invalid value.
    pub field: std::option::Option<wkt::StringValue>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TimePartitioning {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::TimePartitioning::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [expiration_ms][crate::model::TimePartitioning::expiration_ms].
    pub fn set_expiration_ms<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.expiration_ms = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expiration_ms][crate::model::TimePartitioning::expiration_ms].
    pub fn set_or_clear_expiration_ms<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.expiration_ms = v.map(|x| x.into());
        self
    }

    /// Sets the value of [field][crate::model::TimePartitioning::field].
    pub fn set_field<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.field = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [field][crate::model::TimePartitioning::field].
    pub fn set_or_clear_field<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.field = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for TimePartitioning {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.TimePartitioning"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TimePartitioning {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __expiration_ms,
            __field,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TimePartitioning")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "expirationMs" => Ok(__FieldTag::__expiration_ms),
                            "expiration_ms" => Ok(__FieldTag::__expiration_ms),
                            "field" => Ok(__FieldTag::__field),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TimePartitioning;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TimePartitioning")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__expiration_ms => {
                            if !fields.insert(__FieldTag::__expiration_ms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expiration_ms",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.expiration_ms = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__field => {
                            if !fields.insert(__FieldTag::__field) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field",
                                ));
                            }
                            result.field =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TimePartitioning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.r#type.is_empty() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if self.expiration_ms.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("expirationMs", &__With(&self.expiration_ms))?;
        }
        if self.field.is_some() {
            state.serialize_entry("field", &self.field)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// This is used for defining User Defined Function (UDF) resources only when
/// using legacy SQL.  Users of GoogleSQL should leverage either DDL (e.g.
/// CREATE [TEMPORARY] FUNCTION ... ) or the Routines API to define UDF
/// resources.
///
/// For additional information on migrating, see:
/// <https://cloud.google.com/bigquery/docs/reference/standard-sql/migrating-from-legacy-sql#differences_in_user-defined_javascript_functions>
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UserDefinedFunctionResource {
    /// [Pick one] A code resource to load from a Google Cloud Storage URI
    /// (gs://bucket/path).
    pub resource_uri: std::option::Option<wkt::StringValue>,

    /// [Pick one] An inline resource that contains code for a user-defined
    /// function (UDF). Providing a inline code resource is equivalent to providing
    /// a URI for a file containing the same code.
    pub inline_code: std::option::Option<wkt::StringValue>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UserDefinedFunctionResource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_uri][crate::model::UserDefinedFunctionResource::resource_uri].
    pub fn set_resource_uri<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.resource_uri = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resource_uri][crate::model::UserDefinedFunctionResource::resource_uri].
    pub fn set_or_clear_resource_uri<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.resource_uri = v.map(|x| x.into());
        self
    }

    /// Sets the value of [inline_code][crate::model::UserDefinedFunctionResource::inline_code].
    pub fn set_inline_code<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.inline_code = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [inline_code][crate::model::UserDefinedFunctionResource::inline_code].
    pub fn set_or_clear_inline_code<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.inline_code = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UserDefinedFunctionResource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.v2.UserDefinedFunctionResource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UserDefinedFunctionResource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __resource_uri,
            __inline_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UserDefinedFunctionResource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resourceUri" => Ok(__FieldTag::__resource_uri),
                            "resource_uri" => Ok(__FieldTag::__resource_uri),
                            "inlineCode" => Ok(__FieldTag::__inline_code),
                            "inline_code" => Ok(__FieldTag::__inline_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UserDefinedFunctionResource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UserDefinedFunctionResource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__resource_uri => {
                            if !fields.insert(__FieldTag::__resource_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_uri",
                                ));
                            }
                            result.resource_uri =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::__inline_code => {
                            if !fields.insert(__FieldTag::__inline_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inline_code",
                                ));
                            }
                            result.inline_code =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UserDefinedFunctionResource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.resource_uri.is_some() {
            state.serialize_entry("resourceUri", &self.resource_uri)?;
        }
        if self.inline_code.is_some() {
            state.serialize_entry("inlineCode", &self.inline_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The data types that could be used as a target type when converting decimal
/// values.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum DecimalTargetType {
    /// Invalid type.
    Unspecified,
    /// Decimal values could be converted to NUMERIC
    /// type.
    Numeric,
    /// Decimal values could be converted to BIGNUMERIC
    /// type.
    Bignumeric,
    /// Decimal values could be converted to STRING type.
    String,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [DecimalTargetType::value] or
    /// [DecimalTargetType::name].
    UnknownValue(decimal_target_type::UnknownValue),
}

#[doc(hidden)]
pub mod decimal_target_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl DecimalTargetType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Numeric => std::option::Option::Some(1),
            Self::Bignumeric => std::option::Option::Some(2),
            Self::String => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("DECIMAL_TARGET_TYPE_UNSPECIFIED"),
            Self::Numeric => std::option::Option::Some("NUMERIC"),
            Self::Bignumeric => std::option::Option::Some("BIGNUMERIC"),
            Self::String => std::option::Option::Some("STRING"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for DecimalTargetType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for DecimalTargetType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for DecimalTargetType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Numeric,
            2 => Self::Bignumeric,
            3 => Self::String,
            _ => Self::UnknownValue(decimal_target_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for DecimalTargetType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "DECIMAL_TARGET_TYPE_UNSPECIFIED" => Self::Unspecified,
            "NUMERIC" => Self::Numeric,
            "BIGNUMERIC" => Self::Bignumeric,
            "STRING" => Self::String,
            _ => Self::UnknownValue(decimal_target_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for DecimalTargetType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Numeric => serializer.serialize_i32(1),
            Self::Bignumeric => serializer.serialize_i32(2),
            Self::String => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for DecimalTargetType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<DecimalTargetType>::new(
            ".google.cloud.bigquery.v2.DecimalTargetType",
        ))
    }
}

/// This enum defines how to interpret source URIs for load jobs and external
/// tables.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum FileSetSpecType {
    /// This option expands source URIs by listing files from the object store. It
    /// is the default behavior if FileSetSpecType is not set.
    FileSystemMatch,
    /// This option indicates that the provided URIs are newline-delimited manifest
    /// files, with one URI per line. Wildcard URIs are not supported.
    NewLineDelimitedManifest,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [FileSetSpecType::value] or
    /// [FileSetSpecType::name].
    UnknownValue(file_set_spec_type::UnknownValue),
}

#[doc(hidden)]
pub mod file_set_spec_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl FileSetSpecType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::FileSystemMatch => std::option::Option::Some(0),
            Self::NewLineDelimitedManifest => std::option::Option::Some(1),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::FileSystemMatch => {
                std::option::Option::Some("FILE_SET_SPEC_TYPE_FILE_SYSTEM_MATCH")
            }
            Self::NewLineDelimitedManifest => {
                std::option::Option::Some("FILE_SET_SPEC_TYPE_NEW_LINE_DELIMITED_MANIFEST")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for FileSetSpecType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for FileSetSpecType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for FileSetSpecType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::FileSystemMatch,
            1 => Self::NewLineDelimitedManifest,
            _ => Self::UnknownValue(file_set_spec_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for FileSetSpecType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "FILE_SET_SPEC_TYPE_FILE_SYSTEM_MATCH" => Self::FileSystemMatch,
            "FILE_SET_SPEC_TYPE_NEW_LINE_DELIMITED_MANIFEST" => Self::NewLineDelimitedManifest,
            _ => Self::UnknownValue(file_set_spec_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for FileSetSpecType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::FileSystemMatch => serializer.serialize_i32(0),
            Self::NewLineDelimitedManifest => serializer.serialize_i32(1),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for FileSetSpecType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<FileSetSpecType>::new(
            ".google.cloud.bigquery.v2.FileSetSpecType",
        ))
    }
}

/// Used to indicate that a JSON variant, rather than normal JSON, is being used
/// as the source_format. This should only be used in combination with the
/// JSON source format.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum JsonExtension {
    /// The default if provided value is not one included in the enum, or the value
    /// is not specified. The source format is parsed without any modification.
    Unspecified,
    /// Use GeoJSON variant of JSON. See <https://tools.ietf.org/html/rfc7946>.
    Geojson,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [JsonExtension::value] or
    /// [JsonExtension::name].
    UnknownValue(json_extension::UnknownValue),
}

#[doc(hidden)]
pub mod json_extension {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl JsonExtension {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Geojson => std::option::Option::Some(1),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("JSON_EXTENSION_UNSPECIFIED"),
            Self::Geojson => std::option::Option::Some("GEOJSON"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for JsonExtension {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for JsonExtension {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for JsonExtension {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Geojson,
            _ => Self::UnknownValue(json_extension::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for JsonExtension {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "JSON_EXTENSION_UNSPECIFIED" => Self::Unspecified,
            "GEOJSON" => Self::Geojson,
            _ => Self::UnknownValue(json_extension::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for JsonExtension {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Geojson => serializer.serialize_i32(1),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for JsonExtension {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<JsonExtension>::new(
            ".google.cloud.bigquery.v2.JsonExtension",
        ))
    }
}

/// The classification of managed table types that can be created.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ManagedTableType {
    /// No managed table type specified.
    Unspecified,
    /// The managed table is a native BigQuery table.
    Native,
    /// The managed table is a BigLake table for Apache Iceberg in BigQuery.
    Biglake,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ManagedTableType::value] or
    /// [ManagedTableType::name].
    UnknownValue(managed_table_type::UnknownValue),
}

#[doc(hidden)]
pub mod managed_table_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ManagedTableType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Native => std::option::Option::Some(1),
            Self::Biglake => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("MANAGED_TABLE_TYPE_UNSPECIFIED"),
            Self::Native => std::option::Option::Some("NATIVE"),
            Self::Biglake => std::option::Option::Some("BIGLAKE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ManagedTableType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ManagedTableType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ManagedTableType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Native,
            2 => Self::Biglake,
            _ => Self::UnknownValue(managed_table_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ManagedTableType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "MANAGED_TABLE_TYPE_UNSPECIFIED" => Self::Unspecified,
            "NATIVE" => Self::Native,
            "BIGLAKE" => Self::Biglake,
            _ => Self::UnknownValue(managed_table_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ManagedTableType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Native => serializer.serialize_i32(1),
            Self::Biglake => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ManagedTableType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ManagedTableType>::new(
            ".google.cloud.bigquery.v2.ManagedTableType",
        ))
    }
}

/// Indicates the map target type. Only applies to parquet maps.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum MapTargetType {
    /// In this mode, the map will have the following schema:
    /// struct map_field_name {  repeated struct key_value {  key  value  } }.
    Unspecified,
    /// In this mode, the map will have the following schema:
    /// repeated struct map_field_name {  key  value }.
    ArrayOfStruct,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [MapTargetType::value] or
    /// [MapTargetType::name].
    UnknownValue(map_target_type::UnknownValue),
}

#[doc(hidden)]
pub mod map_target_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl MapTargetType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::ArrayOfStruct => std::option::Option::Some(1),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("MAP_TARGET_TYPE_UNSPECIFIED"),
            Self::ArrayOfStruct => std::option::Option::Some("ARRAY_OF_STRUCT"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for MapTargetType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for MapTargetType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for MapTargetType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::ArrayOfStruct,
            _ => Self::UnknownValue(map_target_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for MapTargetType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "MAP_TARGET_TYPE_UNSPECIFIED" => Self::Unspecified,
            "ARRAY_OF_STRUCT" => Self::ArrayOfStruct,
            _ => Self::UnknownValue(map_target_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for MapTargetType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::ArrayOfStruct => serializer.serialize_i32(1),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for MapTargetType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<MapTargetType>::new(
            ".google.cloud.bigquery.v2.MapTargetType",
        ))
    }
}
