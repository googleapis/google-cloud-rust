// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.
#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]

use crate::Result;

/// Implements a client for the BigQuery API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_bigquery_v2::client::DatasetService;
/// let client = DatasetService::builder().build().await?;
/// // use `client` to make requests to the BigQuery API.
/// # gax::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// DatasetService provides methods for managing BigQuery datasets.
///
/// # Configuration
///
/// To configure `DatasetService` use the `with_*` methods in the type returned
/// by [builder()][DatasetService::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://bigquery.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::dataset_service::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::dataset_service::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `DatasetService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `DatasetService` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[derive(Clone, Debug)]
pub struct DatasetService {
    inner: std::sync::Arc<dyn super::stub::dynamic::DatasetService>,
}

impl DatasetService {
    /// Returns a builder for [DatasetService].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_bigquery_v2::client::DatasetService;
    /// let client = DatasetService::builder().build().await?;
    /// # gax::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::dataset_service::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::dataset_service::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::DatasetService + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(config: gaxi::options::ClientConfig) -> Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> Result<std::sync::Arc<dyn super::stub::dynamic::DatasetService>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> Result<impl super::stub::DatasetService> {
        super::transport::DatasetService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> Result<impl super::stub::DatasetService> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::DatasetService::new)
    }

    /// Returns the dataset specified by datasetID.
    pub fn get_dataset(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
    ) -> super::builder::dataset_service::GetDataset {
        super::builder::dataset_service::GetDataset::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_dataset_id(dataset_id.into())
    }

    /// Creates a new empty dataset.
    pub fn insert_dataset(
        &self,
        project_id: impl Into<std::string::String>,
    ) -> super::builder::dataset_service::InsertDataset {
        super::builder::dataset_service::InsertDataset::new(self.inner.clone())
            .set_project_id(project_id.into())
    }

    /// Updates information in an existing dataset. The update method replaces the
    /// entire dataset resource, whereas the patch method only replaces fields that
    /// are provided in the submitted dataset resource.
    /// This method supports RFC5789 patch semantics.
    pub fn patch_dataset(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
    ) -> super::builder::dataset_service::PatchDataset {
        super::builder::dataset_service::PatchDataset::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_dataset_id(dataset_id.into())
    }

    /// Updates information in an existing dataset. The update method replaces the
    /// entire dataset resource, whereas the patch method only replaces fields that
    /// are provided in the submitted dataset resource.
    pub fn update_dataset(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
    ) -> super::builder::dataset_service::UpdateDataset {
        super::builder::dataset_service::UpdateDataset::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_dataset_id(dataset_id.into())
    }

    /// Deletes the dataset specified by the datasetId value. Before you can delete
    /// a dataset, you must delete all its tables, either manually or by specifying
    /// deleteContents. Immediately after deletion, you can create another dataset
    /// with the same name.
    pub fn delete_dataset(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
    ) -> super::builder::dataset_service::DeleteDataset {
        super::builder::dataset_service::DeleteDataset::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_dataset_id(dataset_id.into())
    }

    /// Lists all datasets in the specified project to which the user has been
    /// granted the READER dataset role.
    pub fn list_datasets(
        &self,
        project_id: impl Into<std::string::String>,
    ) -> super::builder::dataset_service::ListDatasets {
        super::builder::dataset_service::ListDatasets::new(self.inner.clone())
            .set_project_id(project_id.into())
    }

    /// Undeletes a dataset which is within time travel window based on datasetId.
    /// If a time is specified, the dataset version deleted at that time is
    /// undeleted, else the last live version is undeleted.
    pub fn undelete_dataset(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
    ) -> super::builder::dataset_service::UndeleteDataset {
        super::builder::dataset_service::UndeleteDataset::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_dataset_id(dataset_id.into())
    }
}

/// Implements a client for the BigQuery API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_bigquery_v2::client::ModelService;
/// let client = ModelService::builder().build().await?;
/// // use `client` to make requests to the BigQuery API.
/// # gax::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Model Service for BigQuery ML
///
/// # Configuration
///
/// To configure `ModelService` use the `with_*` methods in the type returned
/// by [builder()][ModelService::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://bigquery.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::model_service::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::model_service::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `ModelService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `ModelService` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[derive(Clone, Debug)]
pub struct ModelService {
    inner: std::sync::Arc<dyn super::stub::dynamic::ModelService>,
}

impl ModelService {
    /// Returns a builder for [ModelService].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_bigquery_v2::client::ModelService;
    /// let client = ModelService::builder().build().await?;
    /// # gax::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::model_service::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::model_service::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::ModelService + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(config: gaxi::options::ClientConfig) -> Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> Result<std::sync::Arc<dyn super::stub::dynamic::ModelService>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> Result<impl super::stub::ModelService> {
        super::transport::ModelService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> Result<impl super::stub::ModelService> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::ModelService::new)
    }

    /// Gets the specified model resource by model ID.
    pub fn get_model(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
        model_id: impl Into<std::string::String>,
    ) -> super::builder::model_service::GetModel {
        super::builder::model_service::GetModel::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_dataset_id(dataset_id.into())
            .set_model_id(model_id.into())
    }

    /// Lists all models in the specified dataset. Requires the READER dataset
    /// role. After retrieving the list of models, you can get information about a
    /// particular model by calling the models.get method.
    pub fn list_models(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
    ) -> super::builder::model_service::ListModels {
        super::builder::model_service::ListModels::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_dataset_id(dataset_id.into())
    }

    /// Patch specific fields in the specified model.
    pub fn patch_model(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
        model_id: impl Into<std::string::String>,
    ) -> super::builder::model_service::PatchModel {
        super::builder::model_service::PatchModel::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_dataset_id(dataset_id.into())
            .set_model_id(model_id.into())
    }

    /// Deletes the model specified by modelId from the dataset.
    pub fn delete_model(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
        model_id: impl Into<std::string::String>,
    ) -> super::builder::model_service::DeleteModel {
        super::builder::model_service::DeleteModel::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_dataset_id(dataset_id.into())
            .set_model_id(model_id.into())
    }
}

/// Implements a client for the BigQuery API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_bigquery_v2::client::ProjectService;
/// let client = ProjectService::builder().build().await?;
/// // use `client` to make requests to the BigQuery API.
/// # gax::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// This service provides access to BigQuery functionality related to projects.
///
/// # Configuration
///
/// To configure `ProjectService` use the `with_*` methods in the type returned
/// by [builder()][ProjectService::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://bigquery.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::project_service::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::project_service::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `ProjectService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `ProjectService` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[derive(Clone, Debug)]
pub struct ProjectService {
    inner: std::sync::Arc<dyn super::stub::dynamic::ProjectService>,
}

impl ProjectService {
    /// Returns a builder for [ProjectService].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_bigquery_v2::client::ProjectService;
    /// let client = ProjectService::builder().build().await?;
    /// # gax::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::project_service::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::project_service::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::ProjectService + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(config: gaxi::options::ClientConfig) -> Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> Result<std::sync::Arc<dyn super::stub::dynamic::ProjectService>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> Result<impl super::stub::ProjectService> {
        super::transport::ProjectService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> Result<impl super::stub::ProjectService> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::ProjectService::new)
    }

    /// RPC to get the service account for a project used for interactions with
    /// Google Cloud KMS
    pub fn get_service_account(
        &self,
        project_id: impl Into<std::string::String>,
    ) -> super::builder::project_service::GetServiceAccount {
        super::builder::project_service::GetServiceAccount::new(self.inner.clone())
            .set_project_id(project_id.into())
    }
}

/// Implements a client for the BigQuery API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_bigquery_v2::client::RoutineService;
/// let client = RoutineService::builder().build().await?;
/// // use `client` to make requests to the BigQuery API.
/// # gax::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// RoutineService provides management access to BigQuery routines.
///
/// # Configuration
///
/// To configure `RoutineService` use the `with_*` methods in the type returned
/// by [builder()][RoutineService::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://bigquery.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::routine_service::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::routine_service::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `RoutineService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `RoutineService` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[derive(Clone, Debug)]
pub struct RoutineService {
    inner: std::sync::Arc<dyn super::stub::dynamic::RoutineService>,
}

impl RoutineService {
    /// Returns a builder for [RoutineService].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_bigquery_v2::client::RoutineService;
    /// let client = RoutineService::builder().build().await?;
    /// # gax::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::routine_service::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::routine_service::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::RoutineService + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(config: gaxi::options::ClientConfig) -> Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> Result<std::sync::Arc<dyn super::stub::dynamic::RoutineService>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> Result<impl super::stub::RoutineService> {
        super::transport::RoutineService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> Result<impl super::stub::RoutineService> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::RoutineService::new)
    }

    /// Gets the specified routine resource by routine ID.
    pub fn get_routine(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
        routine_id: impl Into<std::string::String>,
    ) -> super::builder::routine_service::GetRoutine {
        super::builder::routine_service::GetRoutine::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_dataset_id(dataset_id.into())
            .set_routine_id(routine_id.into())
    }

    /// Creates a new routine in the dataset.
    pub fn insert_routine(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
    ) -> super::builder::routine_service::InsertRoutine {
        super::builder::routine_service::InsertRoutine::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_dataset_id(dataset_id.into())
    }

    /// Updates information in an existing routine. The update method replaces the
    /// entire Routine resource.
    pub fn update_routine(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
        routine_id: impl Into<std::string::String>,
    ) -> super::builder::routine_service::UpdateRoutine {
        super::builder::routine_service::UpdateRoutine::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_dataset_id(dataset_id.into())
            .set_routine_id(routine_id.into())
    }

    /// Deletes the routine specified by routineId from the dataset.
    pub fn delete_routine(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
        routine_id: impl Into<std::string::String>,
    ) -> super::builder::routine_service::DeleteRoutine {
        super::builder::routine_service::DeleteRoutine::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_dataset_id(dataset_id.into())
            .set_routine_id(routine_id.into())
    }

    /// Lists all routines in the specified dataset. Requires the READER dataset
    /// role.
    pub fn list_routines(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
    ) -> super::builder::routine_service::ListRoutines {
        super::builder::routine_service::ListRoutines::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_dataset_id(dataset_id.into())
    }
}

/// Implements a client for the BigQuery API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_bigquery_v2::client::RowAccessPolicyService;
/// let client = RowAccessPolicyService::builder().build().await?;
/// // use `client` to make requests to the BigQuery API.
/// # gax::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for interacting with row access policies.
///
/// # Configuration
///
/// To configure `RowAccessPolicyService` use the `with_*` methods in the type returned
/// by [builder()][RowAccessPolicyService::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://bigquery.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::row_access_policy_service::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::row_access_policy_service::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `RowAccessPolicyService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `RowAccessPolicyService` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[derive(Clone, Debug)]
pub struct RowAccessPolicyService {
    inner: std::sync::Arc<dyn super::stub::dynamic::RowAccessPolicyService>,
}

impl RowAccessPolicyService {
    /// Returns a builder for [RowAccessPolicyService].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_bigquery_v2::client::RowAccessPolicyService;
    /// let client = RowAccessPolicyService::builder().build().await?;
    /// # gax::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::row_access_policy_service::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::row_access_policy_service::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::RowAccessPolicyService + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(config: gaxi::options::ClientConfig) -> Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> Result<std::sync::Arc<dyn super::stub::dynamic::RowAccessPolicyService>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> Result<impl super::stub::RowAccessPolicyService> {
        super::transport::RowAccessPolicyService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> Result<impl super::stub::RowAccessPolicyService> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::RowAccessPolicyService::new)
    }

    /// Lists all row access policies on the specified table.
    pub fn list_row_access_policies(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
        table_id: impl Into<std::string::String>,
    ) -> super::builder::row_access_policy_service::ListRowAccessPolicies {
        super::builder::row_access_policy_service::ListRowAccessPolicies::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_dataset_id(dataset_id.into())
            .set_table_id(table_id.into())
    }

    /// Gets the specified row access policy by policy ID.
    pub fn get_row_access_policy(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
        table_id: impl Into<std::string::String>,
        policy_id: impl Into<std::string::String>,
    ) -> super::builder::row_access_policy_service::GetRowAccessPolicy {
        super::builder::row_access_policy_service::GetRowAccessPolicy::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_dataset_id(dataset_id.into())
            .set_table_id(table_id.into())
            .set_policy_id(policy_id.into())
    }

    /// Creates a row access policy.
    pub fn create_row_access_policy(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
        table_id: impl Into<std::string::String>,
    ) -> super::builder::row_access_policy_service::CreateRowAccessPolicy {
        super::builder::row_access_policy_service::CreateRowAccessPolicy::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_dataset_id(dataset_id.into())
            .set_table_id(table_id.into())
    }

    /// Updates a row access policy.
    pub fn update_row_access_policy(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
        table_id: impl Into<std::string::String>,
        policy_id: impl Into<std::string::String>,
    ) -> super::builder::row_access_policy_service::UpdateRowAccessPolicy {
        super::builder::row_access_policy_service::UpdateRowAccessPolicy::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_dataset_id(dataset_id.into())
            .set_table_id(table_id.into())
            .set_policy_id(policy_id.into())
    }

    /// Deletes a row access policy.
    pub fn delete_row_access_policy(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
        table_id: impl Into<std::string::String>,
        policy_id: impl Into<std::string::String>,
    ) -> super::builder::row_access_policy_service::DeleteRowAccessPolicy {
        super::builder::row_access_policy_service::DeleteRowAccessPolicy::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_dataset_id(dataset_id.into())
            .set_table_id(table_id.into())
            .set_policy_id(policy_id.into())
    }

    /// Deletes provided row access policies.
    pub fn batch_delete_row_access_policies(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
        table_id: impl Into<std::string::String>,
    ) -> super::builder::row_access_policy_service::BatchDeleteRowAccessPolicies {
        super::builder::row_access_policy_service::BatchDeleteRowAccessPolicies::new(
            self.inner.clone(),
        )
        .set_project_id(project_id.into())
        .set_dataset_id(dataset_id.into())
        .set_table_id(table_id.into())
    }
}

/// Implements a client for the BigQuery API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_bigquery_v2::client::TableService;
/// let client = TableService::builder().build().await?;
/// // use `client` to make requests to the BigQuery API.
/// # gax::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// TableService provides methods for managing BigQuery tables and table-like
/// entities such as views and snapshots.
///
/// # Configuration
///
/// To configure `TableService` use the `with_*` methods in the type returned
/// by [builder()][TableService::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://bigquery.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::table_service::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::table_service::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `TableService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `TableService` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[derive(Clone, Debug)]
pub struct TableService {
    inner: std::sync::Arc<dyn super::stub::dynamic::TableService>,
}

impl TableService {
    /// Returns a builder for [TableService].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_bigquery_v2::client::TableService;
    /// let client = TableService::builder().build().await?;
    /// # gax::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::table_service::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::table_service::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::TableService + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(config: gaxi::options::ClientConfig) -> Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> Result<std::sync::Arc<dyn super::stub::dynamic::TableService>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> Result<impl super::stub::TableService> {
        super::transport::TableService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> Result<impl super::stub::TableService> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::TableService::new)
    }

    /// Gets the specified table resource by table ID.
    /// This method does not return the data in the table, it only returns the
    /// table resource, which describes the structure of this table.
    pub fn get_table(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
        table_id: impl Into<std::string::String>,
    ) -> super::builder::table_service::GetTable {
        super::builder::table_service::GetTable::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_dataset_id(dataset_id.into())
            .set_table_id(table_id.into())
    }

    /// Creates a new, empty table in the dataset.
    pub fn insert_table(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
    ) -> super::builder::table_service::InsertTable {
        super::builder::table_service::InsertTable::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_dataset_id(dataset_id.into())
    }

    /// Updates information in an existing table. The update method replaces the
    /// entire table resource, whereas the patch method only replaces fields that
    /// are provided in the submitted table resource.
    /// This method supports RFC5789 patch semantics.
    pub fn patch_table(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
        table_id: impl Into<std::string::String>,
    ) -> super::builder::table_service::PatchTable {
        super::builder::table_service::PatchTable::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_dataset_id(dataset_id.into())
            .set_table_id(table_id.into())
    }

    /// Updates information in an existing table. The update method replaces the
    /// entire Table resource, whereas the patch method only replaces fields that
    /// are provided in the submitted Table resource.
    pub fn update_table(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
        table_id: impl Into<std::string::String>,
    ) -> super::builder::table_service::UpdateTable {
        super::builder::table_service::UpdateTable::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_dataset_id(dataset_id.into())
            .set_table_id(table_id.into())
    }

    /// Deletes the table specified by tableId from the dataset.
    /// If the table contains data, all the data will be deleted.
    pub fn delete_table(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
        table_id: impl Into<std::string::String>,
    ) -> super::builder::table_service::DeleteTable {
        super::builder::table_service::DeleteTable::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_dataset_id(dataset_id.into())
            .set_table_id(table_id.into())
    }

    /// Lists all tables in the specified dataset. Requires the READER dataset
    /// role.
    pub fn list_tables(
        &self,
        project_id: impl Into<std::string::String>,
        dataset_id: impl Into<std::string::String>,
    ) -> super::builder::table_service::ListTables {
        super::builder::table_service::ListTables::new(self.inner.clone())
            .set_project_id(project_id.into())
            .set_dataset_id(dataset_id.into())
    }
}
