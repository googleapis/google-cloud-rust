// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate iam_v1;
extern crate lazy_static;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// The request for
/// [ConnectionService.CreateConnection][google.cloud.bigquery.connection.v1.ConnectionService.CreateConnection].
///
/// [google.cloud.bigquery.connection.v1.ConnectionService.CreateConnection]: crate::client::ConnectionService::create_connection
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateConnectionRequest {
    /// Required. Parent resource name.
    /// Must be in the format `projects/{project_id}/locations/{location_id}`
    pub parent: std::string::String,

    /// Optional. Connection id that should be assigned to the created connection.
    pub connection_id: std::string::String,

    /// Required. Connection to create.
    pub connection: std::option::Option<crate::model::Connection>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateConnectionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [connection_id][crate::model::CreateConnectionRequest::connection_id].
    pub fn set_connection_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.connection_id = v.into();
        self
    }

    /// Sets the value of [connection][crate::model::CreateConnectionRequest::connection].
    pub fn set_connection<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Connection>,
    {
        self.connection = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [connection][crate::model::CreateConnectionRequest::connection].
    pub fn set_or_clear_connection<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Connection>,
    {
        self.connection = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.connection.v1.CreateConnectionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateConnectionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __connection_id,
            __connection,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateConnectionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "connectionId" => Ok(__FieldTag::__connection_id),
                            "connection_id" => Ok(__FieldTag::__connection_id),
                            "connection" => Ok(__FieldTag::__connection),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateConnectionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateConnectionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__connection_id => {
                            if !fields.insert(__FieldTag::__connection_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection_id",
                                ));
                            }
                            result.connection_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__connection => {
                            if !fields.insert(__FieldTag::__connection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection",
                                ));
                            }
                            result.connection =
                                map.next_value::<std::option::Option<crate::model::Connection>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateConnectionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.connection_id.is_empty() {
            state.serialize_entry("connectionId", &self.connection_id)?;
        }
        if self.connection.is_some() {
            state.serialize_entry("connection", &self.connection)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateConnectionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateConnectionRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("connection_id", &self.connection_id);
        debug_struct.field("connection", &self.connection);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for
/// [ConnectionService.GetConnection][google.cloud.bigquery.connection.v1.ConnectionService.GetConnection].
///
/// [google.cloud.bigquery.connection.v1.ConnectionService.GetConnection]: crate::client::ConnectionService::get_connection
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetConnectionRequest {
    /// Required. Name of the requested connection, for example:
    /// `projects/{project_id}/locations/{location_id}/connections/{connection_id}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetConnectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.connection.v1.GetConnectionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetConnectionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetConnectionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetConnectionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetConnectionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetConnectionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetConnectionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetConnectionRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for
/// [ConnectionService.ListConnections][google.cloud.bigquery.connection.v1.ConnectionService.ListConnections].
///
/// [google.cloud.bigquery.connection.v1.ConnectionService.ListConnections]: crate::client::ConnectionService::list_connections
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListConnectionsRequest {
    /// Required. Parent resource name.
    /// Must be in the form: `projects/{project_id}/locations/{location_id}`
    pub parent: std::string::String,

    /// Required. Page size.
    pub page_size: i32,

    /// Page token.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConnectionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListConnectionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListConnectionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListConnectionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListConnectionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.connection.v1.ListConnectionsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListConnectionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListConnectionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListConnectionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListConnectionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListConnectionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListConnectionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListConnectionsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response for
/// [ConnectionService.ListConnections][google.cloud.bigquery.connection.v1.ConnectionService.ListConnections].
///
/// [google.cloud.bigquery.connection.v1.ConnectionService.ListConnections]: crate::client::ConnectionService::list_connections
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListConnectionsResponse {
    /// Next page token.
    pub next_page_token: std::string::String,

    /// List of connections.
    pub connections: std::vec::Vec<crate::model::Connection>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConnectionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListConnectionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [connections][crate::model::ListConnectionsResponse::connections].
    pub fn set_connections<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Connection>,
    {
        use std::iter::Iterator;
        self.connections = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListConnectionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.connection.v1.ListConnectionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListConnectionsResponse {
    type PageItem = crate::model::Connection;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.connections
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListConnectionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __next_page_token,
            __connections,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListConnectionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "connections" => Ok(__FieldTag::__connections),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListConnectionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListConnectionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__connections => {
                            if !fields.insert(__FieldTag::__connections) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connections",
                                ));
                            }
                            result.connections = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Connection>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListConnectionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.connections.is_empty() {
            state.serialize_entry("connections", &self.connections)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListConnectionsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListConnectionsResponse");
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("connections", &self.connections);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for
/// [ConnectionService.UpdateConnection][google.cloud.bigquery.connection.v1.ConnectionService.UpdateConnection].
///
/// [google.cloud.bigquery.connection.v1.ConnectionService.UpdateConnection]: crate::client::ConnectionService::update_connection
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateConnectionRequest {
    /// Required. Name of the connection to update, for example:
    /// `projects/{project_id}/locations/{location_id}/connections/{connection_id}`
    pub name: std::string::String,

    /// Required. Connection containing the updated fields.
    pub connection: std::option::Option<crate::model::Connection>,

    /// Required. Update mask for the connection fields to be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateConnectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [connection][crate::model::UpdateConnectionRequest::connection].
    pub fn set_connection<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Connection>,
    {
        self.connection = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [connection][crate::model::UpdateConnectionRequest::connection].
    pub fn set_or_clear_connection<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Connection>,
    {
        self.connection = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateConnectionRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateConnectionRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.connection.v1.UpdateConnectionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateConnectionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __connection,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateConnectionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "connection" => Ok(__FieldTag::__connection),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateConnectionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateConnectionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__connection => {
                            if !fields.insert(__FieldTag::__connection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection",
                                ));
                            }
                            result.connection =
                                map.next_value::<std::option::Option<crate::model::Connection>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateConnectionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.connection.is_some() {
            state.serialize_entry("connection", &self.connection)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateConnectionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateConnectionRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("connection", &self.connection);
        debug_struct.field("update_mask", &self.update_mask);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for [ConnectionService.DeleteConnectionRequest][].
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteConnectionRequest {
    /// Required. Name of the deleted connection, for example:
    /// `projects/{project_id}/locations/{location_id}/connections/{connection_id}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteConnectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.connection.v1.DeleteConnectionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteConnectionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteConnectionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteConnectionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteConnectionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteConnectionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteConnectionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteConnectionRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configuration parameters to establish connection with an external data
/// source, except the credential attributes.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Connection {
    /// The resource name of the connection in the form of:
    /// `projects/{project_id}/locations/{location_id}/connections/{connection_id}`
    pub name: std::string::String,

    /// User provided display name for the connection.
    pub friendly_name: std::string::String,

    /// User provided description.
    pub description: std::string::String,

    /// Output only. The creation timestamp of the connection.
    pub creation_time: i64,

    /// Output only. The last update timestamp of the connection.
    pub last_modified_time: i64,

    /// Output only. True, if credential is configured for this connection.
    pub has_credential: bool,

    /// Properties specific to the underlying data source.
    pub properties: std::option::Option<crate::model::connection::Properties>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Connection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Connection::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [friendly_name][crate::model::Connection::friendly_name].
    pub fn set_friendly_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.friendly_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Connection::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [creation_time][crate::model::Connection::creation_time].
    pub fn set_creation_time<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.creation_time = v.into();
        self
    }

    /// Sets the value of [last_modified_time][crate::model::Connection::last_modified_time].
    pub fn set_last_modified_time<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.last_modified_time = v.into();
        self
    }

    /// Sets the value of [has_credential][crate::model::Connection::has_credential].
    pub fn set_has_credential<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.has_credential = v.into();
        self
    }

    /// Sets the value of [properties][crate::model::Connection::properties].
    ///
    /// Note that all the setters affecting `properties` are mutually
    /// exclusive.
    pub fn set_properties<
        T: std::convert::Into<std::option::Option<crate::model::connection::Properties>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.properties = v.into();
        self
    }

    /// The value of [properties][crate::model::Connection::properties]
    /// if it holds a `CloudSql`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_sql(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudSqlProperties>> {
        #[allow(unreachable_patterns)]
        self.properties.as_ref().and_then(|v| match v {
            crate::model::connection::Properties::CloudSql(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [properties][crate::model::Connection::properties]
    /// to hold a `CloudSql`.
    ///
    /// Note that all the setters affecting `properties` are
    /// mutually exclusive.
    pub fn set_cloud_sql<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudSqlProperties>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.properties =
            std::option::Option::Some(crate::model::connection::Properties::CloudSql(v.into()));
        self
    }

    /// The value of [properties][crate::model::Connection::properties]
    /// if it holds a `Aws`, `None` if the field is not set or
    /// holds a different branch.
    pub fn aws(&self) -> std::option::Option<&std::boxed::Box<crate::model::AwsProperties>> {
        #[allow(unreachable_patterns)]
        self.properties.as_ref().and_then(|v| match v {
            crate::model::connection::Properties::Aws(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [properties][crate::model::Connection::properties]
    /// to hold a `Aws`.
    ///
    /// Note that all the setters affecting `properties` are
    /// mutually exclusive.
    pub fn set_aws<T: std::convert::Into<std::boxed::Box<crate::model::AwsProperties>>>(
        mut self,
        v: T,
    ) -> Self {
        self.properties =
            std::option::Option::Some(crate::model::connection::Properties::Aws(v.into()));
        self
    }

    /// The value of [properties][crate::model::Connection::properties]
    /// if it holds a `Azure`, `None` if the field is not set or
    /// holds a different branch.
    pub fn azure(&self) -> std::option::Option<&std::boxed::Box<crate::model::AzureProperties>> {
        #[allow(unreachable_patterns)]
        self.properties.as_ref().and_then(|v| match v {
            crate::model::connection::Properties::Azure(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [properties][crate::model::Connection::properties]
    /// to hold a `Azure`.
    ///
    /// Note that all the setters affecting `properties` are
    /// mutually exclusive.
    pub fn set_azure<T: std::convert::Into<std::boxed::Box<crate::model::AzureProperties>>>(
        mut self,
        v: T,
    ) -> Self {
        self.properties =
            std::option::Option::Some(crate::model::connection::Properties::Azure(v.into()));
        self
    }

    /// The value of [properties][crate::model::Connection::properties]
    /// if it holds a `CloudSpanner`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_spanner(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudSpannerProperties>> {
        #[allow(unreachable_patterns)]
        self.properties.as_ref().and_then(|v| match v {
            crate::model::connection::Properties::CloudSpanner(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [properties][crate::model::Connection::properties]
    /// to hold a `CloudSpanner`.
    ///
    /// Note that all the setters affecting `properties` are
    /// mutually exclusive.
    pub fn set_cloud_spanner<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudSpannerProperties>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.properties =
            std::option::Option::Some(crate::model::connection::Properties::CloudSpanner(v.into()));
        self
    }

    /// The value of [properties][crate::model::Connection::properties]
    /// if it holds a `CloudResource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_resource(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudResourceProperties>> {
        #[allow(unreachable_patterns)]
        self.properties.as_ref().and_then(|v| match v {
            crate::model::connection::Properties::CloudResource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [properties][crate::model::Connection::properties]
    /// to hold a `CloudResource`.
    ///
    /// Note that all the setters affecting `properties` are
    /// mutually exclusive.
    pub fn set_cloud_resource<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudResourceProperties>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.properties = std::option::Option::Some(
            crate::model::connection::Properties::CloudResource(v.into()),
        );
        self
    }

    /// The value of [properties][crate::model::Connection::properties]
    /// if it holds a `Spark`, `None` if the field is not set or
    /// holds a different branch.
    pub fn spark(&self) -> std::option::Option<&std::boxed::Box<crate::model::SparkProperties>> {
        #[allow(unreachable_patterns)]
        self.properties.as_ref().and_then(|v| match v {
            crate::model::connection::Properties::Spark(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [properties][crate::model::Connection::properties]
    /// to hold a `Spark`.
    ///
    /// Note that all the setters affecting `properties` are
    /// mutually exclusive.
    pub fn set_spark<T: std::convert::Into<std::boxed::Box<crate::model::SparkProperties>>>(
        mut self,
        v: T,
    ) -> Self {
        self.properties =
            std::option::Option::Some(crate::model::connection::Properties::Spark(v.into()));
        self
    }

    /// The value of [properties][crate::model::Connection::properties]
    /// if it holds a `SalesforceDataCloud`, `None` if the field is not set or
    /// holds a different branch.
    pub fn salesforce_data_cloud(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SalesforceDataCloudProperties>> {
        #[allow(unreachable_patterns)]
        self.properties.as_ref().and_then(|v| match v {
            crate::model::connection::Properties::SalesforceDataCloud(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [properties][crate::model::Connection::properties]
    /// to hold a `SalesforceDataCloud`.
    ///
    /// Note that all the setters affecting `properties` are
    /// mutually exclusive.
    pub fn set_salesforce_data_cloud<
        T: std::convert::Into<std::boxed::Box<crate::model::SalesforceDataCloudProperties>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.properties = std::option::Option::Some(
            crate::model::connection::Properties::SalesforceDataCloud(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Connection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.connection.v1.Connection"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Connection {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __friendly_name,
            __description,
            __cloud_sql,
            __aws,
            __azure,
            __cloud_spanner,
            __cloud_resource,
            __spark,
            __salesforce_data_cloud,
            __creation_time,
            __last_modified_time,
            __has_credential,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Connection")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "friendlyName" => Ok(__FieldTag::__friendly_name),
                            "friendly_name" => Ok(__FieldTag::__friendly_name),
                            "description" => Ok(__FieldTag::__description),
                            "cloudSql" => Ok(__FieldTag::__cloud_sql),
                            "cloud_sql" => Ok(__FieldTag::__cloud_sql),
                            "aws" => Ok(__FieldTag::__aws),
                            "azure" => Ok(__FieldTag::__azure),
                            "cloudSpanner" => Ok(__FieldTag::__cloud_spanner),
                            "cloud_spanner" => Ok(__FieldTag::__cloud_spanner),
                            "cloudResource" => Ok(__FieldTag::__cloud_resource),
                            "cloud_resource" => Ok(__FieldTag::__cloud_resource),
                            "spark" => Ok(__FieldTag::__spark),
                            "salesforceDataCloud" => Ok(__FieldTag::__salesforce_data_cloud),
                            "salesforce_data_cloud" => Ok(__FieldTag::__salesforce_data_cloud),
                            "creationTime" => Ok(__FieldTag::__creation_time),
                            "creation_time" => Ok(__FieldTag::__creation_time),
                            "lastModifiedTime" => Ok(__FieldTag::__last_modified_time),
                            "last_modified_time" => Ok(__FieldTag::__last_modified_time),
                            "hasCredential" => Ok(__FieldTag::__has_credential),
                            "has_credential" => Ok(__FieldTag::__has_credential),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Connection;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Connection")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__friendly_name => {
                            if !fields.insert(__FieldTag::__friendly_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for friendly_name",
                                ));
                            }
                            result.friendly_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cloud_sql => {
                            if !fields.insert(__FieldTag::__cloud_sql) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_sql",
                                ));
                            }
                            if result.properties.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `properties`, a oneof with full ID .google.cloud.bigquery.connection.v1.Connection.cloud_sql, latest field was cloudSql",
                                ));
                            }
                            result.properties = std::option::Option::Some(
                                crate::model::connection::Properties::CloudSql(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::CloudSqlProperties>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__aws => {
                            if !fields.insert(__FieldTag::__aws) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aws",
                                ));
                            }
                            if result.properties.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `properties`, a oneof with full ID .google.cloud.bigquery.connection.v1.Connection.aws, latest field was aws",
                                ));
                            }
                            result.properties = std::option::Option::Some(
                                crate::model::connection::Properties::Aws(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AwsProperties>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__azure => {
                            if !fields.insert(__FieldTag::__azure) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for azure",
                                ));
                            }
                            if result.properties.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `properties`, a oneof with full ID .google.cloud.bigquery.connection.v1.Connection.azure, latest field was azure",
                                ));
                            }
                            result.properties = std::option::Option::Some(
                                crate::model::connection::Properties::Azure(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AzureProperties>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__cloud_spanner => {
                            if !fields.insert(__FieldTag::__cloud_spanner) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_spanner",
                                ));
                            }
                            if result.properties.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `properties`, a oneof with full ID .google.cloud.bigquery.connection.v1.Connection.cloud_spanner, latest field was cloudSpanner",
                                ));
                            }
                            result.properties = std::option::Option::Some(
                                crate::model::connection::Properties::CloudSpanner(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::CloudSpannerProperties>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__cloud_resource => {
                            if !fields.insert(__FieldTag::__cloud_resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_resource",
                                ));
                            }
                            if result.properties.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `properties`, a oneof with full ID .google.cloud.bigquery.connection.v1.Connection.cloud_resource, latest field was cloudResource",
                                ));
                            }
                            result.properties = std::option::Option::Some(
                                crate::model::connection::Properties::CloudResource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::CloudResourceProperties>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__spark => {
                            if !fields.insert(__FieldTag::__spark) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for spark",
                                ));
                            }
                            if result.properties.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `properties`, a oneof with full ID .google.cloud.bigquery.connection.v1.Connection.spark, latest field was spark",
                                ));
                            }
                            result.properties = std::option::Option::Some(
                                crate::model::connection::Properties::Spark(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SparkProperties>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__salesforce_data_cloud => {
                            if !fields.insert(__FieldTag::__salesforce_data_cloud) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for salesforce_data_cloud",
                                ));
                            }
                            if result.properties.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `properties`, a oneof with full ID .google.cloud.bigquery.connection.v1.Connection.salesforce_data_cloud, latest field was salesforceDataCloud",
                                ));
                            }
                            result.properties = std::option::Option::Some(
                                crate::model::connection::Properties::SalesforceDataCloud(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::SalesforceDataCloudProperties,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__creation_time => {
                            if !fields.insert(__FieldTag::__creation_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for creation_time",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.creation_time =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__last_modified_time => {
                            if !fields.insert(__FieldTag::__last_modified_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_modified_time",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.last_modified_time =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__has_credential => {
                            if !fields.insert(__FieldTag::__has_credential) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for has_credential",
                                ));
                            }
                            result.has_credential = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Connection {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.friendly_name.is_empty() {
            state.serialize_entry("friendlyName", &self.friendly_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if let Some(value) = self.cloud_sql() {
            state.serialize_entry("cloudSql", value)?;
        }
        if let Some(value) = self.aws() {
            state.serialize_entry("aws", value)?;
        }
        if let Some(value) = self.azure() {
            state.serialize_entry("azure", value)?;
        }
        if let Some(value) = self.cloud_spanner() {
            state.serialize_entry("cloudSpanner", value)?;
        }
        if let Some(value) = self.cloud_resource() {
            state.serialize_entry("cloudResource", value)?;
        }
        if let Some(value) = self.spark() {
            state.serialize_entry("spark", value)?;
        }
        if let Some(value) = self.salesforce_data_cloud() {
            state.serialize_entry("salesforceDataCloud", value)?;
        }
        if !wkt::internal::is_default(&self.creation_time) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("creationTime", &__With(&self.creation_time))?;
        }
        if !wkt::internal::is_default(&self.last_modified_time) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("lastModifiedTime", &__With(&self.last_modified_time))?;
        }
        if !wkt::internal::is_default(&self.has_credential) {
            state.serialize_entry("hasCredential", &self.has_credential)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Connection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Connection");
        debug_struct.field("name", &self.name);
        debug_struct.field("friendly_name", &self.friendly_name);
        debug_struct.field("description", &self.description);
        debug_struct.field("creation_time", &self.creation_time);
        debug_struct.field("last_modified_time", &self.last_modified_time);
        debug_struct.field("has_credential", &self.has_credential);
        debug_struct.field("properties", &self.properties);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Connection].
pub mod connection {
    #[allow(unused_imports)]
    use super::*;

    /// Properties specific to the underlying data source.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Properties {
        /// Cloud SQL properties.
        CloudSql(std::boxed::Box<crate::model::CloudSqlProperties>),
        /// Amazon Web Services (AWS) properties.
        Aws(std::boxed::Box<crate::model::AwsProperties>),
        /// Azure properties.
        Azure(std::boxed::Box<crate::model::AzureProperties>),
        /// Cloud Spanner properties.
        CloudSpanner(std::boxed::Box<crate::model::CloudSpannerProperties>),
        /// Cloud Resource properties.
        CloudResource(std::boxed::Box<crate::model::CloudResourceProperties>),
        /// Spark properties.
        Spark(std::boxed::Box<crate::model::SparkProperties>),
        /// Optional. Salesforce DataCloud properties. This field is intended for
        /// use only by Salesforce partner projects. This field contains properties
        /// for your Salesforce DataCloud connection.
        SalesforceDataCloud(std::boxed::Box<crate::model::SalesforceDataCloudProperties>),
    }
}

/// Connection properties specific to the Cloud SQL.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudSqlProperties {
    /// Cloud SQL instance ID in the form `project:location:instance`.
    pub instance_id: std::string::String,

    /// Database name.
    pub database: std::string::String,

    /// Type of the Cloud SQL database.
    pub r#type: crate::model::cloud_sql_properties::DatabaseType,

    /// Input only. Cloud SQL credential.
    pub credential: std::option::Option<crate::model::CloudSqlCredential>,

    /// Output only. The account ID of the service used for the purpose of this
    /// connection.
    ///
    /// When the connection is used in the context of an operation in
    /// BigQuery, this service account will serve as the identity being used for
    /// connecting to the CloudSQL instance specified in this connection.
    pub service_account_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudSqlProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_id][crate::model::CloudSqlProperties::instance_id].
    pub fn set_instance_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_id = v.into();
        self
    }

    /// Sets the value of [database][crate::model::CloudSqlProperties::database].
    pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::CloudSqlProperties::type].
    pub fn set_type<T: std::convert::Into<crate::model::cloud_sql_properties::DatabaseType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [credential][crate::model::CloudSqlProperties::credential].
    pub fn set_credential<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CloudSqlCredential>,
    {
        self.credential = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [credential][crate::model::CloudSqlProperties::credential].
    pub fn set_or_clear_credential<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CloudSqlCredential>,
    {
        self.credential = v.map(|x| x.into());
        self
    }

    /// Sets the value of [service_account_id][crate::model::CloudSqlProperties::service_account_id].
    pub fn set_service_account_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_account_id = v.into();
        self
    }
}

impl wkt::message::Message for CloudSqlProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.connection.v1.CloudSqlProperties"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudSqlProperties {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance_id,
            __database,
            __type,
            __credential,
            __service_account_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudSqlProperties")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instanceId" => Ok(__FieldTag::__instance_id),
                            "instance_id" => Ok(__FieldTag::__instance_id),
                            "database" => Ok(__FieldTag::__database),
                            "type" => Ok(__FieldTag::__type),
                            "credential" => Ok(__FieldTag::__credential),
                            "serviceAccountId" => Ok(__FieldTag::__service_account_id),
                            "service_account_id" => Ok(__FieldTag::__service_account_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudSqlProperties;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudSqlProperties")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance_id => {
                            if !fields.insert(__FieldTag::__instance_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_id",
                                ));
                            }
                            result.instance_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__database => {
                            if !fields.insert(__FieldTag::__database) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database",
                                ));
                            }
                            result.database = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<
                                    crate::model::cloud_sql_properties::DatabaseType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__credential => {
                            if !fields.insert(__FieldTag::__credential) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for credential",
                                ));
                            }
                            result.credential = map.next_value::<std::option::Option<crate::model::CloudSqlCredential>>()?
                                ;
                        }
                        __FieldTag::__service_account_id => {
                            if !fields.insert(__FieldTag::__service_account_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account_id",
                                ));
                            }
                            result.service_account_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudSqlProperties {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance_id.is_empty() {
            state.serialize_entry("instanceId", &self.instance_id)?;
        }
        if !self.database.is_empty() {
            state.serialize_entry("database", &self.database)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if self.credential.is_some() {
            state.serialize_entry("credential", &self.credential)?;
        }
        if !self.service_account_id.is_empty() {
            state.serialize_entry("serviceAccountId", &self.service_account_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CloudSqlProperties {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloudSqlProperties");
        debug_struct.field("instance_id", &self.instance_id);
        debug_struct.field("database", &self.database);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("credential", &self.credential);
        debug_struct.field("service_account_id", &self.service_account_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [CloudSqlProperties].
pub mod cloud_sql_properties {
    #[allow(unused_imports)]
    use super::*;

    /// Supported Cloud SQL database types.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DatabaseType {
        /// Unspecified database type.
        Unspecified,
        /// Cloud SQL for PostgreSQL.
        Postgres,
        /// Cloud SQL for MySQL.
        Mysql,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DatabaseType::value] or
        /// [DatabaseType::name].
        UnknownValue(database_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod database_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DatabaseType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Postgres => std::option::Option::Some(1),
                Self::Mysql => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DATABASE_TYPE_UNSPECIFIED"),
                Self::Postgres => std::option::Option::Some("POSTGRES"),
                Self::Mysql => std::option::Option::Some("MYSQL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DatabaseType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DatabaseType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DatabaseType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Postgres,
                2 => Self::Mysql,
                _ => Self::UnknownValue(database_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DatabaseType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DATABASE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "POSTGRES" => Self::Postgres,
                "MYSQL" => Self::Mysql,
                _ => Self::UnknownValue(database_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DatabaseType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Postgres => serializer.serialize_i32(1),
                Self::Mysql => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DatabaseType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DatabaseType>::new(
                ".google.cloud.bigquery.connection.v1.CloudSqlProperties.DatabaseType",
            ))
        }
    }
}

/// Credential info for the Cloud SQL.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudSqlCredential {
    /// The username for the credential.
    pub username: std::string::String,

    /// The password for the credential.
    pub password: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudSqlCredential {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [username][crate::model::CloudSqlCredential::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }

    /// Sets the value of [password][crate::model::CloudSqlCredential::password].
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }
}

impl wkt::message::Message for CloudSqlCredential {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.connection.v1.CloudSqlCredential"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudSqlCredential {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __username,
            __password,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudSqlCredential")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "username" => Ok(__FieldTag::__username),
                            "password" => Ok(__FieldTag::__password),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudSqlCredential;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudSqlCredential")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__username => {
                            if !fields.insert(__FieldTag::__username) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for username",
                                ));
                            }
                            result.username = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__password => {
                            if !fields.insert(__FieldTag::__password) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for password",
                                ));
                            }
                            result.password = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudSqlCredential {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.username.is_empty() {
            state.serialize_entry("username", &self.username)?;
        }
        if !self.password.is_empty() {
            state.serialize_entry("password", &self.password)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CloudSqlCredential {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloudSqlCredential");
        debug_struct.field("username", &self.username);
        debug_struct.field("password", &self.password);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Connection properties specific to Cloud Spanner.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudSpannerProperties {
    /// Cloud Spanner database in the form `project/instance/database'
    pub database: std::string::String,

    /// If parallelism should be used when reading from Cloud Spanner
    pub use_parallelism: bool,

    /// Allows setting max parallelism per query when executing on Spanner
    /// independent compute resources. If unspecified, default values of
    /// parallelism are chosen that are dependent on the Cloud Spanner instance
    /// configuration.
    ///
    /// REQUIRES: `use_parallelism` must be set.
    /// REQUIRES: Either `use_data_boost` or `use_serverless_analytics` must be
    /// set.
    pub max_parallelism: i32,

    /// If the serverless analytics service should be used to read data from Cloud
    /// Spanner.
    /// Note: `use_parallelism` must be set when using serverless analytics.
    pub use_serverless_analytics: bool,

    /// If set, the request will be executed via Spanner independent compute
    /// resources.
    /// REQUIRES: `use_parallelism` must be set.
    ///
    /// NOTE: `use_serverless_analytics` will be deprecated. Prefer
    /// `use_data_boost` over `use_serverless_analytics`.
    pub use_data_boost: bool,

    /// Optional. Cloud Spanner database role for fine-grained access control.
    /// The Cloud Spanner admin should have provisioned the database role with
    /// appropriate permissions, such as `SELECT` and `INSERT`. Other users should
    /// only use roles provided by their Cloud Spanner admins.
    ///
    /// For more details, see [About fine-grained access control]
    /// (<https://cloud.google.com/spanner/docs/fgac-about>).
    ///
    /// REQUIRES: The database role name must start with a letter, and can only
    /// contain letters, numbers, and underscores.
    pub database_role: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudSpannerProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [database][crate::model::CloudSpannerProperties::database].
    pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [use_parallelism][crate::model::CloudSpannerProperties::use_parallelism].
    pub fn set_use_parallelism<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_parallelism = v.into();
        self
    }

    /// Sets the value of [max_parallelism][crate::model::CloudSpannerProperties::max_parallelism].
    pub fn set_max_parallelism<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_parallelism = v.into();
        self
    }

    /// Sets the value of [use_serverless_analytics][crate::model::CloudSpannerProperties::use_serverless_analytics].
    pub fn set_use_serverless_analytics<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_serverless_analytics = v.into();
        self
    }

    /// Sets the value of [use_data_boost][crate::model::CloudSpannerProperties::use_data_boost].
    pub fn set_use_data_boost<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_data_boost = v.into();
        self
    }

    /// Sets the value of [database_role][crate::model::CloudSpannerProperties::database_role].
    pub fn set_database_role<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database_role = v.into();
        self
    }
}

impl wkt::message::Message for CloudSpannerProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.connection.v1.CloudSpannerProperties"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudSpannerProperties {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __database,
            __use_parallelism,
            __max_parallelism,
            __use_serverless_analytics,
            __use_data_boost,
            __database_role,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudSpannerProperties")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "database" => Ok(__FieldTag::__database),
                            "useParallelism" => Ok(__FieldTag::__use_parallelism),
                            "use_parallelism" => Ok(__FieldTag::__use_parallelism),
                            "maxParallelism" => Ok(__FieldTag::__max_parallelism),
                            "max_parallelism" => Ok(__FieldTag::__max_parallelism),
                            "useServerlessAnalytics" => Ok(__FieldTag::__use_serverless_analytics),
                            "use_serverless_analytics" => {
                                Ok(__FieldTag::__use_serverless_analytics)
                            }
                            "useDataBoost" => Ok(__FieldTag::__use_data_boost),
                            "use_data_boost" => Ok(__FieldTag::__use_data_boost),
                            "databaseRole" => Ok(__FieldTag::__database_role),
                            "database_role" => Ok(__FieldTag::__database_role),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudSpannerProperties;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudSpannerProperties")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__database => {
                            if !fields.insert(__FieldTag::__database) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database",
                                ));
                            }
                            result.database = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__use_parallelism => {
                            if !fields.insert(__FieldTag::__use_parallelism) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for use_parallelism",
                                ));
                            }
                            result.use_parallelism = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__max_parallelism => {
                            if !fields.insert(__FieldTag::__max_parallelism) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_parallelism",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_parallelism =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__use_serverless_analytics => {
                            if !fields.insert(__FieldTag::__use_serverless_analytics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for use_serverless_analytics",
                                ));
                            }
                            result.use_serverless_analytics = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__use_data_boost => {
                            if !fields.insert(__FieldTag::__use_data_boost) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for use_data_boost",
                                ));
                            }
                            result.use_data_boost = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__database_role => {
                            if !fields.insert(__FieldTag::__database_role) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database_role",
                                ));
                            }
                            result.database_role = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudSpannerProperties {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.database.is_empty() {
            state.serialize_entry("database", &self.database)?;
        }
        if !wkt::internal::is_default(&self.use_parallelism) {
            state.serialize_entry("useParallelism", &self.use_parallelism)?;
        }
        if !wkt::internal::is_default(&self.max_parallelism) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxParallelism", &__With(&self.max_parallelism))?;
        }
        if !wkt::internal::is_default(&self.use_serverless_analytics) {
            state.serialize_entry("useServerlessAnalytics", &self.use_serverless_analytics)?;
        }
        if !wkt::internal::is_default(&self.use_data_boost) {
            state.serialize_entry("useDataBoost", &self.use_data_boost)?;
        }
        if !self.database_role.is_empty() {
            state.serialize_entry("databaseRole", &self.database_role)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CloudSpannerProperties {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloudSpannerProperties");
        debug_struct.field("database", &self.database);
        debug_struct.field("use_parallelism", &self.use_parallelism);
        debug_struct.field("max_parallelism", &self.max_parallelism);
        debug_struct.field("use_serverless_analytics", &self.use_serverless_analytics);
        debug_struct.field("use_data_boost", &self.use_data_boost);
        debug_struct.field("database_role", &self.database_role);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Connection properties specific to Amazon Web Services (AWS).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AwsProperties {
    /// Authentication method chosen at connection creation.
    pub authentication_method:
        std::option::Option<crate::model::aws_properties::AuthenticationMethod>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [authentication_method][crate::model::AwsProperties::authentication_method].
    ///
    /// Note that all the setters affecting `authentication_method` are mutually
    /// exclusive.
    pub fn set_authentication_method<
        T: std::convert::Into<std::option::Option<crate::model::aws_properties::AuthenticationMethod>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.authentication_method = v.into();
        self
    }

    /// The value of [authentication_method][crate::model::AwsProperties::authentication_method]
    /// if it holds a `CrossAccountRole`, `None` if the field is not set or
    /// holds a different branch.
    #[deprecated]
    pub fn cross_account_role(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AwsCrossAccountRole>> {
        #[allow(unreachable_patterns)]
        self.authentication_method.as_ref().and_then(|v| match v {
            crate::model::aws_properties::AuthenticationMethod::CrossAccountRole(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [authentication_method][crate::model::AwsProperties::authentication_method]
    /// to hold a `CrossAccountRole`.
    ///
    /// Note that all the setters affecting `authentication_method` are
    /// mutually exclusive.
    #[deprecated]
    pub fn set_cross_account_role<
        T: std::convert::Into<std::boxed::Box<crate::model::AwsCrossAccountRole>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.authentication_method = std::option::Option::Some(
            crate::model::aws_properties::AuthenticationMethod::CrossAccountRole(v.into()),
        );
        self
    }

    /// The value of [authentication_method][crate::model::AwsProperties::authentication_method]
    /// if it holds a `AccessRole`, `None` if the field is not set or
    /// holds a different branch.
    pub fn access_role(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AwsAccessRole>> {
        #[allow(unreachable_patterns)]
        self.authentication_method.as_ref().and_then(|v| match v {
            crate::model::aws_properties::AuthenticationMethod::AccessRole(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [authentication_method][crate::model::AwsProperties::authentication_method]
    /// to hold a `AccessRole`.
    ///
    /// Note that all the setters affecting `authentication_method` are
    /// mutually exclusive.
    pub fn set_access_role<T: std::convert::Into<std::boxed::Box<crate::model::AwsAccessRole>>>(
        mut self,
        v: T,
    ) -> Self {
        self.authentication_method = std::option::Option::Some(
            crate::model::aws_properties::AuthenticationMethod::AccessRole(v.into()),
        );
        self
    }
}

impl wkt::message::Message for AwsProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.connection.v1.AwsProperties"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AwsProperties {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cross_account_role,
            __access_role,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AwsProperties")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "crossAccountRole" => Ok(__FieldTag::__cross_account_role),
                            "cross_account_role" => Ok(__FieldTag::__cross_account_role),
                            "accessRole" => Ok(__FieldTag::__access_role),
                            "access_role" => Ok(__FieldTag::__access_role),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AwsProperties;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AwsProperties")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cross_account_role => {
                            if !fields.insert(__FieldTag::__cross_account_role) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cross_account_role",
                                ));
                            }
                            if result.authentication_method.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `authentication_method`, a oneof with full ID .google.cloud.bigquery.connection.v1.AwsProperties.cross_account_role, latest field was crossAccountRole",
                                ));
                            }
                            result.authentication_method = std::option::Option::Some(
                                crate::model::aws_properties::AuthenticationMethod::CrossAccountRole(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::AwsCrossAccountRole>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__access_role => {
                            if !fields.insert(__FieldTag::__access_role) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for access_role",
                                ));
                            }
                            if result.authentication_method.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `authentication_method`, a oneof with full ID .google.cloud.bigquery.connection.v1.AwsProperties.access_role, latest field was accessRole",
                                ));
                            }
                            result.authentication_method = std::option::Option::Some(
                                crate::model::aws_properties::AuthenticationMethod::AccessRole(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AwsAccessRole>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AwsProperties {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.cross_account_role() {
            state.serialize_entry("crossAccountRole", value)?;
        }
        if let Some(value) = self.access_role() {
            state.serialize_entry("accessRole", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AwsProperties {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AwsProperties");
        debug_struct.field("authentication_method", &self.authentication_method);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AwsProperties].
pub mod aws_properties {
    #[allow(unused_imports)]
    use super::*;

    /// Authentication method chosen at connection creation.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AuthenticationMethod {
        /// Authentication using Google owned AWS IAM user's access key to assume
        /// into customer's AWS IAM Role.
        /// Deprecated, do not use.
        #[deprecated]
        CrossAccountRole(std::boxed::Box<crate::model::AwsCrossAccountRole>),
        /// Authentication using Google owned service account to assume into
        /// customer's AWS IAM Role.
        AccessRole(std::boxed::Box<crate::model::AwsAccessRole>),
    }
}

/// Authentication method for Amazon Web Services (AWS) that uses Google owned
/// AWS IAM user's access key to assume into customer's AWS IAM Role.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AwsCrossAccountRole {
    /// The users AWS IAM Role that trusts the Google-owned AWS IAM user
    /// Connection.
    pub iam_role_id: std::string::String,

    /// Output only. Google-owned AWS IAM User for a Connection.
    pub iam_user_id: std::string::String,

    /// Output only. A Google-generated id for representing Connections identity
    /// in AWS. External Id is also used for preventing the Confused Deputy
    /// Problem. See
    /// <https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-user_externalid.html>
    pub external_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsCrossAccountRole {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [iam_role_id][crate::model::AwsCrossAccountRole::iam_role_id].
    pub fn set_iam_role_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.iam_role_id = v.into();
        self
    }

    /// Sets the value of [iam_user_id][crate::model::AwsCrossAccountRole::iam_user_id].
    pub fn set_iam_user_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.iam_user_id = v.into();
        self
    }

    /// Sets the value of [external_id][crate::model::AwsCrossAccountRole::external_id].
    pub fn set_external_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.external_id = v.into();
        self
    }
}

impl wkt::message::Message for AwsCrossAccountRole {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.connection.v1.AwsCrossAccountRole"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AwsCrossAccountRole {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __iam_role_id,
            __iam_user_id,
            __external_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AwsCrossAccountRole")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "iamRoleId" => Ok(__FieldTag::__iam_role_id),
                            "iam_role_id" => Ok(__FieldTag::__iam_role_id),
                            "iamUserId" => Ok(__FieldTag::__iam_user_id),
                            "iam_user_id" => Ok(__FieldTag::__iam_user_id),
                            "externalId" => Ok(__FieldTag::__external_id),
                            "external_id" => Ok(__FieldTag::__external_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AwsCrossAccountRole;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AwsCrossAccountRole")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__iam_role_id => {
                            if !fields.insert(__FieldTag::__iam_role_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for iam_role_id",
                                ));
                            }
                            result.iam_role_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__iam_user_id => {
                            if !fields.insert(__FieldTag::__iam_user_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for iam_user_id",
                                ));
                            }
                            result.iam_user_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__external_id => {
                            if !fields.insert(__FieldTag::__external_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_id",
                                ));
                            }
                            result.external_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AwsCrossAccountRole {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.iam_role_id.is_empty() {
            state.serialize_entry("iamRoleId", &self.iam_role_id)?;
        }
        if !self.iam_user_id.is_empty() {
            state.serialize_entry("iamUserId", &self.iam_user_id)?;
        }
        if !self.external_id.is_empty() {
            state.serialize_entry("externalId", &self.external_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AwsCrossAccountRole {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AwsCrossAccountRole");
        debug_struct.field("iam_role_id", &self.iam_role_id);
        debug_struct.field("iam_user_id", &self.iam_user_id);
        debug_struct.field("external_id", &self.external_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Authentication method for Amazon Web Services (AWS) that uses Google owned
/// Google service account to assume into customer's AWS IAM Role.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AwsAccessRole {
    /// The users AWS IAM Role that trusts the Google-owned AWS IAM user
    /// Connection.
    pub iam_role_id: std::string::String,

    /// A unique Google-owned and Google-generated identity for the Connection.
    /// This identity will be used to access the user's AWS IAM Role.
    pub identity: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsAccessRole {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [iam_role_id][crate::model::AwsAccessRole::iam_role_id].
    pub fn set_iam_role_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.iam_role_id = v.into();
        self
    }

    /// Sets the value of [identity][crate::model::AwsAccessRole::identity].
    pub fn set_identity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.identity = v.into();
        self
    }
}

impl wkt::message::Message for AwsAccessRole {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.connection.v1.AwsAccessRole"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AwsAccessRole {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __iam_role_id,
            __identity,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AwsAccessRole")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "iamRoleId" => Ok(__FieldTag::__iam_role_id),
                            "iam_role_id" => Ok(__FieldTag::__iam_role_id),
                            "identity" => Ok(__FieldTag::__identity),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AwsAccessRole;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AwsAccessRole")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__iam_role_id => {
                            if !fields.insert(__FieldTag::__iam_role_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for iam_role_id",
                                ));
                            }
                            result.iam_role_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__identity => {
                            if !fields.insert(__FieldTag::__identity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for identity",
                                ));
                            }
                            result.identity = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AwsAccessRole {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.iam_role_id.is_empty() {
            state.serialize_entry("iamRoleId", &self.iam_role_id)?;
        }
        if !self.identity.is_empty() {
            state.serialize_entry("identity", &self.identity)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AwsAccessRole {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AwsAccessRole");
        debug_struct.field("iam_role_id", &self.iam_role_id);
        debug_struct.field("identity", &self.identity);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Container for connection properties specific to Azure.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AzureProperties {
    /// Output only. The name of the Azure Active Directory Application.
    pub application: std::string::String,

    /// Output only. The client id of the Azure Active Directory Application.
    pub client_id: std::string::String,

    /// Output only. The object id of the Azure Active Directory Application.
    pub object_id: std::string::String,

    /// The id of customer's directory that host the data.
    pub customer_tenant_id: std::string::String,

    /// The URL user will be redirected to after granting consent during connection
    /// setup.
    pub redirect_uri: std::string::String,

    /// The client ID of the user's Azure Active Directory Application used for a
    /// federated connection.
    pub federated_application_client_id: std::string::String,

    /// Output only. A unique Google-owned and Google-generated identity for the
    /// Connection. This identity will be used to access the user's Azure Active
    /// Directory Application.
    pub identity: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AzureProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [application][crate::model::AzureProperties::application].
    pub fn set_application<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.application = v.into();
        self
    }

    /// Sets the value of [client_id][crate::model::AzureProperties::client_id].
    pub fn set_client_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.client_id = v.into();
        self
    }

    /// Sets the value of [object_id][crate::model::AzureProperties::object_id].
    pub fn set_object_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.object_id = v.into();
        self
    }

    /// Sets the value of [customer_tenant_id][crate::model::AzureProperties::customer_tenant_id].
    pub fn set_customer_tenant_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.customer_tenant_id = v.into();
        self
    }

    /// Sets the value of [redirect_uri][crate::model::AzureProperties::redirect_uri].
    pub fn set_redirect_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.redirect_uri = v.into();
        self
    }

    /// Sets the value of [federated_application_client_id][crate::model::AzureProperties::federated_application_client_id].
    pub fn set_federated_application_client_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.federated_application_client_id = v.into();
        self
    }

    /// Sets the value of [identity][crate::model::AzureProperties::identity].
    pub fn set_identity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.identity = v.into();
        self
    }
}

impl wkt::message::Message for AzureProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.connection.v1.AzureProperties"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AzureProperties {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __application,
            __client_id,
            __object_id,
            __customer_tenant_id,
            __redirect_uri,
            __federated_application_client_id,
            __identity,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AzureProperties")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "application" => Ok(__FieldTag::__application),
                            "clientId" => Ok(__FieldTag::__client_id),
                            "client_id" => Ok(__FieldTag::__client_id),
                            "objectId" => Ok(__FieldTag::__object_id),
                            "object_id" => Ok(__FieldTag::__object_id),
                            "customerTenantId" => Ok(__FieldTag::__customer_tenant_id),
                            "customer_tenant_id" => Ok(__FieldTag::__customer_tenant_id),
                            "redirectUri" => Ok(__FieldTag::__redirect_uri),
                            "redirect_uri" => Ok(__FieldTag::__redirect_uri),
                            "federatedApplicationClientId" => {
                                Ok(__FieldTag::__federated_application_client_id)
                            }
                            "federated_application_client_id" => {
                                Ok(__FieldTag::__federated_application_client_id)
                            }
                            "identity" => Ok(__FieldTag::__identity),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AzureProperties;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AzureProperties")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__application => {
                            if !fields.insert(__FieldTag::__application) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for application",
                                ));
                            }
                            result.application = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__client_id => {
                            if !fields.insert(__FieldTag::__client_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for client_id",
                                ));
                            }
                            result.client_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__object_id => {
                            if !fields.insert(__FieldTag::__object_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for object_id",
                                ));
                            }
                            result.object_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__customer_tenant_id => {
                            if !fields.insert(__FieldTag::__customer_tenant_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for customer_tenant_id",
                                ));
                            }
                            result.customer_tenant_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__redirect_uri => {
                            if !fields.insert(__FieldTag::__redirect_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for redirect_uri",
                                ));
                            }
                            result.redirect_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__federated_application_client_id => {
                            if !fields.insert(__FieldTag::__federated_application_client_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for federated_application_client_id",
                                ));
                            }
                            result.federated_application_client_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__identity => {
                            if !fields.insert(__FieldTag::__identity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for identity",
                                ));
                            }
                            result.identity = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AzureProperties {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.application.is_empty() {
            state.serialize_entry("application", &self.application)?;
        }
        if !self.client_id.is_empty() {
            state.serialize_entry("clientId", &self.client_id)?;
        }
        if !self.object_id.is_empty() {
            state.serialize_entry("objectId", &self.object_id)?;
        }
        if !self.customer_tenant_id.is_empty() {
            state.serialize_entry("customerTenantId", &self.customer_tenant_id)?;
        }
        if !self.redirect_uri.is_empty() {
            state.serialize_entry("redirectUri", &self.redirect_uri)?;
        }
        if !self.federated_application_client_id.is_empty() {
            state.serialize_entry(
                "federatedApplicationClientId",
                &self.federated_application_client_id,
            )?;
        }
        if !self.identity.is_empty() {
            state.serialize_entry("identity", &self.identity)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AzureProperties {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AzureProperties");
        debug_struct.field("application", &self.application);
        debug_struct.field("client_id", &self.client_id);
        debug_struct.field("object_id", &self.object_id);
        debug_struct.field("customer_tenant_id", &self.customer_tenant_id);
        debug_struct.field("redirect_uri", &self.redirect_uri);
        debug_struct.field(
            "federated_application_client_id",
            &self.federated_application_client_id,
        );
        debug_struct.field("identity", &self.identity);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Container for connection properties for delegation of access to GCP
/// resources.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudResourceProperties {
    /// Output only. The account ID of the service created for the purpose of this
    /// connection.
    ///
    /// The service account does not have any permissions associated with it
    /// when it is created. After creation, customers delegate permissions
    /// to the service account. When the connection is used in the context of an
    /// operation in BigQuery, the service account will be used to connect to the
    /// desired resources in GCP.
    ///
    /// The account ID is in the form of:
    /// \<service-1234\>@gcp-sa-bigquery-cloudresource.iam.gserviceaccount.com
    pub service_account_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudResourceProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_account_id][crate::model::CloudResourceProperties::service_account_id].
    pub fn set_service_account_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_account_id = v.into();
        self
    }
}

impl wkt::message::Message for CloudResourceProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.connection.v1.CloudResourceProperties"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudResourceProperties {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __service_account_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudResourceProperties")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "serviceAccountId" => Ok(__FieldTag::__service_account_id),
                            "service_account_id" => Ok(__FieldTag::__service_account_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudResourceProperties;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudResourceProperties")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__service_account_id => {
                            if !fields.insert(__FieldTag::__service_account_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account_id",
                                ));
                            }
                            result.service_account_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudResourceProperties {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.service_account_id.is_empty() {
            state.serialize_entry("serviceAccountId", &self.service_account_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CloudResourceProperties {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloudResourceProperties");
        debug_struct.field("service_account_id", &self.service_account_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configuration of the Dataproc Metastore Service.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MetastoreServiceConfig {
    /// Optional. Resource name of an existing Dataproc Metastore service.
    ///
    /// Example:
    ///
    /// * `projects/[project_id]/locations/[region]/services/[service_id]`
    pub metastore_service: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MetastoreServiceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metastore_service][crate::model::MetastoreServiceConfig::metastore_service].
    pub fn set_metastore_service<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.metastore_service = v.into();
        self
    }
}

impl wkt::message::Message for MetastoreServiceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.connection.v1.MetastoreServiceConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MetastoreServiceConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __metastore_service,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MetastoreServiceConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "metastoreService" => Ok(__FieldTag::__metastore_service),
                            "metastore_service" => Ok(__FieldTag::__metastore_service),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MetastoreServiceConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MetastoreServiceConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__metastore_service => {
                            if !fields.insert(__FieldTag::__metastore_service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metastore_service",
                                ));
                            }
                            result.metastore_service = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MetastoreServiceConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.metastore_service.is_empty() {
            state.serialize_entry("metastoreService", &self.metastore_service)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MetastoreServiceConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MetastoreServiceConfig");
        debug_struct.field("metastore_service", &self.metastore_service);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configuration of the Spark History Server.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SparkHistoryServerConfig {
    /// Optional. Resource name of an existing Dataproc Cluster to act as a Spark
    /// History Server for the connection.
    ///
    /// Example:
    ///
    /// * `projects/[project_id]/regions/[region]/clusters/[cluster_name]`
    pub dataproc_cluster: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SparkHistoryServerConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dataproc_cluster][crate::model::SparkHistoryServerConfig::dataproc_cluster].
    pub fn set_dataproc_cluster<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.dataproc_cluster = v.into();
        self
    }
}

impl wkt::message::Message for SparkHistoryServerConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.connection.v1.SparkHistoryServerConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SparkHistoryServerConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dataproc_cluster,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SparkHistoryServerConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dataprocCluster" => Ok(__FieldTag::__dataproc_cluster),
                            "dataproc_cluster" => Ok(__FieldTag::__dataproc_cluster),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SparkHistoryServerConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SparkHistoryServerConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dataproc_cluster => {
                            if !fields.insert(__FieldTag::__dataproc_cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataproc_cluster",
                                ));
                            }
                            result.dataproc_cluster = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SparkHistoryServerConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.dataproc_cluster.is_empty() {
            state.serialize_entry("dataprocCluster", &self.dataproc_cluster)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SparkHistoryServerConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SparkHistoryServerConfig");
        debug_struct.field("dataproc_cluster", &self.dataproc_cluster);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Container for connection properties to execute stored procedures for Apache
/// Spark.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SparkProperties {
    /// Output only. The account ID of the service created for the purpose of this
    /// connection.
    ///
    /// The service account does not have any permissions associated with it when
    /// it is created. After creation, customers delegate permissions to the
    /// service account. When the connection is used in the context of a stored
    /// procedure for Apache Spark in BigQuery, the service account is used to
    /// connect to the desired resources in Google Cloud.
    ///
    /// The account ID is in the form of:
    /// bqcx-\<projectnumber\>-\<uniqueid\>@gcp-sa-bigquery-consp.iam.gserviceaccount.com
    pub service_account_id: std::string::String,

    /// Optional. Dataproc Metastore Service configuration for the connection.
    pub metastore_service_config: std::option::Option<crate::model::MetastoreServiceConfig>,

    /// Optional. Spark History Server configuration for the connection.
    pub spark_history_server_config: std::option::Option<crate::model::SparkHistoryServerConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SparkProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_account_id][crate::model::SparkProperties::service_account_id].
    pub fn set_service_account_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_account_id = v.into();
        self
    }

    /// Sets the value of [metastore_service_config][crate::model::SparkProperties::metastore_service_config].
    pub fn set_metastore_service_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MetastoreServiceConfig>,
    {
        self.metastore_service_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metastore_service_config][crate::model::SparkProperties::metastore_service_config].
    pub fn set_or_clear_metastore_service_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MetastoreServiceConfig>,
    {
        self.metastore_service_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [spark_history_server_config][crate::model::SparkProperties::spark_history_server_config].
    pub fn set_spark_history_server_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SparkHistoryServerConfig>,
    {
        self.spark_history_server_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [spark_history_server_config][crate::model::SparkProperties::spark_history_server_config].
    pub fn set_or_clear_spark_history_server_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SparkHistoryServerConfig>,
    {
        self.spark_history_server_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SparkProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.connection.v1.SparkProperties"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SparkProperties {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __service_account_id,
            __metastore_service_config,
            __spark_history_server_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SparkProperties")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "serviceAccountId" => Ok(__FieldTag::__service_account_id),
                            "service_account_id" => Ok(__FieldTag::__service_account_id),
                            "metastoreServiceConfig" => Ok(__FieldTag::__metastore_service_config),
                            "metastore_service_config" => {
                                Ok(__FieldTag::__metastore_service_config)
                            }
                            "sparkHistoryServerConfig" => {
                                Ok(__FieldTag::__spark_history_server_config)
                            }
                            "spark_history_server_config" => {
                                Ok(__FieldTag::__spark_history_server_config)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SparkProperties;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SparkProperties")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__service_account_id => {
                            if !fields.insert(__FieldTag::__service_account_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account_id",
                                ));
                            }
                            result.service_account_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__metastore_service_config => {
                            if !fields.insert(__FieldTag::__metastore_service_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metastore_service_config",
                                ));
                            }
                            result.metastore_service_config = map.next_value::<std::option::Option<crate::model::MetastoreServiceConfig>>()?
                                ;
                        }
                        __FieldTag::__spark_history_server_config => {
                            if !fields.insert(__FieldTag::__spark_history_server_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for spark_history_server_config",
                                ));
                            }
                            result.spark_history_server_config = map.next_value::<std::option::Option<crate::model::SparkHistoryServerConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SparkProperties {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.service_account_id.is_empty() {
            state.serialize_entry("serviceAccountId", &self.service_account_id)?;
        }
        if self.metastore_service_config.is_some() {
            state.serialize_entry("metastoreServiceConfig", &self.metastore_service_config)?;
        }
        if self.spark_history_server_config.is_some() {
            state.serialize_entry(
                "sparkHistoryServerConfig",
                &self.spark_history_server_config,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SparkProperties {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SparkProperties");
        debug_struct.field("service_account_id", &self.service_account_id);
        debug_struct.field("metastore_service_config", &self.metastore_service_config);
        debug_struct.field(
            "spark_history_server_config",
            &self.spark_history_server_config,
        );

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Connection properties specific to Salesforce DataCloud. This is intended for
/// use only by Salesforce partner projects.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SalesforceDataCloudProperties {
    /// The URL to the user's Salesforce DataCloud instance.
    pub instance_uri: std::string::String,

    /// Output only. A unique Google-owned and Google-generated service account
    /// identity for the connection.
    pub identity: std::string::String,

    /// The ID of the user's Salesforce tenant.
    pub tenant_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SalesforceDataCloudProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_uri][crate::model::SalesforceDataCloudProperties::instance_uri].
    pub fn set_instance_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_uri = v.into();
        self
    }

    /// Sets the value of [identity][crate::model::SalesforceDataCloudProperties::identity].
    pub fn set_identity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.identity = v.into();
        self
    }

    /// Sets the value of [tenant_id][crate::model::SalesforceDataCloudProperties::tenant_id].
    pub fn set_tenant_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tenant_id = v.into();
        self
    }
}

impl wkt::message::Message for SalesforceDataCloudProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.connection.v1.SalesforceDataCloudProperties"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SalesforceDataCloudProperties {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance_uri,
            __identity,
            __tenant_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SalesforceDataCloudProperties")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instanceUri" => Ok(__FieldTag::__instance_uri),
                            "instance_uri" => Ok(__FieldTag::__instance_uri),
                            "identity" => Ok(__FieldTag::__identity),
                            "tenantId" => Ok(__FieldTag::__tenant_id),
                            "tenant_id" => Ok(__FieldTag::__tenant_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SalesforceDataCloudProperties;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SalesforceDataCloudProperties")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance_uri => {
                            if !fields.insert(__FieldTag::__instance_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_uri",
                                ));
                            }
                            result.instance_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__identity => {
                            if !fields.insert(__FieldTag::__identity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for identity",
                                ));
                            }
                            result.identity = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tenant_id => {
                            if !fields.insert(__FieldTag::__tenant_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tenant_id",
                                ));
                            }
                            result.tenant_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SalesforceDataCloudProperties {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance_uri.is_empty() {
            state.serialize_entry("instanceUri", &self.instance_uri)?;
        }
        if !self.identity.is_empty() {
            state.serialize_entry("identity", &self.identity)?;
        }
        if !self.tenant_id.is_empty() {
            state.serialize_entry("tenantId", &self.tenant_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SalesforceDataCloudProperties {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SalesforceDataCloudProperties");
        debug_struct.field("instance_uri", &self.instance_uri);
        debug_struct.field("identity", &self.identity);
        debug_struct.field("tenant_id", &self.tenant_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}
