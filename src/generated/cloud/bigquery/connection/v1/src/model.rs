// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate iam_v1;
extern crate lazy_static;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// The request for
/// [ConnectionService.CreateConnection][google.cloud.bigquery.connection.v1.ConnectionService.CreateConnection].
///
/// [google.cloud.bigquery.connection.v1.ConnectionService.CreateConnection]: crate::client::ConnectionService::create_connection
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateConnectionRequest {
    /// Required. Parent resource name.
    /// Must be in the format `projects/{project_id}/locations/{location_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Connection id that should be assigned to the created connection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub connection_id: std::string::String,

    /// Required. Connection to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub connection: std::option::Option<crate::model::Connection>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateConnectionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [connection_id][crate::model::CreateConnectionRequest::connection_id].
    pub fn set_connection_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.connection_id = v.into();
        self
    }

    /// Sets the value of [connection][crate::model::CreateConnectionRequest::connection].
    pub fn set_connection<T: std::convert::Into<std::option::Option<crate::model::Connection>>>(
        mut self,
        v: T,
    ) -> Self {
        self.connection = v.into();
        self
    }
}

impl wkt::message::Message for CreateConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.connection.v1.CreateConnectionRequest"
    }
}

/// The request for
/// [ConnectionService.GetConnection][google.cloud.bigquery.connection.v1.ConnectionService.GetConnection].
///
/// [google.cloud.bigquery.connection.v1.ConnectionService.GetConnection]: crate::client::ConnectionService::get_connection
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetConnectionRequest {
    /// Required. Name of the requested connection, for example:
    /// `projects/{project_id}/locations/{location_id}/connections/{connection_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetConnectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.connection.v1.GetConnectionRequest"
    }
}

/// The request for
/// [ConnectionService.ListConnections][google.cloud.bigquery.connection.v1.ConnectionService.ListConnections].
///
/// [google.cloud.bigquery.connection.v1.ConnectionService.ListConnections]: crate::client::ConnectionService::list_connections
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListConnectionsRequest {
    /// Required. Parent resource name.
    /// Must be in the form: `projects/{project_id}/locations/{location_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Page size.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConnectionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListConnectionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListConnectionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListConnectionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListConnectionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.connection.v1.ListConnectionsRequest"
    }
}

/// The response for
/// [ConnectionService.ListConnections][google.cloud.bigquery.connection.v1.ConnectionService.ListConnections].
///
/// [google.cloud.bigquery.connection.v1.ConnectionService.ListConnections]: crate::client::ConnectionService::list_connections
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListConnectionsResponse {
    /// Next page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// List of connections.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub connections: std::vec::Vec<crate::model::Connection>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConnectionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListConnectionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [connections][crate::model::ListConnectionsResponse::connections].
    pub fn set_connections<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Connection>,
    {
        use std::iter::Iterator;
        self.connections = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListConnectionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.connection.v1.ListConnectionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListConnectionsResponse {
    type PageItem = crate::model::Connection;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.connections
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request for
/// [ConnectionService.UpdateConnection][google.cloud.bigquery.connection.v1.ConnectionService.UpdateConnection].
///
/// [google.cloud.bigquery.connection.v1.ConnectionService.UpdateConnection]: crate::client::ConnectionService::update_connection
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateConnectionRequest {
    /// Required. Name of the connection to update, for example:
    /// `projects/{project_id}/locations/{location_id}/connections/{connection_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. Connection containing the updated fields.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub connection: std::option::Option<crate::model::Connection>,

    /// Required. Update mask for the connection fields to be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateConnectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [connection][crate::model::UpdateConnectionRequest::connection].
    pub fn set_connection<T: std::convert::Into<std::option::Option<crate::model::Connection>>>(
        mut self,
        v: T,
    ) -> Self {
        self.connection = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateConnectionRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.connection.v1.UpdateConnectionRequest"
    }
}

/// The request for [ConnectionService.DeleteConnectionRequest][].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteConnectionRequest {
    /// Required. Name of the deleted connection, for example:
    /// `projects/{project_id}/locations/{location_id}/connections/{connection_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteConnectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.connection.v1.DeleteConnectionRequest"
    }
}

/// Configuration parameters to establish connection with an external data
/// source, except the credential attributes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Connection {
    /// The resource name of the connection in the form of:
    /// `projects/{project_id}/locations/{location_id}/connections/{connection_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// User provided display name for the connection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub friendly_name: std::string::String,

    /// User provided description.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. The creation timestamp of the connection.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub creation_time: i64,

    /// Output only. The last update timestamp of the connection.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub last_modified_time: i64,

    /// Output only. True, if credential is configured for this connection.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub has_credential: bool,

    /// Properties specific to the underlying data source.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub properties: std::option::Option<crate::model::connection::Properties>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Connection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Connection::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [friendly_name][crate::model::Connection::friendly_name].
    pub fn set_friendly_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.friendly_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Connection::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [creation_time][crate::model::Connection::creation_time].
    pub fn set_creation_time<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.creation_time = v.into();
        self
    }

    /// Sets the value of [last_modified_time][crate::model::Connection::last_modified_time].
    pub fn set_last_modified_time<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.last_modified_time = v.into();
        self
    }

    /// Sets the value of [has_credential][crate::model::Connection::has_credential].
    pub fn set_has_credential<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.has_credential = v.into();
        self
    }

    /// Sets the value of [properties][crate::model::Connection::properties].
    ///
    /// Note that all the setters affecting `properties` are mutually
    /// exclusive.
    pub fn set_properties<
        T: std::convert::Into<std::option::Option<crate::model::connection::Properties>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.properties = v.into();
        self
    }

    /// The value of [properties][crate::model::Connection::properties]
    /// if it holds a `CloudSql`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_sql(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudSqlProperties>> {
        #[allow(unreachable_patterns)]
        self.properties.as_ref().and_then(|v| match v {
            crate::model::connection::Properties::CloudSql(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [properties][crate::model::Connection::properties]
    /// to hold a `CloudSql`.
    ///
    /// Note that all the setters affecting `properties` are
    /// mutually exclusive.
    pub fn set_cloud_sql<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudSqlProperties>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.properties =
            std::option::Option::Some(crate::model::connection::Properties::CloudSql(v.into()));
        self
    }

    /// The value of [properties][crate::model::Connection::properties]
    /// if it holds a `Aws`, `None` if the field is not set or
    /// holds a different branch.
    pub fn aws(&self) -> std::option::Option<&std::boxed::Box<crate::model::AwsProperties>> {
        #[allow(unreachable_patterns)]
        self.properties.as_ref().and_then(|v| match v {
            crate::model::connection::Properties::Aws(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [properties][crate::model::Connection::properties]
    /// to hold a `Aws`.
    ///
    /// Note that all the setters affecting `properties` are
    /// mutually exclusive.
    pub fn set_aws<T: std::convert::Into<std::boxed::Box<crate::model::AwsProperties>>>(
        mut self,
        v: T,
    ) -> Self {
        self.properties =
            std::option::Option::Some(crate::model::connection::Properties::Aws(v.into()));
        self
    }

    /// The value of [properties][crate::model::Connection::properties]
    /// if it holds a `Azure`, `None` if the field is not set or
    /// holds a different branch.
    pub fn azure(&self) -> std::option::Option<&std::boxed::Box<crate::model::AzureProperties>> {
        #[allow(unreachable_patterns)]
        self.properties.as_ref().and_then(|v| match v {
            crate::model::connection::Properties::Azure(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [properties][crate::model::Connection::properties]
    /// to hold a `Azure`.
    ///
    /// Note that all the setters affecting `properties` are
    /// mutually exclusive.
    pub fn set_azure<T: std::convert::Into<std::boxed::Box<crate::model::AzureProperties>>>(
        mut self,
        v: T,
    ) -> Self {
        self.properties =
            std::option::Option::Some(crate::model::connection::Properties::Azure(v.into()));
        self
    }

    /// The value of [properties][crate::model::Connection::properties]
    /// if it holds a `CloudSpanner`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_spanner(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudSpannerProperties>> {
        #[allow(unreachable_patterns)]
        self.properties.as_ref().and_then(|v| match v {
            crate::model::connection::Properties::CloudSpanner(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [properties][crate::model::Connection::properties]
    /// to hold a `CloudSpanner`.
    ///
    /// Note that all the setters affecting `properties` are
    /// mutually exclusive.
    pub fn set_cloud_spanner<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudSpannerProperties>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.properties =
            std::option::Option::Some(crate::model::connection::Properties::CloudSpanner(v.into()));
        self
    }

    /// The value of [properties][crate::model::Connection::properties]
    /// if it holds a `CloudResource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_resource(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudResourceProperties>> {
        #[allow(unreachable_patterns)]
        self.properties.as_ref().and_then(|v| match v {
            crate::model::connection::Properties::CloudResource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [properties][crate::model::Connection::properties]
    /// to hold a `CloudResource`.
    ///
    /// Note that all the setters affecting `properties` are
    /// mutually exclusive.
    pub fn set_cloud_resource<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudResourceProperties>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.properties = std::option::Option::Some(
            crate::model::connection::Properties::CloudResource(v.into()),
        );
        self
    }

    /// The value of [properties][crate::model::Connection::properties]
    /// if it holds a `Spark`, `None` if the field is not set or
    /// holds a different branch.
    pub fn spark(&self) -> std::option::Option<&std::boxed::Box<crate::model::SparkProperties>> {
        #[allow(unreachable_patterns)]
        self.properties.as_ref().and_then(|v| match v {
            crate::model::connection::Properties::Spark(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [properties][crate::model::Connection::properties]
    /// to hold a `Spark`.
    ///
    /// Note that all the setters affecting `properties` are
    /// mutually exclusive.
    pub fn set_spark<T: std::convert::Into<std::boxed::Box<crate::model::SparkProperties>>>(
        mut self,
        v: T,
    ) -> Self {
        self.properties =
            std::option::Option::Some(crate::model::connection::Properties::Spark(v.into()));
        self
    }

    /// The value of [properties][crate::model::Connection::properties]
    /// if it holds a `SalesforceDataCloud`, `None` if the field is not set or
    /// holds a different branch.
    pub fn salesforce_data_cloud(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SalesforceDataCloudProperties>> {
        #[allow(unreachable_patterns)]
        self.properties.as_ref().and_then(|v| match v {
            crate::model::connection::Properties::SalesforceDataCloud(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [properties][crate::model::Connection::properties]
    /// to hold a `SalesforceDataCloud`.
    ///
    /// Note that all the setters affecting `properties` are
    /// mutually exclusive.
    pub fn set_salesforce_data_cloud<
        T: std::convert::Into<std::boxed::Box<crate::model::SalesforceDataCloudProperties>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.properties = std::option::Option::Some(
            crate::model::connection::Properties::SalesforceDataCloud(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Connection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.connection.v1.Connection"
    }
}

/// Defines additional types related to [Connection].
pub mod connection {
    #[allow(unused_imports)]
    use super::*;

    /// Properties specific to the underlying data source.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Properties {
        /// Cloud SQL properties.
        CloudSql(std::boxed::Box<crate::model::CloudSqlProperties>),
        /// Amazon Web Services (AWS) properties.
        Aws(std::boxed::Box<crate::model::AwsProperties>),
        /// Azure properties.
        Azure(std::boxed::Box<crate::model::AzureProperties>),
        /// Cloud Spanner properties.
        CloudSpanner(std::boxed::Box<crate::model::CloudSpannerProperties>),
        /// Cloud Resource properties.
        CloudResource(std::boxed::Box<crate::model::CloudResourceProperties>),
        /// Spark properties.
        Spark(std::boxed::Box<crate::model::SparkProperties>),
        /// Optional. Salesforce DataCloud properties. This field is intended for
        /// use only by Salesforce partner projects. This field contains properties
        /// for your Salesforce DataCloud connection.
        SalesforceDataCloud(std::boxed::Box<crate::model::SalesforceDataCloudProperties>),
    }
}

/// Connection properties specific to the Cloud SQL.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudSqlProperties {
    /// Cloud SQL instance ID in the form `project:location:instance`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance_id: std::string::String,

    /// Database name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub database: std::string::String,

    /// Type of the Cloud SQL database.
    #[serde(rename = "type")]
    pub r#type: crate::model::cloud_sql_properties::DatabaseType,

    /// Input only. Cloud SQL credential.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub credential: std::option::Option<crate::model::CloudSqlCredential>,

    /// Output only. The account ID of the service used for the purpose of this
    /// connection.
    ///
    /// When the connection is used in the context of an operation in
    /// BigQuery, this service account will serve as the identity being used for
    /// connecting to the CloudSQL instance specified in this connection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudSqlProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_id][crate::model::CloudSqlProperties::instance_id].
    pub fn set_instance_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_id = v.into();
        self
    }

    /// Sets the value of [database][crate::model::CloudSqlProperties::database].
    pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::CloudSqlProperties::type].
    pub fn set_type<T: std::convert::Into<crate::model::cloud_sql_properties::DatabaseType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [credential][crate::model::CloudSqlProperties::credential].
    pub fn set_credential<
        T: std::convert::Into<std::option::Option<crate::model::CloudSqlCredential>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.credential = v.into();
        self
    }

    /// Sets the value of [service_account_id][crate::model::CloudSqlProperties::service_account_id].
    pub fn set_service_account_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_account_id = v.into();
        self
    }
}

impl wkt::message::Message for CloudSqlProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.connection.v1.CloudSqlProperties"
    }
}

/// Defines additional types related to [CloudSqlProperties].
pub mod cloud_sql_properties {
    #[allow(unused_imports)]
    use super::*;

    /// Supported Cloud SQL database types.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DatabaseType {
        /// Unspecified database type.
        Unspecified,
        /// Cloud SQL for PostgreSQL.
        Postgres,
        /// Cloud SQL for MySQL.
        Mysql,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DatabaseType::value] or
        /// [DatabaseType::name].
        UnknownValue(database_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod database_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DatabaseType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Postgres => std::option::Option::Some(1),
                Self::Mysql => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DATABASE_TYPE_UNSPECIFIED"),
                Self::Postgres => std::option::Option::Some("POSTGRES"),
                Self::Mysql => std::option::Option::Some("MYSQL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DatabaseType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DatabaseType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DatabaseType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Postgres,
                2 => Self::Mysql,
                _ => Self::UnknownValue(database_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DatabaseType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DATABASE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "POSTGRES" => Self::Postgres,
                "MYSQL" => Self::Mysql,
                _ => Self::UnknownValue(database_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DatabaseType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Postgres => serializer.serialize_i32(1),
                Self::Mysql => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DatabaseType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DatabaseType>::new(
                ".google.cloud.bigquery.connection.v1.CloudSqlProperties.DatabaseType",
            ))
        }
    }
}

/// Credential info for the Cloud SQL.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudSqlCredential {
    /// The username for the credential.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub username: std::string::String,

    /// The password for the credential.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub password: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudSqlCredential {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [username][crate::model::CloudSqlCredential::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }

    /// Sets the value of [password][crate::model::CloudSqlCredential::password].
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }
}

impl wkt::message::Message for CloudSqlCredential {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.connection.v1.CloudSqlCredential"
    }
}

/// Connection properties specific to Cloud Spanner.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudSpannerProperties {
    /// Cloud Spanner database in the form `project/instance/database'
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub database: std::string::String,

    /// If parallelism should be used when reading from Cloud Spanner
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub use_parallelism: bool,

    /// Allows setting max parallelism per query when executing on Spanner
    /// independent compute resources. If unspecified, default values of
    /// parallelism are chosen that are dependent on the Cloud Spanner instance
    /// configuration.
    ///
    /// REQUIRES: `use_parallelism` must be set.
    /// REQUIRES: Either `use_data_boost` or `use_serverless_analytics` must be
    /// set.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub max_parallelism: i32,

    /// If the serverless analytics service should be used to read data from Cloud
    /// Spanner.
    /// Note: `use_parallelism` must be set when using serverless analytics.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub use_serverless_analytics: bool,

    /// If set, the request will be executed via Spanner independent compute
    /// resources.
    /// REQUIRES: `use_parallelism` must be set.
    ///
    /// NOTE: `use_serverless_analytics` will be deprecated. Prefer
    /// `use_data_boost` over `use_serverless_analytics`.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub use_data_boost: bool,

    /// Optional. Cloud Spanner database role for fine-grained access control.
    /// The Cloud Spanner admin should have provisioned the database role with
    /// appropriate permissions, such as `SELECT` and `INSERT`. Other users should
    /// only use roles provided by their Cloud Spanner admins.
    ///
    /// For more details, see [About fine-grained access control]
    /// (<https://cloud.google.com/spanner/docs/fgac-about>).
    ///
    /// REQUIRES: The database role name must start with a letter, and can only
    /// contain letters, numbers, and underscores.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub database_role: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudSpannerProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [database][crate::model::CloudSpannerProperties::database].
    pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [use_parallelism][crate::model::CloudSpannerProperties::use_parallelism].
    pub fn set_use_parallelism<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_parallelism = v.into();
        self
    }

    /// Sets the value of [max_parallelism][crate::model::CloudSpannerProperties::max_parallelism].
    pub fn set_max_parallelism<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_parallelism = v.into();
        self
    }

    /// Sets the value of [use_serverless_analytics][crate::model::CloudSpannerProperties::use_serverless_analytics].
    pub fn set_use_serverless_analytics<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_serverless_analytics = v.into();
        self
    }

    /// Sets the value of [use_data_boost][crate::model::CloudSpannerProperties::use_data_boost].
    pub fn set_use_data_boost<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_data_boost = v.into();
        self
    }

    /// Sets the value of [database_role][crate::model::CloudSpannerProperties::database_role].
    pub fn set_database_role<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database_role = v.into();
        self
    }
}

impl wkt::message::Message for CloudSpannerProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.connection.v1.CloudSpannerProperties"
    }
}

/// Connection properties specific to Amazon Web Services (AWS).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AwsProperties {
    /// Authentication method chosen at connection creation.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub authentication_method:
        std::option::Option<crate::model::aws_properties::AuthenticationMethod>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [authentication_method][crate::model::AwsProperties::authentication_method].
    ///
    /// Note that all the setters affecting `authentication_method` are mutually
    /// exclusive.
    pub fn set_authentication_method<
        T: std::convert::Into<std::option::Option<crate::model::aws_properties::AuthenticationMethod>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.authentication_method = v.into();
        self
    }

    /// The value of [authentication_method][crate::model::AwsProperties::authentication_method]
    /// if it holds a `CrossAccountRole`, `None` if the field is not set or
    /// holds a different branch.
    #[deprecated]
    pub fn cross_account_role(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AwsCrossAccountRole>> {
        #[allow(unreachable_patterns)]
        self.authentication_method.as_ref().and_then(|v| match v {
            crate::model::aws_properties::AuthenticationMethod::CrossAccountRole(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [authentication_method][crate::model::AwsProperties::authentication_method]
    /// to hold a `CrossAccountRole`.
    ///
    /// Note that all the setters affecting `authentication_method` are
    /// mutually exclusive.
    #[deprecated]
    pub fn set_cross_account_role<
        T: std::convert::Into<std::boxed::Box<crate::model::AwsCrossAccountRole>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.authentication_method = std::option::Option::Some(
            crate::model::aws_properties::AuthenticationMethod::CrossAccountRole(v.into()),
        );
        self
    }

    /// The value of [authentication_method][crate::model::AwsProperties::authentication_method]
    /// if it holds a `AccessRole`, `None` if the field is not set or
    /// holds a different branch.
    pub fn access_role(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AwsAccessRole>> {
        #[allow(unreachable_patterns)]
        self.authentication_method.as_ref().and_then(|v| match v {
            crate::model::aws_properties::AuthenticationMethod::AccessRole(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [authentication_method][crate::model::AwsProperties::authentication_method]
    /// to hold a `AccessRole`.
    ///
    /// Note that all the setters affecting `authentication_method` are
    /// mutually exclusive.
    pub fn set_access_role<T: std::convert::Into<std::boxed::Box<crate::model::AwsAccessRole>>>(
        mut self,
        v: T,
    ) -> Self {
        self.authentication_method = std::option::Option::Some(
            crate::model::aws_properties::AuthenticationMethod::AccessRole(v.into()),
        );
        self
    }
}

impl wkt::message::Message for AwsProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.connection.v1.AwsProperties"
    }
}

/// Defines additional types related to [AwsProperties].
pub mod aws_properties {
    #[allow(unused_imports)]
    use super::*;

    /// Authentication method chosen at connection creation.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum AuthenticationMethod {
        /// Authentication using Google owned AWS IAM user's access key to assume
        /// into customer's AWS IAM Role.
        /// Deprecated, do not use.
        #[deprecated]
        CrossAccountRole(std::boxed::Box<crate::model::AwsCrossAccountRole>),
        /// Authentication using Google owned service account to assume into
        /// customer's AWS IAM Role.
        AccessRole(std::boxed::Box<crate::model::AwsAccessRole>),
    }
}

/// Authentication method for Amazon Web Services (AWS) that uses Google owned
/// AWS IAM user's access key to assume into customer's AWS IAM Role.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AwsCrossAccountRole {
    /// The user’s AWS IAM Role that trusts the Google-owned AWS IAM user
    /// Connection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub iam_role_id: std::string::String,

    /// Output only. Google-owned AWS IAM User for a Connection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub iam_user_id: std::string::String,

    /// Output only. A Google-generated id for representing Connection’s identity
    /// in AWS. External Id is also used for preventing the Confused Deputy
    /// Problem. See
    /// <https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-user_externalid.html>
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub external_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsCrossAccountRole {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [iam_role_id][crate::model::AwsCrossAccountRole::iam_role_id].
    pub fn set_iam_role_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.iam_role_id = v.into();
        self
    }

    /// Sets the value of [iam_user_id][crate::model::AwsCrossAccountRole::iam_user_id].
    pub fn set_iam_user_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.iam_user_id = v.into();
        self
    }

    /// Sets the value of [external_id][crate::model::AwsCrossAccountRole::external_id].
    pub fn set_external_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.external_id = v.into();
        self
    }
}

impl wkt::message::Message for AwsCrossAccountRole {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.connection.v1.AwsCrossAccountRole"
    }
}

/// Authentication method for Amazon Web Services (AWS) that uses Google owned
/// Google service account to assume into customer's AWS IAM Role.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AwsAccessRole {
    /// The user’s AWS IAM Role that trusts the Google-owned AWS IAM user
    /// Connection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub iam_role_id: std::string::String,

    /// A unique Google-owned and Google-generated identity for the Connection.
    /// This identity will be used to access the user's AWS IAM Role.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub identity: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsAccessRole {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [iam_role_id][crate::model::AwsAccessRole::iam_role_id].
    pub fn set_iam_role_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.iam_role_id = v.into();
        self
    }

    /// Sets the value of [identity][crate::model::AwsAccessRole::identity].
    pub fn set_identity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.identity = v.into();
        self
    }
}

impl wkt::message::Message for AwsAccessRole {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.connection.v1.AwsAccessRole"
    }
}

/// Container for connection properties specific to Azure.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AzureProperties {
    /// Output only. The name of the Azure Active Directory Application.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub application: std::string::String,

    /// Output only. The client id of the Azure Active Directory Application.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub client_id: std::string::String,

    /// Output only. The object id of the Azure Active Directory Application.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub object_id: std::string::String,

    /// The id of customer's directory that host the data.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub customer_tenant_id: std::string::String,

    /// The URL user will be redirected to after granting consent during connection
    /// setup.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub redirect_uri: std::string::String,

    /// The client ID of the user's Azure Active Directory Application used for a
    /// federated connection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub federated_application_client_id: std::string::String,

    /// Output only. A unique Google-owned and Google-generated identity for the
    /// Connection. This identity will be used to access the user's Azure Active
    /// Directory Application.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub identity: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AzureProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [application][crate::model::AzureProperties::application].
    pub fn set_application<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.application = v.into();
        self
    }

    /// Sets the value of [client_id][crate::model::AzureProperties::client_id].
    pub fn set_client_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.client_id = v.into();
        self
    }

    /// Sets the value of [object_id][crate::model::AzureProperties::object_id].
    pub fn set_object_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.object_id = v.into();
        self
    }

    /// Sets the value of [customer_tenant_id][crate::model::AzureProperties::customer_tenant_id].
    pub fn set_customer_tenant_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.customer_tenant_id = v.into();
        self
    }

    /// Sets the value of [redirect_uri][crate::model::AzureProperties::redirect_uri].
    pub fn set_redirect_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.redirect_uri = v.into();
        self
    }

    /// Sets the value of [federated_application_client_id][crate::model::AzureProperties::federated_application_client_id].
    pub fn set_federated_application_client_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.federated_application_client_id = v.into();
        self
    }

    /// Sets the value of [identity][crate::model::AzureProperties::identity].
    pub fn set_identity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.identity = v.into();
        self
    }
}

impl wkt::message::Message for AzureProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.connection.v1.AzureProperties"
    }
}

/// Container for connection properties for delegation of access to GCP
/// resources.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudResourceProperties {
    /// Output only. The account ID of the service created for the purpose of this
    /// connection.
    ///
    /// The service account does not have any permissions associated with it
    /// when it is created. After creation, customers delegate permissions
    /// to the service account. When the connection is used in the context of an
    /// operation in BigQuery, the service account will be used to connect to the
    /// desired resources in GCP.
    ///
    /// The account ID is in the form of:
    /// \<service-1234\>@gcp-sa-bigquery-cloudresource.iam.gserviceaccount.com
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudResourceProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_account_id][crate::model::CloudResourceProperties::service_account_id].
    pub fn set_service_account_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_account_id = v.into();
        self
    }
}

impl wkt::message::Message for CloudResourceProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.connection.v1.CloudResourceProperties"
    }
}

/// Configuration of the Dataproc Metastore Service.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MetastoreServiceConfig {
    /// Optional. Resource name of an existing Dataproc Metastore service.
    ///
    /// Example:
    ///
    /// * `projects/[project_id]/locations/[region]/services/[service_id]`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub metastore_service: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MetastoreServiceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metastore_service][crate::model::MetastoreServiceConfig::metastore_service].
    pub fn set_metastore_service<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.metastore_service = v.into();
        self
    }
}

impl wkt::message::Message for MetastoreServiceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.connection.v1.MetastoreServiceConfig"
    }
}

/// Configuration of the Spark History Server.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SparkHistoryServerConfig {
    /// Optional. Resource name of an existing Dataproc Cluster to act as a Spark
    /// History Server for the connection.
    ///
    /// Example:
    ///
    /// * `projects/[project_id]/regions/[region]/clusters/[cluster_name]`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataproc_cluster: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SparkHistoryServerConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dataproc_cluster][crate::model::SparkHistoryServerConfig::dataproc_cluster].
    pub fn set_dataproc_cluster<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.dataproc_cluster = v.into();
        self
    }
}

impl wkt::message::Message for SparkHistoryServerConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.connection.v1.SparkHistoryServerConfig"
    }
}

/// Container for connection properties to execute stored procedures for Apache
/// Spark.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SparkProperties {
    /// Output only. The account ID of the service created for the purpose of this
    /// connection.
    ///
    /// The service account does not have any permissions associated with it when
    /// it is created. After creation, customers delegate permissions to the
    /// service account. When the connection is used in the context of a stored
    /// procedure for Apache Spark in BigQuery, the service account is used to
    /// connect to the desired resources in Google Cloud.
    ///
    /// The account ID is in the form of:
    /// bqcx-\<projectnumber\>-\<uniqueid\>@gcp-sa-bigquery-consp.iam.gserviceaccount.com
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account_id: std::string::String,

    /// Optional. Dataproc Metastore Service configuration for the connection.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metastore_service_config: std::option::Option<crate::model::MetastoreServiceConfig>,

    /// Optional. Spark History Server configuration for the connection.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub spark_history_server_config: std::option::Option<crate::model::SparkHistoryServerConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SparkProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_account_id][crate::model::SparkProperties::service_account_id].
    pub fn set_service_account_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_account_id = v.into();
        self
    }

    /// Sets the value of [metastore_service_config][crate::model::SparkProperties::metastore_service_config].
    pub fn set_metastore_service_config<
        T: std::convert::Into<std::option::Option<crate::model::MetastoreServiceConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metastore_service_config = v.into();
        self
    }

    /// Sets the value of [spark_history_server_config][crate::model::SparkProperties::spark_history_server_config].
    pub fn set_spark_history_server_config<
        T: std::convert::Into<std::option::Option<crate::model::SparkHistoryServerConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.spark_history_server_config = v.into();
        self
    }
}

impl wkt::message::Message for SparkProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.connection.v1.SparkProperties"
    }
}

/// Connection properties specific to Salesforce DataCloud. This is intended for
/// use only by Salesforce partner projects.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SalesforceDataCloudProperties {
    /// The URL to the user's Salesforce DataCloud instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance_uri: std::string::String,

    /// Output only. A unique Google-owned and Google-generated service account
    /// identity for the connection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub identity: std::string::String,

    /// The ID of the user's Salesforce tenant.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tenant_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SalesforceDataCloudProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_uri][crate::model::SalesforceDataCloudProperties::instance_uri].
    pub fn set_instance_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_uri = v.into();
        self
    }

    /// Sets the value of [identity][crate::model::SalesforceDataCloudProperties::identity].
    pub fn set_identity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.identity = v.into();
        self
    }

    /// Sets the value of [tenant_id][crate::model::SalesforceDataCloudProperties::tenant_id].
    pub fn set_tenant_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tenant_id = v.into();
        self
    }
}

impl wkt::message::Message for SalesforceDataCloudProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.connection.v1.SalesforceDataCloudProperties"
    }
}
