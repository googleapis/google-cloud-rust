// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate api;
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// A migration workflow which specifies what needs to be done for an EDW
/// migration.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct MigrationWorkflow {
    /// Output only. Immutable. Identifier. The unique identifier for the migration
    /// workflow. The ID is server-generated.
    ///
    /// Example: `projects/123/locations/us/workflows/345`
    pub name: std::string::String,

    /// The display name of the workflow. This can be set to give a workflow
    /// a descriptive name. There is no guarantee or enforcement of uniqueness.
    pub display_name: std::string::String,

    /// The tasks in a workflow in a named map. The name (i.e. key) has no
    /// meaning and is merely a convenient way to address a specific task
    /// in a workflow.
    pub tasks: std::collections::HashMap<std::string::String, crate::model::MigrationTask>,

    /// Output only. That status of the workflow.
    pub state: crate::model::migration_workflow::State,

    /// Time when the workflow was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Time when the workflow was last updated.
    pub last_update_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MigrationWorkflow {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MigrationWorkflow::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::MigrationWorkflow::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [tasks][crate::model::MigrationWorkflow::tasks].
    pub fn set_tasks<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::MigrationTask>,
    {
        use std::iter::Iterator;
        self.tasks = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [state][crate::model::MigrationWorkflow::state].
    pub fn set_state<T: std::convert::Into<crate::model::migration_workflow::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::MigrationWorkflow::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::MigrationWorkflow::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_update_time][crate::model::MigrationWorkflow::last_update_time].
    pub fn set_last_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_update_time][crate::model::MigrationWorkflow::last_update_time].
    pub fn set_or_clear_last_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for MigrationWorkflow {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.MigrationWorkflow"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MigrationWorkflow {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __tasks,
            __state,
            __create_time,
            __last_update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MigrationWorkflow")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "tasks" => Ok(__FieldTag::__tasks),
                            "state" => Ok(__FieldTag::__state),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "lastUpdateTime" => Ok(__FieldTag::__last_update_time),
                            "last_update_time" => Ok(__FieldTag::__last_update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MigrationWorkflow;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MigrationWorkflow")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tasks => {
                            if !fields.insert(__FieldTag::__tasks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tasks",
                                ));
                            }
                            result.tasks = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::MigrationTask,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::migration_workflow::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__last_update_time => {
                            if !fields.insert(__FieldTag::__last_update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_update_time",
                                ));
                            }
                            result.last_update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MigrationWorkflow {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.tasks.is_empty() {
            state.serialize_entry("tasks", &self.tasks)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.last_update_time.is_some() {
            state.serialize_entry("lastUpdateTime", &self.last_update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [MigrationWorkflow].
pub mod migration_workflow {
    #[allow(unused_imports)]
    use super::*;

    /// Possible migration workflow states.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Workflow state is unspecified.
        Unspecified,
        /// Workflow is in draft status, i.e. tasks are not yet eligible for
        /// execution.
        Draft,
        /// Workflow is running (i.e. tasks are eligible for execution).
        Running,
        /// Workflow is paused. Tasks currently in progress may continue, but no
        /// further tasks will be scheduled.
        Paused,
        /// Workflow is complete. There should not be any task in a non-terminal
        /// state, but if they are (e.g. forced termination), they will not be
        /// scheduled.
        Completed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Draft => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::Paused => std::option::Option::Some(3),
                Self::Completed => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Draft => std::option::Option::Some("DRAFT"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Paused => std::option::Option::Some("PAUSED"),
                Self::Completed => std::option::Option::Some("COMPLETED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Draft,
                2 => Self::Running,
                3 => Self::Paused,
                4 => Self::Completed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "DRAFT" => Self::Draft,
                "RUNNING" => Self::Running,
                "PAUSED" => Self::Paused,
                "COMPLETED" => Self::Completed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Draft => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::Paused => serializer.serialize_i32(3),
                Self::Completed => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.bigquery.migration.v2.MigrationWorkflow.State",
            ))
        }
    }
}

/// A single task for a migration which has details about the configuration of
/// the task.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct MigrationTask {
    /// Output only. Immutable. The unique identifier for the migration task. The
    /// ID is server-generated.
    pub id: std::string::String,

    /// The type of the task. This must be one of the supported task types:
    /// Translation_Teradata2BQ, Translation_Redshift2BQ, Translation_Bteq2BQ,
    /// Translation_Oracle2BQ, Translation_HiveQL2BQ, Translation_SparkSQL2BQ,
    /// Translation_Snowflake2BQ, Translation_Netezza2BQ,
    /// Translation_AzureSynapse2BQ, Translation_Vertica2BQ,
    /// Translation_SQLServer2BQ, Translation_Presto2BQ, Translation_MySQL2BQ,
    /// Translation_Postgresql2BQ, Translation_SQLite2BQ, Translation_Greenplum2BQ.
    pub r#type: std::string::String,

    /// Output only. The current state of the task.
    pub state: crate::model::migration_task::State,

    /// Output only. An explanation that may be populated when the task is in
    /// FAILED state.
    pub processing_error: std::option::Option<rpc::model::ErrorInfo>,

    /// Time when the task was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Time when the task was last updated.
    pub last_update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Provides details to errors and issues encountered while
    /// processing the task. Presence of error details does not mean that the task
    /// failed.
    pub resource_error_details: std::vec::Vec<crate::model::ResourceErrorDetail>,

    /// The number or resources with errors. Note: This is not the total
    /// number of errors as each resource can have more than one error.
    /// This is used to indicate truncation by having a `resource_error_count`
    /// that is higher than the size of `resource_error_details`.
    pub resource_error_count: i32,

    /// The metrics for the task.
    pub metrics: std::vec::Vec<crate::model::TimeSeries>,

    /// Output only. The result of the task.
    pub task_result: std::option::Option<crate::model::MigrationTaskResult>,

    /// Count of all the processing errors in this task and its subtasks.
    pub total_processing_error_count: i32,

    /// Count of all the resource errors in this task and its subtasks.
    pub total_resource_error_count: i32,

    /// The details of the task.
    pub task_details: std::option::Option<crate::model::migration_task::TaskDetails>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MigrationTask {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::MigrationTask::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::MigrationTask::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [state][crate::model::MigrationTask::state].
    pub fn set_state<T: std::convert::Into<crate::model::migration_task::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [processing_error][crate::model::MigrationTask::processing_error].
    pub fn set_processing_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::ErrorInfo>,
    {
        self.processing_error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [processing_error][crate::model::MigrationTask::processing_error].
    pub fn set_or_clear_processing_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::ErrorInfo>,
    {
        self.processing_error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [create_time][crate::model::MigrationTask::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::MigrationTask::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_update_time][crate::model::MigrationTask::last_update_time].
    pub fn set_last_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_update_time][crate::model::MigrationTask::last_update_time].
    pub fn set_or_clear_last_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resource_error_details][crate::model::MigrationTask::resource_error_details].
    pub fn set_resource_error_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ResourceErrorDetail>,
    {
        use std::iter::Iterator;
        self.resource_error_details = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [resource_error_count][crate::model::MigrationTask::resource_error_count].
    pub fn set_resource_error_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.resource_error_count = v.into();
        self
    }

    /// Sets the value of [metrics][crate::model::MigrationTask::metrics].
    pub fn set_metrics<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TimeSeries>,
    {
        use std::iter::Iterator;
        self.metrics = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [task_result][crate::model::MigrationTask::task_result].
    pub fn set_task_result<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MigrationTaskResult>,
    {
        self.task_result = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [task_result][crate::model::MigrationTask::task_result].
    pub fn set_or_clear_task_result<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MigrationTaskResult>,
    {
        self.task_result = v.map(|x| x.into());
        self
    }

    /// Sets the value of [total_processing_error_count][crate::model::MigrationTask::total_processing_error_count].
    pub fn set_total_processing_error_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_processing_error_count = v.into();
        self
    }

    /// Sets the value of [total_resource_error_count][crate::model::MigrationTask::total_resource_error_count].
    pub fn set_total_resource_error_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_resource_error_count = v.into();
        self
    }

    /// Sets the value of [task_details][crate::model::MigrationTask::task_details].
    ///
    /// Note that all the setters affecting `task_details` are mutually
    /// exclusive.
    pub fn set_task_details<
        T: std::convert::Into<std::option::Option<crate::model::migration_task::TaskDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.task_details = v.into();
        self
    }

    /// The value of [task_details][crate::model::MigrationTask::task_details]
    /// if it holds a `TranslationConfigDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn translation_config_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TranslationConfigDetails>> {
        #[allow(unreachable_patterns)]
        self.task_details.as_ref().and_then(|v| match v {
            crate::model::migration_task::TaskDetails::TranslationConfigDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [task_details][crate::model::MigrationTask::task_details]
    /// to hold a `TranslationConfigDetails`.
    ///
    /// Note that all the setters affecting `task_details` are
    /// mutually exclusive.
    pub fn set_translation_config_details<
        T: std::convert::Into<std::boxed::Box<crate::model::TranslationConfigDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.task_details = std::option::Option::Some(
            crate::model::migration_task::TaskDetails::TranslationConfigDetails(v.into()),
        );
        self
    }

    /// The value of [task_details][crate::model::MigrationTask::task_details]
    /// if it holds a `TranslationDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn translation_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TranslationDetails>> {
        #[allow(unreachable_patterns)]
        self.task_details.as_ref().and_then(|v| match v {
            crate::model::migration_task::TaskDetails::TranslationDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [task_details][crate::model::MigrationTask::task_details]
    /// to hold a `TranslationDetails`.
    ///
    /// Note that all the setters affecting `task_details` are
    /// mutually exclusive.
    pub fn set_translation_details<
        T: std::convert::Into<std::boxed::Box<crate::model::TranslationDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.task_details = std::option::Option::Some(
            crate::model::migration_task::TaskDetails::TranslationDetails(v.into()),
        );
        self
    }
}

impl wkt::message::Message for MigrationTask {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.MigrationTask"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MigrationTask {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __translation_config_details,
            __translation_details,
            __id,
            __type,
            __state,
            __processing_error,
            __create_time,
            __last_update_time,
            __resource_error_details,
            __resource_error_count,
            __metrics,
            __task_result,
            __total_processing_error_count,
            __total_resource_error_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MigrationTask")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "translationConfigDetails" => {
                                Ok(__FieldTag::__translation_config_details)
                            }
                            "translation_config_details" => {
                                Ok(__FieldTag::__translation_config_details)
                            }
                            "translationDetails" => Ok(__FieldTag::__translation_details),
                            "translation_details" => Ok(__FieldTag::__translation_details),
                            "id" => Ok(__FieldTag::__id),
                            "type" => Ok(__FieldTag::__type),
                            "state" => Ok(__FieldTag::__state),
                            "processingError" => Ok(__FieldTag::__processing_error),
                            "processing_error" => Ok(__FieldTag::__processing_error),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "lastUpdateTime" => Ok(__FieldTag::__last_update_time),
                            "last_update_time" => Ok(__FieldTag::__last_update_time),
                            "resourceErrorDetails" => Ok(__FieldTag::__resource_error_details),
                            "resource_error_details" => Ok(__FieldTag::__resource_error_details),
                            "resourceErrorCount" => Ok(__FieldTag::__resource_error_count),
                            "resource_error_count" => Ok(__FieldTag::__resource_error_count),
                            "metrics" => Ok(__FieldTag::__metrics),
                            "taskResult" => Ok(__FieldTag::__task_result),
                            "task_result" => Ok(__FieldTag::__task_result),
                            "totalProcessingErrorCount" => {
                                Ok(__FieldTag::__total_processing_error_count)
                            }
                            "total_processing_error_count" => {
                                Ok(__FieldTag::__total_processing_error_count)
                            }
                            "totalResourceErrorCount" => {
                                Ok(__FieldTag::__total_resource_error_count)
                            }
                            "total_resource_error_count" => {
                                Ok(__FieldTag::__total_resource_error_count)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MigrationTask;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MigrationTask")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__translation_config_details => {
                            if !fields.insert(__FieldTag::__translation_config_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for translation_config_details",
                                ));
                            }
                            if result.task_details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `task_details`, a oneof with full ID .google.cloud.bigquery.migration.v2.MigrationTask.translation_config_details, latest field was translationConfigDetails",
                                ));
                            }
                            result.task_details = std::option::Option::Some(
                                crate::model::migration_task::TaskDetails::TranslationConfigDetails(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::TranslationConfigDetails>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__translation_details => {
                            if !fields.insert(__FieldTag::__translation_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for translation_details",
                                ));
                            }
                            if result.task_details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `task_details`, a oneof with full ID .google.cloud.bigquery.migration.v2.MigrationTask.translation_details, latest field was translationDetails",
                                ));
                            }
                            result.task_details = std::option::Option::Some(
                                crate::model::migration_task::TaskDetails::TranslationDetails(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::TranslationDetails>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::migration_task::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__processing_error => {
                            if !fields.insert(__FieldTag::__processing_error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for processing_error",
                                ));
                            }
                            result.processing_error =
                                map.next_value::<std::option::Option<rpc::model::ErrorInfo>>()?;
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__last_update_time => {
                            if !fields.insert(__FieldTag::__last_update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_update_time",
                                ));
                            }
                            result.last_update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__resource_error_details => {
                            if !fields.insert(__FieldTag::__resource_error_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_error_details",
                                ));
                            }
                            result.resource_error_details = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ResourceErrorDetail>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_error_count => {
                            if !fields.insert(__FieldTag::__resource_error_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_error_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.resource_error_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__metrics => {
                            if !fields.insert(__FieldTag::__metrics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metrics",
                                ));
                            }
                            result.metrics = map.next_value::<std::option::Option<std::vec::Vec<crate::model::TimeSeries>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__task_result => {
                            if !fields.insert(__FieldTag::__task_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for task_result",
                                ));
                            }
                            result.task_result = map.next_value::<std::option::Option<crate::model::MigrationTaskResult>>()?
                                ;
                        }
                        __FieldTag::__total_processing_error_count => {
                            if !fields.insert(__FieldTag::__total_processing_error_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_processing_error_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_processing_error_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__total_resource_error_count => {
                            if !fields.insert(__FieldTag::__total_resource_error_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_resource_error_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_resource_error_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MigrationTask {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.translation_config_details() {
            state.serialize_entry("translationConfigDetails", value)?;
        }
        if let Some(value) = self.translation_details() {
            state.serialize_entry("translationDetails", value)?;
        }
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.r#type.is_empty() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.processing_error.is_some() {
            state.serialize_entry("processingError", &self.processing_error)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.last_update_time.is_some() {
            state.serialize_entry("lastUpdateTime", &self.last_update_time)?;
        }
        if !self.resource_error_details.is_empty() {
            state.serialize_entry("resourceErrorDetails", &self.resource_error_details)?;
        }
        if !wkt::internal::is_default(&self.resource_error_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("resourceErrorCount", &__With(&self.resource_error_count))?;
        }
        if !self.metrics.is_empty() {
            state.serialize_entry("metrics", &self.metrics)?;
        }
        if self.task_result.is_some() {
            state.serialize_entry("taskResult", &self.task_result)?;
        }
        if !wkt::internal::is_default(&self.total_processing_error_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "totalProcessingErrorCount",
                &__With(&self.total_processing_error_count),
            )?;
        }
        if !wkt::internal::is_default(&self.total_resource_error_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "totalResourceErrorCount",
                &__With(&self.total_resource_error_count),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [MigrationTask].
pub mod migration_task {
    #[allow(unused_imports)]
    use super::*;

    /// Possible states of a migration task.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state is unspecified.
        Unspecified,
        /// The task is waiting for orchestration.
        Pending,
        /// The task is assigned to an orchestrator.
        Orchestrating,
        /// The task is running, i.e. its subtasks are ready for execution.
        Running,
        /// Tha task is paused. Assigned subtasks can continue, but no new subtasks
        /// will be scheduled.
        Paused,
        /// The task finished successfully.
        Succeeded,
        /// The task finished unsuccessfully.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Orchestrating => std::option::Option::Some(2),
                Self::Running => std::option::Option::Some(3),
                Self::Paused => std::option::Option::Some(4),
                Self::Succeeded => std::option::Option::Some(5),
                Self::Failed => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Orchestrating => std::option::Option::Some("ORCHESTRATING"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Paused => std::option::Option::Some("PAUSED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Orchestrating,
                3 => Self::Running,
                4 => Self::Paused,
                5 => Self::Succeeded,
                6 => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "ORCHESTRATING" => Self::Orchestrating,
                "RUNNING" => Self::Running,
                "PAUSED" => Self::Paused,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Orchestrating => serializer.serialize_i32(2),
                Self::Running => serializer.serialize_i32(3),
                Self::Paused => serializer.serialize_i32(4),
                Self::Succeeded => serializer.serialize_i32(5),
                Self::Failed => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.bigquery.migration.v2.MigrationTask.State",
            ))
        }
    }

    /// The details of the task.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TaskDetails {
        /// Task configuration for CW Batch/Offline SQL Translation.
        TranslationConfigDetails(std::boxed::Box<crate::model::TranslationConfigDetails>),
        /// Task details for unified SQL Translation.
        TranslationDetails(std::boxed::Box<crate::model::TranslationDetails>),
    }
}

/// A subtask for a migration which carries details about the configuration of
/// the subtask. The content of the details should not matter to the end user,
/// but is a contract between the subtask creator and subtask worker.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct MigrationSubtask {
    /// Output only. Immutable. The resource name for the migration subtask. The ID
    /// is server-generated.
    ///
    /// Example: `projects/123/locations/us/workflows/345/subtasks/678`
    pub name: std::string::String,

    /// The unique ID of the task to which this subtask belongs.
    pub task_id: std::string::String,

    /// The type of the Subtask. The migration service does not check whether this
    /// is a known type. It is up to the task creator (i.e. orchestrator or worker)
    /// to ensure it only creates subtasks for which there are compatible workers
    /// polling for Subtasks.
    pub r#type: std::string::String,

    /// Output only. The current state of the subtask.
    pub state: crate::model::migration_subtask::State,

    /// Output only. An explanation that may be populated when the task is in
    /// FAILED state.
    pub processing_error: std::option::Option<rpc::model::ErrorInfo>,

    /// Output only. Provides details to errors and issues encountered while
    /// processing the subtask. Presence of error details does not mean that the
    /// subtask failed.
    pub resource_error_details: std::vec::Vec<crate::model::ResourceErrorDetail>,

    /// The number or resources with errors. Note: This is not the total
    /// number of errors as each resource can have more than one error.
    /// This is used to indicate truncation by having a `resource_error_count`
    /// that is higher than the size of `resource_error_details`.
    pub resource_error_count: i32,

    /// Time when the subtask was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Time when the subtask was last updated.
    pub last_update_time: std::option::Option<wkt::Timestamp>,

    /// The metrics for the subtask.
    pub metrics: std::vec::Vec<crate::model::TimeSeries>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MigrationSubtask {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MigrationSubtask::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [task_id][crate::model::MigrationSubtask::task_id].
    pub fn set_task_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.task_id = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::MigrationSubtask::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [state][crate::model::MigrationSubtask::state].
    pub fn set_state<T: std::convert::Into<crate::model::migration_subtask::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [processing_error][crate::model::MigrationSubtask::processing_error].
    pub fn set_processing_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::ErrorInfo>,
    {
        self.processing_error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [processing_error][crate::model::MigrationSubtask::processing_error].
    pub fn set_or_clear_processing_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::ErrorInfo>,
    {
        self.processing_error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resource_error_details][crate::model::MigrationSubtask::resource_error_details].
    pub fn set_resource_error_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ResourceErrorDetail>,
    {
        use std::iter::Iterator;
        self.resource_error_details = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [resource_error_count][crate::model::MigrationSubtask::resource_error_count].
    pub fn set_resource_error_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.resource_error_count = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::MigrationSubtask::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::MigrationSubtask::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_update_time][crate::model::MigrationSubtask::last_update_time].
    pub fn set_last_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_update_time][crate::model::MigrationSubtask::last_update_time].
    pub fn set_or_clear_last_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [metrics][crate::model::MigrationSubtask::metrics].
    pub fn set_metrics<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TimeSeries>,
    {
        use std::iter::Iterator;
        self.metrics = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for MigrationSubtask {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.MigrationSubtask"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MigrationSubtask {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __task_id,
            __type,
            __state,
            __processing_error,
            __resource_error_details,
            __resource_error_count,
            __create_time,
            __last_update_time,
            __metrics,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MigrationSubtask")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "taskId" => Ok(__FieldTag::__task_id),
                            "task_id" => Ok(__FieldTag::__task_id),
                            "type" => Ok(__FieldTag::__type),
                            "state" => Ok(__FieldTag::__state),
                            "processingError" => Ok(__FieldTag::__processing_error),
                            "processing_error" => Ok(__FieldTag::__processing_error),
                            "resourceErrorDetails" => Ok(__FieldTag::__resource_error_details),
                            "resource_error_details" => Ok(__FieldTag::__resource_error_details),
                            "resourceErrorCount" => Ok(__FieldTag::__resource_error_count),
                            "resource_error_count" => Ok(__FieldTag::__resource_error_count),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "lastUpdateTime" => Ok(__FieldTag::__last_update_time),
                            "last_update_time" => Ok(__FieldTag::__last_update_time),
                            "metrics" => Ok(__FieldTag::__metrics),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MigrationSubtask;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MigrationSubtask")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__task_id => {
                            if !fields.insert(__FieldTag::__task_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for task_id",
                                ));
                            }
                            result.task_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::migration_subtask::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__processing_error => {
                            if !fields.insert(__FieldTag::__processing_error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for processing_error",
                                ));
                            }
                            result.processing_error =
                                map.next_value::<std::option::Option<rpc::model::ErrorInfo>>()?;
                        }
                        __FieldTag::__resource_error_details => {
                            if !fields.insert(__FieldTag::__resource_error_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_error_details",
                                ));
                            }
                            result.resource_error_details = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ResourceErrorDetail>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_error_count => {
                            if !fields.insert(__FieldTag::__resource_error_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_error_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.resource_error_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__last_update_time => {
                            if !fields.insert(__FieldTag::__last_update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_update_time",
                                ));
                            }
                            result.last_update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__metrics => {
                            if !fields.insert(__FieldTag::__metrics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metrics",
                                ));
                            }
                            result.metrics = map.next_value::<std::option::Option<std::vec::Vec<crate::model::TimeSeries>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MigrationSubtask {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.task_id.is_empty() {
            state.serialize_entry("taskId", &self.task_id)?;
        }
        if !self.r#type.is_empty() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.processing_error.is_some() {
            state.serialize_entry("processingError", &self.processing_error)?;
        }
        if !self.resource_error_details.is_empty() {
            state.serialize_entry("resourceErrorDetails", &self.resource_error_details)?;
        }
        if !wkt::internal::is_default(&self.resource_error_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("resourceErrorCount", &__With(&self.resource_error_count))?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.last_update_time.is_some() {
            state.serialize_entry("lastUpdateTime", &self.last_update_time)?;
        }
        if !self.metrics.is_empty() {
            state.serialize_entry("metrics", &self.metrics)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [MigrationSubtask].
pub mod migration_subtask {
    #[allow(unused_imports)]
    use super::*;

    /// Possible states of a migration subtask.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state is unspecified.
        Unspecified,
        /// The subtask is ready, i.e. it is ready for execution.
        Active,
        /// The subtask is running, i.e. it is assigned to a worker for execution.
        Running,
        /// The subtask finished successfully.
        Succeeded,
        /// The subtask finished unsuccessfully.
        Failed,
        /// The subtask is paused, i.e., it will not be scheduled. If it was already
        /// assigned,it might still finish but no new lease renewals will be granted.
        Paused,
        /// The subtask is pending a dependency. It will be scheduled once its
        /// dependencies are done.
        PendingDependency,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Active => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::Succeeded => std::option::Option::Some(3),
                Self::Failed => std::option::Option::Some(4),
                Self::Paused => std::option::Option::Some(5),
                Self::PendingDependency => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Paused => std::option::Option::Some("PAUSED"),
                Self::PendingDependency => std::option::Option::Some("PENDING_DEPENDENCY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Active,
                2 => Self::Running,
                3 => Self::Succeeded,
                4 => Self::Failed,
                5 => Self::Paused,
                6 => Self::PendingDependency,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ACTIVE" => Self::Active,
                "RUNNING" => Self::Running,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                "PAUSED" => Self::Paused,
                "PENDING_DEPENDENCY" => Self::PendingDependency,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Active => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::Succeeded => serializer.serialize_i32(3),
                Self::Failed => serializer.serialize_i32(4),
                Self::Paused => serializer.serialize_i32(5),
                Self::PendingDependency => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.bigquery.migration.v2.MigrationSubtask.State",
            ))
        }
    }
}

/// The migration task result.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct MigrationTaskResult {
    /// Details specific to the task type.
    pub details: std::option::Option<crate::model::migration_task_result::Details>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MigrationTaskResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [details][crate::model::MigrationTaskResult::details].
    ///
    /// Note that all the setters affecting `details` are mutually
    /// exclusive.
    pub fn set_details<
        T: std::convert::Into<std::option::Option<crate::model::migration_task_result::Details>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = v.into();
        self
    }

    /// The value of [details][crate::model::MigrationTaskResult::details]
    /// if it holds a `TranslationTaskResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn translation_task_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TranslationTaskResult>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::migration_task_result::Details::TranslationTaskResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::MigrationTaskResult::details]
    /// to hold a `TranslationTaskResult`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_translation_task_result<
        T: std::convert::Into<std::boxed::Box<crate::model::TranslationTaskResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = std::option::Option::Some(
            crate::model::migration_task_result::Details::TranslationTaskResult(v.into()),
        );
        self
    }
}

impl wkt::message::Message for MigrationTaskResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.MigrationTaskResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MigrationTaskResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __translation_task_result,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MigrationTaskResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "translationTaskResult" => Ok(__FieldTag::__translation_task_result),
                            "translation_task_result" => Ok(__FieldTag::__translation_task_result),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MigrationTaskResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MigrationTaskResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__translation_task_result => {
                            if !fields.insert(__FieldTag::__translation_task_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for translation_task_result",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .google.cloud.bigquery.migration.v2.MigrationTaskResult.translation_task_result, latest field was translationTaskResult",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::migration_task_result::Details::TranslationTaskResult(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::TranslationTaskResult>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MigrationTaskResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.translation_task_result() {
            state.serialize_entry("translationTaskResult", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [MigrationTaskResult].
pub mod migration_task_result {
    #[allow(unused_imports)]
    use super::*;

    /// Details specific to the task type.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Details {
        /// Details specific to translation task types.
        TranslationTaskResult(std::boxed::Box<crate::model::TranslationTaskResult>),
    }
}

/// Translation specific result details from the migration task.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TranslationTaskResult {
    /// The list of the translated literals.
    pub translated_literals: std::vec::Vec<crate::model::Literal>,

    /// The records from the aggregate CSV report for a migration workflow.
    pub report_log_messages: std::vec::Vec<crate::model::GcsReportLogMessage>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TranslationTaskResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [translated_literals][crate::model::TranslationTaskResult::translated_literals].
    pub fn set_translated_literals<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Literal>,
    {
        use std::iter::Iterator;
        self.translated_literals = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [report_log_messages][crate::model::TranslationTaskResult::report_log_messages].
    pub fn set_report_log_messages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::GcsReportLogMessage>,
    {
        use std::iter::Iterator;
        self.report_log_messages = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TranslationTaskResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.TranslationTaskResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TranslationTaskResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __translated_literals,
            __report_log_messages,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TranslationTaskResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "translatedLiterals" => Ok(__FieldTag::__translated_literals),
                            "translated_literals" => Ok(__FieldTag::__translated_literals),
                            "reportLogMessages" => Ok(__FieldTag::__report_log_messages),
                            "report_log_messages" => Ok(__FieldTag::__report_log_messages),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TranslationTaskResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TranslationTaskResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__translated_literals => {
                            if !fields.insert(__FieldTag::__translated_literals) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for translated_literals",
                                ));
                            }
                            result.translated_literals = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Literal>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__report_log_messages => {
                            if !fields.insert(__FieldTag::__report_log_messages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for report_log_messages",
                                ));
                            }
                            result.report_log_messages = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::GcsReportLogMessage>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TranslationTaskResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.translated_literals.is_empty() {
            state.serialize_entry("translatedLiterals", &self.translated_literals)?;
        }
        if !self.report_log_messages.is_empty() {
            state.serialize_entry("reportLogMessages", &self.report_log_messages)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Provides details for errors and the corresponding resources.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ResourceErrorDetail {
    /// Required. Information about the resource where the error is located.
    pub resource_info: std::option::Option<rpc::model::ResourceInfo>,

    /// Required. The error details for the resource.
    pub error_details: std::vec::Vec<crate::model::ErrorDetail>,

    /// Required. How many errors there are in total for the resource. Truncation
    /// can be indicated by having an `error_count` that is higher than the size of
    /// `error_details`.
    pub error_count: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResourceErrorDetail {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_info][crate::model::ResourceErrorDetail::resource_info].
    pub fn set_resource_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::ResourceInfo>,
    {
        self.resource_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resource_info][crate::model::ResourceErrorDetail::resource_info].
    pub fn set_or_clear_resource_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::ResourceInfo>,
    {
        self.resource_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [error_details][crate::model::ResourceErrorDetail::error_details].
    pub fn set_error_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ErrorDetail>,
    {
        use std::iter::Iterator;
        self.error_details = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [error_count][crate::model::ResourceErrorDetail::error_count].
    pub fn set_error_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.error_count = v.into();
        self
    }
}

impl wkt::message::Message for ResourceErrorDetail {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.ResourceErrorDetail"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ResourceErrorDetail {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __resource_info,
            __error_details,
            __error_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResourceErrorDetail")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resourceInfo" => Ok(__FieldTag::__resource_info),
                            "resource_info" => Ok(__FieldTag::__resource_info),
                            "errorDetails" => Ok(__FieldTag::__error_details),
                            "error_details" => Ok(__FieldTag::__error_details),
                            "errorCount" => Ok(__FieldTag::__error_count),
                            "error_count" => Ok(__FieldTag::__error_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ResourceErrorDetail;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResourceErrorDetail")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__resource_info => {
                            if !fields.insert(__FieldTag::__resource_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_info",
                                ));
                            }
                            result.resource_info =
                                map.next_value::<std::option::Option<rpc::model::ResourceInfo>>()?;
                        }
                        __FieldTag::__error_details => {
                            if !fields.insert(__FieldTag::__error_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_details",
                                ));
                            }
                            result.error_details = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ErrorDetail>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__error_count => {
                            if !fields.insert(__FieldTag::__error_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.error_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ResourceErrorDetail {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.resource_info.is_some() {
            state.serialize_entry("resourceInfo", &self.resource_info)?;
        }
        if !self.error_details.is_empty() {
            state.serialize_entry("errorDetails", &self.error_details)?;
        }
        if !wkt::internal::is_default(&self.error_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("errorCount", &__With(&self.error_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Provides details for errors, e.g. issues that where encountered when
/// processing a subtask.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ErrorDetail {
    /// Optional. The exact location within the resource (if applicable).
    pub location: std::option::Option<crate::model::ErrorLocation>,

    /// Required. Describes the cause of the error with structured detail.
    pub error_info: std::option::Option<rpc::model::ErrorInfo>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ErrorDetail {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::ErrorDetail::location].
    pub fn set_location<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ErrorLocation>,
    {
        self.location = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [location][crate::model::ErrorDetail::location].
    pub fn set_or_clear_location<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ErrorLocation>,
    {
        self.location = v.map(|x| x.into());
        self
    }

    /// Sets the value of [error_info][crate::model::ErrorDetail::error_info].
    pub fn set_error_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::ErrorInfo>,
    {
        self.error_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error_info][crate::model::ErrorDetail::error_info].
    pub fn set_or_clear_error_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::ErrorInfo>,
    {
        self.error_info = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ErrorDetail {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.ErrorDetail"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ErrorDetail {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __location,
            __error_info,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ErrorDetail")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "location" => Ok(__FieldTag::__location),
                            "errorInfo" => Ok(__FieldTag::__error_info),
                            "error_info" => Ok(__FieldTag::__error_info),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ErrorDetail;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ErrorDetail")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<crate::model::ErrorLocation>>()?;
                        }
                        __FieldTag::__error_info => {
                            if !fields.insert(__FieldTag::__error_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_info",
                                ));
                            }
                            result.error_info =
                                map.next_value::<std::option::Option<rpc::model::ErrorInfo>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ErrorDetail {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.location.is_some() {
            state.serialize_entry("location", &self.location)?;
        }
        if self.error_info.is_some() {
            state.serialize_entry("errorInfo", &self.error_info)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Holds information about where the error is located.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ErrorLocation {
    /// Optional. If applicable, denotes the line where the error occurred. A zero
    /// value means that there is no line information.
    pub line: i32,

    /// Optional. If applicable, denotes the column where the error occurred. A
    /// zero value means that there is no columns information.
    pub column: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ErrorLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [line][crate::model::ErrorLocation::line].
    pub fn set_line<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.line = v.into();
        self
    }

    /// Sets the value of [column][crate::model::ErrorLocation::column].
    pub fn set_column<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.column = v.into();
        self
    }
}

impl wkt::message::Message for ErrorLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.ErrorLocation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ErrorLocation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __line,
            __column,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ErrorLocation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "line" => Ok(__FieldTag::__line),
                            "column" => Ok(__FieldTag::__column),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ErrorLocation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ErrorLocation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__line => {
                            if !fields.insert(__FieldTag::__line) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for line",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.line = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__column => {
                            if !fields.insert(__FieldTag::__column) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for column",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.column = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ErrorLocation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.line) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("line", &__With(&self.line))?;
        }
        if !wkt::internal::is_default(&self.column) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("column", &__With(&self.column))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The metrics object for a SubTask.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TimeSeries {
    /// Required. The name of the metric.
    ///
    /// If the metric is not known by the service yet, it will be auto-created.
    pub metric: std::string::String,

    /// Required. The value type of the time series.
    pub value_type: api::model::metric_descriptor::ValueType,

    /// Optional. The metric kind of the time series.
    ///
    /// If present, it must be the same as the metric kind of the associated
    /// metric. If the associated metric's descriptor must be auto-created, then
    /// this field specifies the metric kind of the new descriptor and must be
    /// either `GAUGE` (the default) or `CUMULATIVE`.
    pub metric_kind: api::model::metric_descriptor::MetricKind,

    /// Required. The data points of this time series. When listing time series,
    /// points are returned in reverse time order.
    ///
    /// When creating a time series, this field must contain exactly one point and
    /// the point's type must be the same as the value type of the associated
    /// metric. If the associated metric's descriptor must be auto-created, then
    /// the value type of the descriptor is determined by the point's type, which
    /// must be `BOOL`, `INT64`, `DOUBLE`, or `DISTRIBUTION`.
    pub points: std::vec::Vec<crate::model::Point>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TimeSeries {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric][crate::model::TimeSeries::metric].
    pub fn set_metric<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.metric = v.into();
        self
    }

    /// Sets the value of [value_type][crate::model::TimeSeries::value_type].
    pub fn set_value_type<T: std::convert::Into<api::model::metric_descriptor::ValueType>>(
        mut self,
        v: T,
    ) -> Self {
        self.value_type = v.into();
        self
    }

    /// Sets the value of [metric_kind][crate::model::TimeSeries::metric_kind].
    pub fn set_metric_kind<T: std::convert::Into<api::model::metric_descriptor::MetricKind>>(
        mut self,
        v: T,
    ) -> Self {
        self.metric_kind = v.into();
        self
    }

    /// Sets the value of [points][crate::model::TimeSeries::points].
    pub fn set_points<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Point>,
    {
        use std::iter::Iterator;
        self.points = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TimeSeries {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.TimeSeries"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TimeSeries {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __metric,
            __value_type,
            __metric_kind,
            __points,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TimeSeries")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "metric" => Ok(__FieldTag::__metric),
                            "valueType" => Ok(__FieldTag::__value_type),
                            "value_type" => Ok(__FieldTag::__value_type),
                            "metricKind" => Ok(__FieldTag::__metric_kind),
                            "metric_kind" => Ok(__FieldTag::__metric_kind),
                            "points" => Ok(__FieldTag::__points),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TimeSeries;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TimeSeries")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__metric => {
                            if !fields.insert(__FieldTag::__metric) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metric",
                                ));
                            }
                            result.metric = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__value_type => {
                            if !fields.insert(__FieldTag::__value_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value_type",
                                ));
                            }
                            result.value_type = map.next_value::<std::option::Option<api::model::metric_descriptor::ValueType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__metric_kind => {
                            if !fields.insert(__FieldTag::__metric_kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metric_kind",
                                ));
                            }
                            result.metric_kind = map.next_value::<std::option::Option<api::model::metric_descriptor::MetricKind>>()?.unwrap_or_default();
                        }
                        __FieldTag::__points => {
                            if !fields.insert(__FieldTag::__points) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for points",
                                ));
                            }
                            result.points = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Point>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TimeSeries {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.metric.is_empty() {
            state.serialize_entry("metric", &self.metric)?;
        }
        if !wkt::internal::is_default(&self.value_type) {
            state.serialize_entry("valueType", &self.value_type)?;
        }
        if !wkt::internal::is_default(&self.metric_kind) {
            state.serialize_entry("metricKind", &self.metric_kind)?;
        }
        if !self.points.is_empty() {
            state.serialize_entry("points", &self.points)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A single data point in a time series.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Point {
    /// The time interval to which the data point applies.  For `GAUGE` metrics,
    /// the start time does not need to be supplied, but if it is supplied, it must
    /// equal the end time.  For `DELTA` metrics, the start and end time should
    /// specify a non-zero interval, with subsequent points specifying contiguous
    /// and non-overlapping intervals.  For `CUMULATIVE` metrics, the start and end
    /// time should specify a non-zero interval, with subsequent points specifying
    /// the same start time and increasing end times, until an event resets the
    /// cumulative value to zero and sets a new start time for the following
    /// points.
    pub interval: std::option::Option<crate::model::TimeInterval>,

    /// The value of the data point.
    pub value: std::option::Option<crate::model::TypedValue>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Point {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [interval][crate::model::Point::interval].
    pub fn set_interval<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TimeInterval>,
    {
        self.interval = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [interval][crate::model::Point::interval].
    pub fn set_or_clear_interval<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TimeInterval>,
    {
        self.interval = v.map(|x| x.into());
        self
    }

    /// Sets the value of [value][crate::model::Point::value].
    pub fn set_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TypedValue>,
    {
        self.value = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [value][crate::model::Point::value].
    pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TypedValue>,
    {
        self.value = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Point {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.Point"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Point {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __interval,
            __value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Point")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "interval" => Ok(__FieldTag::__interval),
                            "value" => Ok(__FieldTag::__value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Point;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Point")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__interval => {
                            if !fields.insert(__FieldTag::__interval) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for interval",
                                ));
                            }
                            result.interval = map
                                .next_value::<std::option::Option<crate::model::TimeInterval>>()?;
                        }
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            result.value =
                                map.next_value::<std::option::Option<crate::model::TypedValue>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Point {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.interval.is_some() {
            state.serialize_entry("interval", &self.interval)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A time interval extending just after a start time through an end time.
/// If the start time is the same as the end time, then the interval
/// represents a single point in time.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TimeInterval {
    /// Optional. The beginning of the time interval.  The default value
    /// for the start time is the end time. The start time must not be
    /// later than the end time.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Required. The end of the time interval.
    pub end_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TimeInterval {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::TimeInterval::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::TimeInterval::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::TimeInterval::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::TimeInterval::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for TimeInterval {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.TimeInterval"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TimeInterval {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __start_time,
            __end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TimeInterval")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TimeInterval;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TimeInterval")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TimeInterval {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A single strongly-typed value.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TypedValue {
    /// The typed value field.
    pub value: std::option::Option<crate::model::typed_value::Value>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TypedValue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [value][crate::model::TypedValue::value].
    ///
    /// Note that all the setters affecting `value` are mutually
    /// exclusive.
    pub fn set_value<
        T: std::convert::Into<std::option::Option<crate::model::typed_value::Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value = v.into();
        self
    }

    /// The value of [value][crate::model::TypedValue::value]
    /// if it holds a `BoolValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bool_value(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::typed_value::Value::BoolValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::TypedValue::value]
    /// to hold a `BoolValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_bool_value<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::typed_value::Value::BoolValue(v.into()));
        self
    }

    /// The value of [value][crate::model::TypedValue::value]
    /// if it holds a `Int64Value`, `None` if the field is not set or
    /// holds a different branch.
    pub fn int64_value(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::typed_value::Value::Int64Value(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::TypedValue::value]
    /// to hold a `Int64Value`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_int64_value<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::typed_value::Value::Int64Value(v.into()));
        self
    }

    /// The value of [value][crate::model::TypedValue::value]
    /// if it holds a `DoubleValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn double_value(&self) -> std::option::Option<&f64> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::typed_value::Value::DoubleValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::TypedValue::value]
    /// to hold a `DoubleValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_double_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::typed_value::Value::DoubleValue(v.into()));
        self
    }

    /// The value of [value][crate::model::TypedValue::value]
    /// if it holds a `StringValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn string_value(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::typed_value::Value::StringValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::TypedValue::value]
    /// to hold a `StringValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_string_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::typed_value::Value::StringValue(v.into()));
        self
    }

    /// The value of [value][crate::model::TypedValue::value]
    /// if it holds a `DistributionValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn distribution_value(
        &self,
    ) -> std::option::Option<&std::boxed::Box<api::model::Distribution>> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::typed_value::Value::DistributionValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::TypedValue::value]
    /// to hold a `DistributionValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_distribution_value<
        T: std::convert::Into<std::boxed::Box<api::model::Distribution>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value = std::option::Option::Some(
            crate::model::typed_value::Value::DistributionValue(v.into()),
        );
        self
    }
}

impl wkt::message::Message for TypedValue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.TypedValue"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TypedValue {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bool_value,
            __int64_value,
            __double_value,
            __string_value,
            __distribution_value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TypedValue")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "boolValue" => Ok(__FieldTag::__bool_value),
                            "bool_value" => Ok(__FieldTag::__bool_value),
                            "int64Value" => Ok(__FieldTag::__int64_value),
                            "int64_value" => Ok(__FieldTag::__int64_value),
                            "doubleValue" => Ok(__FieldTag::__double_value),
                            "double_value" => Ok(__FieldTag::__double_value),
                            "stringValue" => Ok(__FieldTag::__string_value),
                            "string_value" => Ok(__FieldTag::__string_value),
                            "distributionValue" => Ok(__FieldTag::__distribution_value),
                            "distribution_value" => Ok(__FieldTag::__distribution_value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TypedValue;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TypedValue")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bool_value => {
                            if !fields.insert(__FieldTag::__bool_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bool_value",
                                ));
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.cloud.bigquery.migration.v2.TypedValue.bool_value, latest field was boolValue",
                                ));
                            }
                            result.value = std::option::Option::Some(
                                crate::model::typed_value::Value::BoolValue(
                                    map.next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__int64_value => {
                            if !fields.insert(__FieldTag::__int64_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for int64_value",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.cloud.bigquery.migration.v2.TypedValue.int64_value, latest field was int64Value",
                                ));
                            }
                            result.value = std::option::Option::Some(
                                crate::model::typed_value::Value::Int64Value(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__double_value => {
                            if !fields.insert(__FieldTag::__double_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for double_value",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.cloud.bigquery.migration.v2.TypedValue.double_value, latest field was doubleValue",
                                ));
                            }
                            result.value = std::option::Option::Some(
                                crate::model::typed_value::Value::DoubleValue(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__string_value => {
                            if !fields.insert(__FieldTag::__string_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for string_value",
                                ));
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.cloud.bigquery.migration.v2.TypedValue.string_value, latest field was stringValue",
                                ));
                            }
                            result.value = std::option::Option::Some(
                                crate::model::typed_value::Value::StringValue(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__distribution_value => {
                            if !fields.insert(__FieldTag::__distribution_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for distribution_value",
                                ));
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.cloud.bigquery.migration.v2.TypedValue.distribution_value, latest field was distributionValue",
                                ));
                            }
                            result.value = std::option::Option::Some(
                                crate::model::typed_value::Value::DistributionValue(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<api::model::Distribution>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TypedValue {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.bool_value() {
            state.serialize_entry("boolValue", value)?;
        }
        if let Some(value) = self.int64_value() {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("int64Value", &__With(value))?;
        }
        if let Some(value) = self.double_value() {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("doubleValue", &__With(value))?;
        }
        if let Some(value) = self.string_value() {
            state.serialize_entry("stringValue", value)?;
        }
        if let Some(value) = self.distribution_value() {
            state.serialize_entry("distributionValue", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [TypedValue].
pub mod typed_value {
    #[allow(unused_imports)]
    use super::*;

    /// The typed value field.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Value {
        /// A Boolean value: `true` or `false`.
        BoolValue(bool),
        /// A 64-bit integer. Its range is approximately `+/-9.2x10^18`.
        Int64Value(i64),
        /// A 64-bit double-precision floating-point number. Its magnitude
        /// is approximately `+/-10^(+/-300)` and it has 16 significant digits of
        /// precision.
        DoubleValue(f64),
        /// A variable-length string value.
        StringValue(std::string::String),
        /// A distribution value.
        DistributionValue(std::boxed::Box<api::model::Distribution>),
    }
}

/// Request to create a migration workflow resource.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateMigrationWorkflowRequest {
    /// Required. The name of the project to which this migration workflow belongs.
    /// Example: `projects/foo/locations/bar`
    pub parent: std::string::String,

    /// Required. The migration workflow to create.
    pub migration_workflow: std::option::Option<crate::model::MigrationWorkflow>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateMigrationWorkflowRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateMigrationWorkflowRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [migration_workflow][crate::model::CreateMigrationWorkflowRequest::migration_workflow].
    pub fn set_migration_workflow<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MigrationWorkflow>,
    {
        self.migration_workflow = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [migration_workflow][crate::model::CreateMigrationWorkflowRequest::migration_workflow].
    pub fn set_or_clear_migration_workflow<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MigrationWorkflow>,
    {
        self.migration_workflow = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateMigrationWorkflowRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.CreateMigrationWorkflowRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateMigrationWorkflowRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __migration_workflow,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateMigrationWorkflowRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "migrationWorkflow" => Ok(__FieldTag::__migration_workflow),
                            "migration_workflow" => Ok(__FieldTag::__migration_workflow),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateMigrationWorkflowRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateMigrationWorkflowRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__migration_workflow => {
                            if !fields.insert(__FieldTag::__migration_workflow) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for migration_workflow",
                                ));
                            }
                            result.migration_workflow = map
                                .next_value::<std::option::Option<crate::model::MigrationWorkflow>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateMigrationWorkflowRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.migration_workflow.is_some() {
            state.serialize_entry("migrationWorkflow", &self.migration_workflow)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A request to get a previously created migration workflow.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetMigrationWorkflowRequest {
    /// Required. The unique identifier for the migration workflow.
    /// Example: `projects/123/locations/us/workflows/1234`
    pub name: std::string::String,

    /// The list of fields to be retrieved.
    pub read_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetMigrationWorkflowRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetMigrationWorkflowRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::GetMigrationWorkflowRequest::read_mask].
    pub fn set_read_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.read_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [read_mask][crate::model::GetMigrationWorkflowRequest::read_mask].
    pub fn set_or_clear_read_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.read_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for GetMigrationWorkflowRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.GetMigrationWorkflowRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetMigrationWorkflowRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __read_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetMigrationWorkflowRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "readMask" => Ok(__FieldTag::__read_mask),
                            "read_mask" => Ok(__FieldTag::__read_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetMigrationWorkflowRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetMigrationWorkflowRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__read_mask => {
                            if !fields.insert(__FieldTag::__read_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_mask",
                                ));
                            }
                            result.read_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetMigrationWorkflowRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.read_mask.is_some() {
            state.serialize_entry("readMask", &self.read_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A request to list previously created migration workflows.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListMigrationWorkflowsRequest {
    /// Required. The project and location of the migration workflows to list.
    /// Example: `projects/123/locations/us`
    pub parent: std::string::String,

    /// The list of fields to be retrieved.
    pub read_mask: std::option::Option<wkt::FieldMask>,

    /// The maximum number of migration workflows to return. The service may return
    /// fewer than this number.
    pub page_size: i32,

    /// A page token, received from previous `ListMigrationWorkflows` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListMigrationWorkflows`
    /// must match the call that provided the page token.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMigrationWorkflowsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListMigrationWorkflowsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListMigrationWorkflowsRequest::read_mask].
    pub fn set_read_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.read_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [read_mask][crate::model::ListMigrationWorkflowsRequest::read_mask].
    pub fn set_or_clear_read_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.read_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [page_size][crate::model::ListMigrationWorkflowsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListMigrationWorkflowsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListMigrationWorkflowsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.ListMigrationWorkflowsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListMigrationWorkflowsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __read_mask,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListMigrationWorkflowsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "readMask" => Ok(__FieldTag::__read_mask),
                            "read_mask" => Ok(__FieldTag::__read_mask),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListMigrationWorkflowsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListMigrationWorkflowsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__read_mask => {
                            if !fields.insert(__FieldTag::__read_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_mask",
                                ));
                            }
                            result.read_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListMigrationWorkflowsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.read_mask.is_some() {
            state.serialize_entry("readMask", &self.read_mask)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response object for a `ListMigrationWorkflows` call.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListMigrationWorkflowsResponse {
    /// The migration workflows for the specified project / location.
    pub migration_workflows: std::vec::Vec<crate::model::MigrationWorkflow>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMigrationWorkflowsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [migration_workflows][crate::model::ListMigrationWorkflowsResponse::migration_workflows].
    pub fn set_migration_workflows<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MigrationWorkflow>,
    {
        use std::iter::Iterator;
        self.migration_workflows = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListMigrationWorkflowsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListMigrationWorkflowsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.ListMigrationWorkflowsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListMigrationWorkflowsResponse {
    type PageItem = crate::model::MigrationWorkflow;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.migration_workflows
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListMigrationWorkflowsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __migration_workflows,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListMigrationWorkflowsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "migrationWorkflows" => Ok(__FieldTag::__migration_workflows),
                            "migration_workflows" => Ok(__FieldTag::__migration_workflows),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListMigrationWorkflowsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListMigrationWorkflowsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__migration_workflows => {
                            if !fields.insert(__FieldTag::__migration_workflows) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for migration_workflows",
                                ));
                            }
                            result.migration_workflows =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::MigrationWorkflow>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListMigrationWorkflowsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.migration_workflows.is_empty() {
            state.serialize_entry("migrationWorkflows", &self.migration_workflows)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A request to delete a previously created migration workflow.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteMigrationWorkflowRequest {
    /// Required. The unique identifier for the migration workflow.
    /// Example: `projects/123/locations/us/workflows/1234`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteMigrationWorkflowRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteMigrationWorkflowRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteMigrationWorkflowRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.DeleteMigrationWorkflowRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteMigrationWorkflowRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteMigrationWorkflowRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteMigrationWorkflowRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteMigrationWorkflowRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteMigrationWorkflowRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A request to start a previously created migration workflow.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StartMigrationWorkflowRequest {
    /// Required. The unique identifier for the migration workflow.
    /// Example: `projects/123/locations/us/workflows/1234`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StartMigrationWorkflowRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StartMigrationWorkflowRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for StartMigrationWorkflowRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.StartMigrationWorkflowRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StartMigrationWorkflowRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StartMigrationWorkflowRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StartMigrationWorkflowRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StartMigrationWorkflowRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StartMigrationWorkflowRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A request to get a previously created migration subtasks.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetMigrationSubtaskRequest {
    /// Required. The unique identifier for the migration subtask.
    /// Example: `projects/123/locations/us/workflows/1234/subtasks/543`
    pub name: std::string::String,

    /// Optional. The list of fields to be retrieved.
    pub read_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetMigrationSubtaskRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetMigrationSubtaskRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::GetMigrationSubtaskRequest::read_mask].
    pub fn set_read_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.read_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [read_mask][crate::model::GetMigrationSubtaskRequest::read_mask].
    pub fn set_or_clear_read_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.read_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for GetMigrationSubtaskRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.GetMigrationSubtaskRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetMigrationSubtaskRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __read_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetMigrationSubtaskRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "readMask" => Ok(__FieldTag::__read_mask),
                            "read_mask" => Ok(__FieldTag::__read_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetMigrationSubtaskRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetMigrationSubtaskRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__read_mask => {
                            if !fields.insert(__FieldTag::__read_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_mask",
                                ));
                            }
                            result.read_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetMigrationSubtaskRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.read_mask.is_some() {
            state.serialize_entry("readMask", &self.read_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A request to list previously created migration subtasks.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListMigrationSubtasksRequest {
    /// Required. The migration task of the subtasks to list.
    /// Example: `projects/123/locations/us/workflows/1234`
    pub parent: std::string::String,

    /// Optional. The list of fields to be retrieved.
    pub read_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. The maximum number of migration tasks to return. The service may
    /// return fewer than this number.
    pub page_size: i32,

    /// Optional. A page token, received from previous `ListMigrationSubtasks`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListMigrationSubtasks`
    /// must match the call that provided the page token.
    pub page_token: std::string::String,

    /// Optional. The filter to apply. This can be used to get the subtasks of a
    /// specific tasks in a workflow, e.g. `migration_task = "ab012"` where
    /// `"ab012"` is the task ID (not the name in the named map).
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMigrationSubtasksRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListMigrationSubtasksRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListMigrationSubtasksRequest::read_mask].
    pub fn set_read_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.read_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [read_mask][crate::model::ListMigrationSubtasksRequest::read_mask].
    pub fn set_or_clear_read_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.read_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [page_size][crate::model::ListMigrationSubtasksRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListMigrationSubtasksRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListMigrationSubtasksRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListMigrationSubtasksRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.ListMigrationSubtasksRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListMigrationSubtasksRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __read_mask,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListMigrationSubtasksRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "readMask" => Ok(__FieldTag::__read_mask),
                            "read_mask" => Ok(__FieldTag::__read_mask),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListMigrationSubtasksRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListMigrationSubtasksRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__read_mask => {
                            if !fields.insert(__FieldTag::__read_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_mask",
                                ));
                            }
                            result.read_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListMigrationSubtasksRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.read_mask.is_some() {
            state.serialize_entry("readMask", &self.read_mask)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response object for a `ListMigrationSubtasks` call.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListMigrationSubtasksResponse {
    /// The migration subtasks for the specified task.
    pub migration_subtasks: std::vec::Vec<crate::model::MigrationSubtask>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMigrationSubtasksResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [migration_subtasks][crate::model::ListMigrationSubtasksResponse::migration_subtasks].
    pub fn set_migration_subtasks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MigrationSubtask>,
    {
        use std::iter::Iterator;
        self.migration_subtasks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListMigrationSubtasksResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListMigrationSubtasksResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.ListMigrationSubtasksResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListMigrationSubtasksResponse {
    type PageItem = crate::model::MigrationSubtask;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.migration_subtasks
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListMigrationSubtasksResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __migration_subtasks,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListMigrationSubtasksResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "migrationSubtasks" => Ok(__FieldTag::__migration_subtasks),
                            "migration_subtasks" => Ok(__FieldTag::__migration_subtasks),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListMigrationSubtasksResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListMigrationSubtasksResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__migration_subtasks => {
                            if !fields.insert(__FieldTag::__migration_subtasks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for migration_subtasks",
                                ));
                            }
                            result.migration_subtasks =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::MigrationSubtask>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListMigrationSubtasksResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.migration_subtasks.is_empty() {
            state.serialize_entry("migrationSubtasks", &self.migration_subtasks)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The translation config to capture necessary settings for a translation task
/// and subtask.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TranslationConfigDetails {
    /// The dialect of the input files.
    pub source_dialect: std::option::Option<crate::model::Dialect>,

    /// The target dialect for the engine to translate the input to.
    pub target_dialect: std::option::Option<crate::model::Dialect>,

    /// The default source environment values for the translation.
    pub source_env: std::option::Option<crate::model::SourceEnv>,

    /// The indicator to show translation request initiator.
    pub request_source: std::string::String,

    /// The types of output to generate, e.g. sql, metadata etc. If not specified,
    /// a default set of targets will be generated. Some additional target types
    /// may be slower to generate. See the documentation for the set of available
    /// target types.
    pub target_types: std::vec::Vec<std::string::String>,

    /// The chosen path where the source for input files will be found.
    pub source_location:
        std::option::Option<crate::model::translation_config_details::SourceLocation>,

    /// The chosen path where the destination for output files will be found.
    pub target_location:
        std::option::Option<crate::model::translation_config_details::TargetLocation>,

    /// The mapping of full SQL object names from their current state to the
    /// desired output.
    pub output_name_mapping:
        std::option::Option<crate::model::translation_config_details::OutputNameMapping>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TranslationConfigDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_dialect][crate::model::TranslationConfigDetails::source_dialect].
    pub fn set_source_dialect<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Dialect>,
    {
        self.source_dialect = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_dialect][crate::model::TranslationConfigDetails::source_dialect].
    pub fn set_or_clear_source_dialect<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Dialect>,
    {
        self.source_dialect = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target_dialect][crate::model::TranslationConfigDetails::target_dialect].
    pub fn set_target_dialect<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Dialect>,
    {
        self.target_dialect = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [target_dialect][crate::model::TranslationConfigDetails::target_dialect].
    pub fn set_or_clear_target_dialect<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Dialect>,
    {
        self.target_dialect = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_env][crate::model::TranslationConfigDetails::source_env].
    pub fn set_source_env<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SourceEnv>,
    {
        self.source_env = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_env][crate::model::TranslationConfigDetails::source_env].
    pub fn set_or_clear_source_env<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SourceEnv>,
    {
        self.source_env = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_source][crate::model::TranslationConfigDetails::request_source].
    pub fn set_request_source<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_source = v.into();
        self
    }

    /// Sets the value of [target_types][crate::model::TranslationConfigDetails::target_types].
    pub fn set_target_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.target_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [source_location][crate::model::TranslationConfigDetails::source_location].
    ///
    /// Note that all the setters affecting `source_location` are mutually
    /// exclusive.
    pub fn set_source_location<
        T: std::convert::Into<
                std::option::Option<crate::model::translation_config_details::SourceLocation>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_location = v.into();
        self
    }

    /// The value of [source_location][crate::model::TranslationConfigDetails::source_location]
    /// if it holds a `GcsSourcePath`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_source_path(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source_location.as_ref().and_then(|v| match v {
            crate::model::translation_config_details::SourceLocation::GcsSourcePath(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_location][crate::model::TranslationConfigDetails::source_location]
    /// to hold a `GcsSourcePath`.
    ///
    /// Note that all the setters affecting `source_location` are
    /// mutually exclusive.
    pub fn set_gcs_source_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_location = std::option::Option::Some(
            crate::model::translation_config_details::SourceLocation::GcsSourcePath(v.into()),
        );
        self
    }

    /// Sets the value of [target_location][crate::model::TranslationConfigDetails::target_location].
    ///
    /// Note that all the setters affecting `target_location` are mutually
    /// exclusive.
    pub fn set_target_location<
        T: std::convert::Into<
                std::option::Option<crate::model::translation_config_details::TargetLocation>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target_location = v.into();
        self
    }

    /// The value of [target_location][crate::model::TranslationConfigDetails::target_location]
    /// if it holds a `GcsTargetPath`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_target_path(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.target_location.as_ref().and_then(|v| match v {
            crate::model::translation_config_details::TargetLocation::GcsTargetPath(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target_location][crate::model::TranslationConfigDetails::target_location]
    /// to hold a `GcsTargetPath`.
    ///
    /// Note that all the setters affecting `target_location` are
    /// mutually exclusive.
    pub fn set_gcs_target_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_location = std::option::Option::Some(
            crate::model::translation_config_details::TargetLocation::GcsTargetPath(v.into()),
        );
        self
    }

    /// Sets the value of [output_name_mapping][crate::model::TranslationConfigDetails::output_name_mapping].
    ///
    /// Note that all the setters affecting `output_name_mapping` are mutually
    /// exclusive.
    pub fn set_output_name_mapping<
        T: std::convert::Into<
                std::option::Option<crate::model::translation_config_details::OutputNameMapping>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_name_mapping = v.into();
        self
    }

    /// The value of [output_name_mapping][crate::model::TranslationConfigDetails::output_name_mapping]
    /// if it holds a `NameMappingList`, `None` if the field is not set or
    /// holds a different branch.
    pub fn name_mapping_list(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ObjectNameMappingList>> {
        #[allow(unreachable_patterns)]
        self.output_name_mapping.as_ref().and_then(|v| match v {
            crate::model::translation_config_details::OutputNameMapping::NameMappingList(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [output_name_mapping][crate::model::TranslationConfigDetails::output_name_mapping]
    /// to hold a `NameMappingList`.
    ///
    /// Note that all the setters affecting `output_name_mapping` are
    /// mutually exclusive.
    pub fn set_name_mapping_list<
        T: std::convert::Into<std::boxed::Box<crate::model::ObjectNameMappingList>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_name_mapping = std::option::Option::Some(
            crate::model::translation_config_details::OutputNameMapping::NameMappingList(v.into()),
        );
        self
    }
}

impl wkt::message::Message for TranslationConfigDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.TranslationConfigDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TranslationConfigDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcs_source_path,
            __gcs_target_path,
            __name_mapping_list,
            __source_dialect,
            __target_dialect,
            __source_env,
            __request_source,
            __target_types,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TranslationConfigDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcsSourcePath" => Ok(__FieldTag::__gcs_source_path),
                            "gcs_source_path" => Ok(__FieldTag::__gcs_source_path),
                            "gcsTargetPath" => Ok(__FieldTag::__gcs_target_path),
                            "gcs_target_path" => Ok(__FieldTag::__gcs_target_path),
                            "nameMappingList" => Ok(__FieldTag::__name_mapping_list),
                            "name_mapping_list" => Ok(__FieldTag::__name_mapping_list),
                            "sourceDialect" => Ok(__FieldTag::__source_dialect),
                            "source_dialect" => Ok(__FieldTag::__source_dialect),
                            "targetDialect" => Ok(__FieldTag::__target_dialect),
                            "target_dialect" => Ok(__FieldTag::__target_dialect),
                            "sourceEnv" => Ok(__FieldTag::__source_env),
                            "source_env" => Ok(__FieldTag::__source_env),
                            "requestSource" => Ok(__FieldTag::__request_source),
                            "request_source" => Ok(__FieldTag::__request_source),
                            "targetTypes" => Ok(__FieldTag::__target_types),
                            "target_types" => Ok(__FieldTag::__target_types),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TranslationConfigDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TranslationConfigDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcs_source_path => {
                            if !fields.insert(__FieldTag::__gcs_source_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_source_path",
                                ));
                            }
                            if result.source_location.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source_location`, a oneof with full ID .google.cloud.bigquery.migration.v2.TranslationConfigDetails.gcs_source_path, latest field was gcsSourcePath",
                                ));
                            }
                            result.source_location = std::option::Option::Some(
                                crate::model::translation_config_details::SourceLocation::GcsSourcePath(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__gcs_target_path => {
                            if !fields.insert(__FieldTag::__gcs_target_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_target_path",
                                ));
                            }
                            if result.target_location.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target_location`, a oneof with full ID .google.cloud.bigquery.migration.v2.TranslationConfigDetails.gcs_target_path, latest field was gcsTargetPath",
                                ));
                            }
                            result.target_location = std::option::Option::Some(
                                crate::model::translation_config_details::TargetLocation::GcsTargetPath(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__name_mapping_list => {
                            if !fields.insert(__FieldTag::__name_mapping_list) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name_mapping_list",
                                ));
                            }
                            if result.output_name_mapping.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `output_name_mapping`, a oneof with full ID .google.cloud.bigquery.migration.v2.TranslationConfigDetails.name_mapping_list, latest field was nameMappingList",
                                ));
                            }
                            result.output_name_mapping = std::option::Option::Some(
                                crate::model::translation_config_details::OutputNameMapping::NameMappingList(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ObjectNameMappingList>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__source_dialect => {
                            if !fields.insert(__FieldTag::__source_dialect) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_dialect",
                                ));
                            }
                            result.source_dialect =
                                map.next_value::<std::option::Option<crate::model::Dialect>>()?;
                        }
                        __FieldTag::__target_dialect => {
                            if !fields.insert(__FieldTag::__target_dialect) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_dialect",
                                ));
                            }
                            result.target_dialect =
                                map.next_value::<std::option::Option<crate::model::Dialect>>()?;
                        }
                        __FieldTag::__source_env => {
                            if !fields.insert(__FieldTag::__source_env) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_env",
                                ));
                            }
                            result.source_env =
                                map.next_value::<std::option::Option<crate::model::SourceEnv>>()?;
                        }
                        __FieldTag::__request_source => {
                            if !fields.insert(__FieldTag::__request_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_source",
                                ));
                            }
                            result.request_source = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_types => {
                            if !fields.insert(__FieldTag::__target_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_types",
                                ));
                            }
                            result.target_types = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TranslationConfigDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.gcs_source_path() {
            state.serialize_entry("gcsSourcePath", value)?;
        }
        if let Some(value) = self.gcs_target_path() {
            state.serialize_entry("gcsTargetPath", value)?;
        }
        if let Some(value) = self.name_mapping_list() {
            state.serialize_entry("nameMappingList", value)?;
        }
        if self.source_dialect.is_some() {
            state.serialize_entry("sourceDialect", &self.source_dialect)?;
        }
        if self.target_dialect.is_some() {
            state.serialize_entry("targetDialect", &self.target_dialect)?;
        }
        if self.source_env.is_some() {
            state.serialize_entry("sourceEnv", &self.source_env)?;
        }
        if !self.request_source.is_empty() {
            state.serialize_entry("requestSource", &self.request_source)?;
        }
        if !self.target_types.is_empty() {
            state.serialize_entry("targetTypes", &self.target_types)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [TranslationConfigDetails].
pub mod translation_config_details {
    #[allow(unused_imports)]
    use super::*;

    /// The chosen path where the source for input files will be found.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SourceLocation {
        /// The Cloud Storage path for a directory of files to translate in a task.
        GcsSourcePath(std::string::String),
    }

    /// The chosen path where the destination for output files will be found.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TargetLocation {
        /// The Cloud Storage path to write back the corresponding input files to.
        GcsTargetPath(std::string::String),
    }

    /// The mapping of full SQL object names from their current state to the
    /// desired output.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum OutputNameMapping {
        /// The mapping of objects to their desired output names in list form.
        NameMappingList(std::boxed::Box<crate::model::ObjectNameMappingList>),
    }
}

/// The possible dialect options for translation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Dialect {
    /// The possible dialect options that this message represents.
    pub dialect_value: std::option::Option<crate::model::dialect::DialectValue>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Dialect {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dialect_value][crate::model::Dialect::dialect_value].
    ///
    /// Note that all the setters affecting `dialect_value` are mutually
    /// exclusive.
    pub fn set_dialect_value<
        T: std::convert::Into<std::option::Option<crate::model::dialect::DialectValue>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dialect_value = v.into();
        self
    }

    /// The value of [dialect_value][crate::model::Dialect::dialect_value]
    /// if it holds a `BigqueryDialect`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bigquery_dialect(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryDialect>> {
        #[allow(unreachable_patterns)]
        self.dialect_value.as_ref().and_then(|v| match v {
            crate::model::dialect::DialectValue::BigqueryDialect(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [dialect_value][crate::model::Dialect::dialect_value]
    /// to hold a `BigqueryDialect`.
    ///
    /// Note that all the setters affecting `dialect_value` are
    /// mutually exclusive.
    pub fn set_bigquery_dialect<
        T: std::convert::Into<std::boxed::Box<crate::model::BigQueryDialect>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dialect_value = std::option::Option::Some(
            crate::model::dialect::DialectValue::BigqueryDialect(v.into()),
        );
        self
    }

    /// The value of [dialect_value][crate::model::Dialect::dialect_value]
    /// if it holds a `HiveqlDialect`, `None` if the field is not set or
    /// holds a different branch.
    pub fn hiveql_dialect(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::HiveQLDialect>> {
        #[allow(unreachable_patterns)]
        self.dialect_value.as_ref().and_then(|v| match v {
            crate::model::dialect::DialectValue::HiveqlDialect(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [dialect_value][crate::model::Dialect::dialect_value]
    /// to hold a `HiveqlDialect`.
    ///
    /// Note that all the setters affecting `dialect_value` are
    /// mutually exclusive.
    pub fn set_hiveql_dialect<
        T: std::convert::Into<std::boxed::Box<crate::model::HiveQLDialect>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dialect_value =
            std::option::Option::Some(crate::model::dialect::DialectValue::HiveqlDialect(v.into()));
        self
    }

    /// The value of [dialect_value][crate::model::Dialect::dialect_value]
    /// if it holds a `RedshiftDialect`, `None` if the field is not set or
    /// holds a different branch.
    pub fn redshift_dialect(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::RedshiftDialect>> {
        #[allow(unreachable_patterns)]
        self.dialect_value.as_ref().and_then(|v| match v {
            crate::model::dialect::DialectValue::RedshiftDialect(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [dialect_value][crate::model::Dialect::dialect_value]
    /// to hold a `RedshiftDialect`.
    ///
    /// Note that all the setters affecting `dialect_value` are
    /// mutually exclusive.
    pub fn set_redshift_dialect<
        T: std::convert::Into<std::boxed::Box<crate::model::RedshiftDialect>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dialect_value = std::option::Option::Some(
            crate::model::dialect::DialectValue::RedshiftDialect(v.into()),
        );
        self
    }

    /// The value of [dialect_value][crate::model::Dialect::dialect_value]
    /// if it holds a `TeradataDialect`, `None` if the field is not set or
    /// holds a different branch.
    pub fn teradata_dialect(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TeradataDialect>> {
        #[allow(unreachable_patterns)]
        self.dialect_value.as_ref().and_then(|v| match v {
            crate::model::dialect::DialectValue::TeradataDialect(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [dialect_value][crate::model::Dialect::dialect_value]
    /// to hold a `TeradataDialect`.
    ///
    /// Note that all the setters affecting `dialect_value` are
    /// mutually exclusive.
    pub fn set_teradata_dialect<
        T: std::convert::Into<std::boxed::Box<crate::model::TeradataDialect>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dialect_value = std::option::Option::Some(
            crate::model::dialect::DialectValue::TeradataDialect(v.into()),
        );
        self
    }

    /// The value of [dialect_value][crate::model::Dialect::dialect_value]
    /// if it holds a `OracleDialect`, `None` if the field is not set or
    /// holds a different branch.
    pub fn oracle_dialect(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::OracleDialect>> {
        #[allow(unreachable_patterns)]
        self.dialect_value.as_ref().and_then(|v| match v {
            crate::model::dialect::DialectValue::OracleDialect(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [dialect_value][crate::model::Dialect::dialect_value]
    /// to hold a `OracleDialect`.
    ///
    /// Note that all the setters affecting `dialect_value` are
    /// mutually exclusive.
    pub fn set_oracle_dialect<
        T: std::convert::Into<std::boxed::Box<crate::model::OracleDialect>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dialect_value =
            std::option::Option::Some(crate::model::dialect::DialectValue::OracleDialect(v.into()));
        self
    }

    /// The value of [dialect_value][crate::model::Dialect::dialect_value]
    /// if it holds a `SparksqlDialect`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sparksql_dialect(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SparkSQLDialect>> {
        #[allow(unreachable_patterns)]
        self.dialect_value.as_ref().and_then(|v| match v {
            crate::model::dialect::DialectValue::SparksqlDialect(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [dialect_value][crate::model::Dialect::dialect_value]
    /// to hold a `SparksqlDialect`.
    ///
    /// Note that all the setters affecting `dialect_value` are
    /// mutually exclusive.
    pub fn set_sparksql_dialect<
        T: std::convert::Into<std::boxed::Box<crate::model::SparkSQLDialect>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dialect_value = std::option::Option::Some(
            crate::model::dialect::DialectValue::SparksqlDialect(v.into()),
        );
        self
    }

    /// The value of [dialect_value][crate::model::Dialect::dialect_value]
    /// if it holds a `SnowflakeDialect`, `None` if the field is not set or
    /// holds a different branch.
    pub fn snowflake_dialect(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SnowflakeDialect>> {
        #[allow(unreachable_patterns)]
        self.dialect_value.as_ref().and_then(|v| match v {
            crate::model::dialect::DialectValue::SnowflakeDialect(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [dialect_value][crate::model::Dialect::dialect_value]
    /// to hold a `SnowflakeDialect`.
    ///
    /// Note that all the setters affecting `dialect_value` are
    /// mutually exclusive.
    pub fn set_snowflake_dialect<
        T: std::convert::Into<std::boxed::Box<crate::model::SnowflakeDialect>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dialect_value = std::option::Option::Some(
            crate::model::dialect::DialectValue::SnowflakeDialect(v.into()),
        );
        self
    }

    /// The value of [dialect_value][crate::model::Dialect::dialect_value]
    /// if it holds a `NetezzaDialect`, `None` if the field is not set or
    /// holds a different branch.
    pub fn netezza_dialect(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::NetezzaDialect>> {
        #[allow(unreachable_patterns)]
        self.dialect_value.as_ref().and_then(|v| match v {
            crate::model::dialect::DialectValue::NetezzaDialect(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [dialect_value][crate::model::Dialect::dialect_value]
    /// to hold a `NetezzaDialect`.
    ///
    /// Note that all the setters affecting `dialect_value` are
    /// mutually exclusive.
    pub fn set_netezza_dialect<
        T: std::convert::Into<std::boxed::Box<crate::model::NetezzaDialect>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dialect_value = std::option::Option::Some(
            crate::model::dialect::DialectValue::NetezzaDialect(v.into()),
        );
        self
    }

    /// The value of [dialect_value][crate::model::Dialect::dialect_value]
    /// if it holds a `AzureSynapseDialect`, `None` if the field is not set or
    /// holds a different branch.
    pub fn azure_synapse_dialect(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AzureSynapseDialect>> {
        #[allow(unreachable_patterns)]
        self.dialect_value.as_ref().and_then(|v| match v {
            crate::model::dialect::DialectValue::AzureSynapseDialect(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [dialect_value][crate::model::Dialect::dialect_value]
    /// to hold a `AzureSynapseDialect`.
    ///
    /// Note that all the setters affecting `dialect_value` are
    /// mutually exclusive.
    pub fn set_azure_synapse_dialect<
        T: std::convert::Into<std::boxed::Box<crate::model::AzureSynapseDialect>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dialect_value = std::option::Option::Some(
            crate::model::dialect::DialectValue::AzureSynapseDialect(v.into()),
        );
        self
    }

    /// The value of [dialect_value][crate::model::Dialect::dialect_value]
    /// if it holds a `VerticaDialect`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vertica_dialect(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VerticaDialect>> {
        #[allow(unreachable_patterns)]
        self.dialect_value.as_ref().and_then(|v| match v {
            crate::model::dialect::DialectValue::VerticaDialect(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [dialect_value][crate::model::Dialect::dialect_value]
    /// to hold a `VerticaDialect`.
    ///
    /// Note that all the setters affecting `dialect_value` are
    /// mutually exclusive.
    pub fn set_vertica_dialect<
        T: std::convert::Into<std::boxed::Box<crate::model::VerticaDialect>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dialect_value = std::option::Option::Some(
            crate::model::dialect::DialectValue::VerticaDialect(v.into()),
        );
        self
    }

    /// The value of [dialect_value][crate::model::Dialect::dialect_value]
    /// if it holds a `SqlServerDialect`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sql_server_dialect(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SQLServerDialect>> {
        #[allow(unreachable_patterns)]
        self.dialect_value.as_ref().and_then(|v| match v {
            crate::model::dialect::DialectValue::SqlServerDialect(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [dialect_value][crate::model::Dialect::dialect_value]
    /// to hold a `SqlServerDialect`.
    ///
    /// Note that all the setters affecting `dialect_value` are
    /// mutually exclusive.
    pub fn set_sql_server_dialect<
        T: std::convert::Into<std::boxed::Box<crate::model::SQLServerDialect>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dialect_value = std::option::Option::Some(
            crate::model::dialect::DialectValue::SqlServerDialect(v.into()),
        );
        self
    }

    /// The value of [dialect_value][crate::model::Dialect::dialect_value]
    /// if it holds a `PostgresqlDialect`, `None` if the field is not set or
    /// holds a different branch.
    pub fn postgresql_dialect(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PostgresqlDialect>> {
        #[allow(unreachable_patterns)]
        self.dialect_value.as_ref().and_then(|v| match v {
            crate::model::dialect::DialectValue::PostgresqlDialect(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [dialect_value][crate::model::Dialect::dialect_value]
    /// to hold a `PostgresqlDialect`.
    ///
    /// Note that all the setters affecting `dialect_value` are
    /// mutually exclusive.
    pub fn set_postgresql_dialect<
        T: std::convert::Into<std::boxed::Box<crate::model::PostgresqlDialect>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dialect_value = std::option::Option::Some(
            crate::model::dialect::DialectValue::PostgresqlDialect(v.into()),
        );
        self
    }

    /// The value of [dialect_value][crate::model::Dialect::dialect_value]
    /// if it holds a `PrestoDialect`, `None` if the field is not set or
    /// holds a different branch.
    pub fn presto_dialect(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PrestoDialect>> {
        #[allow(unreachable_patterns)]
        self.dialect_value.as_ref().and_then(|v| match v {
            crate::model::dialect::DialectValue::PrestoDialect(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [dialect_value][crate::model::Dialect::dialect_value]
    /// to hold a `PrestoDialect`.
    ///
    /// Note that all the setters affecting `dialect_value` are
    /// mutually exclusive.
    pub fn set_presto_dialect<
        T: std::convert::Into<std::boxed::Box<crate::model::PrestoDialect>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dialect_value =
            std::option::Option::Some(crate::model::dialect::DialectValue::PrestoDialect(v.into()));
        self
    }

    /// The value of [dialect_value][crate::model::Dialect::dialect_value]
    /// if it holds a `MysqlDialect`, `None` if the field is not set or
    /// holds a different branch.
    pub fn mysql_dialect(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::MySQLDialect>> {
        #[allow(unreachable_patterns)]
        self.dialect_value.as_ref().and_then(|v| match v {
            crate::model::dialect::DialectValue::MysqlDialect(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [dialect_value][crate::model::Dialect::dialect_value]
    /// to hold a `MysqlDialect`.
    ///
    /// Note that all the setters affecting `dialect_value` are
    /// mutually exclusive.
    pub fn set_mysql_dialect<T: std::convert::Into<std::boxed::Box<crate::model::MySQLDialect>>>(
        mut self,
        v: T,
    ) -> Self {
        self.dialect_value =
            std::option::Option::Some(crate::model::dialect::DialectValue::MysqlDialect(v.into()));
        self
    }

    /// The value of [dialect_value][crate::model::Dialect::dialect_value]
    /// if it holds a `Db2Dialect`, `None` if the field is not set or
    /// holds a different branch.
    pub fn db2_dialect(&self) -> std::option::Option<&std::boxed::Box<crate::model::DB2Dialect>> {
        #[allow(unreachable_patterns)]
        self.dialect_value.as_ref().and_then(|v| match v {
            crate::model::dialect::DialectValue::Db2Dialect(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [dialect_value][crate::model::Dialect::dialect_value]
    /// to hold a `Db2Dialect`.
    ///
    /// Note that all the setters affecting `dialect_value` are
    /// mutually exclusive.
    pub fn set_db2_dialect<T: std::convert::Into<std::boxed::Box<crate::model::DB2Dialect>>>(
        mut self,
        v: T,
    ) -> Self {
        self.dialect_value =
            std::option::Option::Some(crate::model::dialect::DialectValue::Db2Dialect(v.into()));
        self
    }

    /// The value of [dialect_value][crate::model::Dialect::dialect_value]
    /// if it holds a `SqliteDialect`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sqlite_dialect(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SQLiteDialect>> {
        #[allow(unreachable_patterns)]
        self.dialect_value.as_ref().and_then(|v| match v {
            crate::model::dialect::DialectValue::SqliteDialect(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [dialect_value][crate::model::Dialect::dialect_value]
    /// to hold a `SqliteDialect`.
    ///
    /// Note that all the setters affecting `dialect_value` are
    /// mutually exclusive.
    pub fn set_sqlite_dialect<
        T: std::convert::Into<std::boxed::Box<crate::model::SQLiteDialect>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dialect_value =
            std::option::Option::Some(crate::model::dialect::DialectValue::SqliteDialect(v.into()));
        self
    }

    /// The value of [dialect_value][crate::model::Dialect::dialect_value]
    /// if it holds a `GreenplumDialect`, `None` if the field is not set or
    /// holds a different branch.
    pub fn greenplum_dialect(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GreenplumDialect>> {
        #[allow(unreachable_patterns)]
        self.dialect_value.as_ref().and_then(|v| match v {
            crate::model::dialect::DialectValue::GreenplumDialect(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [dialect_value][crate::model::Dialect::dialect_value]
    /// to hold a `GreenplumDialect`.
    ///
    /// Note that all the setters affecting `dialect_value` are
    /// mutually exclusive.
    pub fn set_greenplum_dialect<
        T: std::convert::Into<std::boxed::Box<crate::model::GreenplumDialect>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dialect_value = std::option::Option::Some(
            crate::model::dialect::DialectValue::GreenplumDialect(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Dialect {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.Dialect"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Dialect {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bigquery_dialect,
            __hiveql_dialect,
            __redshift_dialect,
            __teradata_dialect,
            __oracle_dialect,
            __sparksql_dialect,
            __snowflake_dialect,
            __netezza_dialect,
            __azure_synapse_dialect,
            __vertica_dialect,
            __sql_server_dialect,
            __postgresql_dialect,
            __presto_dialect,
            __mysql_dialect,
            __db2_dialect,
            __sqlite_dialect,
            __greenplum_dialect,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Dialect")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bigqueryDialect" => Ok(__FieldTag::__bigquery_dialect),
                            "bigquery_dialect" => Ok(__FieldTag::__bigquery_dialect),
                            "hiveqlDialect" => Ok(__FieldTag::__hiveql_dialect),
                            "hiveql_dialect" => Ok(__FieldTag::__hiveql_dialect),
                            "redshiftDialect" => Ok(__FieldTag::__redshift_dialect),
                            "redshift_dialect" => Ok(__FieldTag::__redshift_dialect),
                            "teradataDialect" => Ok(__FieldTag::__teradata_dialect),
                            "teradata_dialect" => Ok(__FieldTag::__teradata_dialect),
                            "oracleDialect" => Ok(__FieldTag::__oracle_dialect),
                            "oracle_dialect" => Ok(__FieldTag::__oracle_dialect),
                            "sparksqlDialect" => Ok(__FieldTag::__sparksql_dialect),
                            "sparksql_dialect" => Ok(__FieldTag::__sparksql_dialect),
                            "snowflakeDialect" => Ok(__FieldTag::__snowflake_dialect),
                            "snowflake_dialect" => Ok(__FieldTag::__snowflake_dialect),
                            "netezzaDialect" => Ok(__FieldTag::__netezza_dialect),
                            "netezza_dialect" => Ok(__FieldTag::__netezza_dialect),
                            "azureSynapseDialect" => Ok(__FieldTag::__azure_synapse_dialect),
                            "azure_synapse_dialect" => Ok(__FieldTag::__azure_synapse_dialect),
                            "verticaDialect" => Ok(__FieldTag::__vertica_dialect),
                            "vertica_dialect" => Ok(__FieldTag::__vertica_dialect),
                            "sqlServerDialect" => Ok(__FieldTag::__sql_server_dialect),
                            "sql_server_dialect" => Ok(__FieldTag::__sql_server_dialect),
                            "postgresqlDialect" => Ok(__FieldTag::__postgresql_dialect),
                            "postgresql_dialect" => Ok(__FieldTag::__postgresql_dialect),
                            "prestoDialect" => Ok(__FieldTag::__presto_dialect),
                            "presto_dialect" => Ok(__FieldTag::__presto_dialect),
                            "mysqlDialect" => Ok(__FieldTag::__mysql_dialect),
                            "mysql_dialect" => Ok(__FieldTag::__mysql_dialect),
                            "db2Dialect" => Ok(__FieldTag::__db2_dialect),
                            "db2_dialect" => Ok(__FieldTag::__db2_dialect),
                            "sqliteDialect" => Ok(__FieldTag::__sqlite_dialect),
                            "sqlite_dialect" => Ok(__FieldTag::__sqlite_dialect),
                            "greenplumDialect" => Ok(__FieldTag::__greenplum_dialect),
                            "greenplum_dialect" => Ok(__FieldTag::__greenplum_dialect),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Dialect;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Dialect")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bigquery_dialect => {
                            if !fields.insert(__FieldTag::__bigquery_dialect) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bigquery_dialect",
                                ));
                            }
                            if result.dialect_value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `dialect_value`, a oneof with full ID .google.cloud.bigquery.migration.v2.Dialect.bigquery_dialect, latest field was bigqueryDialect",
                                ));
                            }
                            result.dialect_value = std::option::Option::Some(
                                crate::model::dialect::DialectValue::BigqueryDialect(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::BigQueryDialect>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__hiveql_dialect => {
                            if !fields.insert(__FieldTag::__hiveql_dialect) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hiveql_dialect",
                                ));
                            }
                            if result.dialect_value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `dialect_value`, a oneof with full ID .google.cloud.bigquery.migration.v2.Dialect.hiveql_dialect, latest field was hiveqlDialect",
                                ));
                            }
                            result.dialect_value = std::option::Option::Some(
                                crate::model::dialect::DialectValue::HiveqlDialect(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::HiveQLDialect>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__redshift_dialect => {
                            if !fields.insert(__FieldTag::__redshift_dialect) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for redshift_dialect",
                                ));
                            }
                            if result.dialect_value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `dialect_value`, a oneof with full ID .google.cloud.bigquery.migration.v2.Dialect.redshift_dialect, latest field was redshiftDialect",
                                ));
                            }
                            result.dialect_value = std::option::Option::Some(
                                crate::model::dialect::DialectValue::RedshiftDialect(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::RedshiftDialect>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__teradata_dialect => {
                            if !fields.insert(__FieldTag::__teradata_dialect) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for teradata_dialect",
                                ));
                            }
                            if result.dialect_value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `dialect_value`, a oneof with full ID .google.cloud.bigquery.migration.v2.Dialect.teradata_dialect, latest field was teradataDialect",
                                ));
                            }
                            result.dialect_value = std::option::Option::Some(
                                crate::model::dialect::DialectValue::TeradataDialect(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::TeradataDialect>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__oracle_dialect => {
                            if !fields.insert(__FieldTag::__oracle_dialect) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oracle_dialect",
                                ));
                            }
                            if result.dialect_value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `dialect_value`, a oneof with full ID .google.cloud.bigquery.migration.v2.Dialect.oracle_dialect, latest field was oracleDialect",
                                ));
                            }
                            result.dialect_value = std::option::Option::Some(
                                crate::model::dialect::DialectValue::OracleDialect(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::OracleDialect>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__sparksql_dialect => {
                            if !fields.insert(__FieldTag::__sparksql_dialect) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sparksql_dialect",
                                ));
                            }
                            if result.dialect_value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `dialect_value`, a oneof with full ID .google.cloud.bigquery.migration.v2.Dialect.sparksql_dialect, latest field was sparksqlDialect",
                                ));
                            }
                            result.dialect_value = std::option::Option::Some(
                                crate::model::dialect::DialectValue::SparksqlDialect(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SparkSQLDialect>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__snowflake_dialect => {
                            if !fields.insert(__FieldTag::__snowflake_dialect) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for snowflake_dialect",
                                ));
                            }
                            if result.dialect_value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `dialect_value`, a oneof with full ID .google.cloud.bigquery.migration.v2.Dialect.snowflake_dialect, latest field was snowflakeDialect",
                                ));
                            }
                            result.dialect_value = std::option::Option::Some(
                                crate::model::dialect::DialectValue::SnowflakeDialect(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SnowflakeDialect>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__netezza_dialect => {
                            if !fields.insert(__FieldTag::__netezza_dialect) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for netezza_dialect",
                                ));
                            }
                            if result.dialect_value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `dialect_value`, a oneof with full ID .google.cloud.bigquery.migration.v2.Dialect.netezza_dialect, latest field was netezzaDialect",
                                ));
                            }
                            result.dialect_value = std::option::Option::Some(
                                crate::model::dialect::DialectValue::NetezzaDialect(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::NetezzaDialect>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__azure_synapse_dialect => {
                            if !fields.insert(__FieldTag::__azure_synapse_dialect) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for azure_synapse_dialect",
                                ));
                            }
                            if result.dialect_value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `dialect_value`, a oneof with full ID .google.cloud.bigquery.migration.v2.Dialect.azure_synapse_dialect, latest field was azureSynapseDialect",
                                ));
                            }
                            result.dialect_value = std::option::Option::Some(
                                crate::model::dialect::DialectValue::AzureSynapseDialect(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AzureSynapseDialect>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__vertica_dialect => {
                            if !fields.insert(__FieldTag::__vertica_dialect) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vertica_dialect",
                                ));
                            }
                            if result.dialect_value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `dialect_value`, a oneof with full ID .google.cloud.bigquery.migration.v2.Dialect.vertica_dialect, latest field was verticaDialect",
                                ));
                            }
                            result.dialect_value = std::option::Option::Some(
                                crate::model::dialect::DialectValue::VerticaDialect(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::VerticaDialect>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__sql_server_dialect => {
                            if !fields.insert(__FieldTag::__sql_server_dialect) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sql_server_dialect",
                                ));
                            }
                            if result.dialect_value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `dialect_value`, a oneof with full ID .google.cloud.bigquery.migration.v2.Dialect.sql_server_dialect, latest field was sqlServerDialect",
                                ));
                            }
                            result.dialect_value = std::option::Option::Some(
                                crate::model::dialect::DialectValue::SqlServerDialect(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SQLServerDialect>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__postgresql_dialect => {
                            if !fields.insert(__FieldTag::__postgresql_dialect) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for postgresql_dialect",
                                ));
                            }
                            if result.dialect_value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `dialect_value`, a oneof with full ID .google.cloud.bigquery.migration.v2.Dialect.postgresql_dialect, latest field was postgresqlDialect",
                                ));
                            }
                            result.dialect_value = std::option::Option::Some(
                                crate::model::dialect::DialectValue::PostgresqlDialect(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::PostgresqlDialect>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__presto_dialect => {
                            if !fields.insert(__FieldTag::__presto_dialect) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for presto_dialect",
                                ));
                            }
                            if result.dialect_value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `dialect_value`, a oneof with full ID .google.cloud.bigquery.migration.v2.Dialect.presto_dialect, latest field was prestoDialect",
                                ));
                            }
                            result.dialect_value = std::option::Option::Some(
                                crate::model::dialect::DialectValue::PrestoDialect(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::PrestoDialect>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__mysql_dialect => {
                            if !fields.insert(__FieldTag::__mysql_dialect) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mysql_dialect",
                                ));
                            }
                            if result.dialect_value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `dialect_value`, a oneof with full ID .google.cloud.bigquery.migration.v2.Dialect.mysql_dialect, latest field was mysqlDialect",
                                ));
                            }
                            result.dialect_value = std::option::Option::Some(
                                crate::model::dialect::DialectValue::MysqlDialect(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::MySQLDialect>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__db2_dialect => {
                            if !fields.insert(__FieldTag::__db2_dialect) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for db2_dialect",
                                ));
                            }
                            if result.dialect_value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `dialect_value`, a oneof with full ID .google.cloud.bigquery.migration.v2.Dialect.db2_dialect, latest field was db2Dialect",
                                ));
                            }
                            result.dialect_value = std::option::Option::Some(
                                crate::model::dialect::DialectValue::Db2Dialect(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DB2Dialect>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__sqlite_dialect => {
                            if !fields.insert(__FieldTag::__sqlite_dialect) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sqlite_dialect",
                                ));
                            }
                            if result.dialect_value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `dialect_value`, a oneof with full ID .google.cloud.bigquery.migration.v2.Dialect.sqlite_dialect, latest field was sqliteDialect",
                                ));
                            }
                            result.dialect_value = std::option::Option::Some(
                                crate::model::dialect::DialectValue::SqliteDialect(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SQLiteDialect>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__greenplum_dialect => {
                            if !fields.insert(__FieldTag::__greenplum_dialect) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for greenplum_dialect",
                                ));
                            }
                            if result.dialect_value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `dialect_value`, a oneof with full ID .google.cloud.bigquery.migration.v2.Dialect.greenplum_dialect, latest field was greenplumDialect",
                                ));
                            }
                            result.dialect_value = std::option::Option::Some(
                                crate::model::dialect::DialectValue::GreenplumDialect(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GreenplumDialect>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Dialect {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.bigquery_dialect() {
            state.serialize_entry("bigqueryDialect", value)?;
        }
        if let Some(value) = self.hiveql_dialect() {
            state.serialize_entry("hiveqlDialect", value)?;
        }
        if let Some(value) = self.redshift_dialect() {
            state.serialize_entry("redshiftDialect", value)?;
        }
        if let Some(value) = self.teradata_dialect() {
            state.serialize_entry("teradataDialect", value)?;
        }
        if let Some(value) = self.oracle_dialect() {
            state.serialize_entry("oracleDialect", value)?;
        }
        if let Some(value) = self.sparksql_dialect() {
            state.serialize_entry("sparksqlDialect", value)?;
        }
        if let Some(value) = self.snowflake_dialect() {
            state.serialize_entry("snowflakeDialect", value)?;
        }
        if let Some(value) = self.netezza_dialect() {
            state.serialize_entry("netezzaDialect", value)?;
        }
        if let Some(value) = self.azure_synapse_dialect() {
            state.serialize_entry("azureSynapseDialect", value)?;
        }
        if let Some(value) = self.vertica_dialect() {
            state.serialize_entry("verticaDialect", value)?;
        }
        if let Some(value) = self.sql_server_dialect() {
            state.serialize_entry("sqlServerDialect", value)?;
        }
        if let Some(value) = self.postgresql_dialect() {
            state.serialize_entry("postgresqlDialect", value)?;
        }
        if let Some(value) = self.presto_dialect() {
            state.serialize_entry("prestoDialect", value)?;
        }
        if let Some(value) = self.mysql_dialect() {
            state.serialize_entry("mysqlDialect", value)?;
        }
        if let Some(value) = self.db2_dialect() {
            state.serialize_entry("db2Dialect", value)?;
        }
        if let Some(value) = self.sqlite_dialect() {
            state.serialize_entry("sqliteDialect", value)?;
        }
        if let Some(value) = self.greenplum_dialect() {
            state.serialize_entry("greenplumDialect", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Dialect].
pub mod dialect {
    #[allow(unused_imports)]
    use super::*;

    /// The possible dialect options that this message represents.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DialectValue {
        /// The BigQuery dialect
        BigqueryDialect(std::boxed::Box<crate::model::BigQueryDialect>),
        /// The HiveQL dialect
        HiveqlDialect(std::boxed::Box<crate::model::HiveQLDialect>),
        /// The Redshift dialect
        RedshiftDialect(std::boxed::Box<crate::model::RedshiftDialect>),
        /// The Teradata dialect
        TeradataDialect(std::boxed::Box<crate::model::TeradataDialect>),
        /// The Oracle dialect
        OracleDialect(std::boxed::Box<crate::model::OracleDialect>),
        /// The SparkSQL dialect
        SparksqlDialect(std::boxed::Box<crate::model::SparkSQLDialect>),
        /// The Snowflake dialect
        SnowflakeDialect(std::boxed::Box<crate::model::SnowflakeDialect>),
        /// The Netezza dialect
        NetezzaDialect(std::boxed::Box<crate::model::NetezzaDialect>),
        /// The Azure Synapse dialect
        AzureSynapseDialect(std::boxed::Box<crate::model::AzureSynapseDialect>),
        /// The Vertica dialect
        VerticaDialect(std::boxed::Box<crate::model::VerticaDialect>),
        /// The SQL Server dialect
        SqlServerDialect(std::boxed::Box<crate::model::SQLServerDialect>),
        /// The Postgresql dialect
        PostgresqlDialect(std::boxed::Box<crate::model::PostgresqlDialect>),
        /// The Presto dialect
        PrestoDialect(std::boxed::Box<crate::model::PrestoDialect>),
        /// The MySQL dialect
        MysqlDialect(std::boxed::Box<crate::model::MySQLDialect>),
        /// DB2 dialect
        Db2Dialect(std::boxed::Box<crate::model::DB2Dialect>),
        /// SQLite dialect
        SqliteDialect(std::boxed::Box<crate::model::SQLiteDialect>),
        /// Greenplum dialect
        GreenplumDialect(std::boxed::Box<crate::model::GreenplumDialect>),
    }
}

/// The dialect definition for BigQuery.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BigQueryDialect {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigQueryDialect {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for BigQueryDialect {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.BigQueryDialect"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BigQueryDialect {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BigQueryDialect")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BigQueryDialect;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BigQueryDialect")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BigQueryDialect {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The dialect definition for HiveQL.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct HiveQLDialect {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HiveQLDialect {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for HiveQLDialect {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.HiveQLDialect"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for HiveQLDialect {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HiveQLDialect")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = HiveQLDialect;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HiveQLDialect")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for HiveQLDialect {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The dialect definition for Redshift.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RedshiftDialect {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RedshiftDialect {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for RedshiftDialect {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.RedshiftDialect"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RedshiftDialect {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RedshiftDialect")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RedshiftDialect;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RedshiftDialect")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RedshiftDialect {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The dialect definition for Teradata.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TeradataDialect {
    /// Which Teradata sub-dialect mode the user specifies.
    pub mode: crate::model::teradata_dialect::Mode,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TeradataDialect {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mode][crate::model::TeradataDialect::mode].
    pub fn set_mode<T: std::convert::Into<crate::model::teradata_dialect::Mode>>(
        mut self,
        v: T,
    ) -> Self {
        self.mode = v.into();
        self
    }
}

impl wkt::message::Message for TeradataDialect {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.TeradataDialect"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TeradataDialect {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __mode,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TeradataDialect")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "mode" => Ok(__FieldTag::__mode),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TeradataDialect;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TeradataDialect")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__mode => {
                            if !fields.insert(__FieldTag::__mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mode",
                                ));
                            }
                            result.mode = map.next_value::<std::option::Option<crate::model::teradata_dialect::Mode>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TeradataDialect {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.mode) {
            state.serialize_entry("mode", &self.mode)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [TeradataDialect].
pub mod teradata_dialect {
    #[allow(unused_imports)]
    use super::*;

    /// The sub-dialect options for Teradata.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Mode {
        /// Unspecified mode.
        Unspecified,
        /// Teradata SQL mode.
        Sql,
        /// BTEQ mode (which includes SQL).
        Bteq,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Mode::value] or
        /// [Mode::name].
        UnknownValue(mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Mode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Sql => std::option::Option::Some(1),
                Self::Bteq => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MODE_UNSPECIFIED"),
                Self::Sql => std::option::Option::Some("SQL"),
                Self::Bteq => std::option::Option::Some("BTEQ"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Mode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Mode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Mode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Sql,
                2 => Self::Bteq,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Mode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MODE_UNSPECIFIED" => Self::Unspecified,
                "SQL" => Self::Sql,
                "BTEQ" => Self::Bteq,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Mode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Sql => serializer.serialize_i32(1),
                Self::Bteq => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Mode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Mode>::new(
                ".google.cloud.bigquery.migration.v2.TeradataDialect.Mode",
            ))
        }
    }
}

/// The dialect definition for Oracle.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct OracleDialect {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OracleDialect {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for OracleDialect {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.OracleDialect"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OracleDialect {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OracleDialect")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OracleDialect;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OracleDialect")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OracleDialect {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The dialect definition for SparkSQL.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SparkSQLDialect {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SparkSQLDialect {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for SparkSQLDialect {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.SparkSQLDialect"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SparkSQLDialect {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SparkSQLDialect")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SparkSQLDialect;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SparkSQLDialect")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SparkSQLDialect {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The dialect definition for Snowflake.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SnowflakeDialect {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SnowflakeDialect {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for SnowflakeDialect {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.SnowflakeDialect"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SnowflakeDialect {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SnowflakeDialect")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SnowflakeDialect;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SnowflakeDialect")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SnowflakeDialect {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The dialect definition for Netezza.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct NetezzaDialect {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NetezzaDialect {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for NetezzaDialect {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.NetezzaDialect"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NetezzaDialect {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NetezzaDialect")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NetezzaDialect;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NetezzaDialect")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NetezzaDialect {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The dialect definition for Azure Synapse.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AzureSynapseDialect {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AzureSynapseDialect {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for AzureSynapseDialect {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.AzureSynapseDialect"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AzureSynapseDialect {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AzureSynapseDialect")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AzureSynapseDialect;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AzureSynapseDialect")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AzureSynapseDialect {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The dialect definition for Vertica.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct VerticaDialect {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VerticaDialect {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for VerticaDialect {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.VerticaDialect"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VerticaDialect {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VerticaDialect")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VerticaDialect;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VerticaDialect")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VerticaDialect {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The dialect definition for SQL Server.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SQLServerDialect {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SQLServerDialect {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for SQLServerDialect {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.SQLServerDialect"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SQLServerDialect {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SQLServerDialect")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SQLServerDialect;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SQLServerDialect")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SQLServerDialect {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The dialect definition for Postgresql.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PostgresqlDialect {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PostgresqlDialect {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for PostgresqlDialect {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.PostgresqlDialect"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PostgresqlDialect {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PostgresqlDialect")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PostgresqlDialect;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PostgresqlDialect")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PostgresqlDialect {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The dialect definition for Presto.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PrestoDialect {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PrestoDialect {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for PrestoDialect {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.PrestoDialect"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PrestoDialect {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PrestoDialect")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PrestoDialect;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PrestoDialect")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PrestoDialect {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The dialect definition for MySQL.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct MySQLDialect {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MySQLDialect {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for MySQLDialect {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.MySQLDialect"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MySQLDialect {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MySQLDialect")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MySQLDialect;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MySQLDialect")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MySQLDialect {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The dialect definition for DB2.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DB2Dialect {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DB2Dialect {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for DB2Dialect {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.DB2Dialect"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DB2Dialect {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DB2Dialect")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DB2Dialect;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DB2Dialect")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DB2Dialect {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The dialect definition for SQLite.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SQLiteDialect {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SQLiteDialect {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for SQLiteDialect {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.SQLiteDialect"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SQLiteDialect {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SQLiteDialect")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SQLiteDialect;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SQLiteDialect")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SQLiteDialect {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The dialect definition for Greenplum.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GreenplumDialect {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GreenplumDialect {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for GreenplumDialect {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.GreenplumDialect"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GreenplumDialect {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GreenplumDialect")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GreenplumDialect;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GreenplumDialect")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GreenplumDialect {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents a map of name mappings using a list of key:value proto messages of
/// existing name to desired output name.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ObjectNameMappingList {
    /// The elements of the object name map.
    pub name_map: std::vec::Vec<crate::model::ObjectNameMapping>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ObjectNameMappingList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name_map][crate::model::ObjectNameMappingList::name_map].
    pub fn set_name_map<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ObjectNameMapping>,
    {
        use std::iter::Iterator;
        self.name_map = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ObjectNameMappingList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.ObjectNameMappingList"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ObjectNameMappingList {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name_map,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ObjectNameMappingList")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "nameMap" => Ok(__FieldTag::__name_map),
                            "name_map" => Ok(__FieldTag::__name_map),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ObjectNameMappingList;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ObjectNameMappingList")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name_map => {
                            if !fields.insert(__FieldTag::__name_map) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name_map",
                                ));
                            }
                            result.name_map =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ObjectNameMapping>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ObjectNameMappingList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name_map.is_empty() {
            state.serialize_entry("nameMap", &self.name_map)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents a key-value pair of NameMappingKey to NameMappingValue to
/// represent the mapping of SQL names from the input value to desired output.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ObjectNameMapping {
    /// The name of the object in source that is being mapped.
    pub source: std::option::Option<crate::model::NameMappingKey>,

    /// The desired target name of the object that is being mapped.
    pub target: std::option::Option<crate::model::NameMappingValue>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ObjectNameMapping {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source][crate::model::ObjectNameMapping::source].
    pub fn set_source<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NameMappingKey>,
    {
        self.source = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source][crate::model::ObjectNameMapping::source].
    pub fn set_or_clear_source<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NameMappingKey>,
    {
        self.source = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::ObjectNameMapping::target].
    pub fn set_target<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NameMappingValue>,
    {
        self.target = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [target][crate::model::ObjectNameMapping::target].
    pub fn set_or_clear_target<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NameMappingValue>,
    {
        self.target = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ObjectNameMapping {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.ObjectNameMapping"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ObjectNameMapping {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source,
            __target,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ObjectNameMapping")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "source" => Ok(__FieldTag::__source),
                            "target" => Ok(__FieldTag::__target),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ObjectNameMapping;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ObjectNameMapping")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source => {
                            if !fields.insert(__FieldTag::__source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source",
                                ));
                            }
                            result.source = map
                                .next_value::<std::option::Option<crate::model::NameMappingKey>>(
                                )?;
                        }
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target",
                                ));
                            }
                            result.target = map
                                .next_value::<std::option::Option<crate::model::NameMappingValue>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ObjectNameMapping {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.source.is_some() {
            state.serialize_entry("source", &self.source)?;
        }
        if self.target.is_some() {
            state.serialize_entry("target", &self.target)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The potential components of a full name mapping that will be mapped
/// during translation in the source data warehouse.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct NameMappingKey {
    /// The type of object that is being mapped.
    pub r#type: crate::model::name_mapping_key::Type,

    /// The database name (BigQuery project ID equivalent in the source data
    /// warehouse).
    pub database: std::string::String,

    /// The schema name (BigQuery dataset equivalent in the source data warehouse).
    pub schema: std::string::String,

    /// The relation name (BigQuery table or view equivalent in the source data
    /// warehouse).
    pub relation: std::string::String,

    /// The attribute name (BigQuery column equivalent in the source data
    /// warehouse).
    pub attribute: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NameMappingKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::NameMappingKey::type].
    pub fn set_type<T: std::convert::Into<crate::model::name_mapping_key::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [database][crate::model::NameMappingKey::database].
    pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [schema][crate::model::NameMappingKey::schema].
    pub fn set_schema<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schema = v.into();
        self
    }

    /// Sets the value of [relation][crate::model::NameMappingKey::relation].
    pub fn set_relation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.relation = v.into();
        self
    }

    /// Sets the value of [attribute][crate::model::NameMappingKey::attribute].
    pub fn set_attribute<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.attribute = v.into();
        self
    }
}

impl wkt::message::Message for NameMappingKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.NameMappingKey"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NameMappingKey {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __database,
            __schema,
            __relation,
            __attribute,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NameMappingKey")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "database" => Ok(__FieldTag::__database),
                            "schema" => Ok(__FieldTag::__schema),
                            "relation" => Ok(__FieldTag::__relation),
                            "attribute" => Ok(__FieldTag::__attribute),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NameMappingKey;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NameMappingKey")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::name_mapping_key::Type>>()?.unwrap_or_default();
                        }
                        __FieldTag::__database => {
                            if !fields.insert(__FieldTag::__database) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database",
                                ));
                            }
                            result.database = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__schema => {
                            if !fields.insert(__FieldTag::__schema) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schema",
                                ));
                            }
                            result.schema = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__relation => {
                            if !fields.insert(__FieldTag::__relation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for relation",
                                ));
                            }
                            result.relation = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__attribute => {
                            if !fields.insert(__FieldTag::__attribute) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attribute",
                                ));
                            }
                            result.attribute = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NameMappingKey {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.database.is_empty() {
            state.serialize_entry("database", &self.database)?;
        }
        if !self.schema.is_empty() {
            state.serialize_entry("schema", &self.schema)?;
        }
        if !self.relation.is_empty() {
            state.serialize_entry("relation", &self.relation)?;
        }
        if !self.attribute.is_empty() {
            state.serialize_entry("attribute", &self.attribute)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [NameMappingKey].
pub mod name_mapping_key {
    #[allow(unused_imports)]
    use super::*;

    /// The type of the object that is being mapped.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Unspecified name mapping type.
        Unspecified,
        /// The object being mapped is a database.
        Database,
        /// The object being mapped is a schema.
        Schema,
        /// The object being mapped is a relation.
        Relation,
        /// The object being mapped is an attribute.
        Attribute,
        /// The object being mapped is a relation alias.
        RelationAlias,
        /// The object being mapped is a an attribute alias.
        AttributeAlias,
        /// The object being mapped is a function.
        Function,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Database => std::option::Option::Some(1),
                Self::Schema => std::option::Option::Some(2),
                Self::Relation => std::option::Option::Some(3),
                Self::Attribute => std::option::Option::Some(4),
                Self::RelationAlias => std::option::Option::Some(5),
                Self::AttributeAlias => std::option::Option::Some(6),
                Self::Function => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::Database => std::option::Option::Some("DATABASE"),
                Self::Schema => std::option::Option::Some("SCHEMA"),
                Self::Relation => std::option::Option::Some("RELATION"),
                Self::Attribute => std::option::Option::Some("ATTRIBUTE"),
                Self::RelationAlias => std::option::Option::Some("RELATION_ALIAS"),
                Self::AttributeAlias => std::option::Option::Some("ATTRIBUTE_ALIAS"),
                Self::Function => std::option::Option::Some("FUNCTION"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Database,
                2 => Self::Schema,
                3 => Self::Relation,
                4 => Self::Attribute,
                5 => Self::RelationAlias,
                6 => Self::AttributeAlias,
                7 => Self::Function,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "DATABASE" => Self::Database,
                "SCHEMA" => Self::Schema,
                "RELATION" => Self::Relation,
                "ATTRIBUTE" => Self::Attribute,
                "RELATION_ALIAS" => Self::RelationAlias,
                "ATTRIBUTE_ALIAS" => Self::AttributeAlias,
                "FUNCTION" => Self::Function,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Database => serializer.serialize_i32(1),
                Self::Schema => serializer.serialize_i32(2),
                Self::Relation => serializer.serialize_i32(3),
                Self::Attribute => serializer.serialize_i32(4),
                Self::RelationAlias => serializer.serialize_i32(5),
                Self::AttributeAlias => serializer.serialize_i32(6),
                Self::Function => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.bigquery.migration.v2.NameMappingKey.Type",
            ))
        }
    }
}

/// The potential components of a full name mapping that will be mapped
/// during translation in the target data warehouse.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct NameMappingValue {
    /// The database name (BigQuery project ID equivalent in the target data
    /// warehouse).
    pub database: std::string::String,

    /// The schema name (BigQuery dataset equivalent in the target data warehouse).
    pub schema: std::string::String,

    /// The relation name (BigQuery table or view equivalent in the target data
    /// warehouse).
    pub relation: std::string::String,

    /// The attribute name (BigQuery column equivalent in the target data
    /// warehouse).
    pub attribute: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NameMappingValue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [database][crate::model::NameMappingValue::database].
    pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [schema][crate::model::NameMappingValue::schema].
    pub fn set_schema<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schema = v.into();
        self
    }

    /// Sets the value of [relation][crate::model::NameMappingValue::relation].
    pub fn set_relation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.relation = v.into();
        self
    }

    /// Sets the value of [attribute][crate::model::NameMappingValue::attribute].
    pub fn set_attribute<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.attribute = v.into();
        self
    }
}

impl wkt::message::Message for NameMappingValue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.NameMappingValue"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NameMappingValue {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __database,
            __schema,
            __relation,
            __attribute,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NameMappingValue")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "database" => Ok(__FieldTag::__database),
                            "schema" => Ok(__FieldTag::__schema),
                            "relation" => Ok(__FieldTag::__relation),
                            "attribute" => Ok(__FieldTag::__attribute),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NameMappingValue;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NameMappingValue")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__database => {
                            if !fields.insert(__FieldTag::__database) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database",
                                ));
                            }
                            result.database = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__schema => {
                            if !fields.insert(__FieldTag::__schema) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schema",
                                ));
                            }
                            result.schema = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__relation => {
                            if !fields.insert(__FieldTag::__relation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for relation",
                                ));
                            }
                            result.relation = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__attribute => {
                            if !fields.insert(__FieldTag::__attribute) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attribute",
                                ));
                            }
                            result.attribute = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NameMappingValue {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.database.is_empty() {
            state.serialize_entry("database", &self.database)?;
        }
        if !self.schema.is_empty() {
            state.serialize_entry("schema", &self.schema)?;
        }
        if !self.relation.is_empty() {
            state.serialize_entry("relation", &self.relation)?;
        }
        if !self.attribute.is_empty() {
            state.serialize_entry("attribute", &self.attribute)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents the default source environment values for the translation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SourceEnv {
    /// The default database name to fully qualify SQL objects when their database
    /// name is missing.
    pub default_database: std::string::String,

    /// The schema search path. When SQL objects are missing schema name,
    /// translation engine will search through this list to find the value.
    pub schema_search_path: std::vec::Vec<std::string::String>,

    /// Optional. Expects a valid BigQuery dataset ID that exists, e.g.,
    /// project-123.metadata_store_123.  If specified, translation will search and
    /// read the required schema information from a metadata store in this dataset.
    /// If metadata store doesn't exist, translation will parse the metadata file
    /// and upload the schema info to a temp table in the dataset to speed up
    /// future translation jobs.
    pub metadata_store_dataset: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SourceEnv {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [default_database][crate::model::SourceEnv::default_database].
    pub fn set_default_database<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.default_database = v.into();
        self
    }

    /// Sets the value of [schema_search_path][crate::model::SourceEnv::schema_search_path].
    pub fn set_schema_search_path<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.schema_search_path = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [metadata_store_dataset][crate::model::SourceEnv::metadata_store_dataset].
    pub fn set_metadata_store_dataset<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.metadata_store_dataset = v.into();
        self
    }
}

impl wkt::message::Message for SourceEnv {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.SourceEnv"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SourceEnv {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __default_database,
            __schema_search_path,
            __metadata_store_dataset,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SourceEnv")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "defaultDatabase" => Ok(__FieldTag::__default_database),
                            "default_database" => Ok(__FieldTag::__default_database),
                            "schemaSearchPath" => Ok(__FieldTag::__schema_search_path),
                            "schema_search_path" => Ok(__FieldTag::__schema_search_path),
                            "metadataStoreDataset" => Ok(__FieldTag::__metadata_store_dataset),
                            "metadata_store_dataset" => Ok(__FieldTag::__metadata_store_dataset),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SourceEnv;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SourceEnv")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__default_database => {
                            if !fields.insert(__FieldTag::__default_database) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_database",
                                ));
                            }
                            result.default_database = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__schema_search_path => {
                            if !fields.insert(__FieldTag::__schema_search_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schema_search_path",
                                ));
                            }
                            result.schema_search_path = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__metadata_store_dataset => {
                            if !fields.insert(__FieldTag::__metadata_store_dataset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata_store_dataset",
                                ));
                            }
                            result.metadata_store_dataset = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SourceEnv {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.default_database.is_empty() {
            state.serialize_entry("defaultDatabase", &self.default_database)?;
        }
        if !self.schema_search_path.is_empty() {
            state.serialize_entry("schemaSearchPath", &self.schema_search_path)?;
        }
        if !self.metadata_store_dataset.is_empty() {
            state.serialize_entry("metadataStoreDataset", &self.metadata_store_dataset)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The translation details to capture the necessary settings for a translation
/// job.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TranslationDetails {
    /// The mapping from source to target SQL.
    pub source_target_mapping: std::vec::Vec<crate::model::SourceTargetMapping>,

    /// The base URI for all writes to persistent storage.
    pub target_base_uri: std::string::String,

    /// The default source environment values for the translation.
    pub source_environment: std::option::Option<crate::model::SourceEnvironment>,

    /// The list of literal targets that will be directly returned to the response.
    /// Each entry consists of the constructed path, EXCLUDING the base path. Not
    /// providing a target_base_uri will prevent writing to persistent storage.
    pub target_return_literals: std::vec::Vec<std::string::String>,

    /// The types of output to generate, e.g. sql, metadata,
    /// lineage_from_sql_scripts, etc. If not specified, a default set of
    /// targets will be generated. Some additional target types may be slower to
    /// generate. See the documentation for the set of available target types.
    pub target_types: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TranslationDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_target_mapping][crate::model::TranslationDetails::source_target_mapping].
    pub fn set_source_target_mapping<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SourceTargetMapping>,
    {
        use std::iter::Iterator;
        self.source_target_mapping = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [target_base_uri][crate::model::TranslationDetails::target_base_uri].
    pub fn set_target_base_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_base_uri = v.into();
        self
    }

    /// Sets the value of [source_environment][crate::model::TranslationDetails::source_environment].
    pub fn set_source_environment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SourceEnvironment>,
    {
        self.source_environment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_environment][crate::model::TranslationDetails::source_environment].
    pub fn set_or_clear_source_environment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SourceEnvironment>,
    {
        self.source_environment = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target_return_literals][crate::model::TranslationDetails::target_return_literals].
    pub fn set_target_return_literals<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.target_return_literals = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [target_types][crate::model::TranslationDetails::target_types].
    pub fn set_target_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.target_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TranslationDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.TranslationDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TranslationDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source_target_mapping,
            __target_base_uri,
            __source_environment,
            __target_return_literals,
            __target_types,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TranslationDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sourceTargetMapping" => Ok(__FieldTag::__source_target_mapping),
                            "source_target_mapping" => Ok(__FieldTag::__source_target_mapping),
                            "targetBaseUri" => Ok(__FieldTag::__target_base_uri),
                            "target_base_uri" => Ok(__FieldTag::__target_base_uri),
                            "sourceEnvironment" => Ok(__FieldTag::__source_environment),
                            "source_environment" => Ok(__FieldTag::__source_environment),
                            "targetReturnLiterals" => Ok(__FieldTag::__target_return_literals),
                            "target_return_literals" => Ok(__FieldTag::__target_return_literals),
                            "targetTypes" => Ok(__FieldTag::__target_types),
                            "target_types" => Ok(__FieldTag::__target_types),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TranslationDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TranslationDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source_target_mapping => {
                            if !fields.insert(__FieldTag::__source_target_mapping) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_target_mapping",
                                ));
                            }
                            result.source_target_mapping = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SourceTargetMapping>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_base_uri => {
                            if !fields.insert(__FieldTag::__target_base_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_base_uri",
                                ));
                            }
                            result.target_base_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_environment => {
                            if !fields.insert(__FieldTag::__source_environment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_environment",
                                ));
                            }
                            result.source_environment = map
                                .next_value::<std::option::Option<crate::model::SourceEnvironment>>(
                                )?;
                        }
                        __FieldTag::__target_return_literals => {
                            if !fields.insert(__FieldTag::__target_return_literals) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_return_literals",
                                ));
                            }
                            result.target_return_literals = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__target_types => {
                            if !fields.insert(__FieldTag::__target_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_types",
                                ));
                            }
                            result.target_types = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TranslationDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.source_target_mapping.is_empty() {
            state.serialize_entry("sourceTargetMapping", &self.source_target_mapping)?;
        }
        if !self.target_base_uri.is_empty() {
            state.serialize_entry("targetBaseUri", &self.target_base_uri)?;
        }
        if self.source_environment.is_some() {
            state.serialize_entry("sourceEnvironment", &self.source_environment)?;
        }
        if !self.target_return_literals.is_empty() {
            state.serialize_entry("targetReturnLiterals", &self.target_return_literals)?;
        }
        if !self.target_types.is_empty() {
            state.serialize_entry("targetTypes", &self.target_types)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents one mapping from a source SQL to a target SQL.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SourceTargetMapping {
    /// The source SQL or the path to it.
    pub source_spec: std::option::Option<crate::model::SourceSpec>,

    /// The target SQL or the path for it.
    pub target_spec: std::option::Option<crate::model::TargetSpec>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SourceTargetMapping {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_spec][crate::model::SourceTargetMapping::source_spec].
    pub fn set_source_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SourceSpec>,
    {
        self.source_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_spec][crate::model::SourceTargetMapping::source_spec].
    pub fn set_or_clear_source_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SourceSpec>,
    {
        self.source_spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target_spec][crate::model::SourceTargetMapping::target_spec].
    pub fn set_target_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TargetSpec>,
    {
        self.target_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [target_spec][crate::model::SourceTargetMapping::target_spec].
    pub fn set_or_clear_target_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TargetSpec>,
    {
        self.target_spec = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SourceTargetMapping {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.SourceTargetMapping"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SourceTargetMapping {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source_spec,
            __target_spec,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SourceTargetMapping")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sourceSpec" => Ok(__FieldTag::__source_spec),
                            "source_spec" => Ok(__FieldTag::__source_spec),
                            "targetSpec" => Ok(__FieldTag::__target_spec),
                            "target_spec" => Ok(__FieldTag::__target_spec),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SourceTargetMapping;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SourceTargetMapping")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source_spec => {
                            if !fields.insert(__FieldTag::__source_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_spec",
                                ));
                            }
                            result.source_spec =
                                map.next_value::<std::option::Option<crate::model::SourceSpec>>()?;
                        }
                        __FieldTag::__target_spec => {
                            if !fields.insert(__FieldTag::__target_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_spec",
                                ));
                            }
                            result.target_spec =
                                map.next_value::<std::option::Option<crate::model::TargetSpec>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SourceTargetMapping {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.source_spec.is_some() {
            state.serialize_entry("sourceSpec", &self.source_spec)?;
        }
        if self.target_spec.is_some() {
            state.serialize_entry("targetSpec", &self.target_spec)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents one path to the location that holds source data.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SourceSpec {
    /// Optional. The optional field to specify the encoding of the sql bytes.
    pub encoding: std::string::String,

    /// The specific source SQL.
    pub source: std::option::Option<crate::model::source_spec::Source>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SourceSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [encoding][crate::model::SourceSpec::encoding].
    pub fn set_encoding<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.encoding = v.into();
        self
    }

    /// Sets the value of [source][crate::model::SourceSpec::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::source_spec::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::SourceSpec::source]
    /// if it holds a `BaseUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn base_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::source_spec::Source::BaseUri(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::SourceSpec::source]
    /// to hold a `BaseUri`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_base_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source =
            std::option::Option::Some(crate::model::source_spec::Source::BaseUri(v.into()));
        self
    }

    /// The value of [source][crate::model::SourceSpec::source]
    /// if it holds a `Literal`, `None` if the field is not set or
    /// holds a different branch.
    pub fn literal(&self) -> std::option::Option<&std::boxed::Box<crate::model::Literal>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::source_spec::Source::Literal(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::SourceSpec::source]
    /// to hold a `Literal`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_literal<T: std::convert::Into<std::boxed::Box<crate::model::Literal>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source =
            std::option::Option::Some(crate::model::source_spec::Source::Literal(v.into()));
        self
    }
}

impl wkt::message::Message for SourceSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.SourceSpec"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SourceSpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __base_uri,
            __literal,
            __encoding,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SourceSpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "baseUri" => Ok(__FieldTag::__base_uri),
                            "base_uri" => Ok(__FieldTag::__base_uri),
                            "literal" => Ok(__FieldTag::__literal),
                            "encoding" => Ok(__FieldTag::__encoding),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SourceSpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SourceSpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__base_uri => {
                            if !fields.insert(__FieldTag::__base_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for base_uri",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.bigquery.migration.v2.SourceSpec.base_uri, latest field was baseUri",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::source_spec::Source::BaseUri(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__literal => {
                            if !fields.insert(__FieldTag::__literal) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for literal",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.bigquery.migration.v2.SourceSpec.literal, latest field was literal",
                                ));
                            }
                            result.source =
                                std::option::Option::Some(
                                    crate::model::source_spec::Source::Literal(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::Literal>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::__encoding => {
                            if !fields.insert(__FieldTag::__encoding) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encoding",
                                ));
                            }
                            result.encoding = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SourceSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.base_uri() {
            state.serialize_entry("baseUri", value)?;
        }
        if let Some(value) = self.literal() {
            state.serialize_entry("literal", value)?;
        }
        if !self.encoding.is_empty() {
            state.serialize_entry("encoding", &self.encoding)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [SourceSpec].
pub mod source_spec {
    #[allow(unused_imports)]
    use super::*;

    /// The specific source SQL.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// The base URI for all files to be read in as sources for translation.
        BaseUri(std::string::String),
        /// Source literal.
        Literal(std::boxed::Box<crate::model::Literal>),
    }
}

/// Represents one path to the location that holds target data.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TargetSpec {
    /// The relative path for the target data. Given source file
    /// `base_uri/input/sql`, the output would be
    /// `target_base_uri/sql/relative_path/input.sql`.
    pub relative_path: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TargetSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [relative_path][crate::model::TargetSpec::relative_path].
    pub fn set_relative_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.relative_path = v.into();
        self
    }
}

impl wkt::message::Message for TargetSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.TargetSpec"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TargetSpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __relative_path,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TargetSpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "relativePath" => Ok(__FieldTag::__relative_path),
                            "relative_path" => Ok(__FieldTag::__relative_path),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TargetSpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TargetSpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__relative_path => {
                            if !fields.insert(__FieldTag::__relative_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for relative_path",
                                ));
                            }
                            result.relative_path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TargetSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.relative_path.is_empty() {
            state.serialize_entry("relativePath", &self.relative_path)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Literal data.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Literal {
    /// Required. The identifier of the literal entry.
    pub relative_path: std::string::String,

    /// The literal SQL contents.
    pub literal_data: std::option::Option<crate::model::literal::LiteralData>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Literal {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [relative_path][crate::model::Literal::relative_path].
    pub fn set_relative_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.relative_path = v.into();
        self
    }

    /// Sets the value of [literal_data][crate::model::Literal::literal_data].
    ///
    /// Note that all the setters affecting `literal_data` are mutually
    /// exclusive.
    pub fn set_literal_data<
        T: std::convert::Into<std::option::Option<crate::model::literal::LiteralData>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.literal_data = v.into();
        self
    }

    /// The value of [literal_data][crate::model::Literal::literal_data]
    /// if it holds a `LiteralString`, `None` if the field is not set or
    /// holds a different branch.
    pub fn literal_string(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.literal_data.as_ref().and_then(|v| match v {
            crate::model::literal::LiteralData::LiteralString(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [literal_data][crate::model::Literal::literal_data]
    /// to hold a `LiteralString`.
    ///
    /// Note that all the setters affecting `literal_data` are
    /// mutually exclusive.
    pub fn set_literal_string<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.literal_data =
            std::option::Option::Some(crate::model::literal::LiteralData::LiteralString(v.into()));
        self
    }

    /// The value of [literal_data][crate::model::Literal::literal_data]
    /// if it holds a `LiteralBytes`, `None` if the field is not set or
    /// holds a different branch.
    pub fn literal_bytes(&self) -> std::option::Option<&::bytes::Bytes> {
        #[allow(unreachable_patterns)]
        self.literal_data.as_ref().and_then(|v| match v {
            crate::model::literal::LiteralData::LiteralBytes(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [literal_data][crate::model::Literal::literal_data]
    /// to hold a `LiteralBytes`.
    ///
    /// Note that all the setters affecting `literal_data` are
    /// mutually exclusive.
    pub fn set_literal_bytes<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.literal_data =
            std::option::Option::Some(crate::model::literal::LiteralData::LiteralBytes(v.into()));
        self
    }
}

impl wkt::message::Message for Literal {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.Literal"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Literal {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __literal_string,
            __literal_bytes,
            __relative_path,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Literal")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "literalString" => Ok(__FieldTag::__literal_string),
                            "literal_string" => Ok(__FieldTag::__literal_string),
                            "literalBytes" => Ok(__FieldTag::__literal_bytes),
                            "literal_bytes" => Ok(__FieldTag::__literal_bytes),
                            "relativePath" => Ok(__FieldTag::__relative_path),
                            "relative_path" => Ok(__FieldTag::__relative_path),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Literal;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Literal")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__literal_string => {
                            if !fields.insert(__FieldTag::__literal_string) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for literal_string",
                                ));
                            }
                            if result.literal_data.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `literal_data`, a oneof with full ID .google.cloud.bigquery.migration.v2.Literal.literal_string, latest field was literalString",
                                ));
                            }
                            result.literal_data = std::option::Option::Some(
                                crate::model::literal::LiteralData::LiteralString(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__literal_bytes => {
                            if !fields.insert(__FieldTag::__literal_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for literal_bytes",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.literal_data.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `literal_data`, a oneof with full ID .google.cloud.bigquery.migration.v2.Literal.literal_bytes, latest field was literalBytes",
                                ));
                            }
                            result.literal_data = std::option::Option::Some(
                                crate::model::literal::LiteralData::LiteralBytes(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__relative_path => {
                            if !fields.insert(__FieldTag::__relative_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for relative_path",
                                ));
                            }
                            result.relative_path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Literal {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.literal_string() {
            state.serialize_entry("literalString", value)?;
        }
        if let Some(value) = self.literal_bytes() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("literalBytes", &__With(value))?;
        }
        if !self.relative_path.is_empty() {
            state.serialize_entry("relativePath", &self.relative_path)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Literal].
pub mod literal {
    #[allow(unused_imports)]
    use super::*;

    /// The literal SQL contents.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LiteralData {
        /// Literal string data.
        LiteralString(std::string::String),
        /// Literal byte data.
        LiteralBytes(::bytes::Bytes),
    }
}

/// Represents the default source environment values for the translation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SourceEnvironment {
    /// The default database name to fully qualify SQL objects when their database
    /// name is missing.
    pub default_database: std::string::String,

    /// The schema search path. When SQL objects are missing schema name,
    /// translation engine will search through this list to find the value.
    pub schema_search_path: std::vec::Vec<std::string::String>,

    /// Optional. Expects a validQ BigQuery dataset ID that exists, e.g.,
    /// project-123.metadata_store_123.  If specified, translation will search and
    /// read the required schema information from a metadata store in this dataset.
    /// If metadata store doesn't exist, translation will parse the metadata file
    /// and upload the schema info to a temp table in the dataset to speed up
    /// future translation jobs.
    pub metadata_store_dataset: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SourceEnvironment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [default_database][crate::model::SourceEnvironment::default_database].
    pub fn set_default_database<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.default_database = v.into();
        self
    }

    /// Sets the value of [schema_search_path][crate::model::SourceEnvironment::schema_search_path].
    pub fn set_schema_search_path<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.schema_search_path = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [metadata_store_dataset][crate::model::SourceEnvironment::metadata_store_dataset].
    pub fn set_metadata_store_dataset<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.metadata_store_dataset = v.into();
        self
    }
}

impl wkt::message::Message for SourceEnvironment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.SourceEnvironment"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SourceEnvironment {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __default_database,
            __schema_search_path,
            __metadata_store_dataset,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SourceEnvironment")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "defaultDatabase" => Ok(__FieldTag::__default_database),
                            "default_database" => Ok(__FieldTag::__default_database),
                            "schemaSearchPath" => Ok(__FieldTag::__schema_search_path),
                            "schema_search_path" => Ok(__FieldTag::__schema_search_path),
                            "metadataStoreDataset" => Ok(__FieldTag::__metadata_store_dataset),
                            "metadata_store_dataset" => Ok(__FieldTag::__metadata_store_dataset),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SourceEnvironment;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SourceEnvironment")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__default_database => {
                            if !fields.insert(__FieldTag::__default_database) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_database",
                                ));
                            }
                            result.default_database = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__schema_search_path => {
                            if !fields.insert(__FieldTag::__schema_search_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schema_search_path",
                                ));
                            }
                            result.schema_search_path = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__metadata_store_dataset => {
                            if !fields.insert(__FieldTag::__metadata_store_dataset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata_store_dataset",
                                ));
                            }
                            result.metadata_store_dataset = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SourceEnvironment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.default_database.is_empty() {
            state.serialize_entry("defaultDatabase", &self.default_database)?;
        }
        if !self.schema_search_path.is_empty() {
            state.serialize_entry("schemaSearchPath", &self.schema_search_path)?;
        }
        if !self.metadata_store_dataset.is_empty() {
            state.serialize_entry("metadataStoreDataset", &self.metadata_store_dataset)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Details about a record.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TranslationReportRecord {
    /// Severity of the translation record.
    pub severity: crate::model::translation_report_record::Severity,

    /// Specifies the row from the source text where the error occurred (0 based).
    /// Example: 2
    pub script_line: i32,

    /// Specifies the column from the source texts where the error occurred. (0
    /// based) example: 6
    pub script_column: i32,

    /// Category of the error/warning. Example: SyntaxError
    pub category: std::string::String,

    /// Detailed message of the record.
    pub message: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TranslationReportRecord {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [severity][crate::model::TranslationReportRecord::severity].
    pub fn set_severity<
        T: std::convert::Into<crate::model::translation_report_record::Severity>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.severity = v.into();
        self
    }

    /// Sets the value of [script_line][crate::model::TranslationReportRecord::script_line].
    pub fn set_script_line<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.script_line = v.into();
        self
    }

    /// Sets the value of [script_column][crate::model::TranslationReportRecord::script_column].
    pub fn set_script_column<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.script_column = v.into();
        self
    }

    /// Sets the value of [category][crate::model::TranslationReportRecord::category].
    pub fn set_category<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.category = v.into();
        self
    }

    /// Sets the value of [message][crate::model::TranslationReportRecord::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }
}

impl wkt::message::Message for TranslationReportRecord {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.TranslationReportRecord"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TranslationReportRecord {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __severity,
            __script_line,
            __script_column,
            __category,
            __message,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TranslationReportRecord")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "severity" => Ok(__FieldTag::__severity),
                            "scriptLine" => Ok(__FieldTag::__script_line),
                            "script_line" => Ok(__FieldTag::__script_line),
                            "scriptColumn" => Ok(__FieldTag::__script_column),
                            "script_column" => Ok(__FieldTag::__script_column),
                            "category" => Ok(__FieldTag::__category),
                            "message" => Ok(__FieldTag::__message),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TranslationReportRecord;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TranslationReportRecord")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__severity => {
                            if !fields.insert(__FieldTag::__severity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for severity",
                                ));
                            }
                            result.severity = map
                                .next_value::<std::option::Option<
                                    crate::model::translation_report_record::Severity,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__script_line => {
                            if !fields.insert(__FieldTag::__script_line) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for script_line",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.script_line = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__script_column => {
                            if !fields.insert(__FieldTag::__script_column) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for script_column",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.script_column =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__category => {
                            if !fields.insert(__FieldTag::__category) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for category",
                                ));
                            }
                            result.category = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TranslationReportRecord {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.severity) {
            state.serialize_entry("severity", &self.severity)?;
        }
        if !wkt::internal::is_default(&self.script_line) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("scriptLine", &__With(&self.script_line))?;
        }
        if !wkt::internal::is_default(&self.script_column) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("scriptColumn", &__With(&self.script_column))?;
        }
        if !self.category.is_empty() {
            state.serialize_entry("category", &self.category)?;
        }
        if !self.message.is_empty() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [TranslationReportRecord].
pub mod translation_report_record {
    #[allow(unused_imports)]
    use super::*;

    /// The severity type of the record.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Severity {
        /// SeverityType not specified.
        Unspecified,
        /// INFO type.
        Info,
        /// WARNING type. The translated query may still provide useful information
        /// if all the report records are WARNING.
        Warning,
        /// ERROR type. Translation failed.
        Error,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Severity::value] or
        /// [Severity::name].
        UnknownValue(severity::UnknownValue),
    }

    #[doc(hidden)]
    pub mod severity {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Severity {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Info => std::option::Option::Some(1),
                Self::Warning => std::option::Option::Some(2),
                Self::Error => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SEVERITY_UNSPECIFIED"),
                Self::Info => std::option::Option::Some("INFO"),
                Self::Warning => std::option::Option::Some("WARNING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Severity {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Severity {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Severity {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Info,
                2 => Self::Warning,
                3 => Self::Error,
                _ => Self::UnknownValue(severity::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Severity {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SEVERITY_UNSPECIFIED" => Self::Unspecified,
                "INFO" => Self::Info,
                "WARNING" => Self::Warning,
                "ERROR" => Self::Error,
                _ => Self::UnknownValue(severity::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Severity {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Info => serializer.serialize_i32(1),
                Self::Warning => serializer.serialize_i32(2),
                Self::Error => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Severity {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Severity>::new(
                ".google.cloud.bigquery.migration.v2.TranslationReportRecord.Severity",
            ))
        }
    }
}

/// A record in the aggregate CSV report for a migration workflow
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GcsReportLogMessage {
    /// Severity of the translation record.
    pub severity: std::string::String,

    /// Category of the error/warning. Example: SyntaxError
    pub category: std::string::String,

    /// The file path in which the error occurred
    pub file_path: std::string::String,

    /// The file name in which the error occurred
    pub filename: std::string::String,

    /// Specifies the row from the source text where the error occurred (0 based,
    /// -1 for messages without line location). Example: 2
    pub source_script_line: i32,

    /// Specifies the column from the source texts where the error occurred. (0
    /// based, -1 for messages without column location) example: 6
    pub source_script_column: i32,

    /// Detailed message of the record.
    pub message: std::string::String,

    /// The script context (obfuscated) in which the error occurred
    pub script_context: std::string::String,

    /// Category of the error/warning. Example: SyntaxError
    pub action: std::string::String,

    /// Effect of the error/warning. Example: COMPATIBILITY
    pub effect: std::string::String,

    /// Name of the affected object in the log message.
    pub object_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcsReportLogMessage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [severity][crate::model::GcsReportLogMessage::severity].
    pub fn set_severity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.severity = v.into();
        self
    }

    /// Sets the value of [category][crate::model::GcsReportLogMessage::category].
    pub fn set_category<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.category = v.into();
        self
    }

    /// Sets the value of [file_path][crate::model::GcsReportLogMessage::file_path].
    pub fn set_file_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.file_path = v.into();
        self
    }

    /// Sets the value of [filename][crate::model::GcsReportLogMessage::filename].
    pub fn set_filename<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filename = v.into();
        self
    }

    /// Sets the value of [source_script_line][crate::model::GcsReportLogMessage::source_script_line].
    pub fn set_source_script_line<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.source_script_line = v.into();
        self
    }

    /// Sets the value of [source_script_column][crate::model::GcsReportLogMessage::source_script_column].
    pub fn set_source_script_column<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.source_script_column = v.into();
        self
    }

    /// Sets the value of [message][crate::model::GcsReportLogMessage::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [script_context][crate::model::GcsReportLogMessage::script_context].
    pub fn set_script_context<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.script_context = v.into();
        self
    }

    /// Sets the value of [action][crate::model::GcsReportLogMessage::action].
    pub fn set_action<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.action = v.into();
        self
    }

    /// Sets the value of [effect][crate::model::GcsReportLogMessage::effect].
    pub fn set_effect<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.effect = v.into();
        self
    }

    /// Sets the value of [object_name][crate::model::GcsReportLogMessage::object_name].
    pub fn set_object_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.object_name = v.into();
        self
    }
}

impl wkt::message::Message for GcsReportLogMessage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.GcsReportLogMessage"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GcsReportLogMessage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __severity,
            __category,
            __file_path,
            __filename,
            __source_script_line,
            __source_script_column,
            __message,
            __script_context,
            __action,
            __effect,
            __object_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GcsReportLogMessage")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "severity" => Ok(__FieldTag::__severity),
                            "category" => Ok(__FieldTag::__category),
                            "filePath" => Ok(__FieldTag::__file_path),
                            "file_path" => Ok(__FieldTag::__file_path),
                            "filename" => Ok(__FieldTag::__filename),
                            "sourceScriptLine" => Ok(__FieldTag::__source_script_line),
                            "source_script_line" => Ok(__FieldTag::__source_script_line),
                            "sourceScriptColumn" => Ok(__FieldTag::__source_script_column),
                            "source_script_column" => Ok(__FieldTag::__source_script_column),
                            "message" => Ok(__FieldTag::__message),
                            "scriptContext" => Ok(__FieldTag::__script_context),
                            "script_context" => Ok(__FieldTag::__script_context),
                            "action" => Ok(__FieldTag::__action),
                            "effect" => Ok(__FieldTag::__effect),
                            "objectName" => Ok(__FieldTag::__object_name),
                            "object_name" => Ok(__FieldTag::__object_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GcsReportLogMessage;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GcsReportLogMessage")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__severity => {
                            if !fields.insert(__FieldTag::__severity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for severity",
                                ));
                            }
                            result.severity = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__category => {
                            if !fields.insert(__FieldTag::__category) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for category",
                                ));
                            }
                            result.category = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__file_path => {
                            if !fields.insert(__FieldTag::__file_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_path",
                                ));
                            }
                            result.file_path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filename => {
                            if !fields.insert(__FieldTag::__filename) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filename",
                                ));
                            }
                            result.filename = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_script_line => {
                            if !fields.insert(__FieldTag::__source_script_line) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_script_line",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.source_script_line =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__source_script_column => {
                            if !fields.insert(__FieldTag::__source_script_column) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_script_column",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.source_script_column =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__script_context => {
                            if !fields.insert(__FieldTag::__script_context) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for script_context",
                                ));
                            }
                            result.script_context = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__action => {
                            if !fields.insert(__FieldTag::__action) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for action",
                                ));
                            }
                            result.action = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__effect => {
                            if !fields.insert(__FieldTag::__effect) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for effect",
                                ));
                            }
                            result.effect = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__object_name => {
                            if !fields.insert(__FieldTag::__object_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for object_name",
                                ));
                            }
                            result.object_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GcsReportLogMessage {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.severity.is_empty() {
            state.serialize_entry("severity", &self.severity)?;
        }
        if !self.category.is_empty() {
            state.serialize_entry("category", &self.category)?;
        }
        if !self.file_path.is_empty() {
            state.serialize_entry("filePath", &self.file_path)?;
        }
        if !self.filename.is_empty() {
            state.serialize_entry("filename", &self.filename)?;
        }
        if !wkt::internal::is_default(&self.source_script_line) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sourceScriptLine", &__With(&self.source_script_line))?;
        }
        if !wkt::internal::is_default(&self.source_script_column) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sourceScriptColumn", &__With(&self.source_script_column))?;
        }
        if !self.message.is_empty() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self.script_context.is_empty() {
            state.serialize_entry("scriptContext", &self.script_context)?;
        }
        if !self.action.is_empty() {
            state.serialize_entry("action", &self.action)?;
        }
        if !self.effect.is_empty() {
            state.serialize_entry("effect", &self.effect)?;
        }
        if !self.object_name.is_empty() {
            state.serialize_entry("objectName", &self.object_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}
