// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate api;
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// A migration workflow which specifies what needs to be done for an EDW
/// migration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MigrationWorkflow {
    /// Output only. Immutable. Identifier. The unique identifier for the migration
    /// workflow. The ID is server-generated.
    ///
    /// Example: `projects/123/locations/us/workflows/345`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The display name of the workflow. This can be set to give a workflow
    /// a descriptive name. There is no guarantee or enforcement of uniqueness.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// The tasks in a workflow in a named map. The name (i.e. key) has no
    /// meaning and is merely a convenient way to address a specific task
    /// in a workflow.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub tasks: std::collections::HashMap<std::string::String, crate::model::MigrationTask>,

    /// Output only. That status of the workflow.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub state: crate::model::migration_workflow::State,

    /// Time when the workflow was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Time when the workflow was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_update_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MigrationWorkflow {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MigrationWorkflow::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::MigrationWorkflow::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [tasks][crate::model::MigrationWorkflow::tasks].
    pub fn set_tasks<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::MigrationTask>,
    {
        use std::iter::Iterator;
        self.tasks = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [state][crate::model::MigrationWorkflow::state].
    pub fn set_state<T: std::convert::Into<crate::model::migration_workflow::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::MigrationWorkflow::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::MigrationWorkflow::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_update_time][crate::model::MigrationWorkflow::last_update_time].
    pub fn set_last_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_update_time][crate::model::MigrationWorkflow::last_update_time].
    pub fn set_or_clear_last_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for MigrationWorkflow {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.MigrationWorkflow"
    }
}

/// Defines additional types related to [MigrationWorkflow].
pub mod migration_workflow {
    #[allow(unused_imports)]
    use super::*;

    /// Possible migration workflow states.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Workflow state is unspecified.
        Unspecified,
        /// Workflow is in draft status, i.e. tasks are not yet eligible for
        /// execution.
        Draft,
        /// Workflow is running (i.e. tasks are eligible for execution).
        Running,
        /// Workflow is paused. Tasks currently in progress may continue, but no
        /// further tasks will be scheduled.
        Paused,
        /// Workflow is complete. There should not be any task in a non-terminal
        /// state, but if they are (e.g. forced termination), they will not be
        /// scheduled.
        Completed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Draft => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::Paused => std::option::Option::Some(3),
                Self::Completed => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Draft => std::option::Option::Some("DRAFT"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Paused => std::option::Option::Some("PAUSED"),
                Self::Completed => std::option::Option::Some("COMPLETED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Draft,
                2 => Self::Running,
                3 => Self::Paused,
                4 => Self::Completed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "DRAFT" => Self::Draft,
                "RUNNING" => Self::Running,
                "PAUSED" => Self::Paused,
                "COMPLETED" => Self::Completed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Draft => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::Paused => serializer.serialize_i32(3),
                Self::Completed => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.bigquery.migration.v2.MigrationWorkflow.State",
            ))
        }
    }
}

/// A single task for a migration which has details about the configuration of
/// the task.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MigrationTask {
    /// Output only. Immutable. The unique identifier for the migration task. The
    /// ID is server-generated.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// The type of the task. This must be one of the supported task types:
    /// Translation_Teradata2BQ, Translation_Redshift2BQ, Translation_Bteq2BQ,
    /// Translation_Oracle2BQ, Translation_HiveQL2BQ, Translation_SparkSQL2BQ,
    /// Translation_Snowflake2BQ, Translation_Netezza2BQ,
    /// Translation_AzureSynapse2BQ, Translation_Vertica2BQ,
    /// Translation_SQLServer2BQ, Translation_Presto2BQ, Translation_MySQL2BQ,
    /// Translation_Postgresql2BQ, Translation_SQLite2BQ, Translation_Greenplum2BQ.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub r#type: std::string::String,

    /// Output only. The current state of the task.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub state: crate::model::migration_task::State,

    /// Output only. An explanation that may be populated when the task is in
    /// FAILED state.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub processing_error: std::option::Option<rpc::model::ErrorInfo>,

    /// Time when the task was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Time when the task was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Provides details to errors and issues encountered while
    /// processing the task. Presence of error details does not mean that the task
    /// failed.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub resource_error_details: std::vec::Vec<crate::model::ResourceErrorDetail>,

    /// The number or resources with errors. Note: This is not the total
    /// number of errors as each resource can have more than one error.
    /// This is used to indicate truncation by having a `resource_error_count`
    /// that is higher than the size of `resource_error_details`.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub resource_error_count: i32,

    /// The metrics for the task.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub metrics: std::vec::Vec<crate::model::TimeSeries>,

    /// Output only. The result of the task.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub task_result: std::option::Option<crate::model::MigrationTaskResult>,

    /// Count of all the processing errors in this task and its subtasks.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub total_processing_error_count: i32,

    /// Count of all the resource errors in this task and its subtasks.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub total_resource_error_count: i32,

    /// The details of the task.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub task_details: std::option::Option<crate::model::migration_task::TaskDetails>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MigrationTask {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::MigrationTask::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::MigrationTask::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [state][crate::model::MigrationTask::state].
    pub fn set_state<T: std::convert::Into<crate::model::migration_task::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [processing_error][crate::model::MigrationTask::processing_error].
    pub fn set_processing_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::ErrorInfo>,
    {
        self.processing_error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [processing_error][crate::model::MigrationTask::processing_error].
    pub fn set_or_clear_processing_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::ErrorInfo>,
    {
        self.processing_error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [create_time][crate::model::MigrationTask::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::MigrationTask::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_update_time][crate::model::MigrationTask::last_update_time].
    pub fn set_last_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_update_time][crate::model::MigrationTask::last_update_time].
    pub fn set_or_clear_last_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resource_error_details][crate::model::MigrationTask::resource_error_details].
    pub fn set_resource_error_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ResourceErrorDetail>,
    {
        use std::iter::Iterator;
        self.resource_error_details = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [resource_error_count][crate::model::MigrationTask::resource_error_count].
    pub fn set_resource_error_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.resource_error_count = v.into();
        self
    }

    /// Sets the value of [metrics][crate::model::MigrationTask::metrics].
    pub fn set_metrics<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TimeSeries>,
    {
        use std::iter::Iterator;
        self.metrics = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [task_result][crate::model::MigrationTask::task_result].
    pub fn set_task_result<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MigrationTaskResult>,
    {
        self.task_result = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [task_result][crate::model::MigrationTask::task_result].
    pub fn set_or_clear_task_result<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MigrationTaskResult>,
    {
        self.task_result = v.map(|x| x.into());
        self
    }

    /// Sets the value of [total_processing_error_count][crate::model::MigrationTask::total_processing_error_count].
    pub fn set_total_processing_error_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_processing_error_count = v.into();
        self
    }

    /// Sets the value of [total_resource_error_count][crate::model::MigrationTask::total_resource_error_count].
    pub fn set_total_resource_error_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_resource_error_count = v.into();
        self
    }

    /// Sets the value of [task_details][crate::model::MigrationTask::task_details].
    ///
    /// Note that all the setters affecting `task_details` are mutually
    /// exclusive.
    pub fn set_task_details<
        T: std::convert::Into<std::option::Option<crate::model::migration_task::TaskDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.task_details = v.into();
        self
    }

    /// The value of [task_details][crate::model::MigrationTask::task_details]
    /// if it holds a `TranslationConfigDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn translation_config_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TranslationConfigDetails>> {
        #[allow(unreachable_patterns)]
        self.task_details.as_ref().and_then(|v| match v {
            crate::model::migration_task::TaskDetails::TranslationConfigDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [task_details][crate::model::MigrationTask::task_details]
    /// to hold a `TranslationConfigDetails`.
    ///
    /// Note that all the setters affecting `task_details` are
    /// mutually exclusive.
    pub fn set_translation_config_details<
        T: std::convert::Into<std::boxed::Box<crate::model::TranslationConfigDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.task_details = std::option::Option::Some(
            crate::model::migration_task::TaskDetails::TranslationConfigDetails(v.into()),
        );
        self
    }

    /// The value of [task_details][crate::model::MigrationTask::task_details]
    /// if it holds a `TranslationDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn translation_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TranslationDetails>> {
        #[allow(unreachable_patterns)]
        self.task_details.as_ref().and_then(|v| match v {
            crate::model::migration_task::TaskDetails::TranslationDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [task_details][crate::model::MigrationTask::task_details]
    /// to hold a `TranslationDetails`.
    ///
    /// Note that all the setters affecting `task_details` are
    /// mutually exclusive.
    pub fn set_translation_details<
        T: std::convert::Into<std::boxed::Box<crate::model::TranslationDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.task_details = std::option::Option::Some(
            crate::model::migration_task::TaskDetails::TranslationDetails(v.into()),
        );
        self
    }
}

impl wkt::message::Message for MigrationTask {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.MigrationTask"
    }
}

/// Defines additional types related to [MigrationTask].
pub mod migration_task {
    #[allow(unused_imports)]
    use super::*;

    /// Possible states of a migration task.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state is unspecified.
        Unspecified,
        /// The task is waiting for orchestration.
        Pending,
        /// The task is assigned to an orchestrator.
        Orchestrating,
        /// The task is running, i.e. its subtasks are ready for execution.
        Running,
        /// Tha task is paused. Assigned subtasks can continue, but no new subtasks
        /// will be scheduled.
        Paused,
        /// The task finished successfully.
        Succeeded,
        /// The task finished unsuccessfully.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Orchestrating => std::option::Option::Some(2),
                Self::Running => std::option::Option::Some(3),
                Self::Paused => std::option::Option::Some(4),
                Self::Succeeded => std::option::Option::Some(5),
                Self::Failed => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Orchestrating => std::option::Option::Some("ORCHESTRATING"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Paused => std::option::Option::Some("PAUSED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Orchestrating,
                3 => Self::Running,
                4 => Self::Paused,
                5 => Self::Succeeded,
                6 => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "ORCHESTRATING" => Self::Orchestrating,
                "RUNNING" => Self::Running,
                "PAUSED" => Self::Paused,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Orchestrating => serializer.serialize_i32(2),
                Self::Running => serializer.serialize_i32(3),
                Self::Paused => serializer.serialize_i32(4),
                Self::Succeeded => serializer.serialize_i32(5),
                Self::Failed => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.bigquery.migration.v2.MigrationTask.State",
            ))
        }
    }

    /// The details of the task.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum TaskDetails {
        /// Task configuration for CW Batch/Offline SQL Translation.
        TranslationConfigDetails(std::boxed::Box<crate::model::TranslationConfigDetails>),
        /// Task details for unified SQL Translation.
        TranslationDetails(std::boxed::Box<crate::model::TranslationDetails>),
    }
}

/// A subtask for a migration which carries details about the configuration of
/// the subtask. The content of the details should not matter to the end user,
/// but is a contract between the subtask creator and subtask worker.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MigrationSubtask {
    /// Output only. Immutable. The resource name for the migration subtask. The ID
    /// is server-generated.
    ///
    /// Example: `projects/123/locations/us/workflows/345/subtasks/678`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The unique ID of the task to which this subtask belongs.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub task_id: std::string::String,

    /// The type of the Subtask. The migration service does not check whether this
    /// is a known type. It is up to the task creator (i.e. orchestrator or worker)
    /// to ensure it only creates subtasks for which there are compatible workers
    /// polling for Subtasks.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub r#type: std::string::String,

    /// Output only. The current state of the subtask.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub state: crate::model::migration_subtask::State,

    /// Output only. An explanation that may be populated when the task is in
    /// FAILED state.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub processing_error: std::option::Option<rpc::model::ErrorInfo>,

    /// Output only. Provides details to errors and issues encountered while
    /// processing the subtask. Presence of error details does not mean that the
    /// subtask failed.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub resource_error_details: std::vec::Vec<crate::model::ResourceErrorDetail>,

    /// The number or resources with errors. Note: This is not the total
    /// number of errors as each resource can have more than one error.
    /// This is used to indicate truncation by having a `resource_error_count`
    /// that is higher than the size of `resource_error_details`.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub resource_error_count: i32,

    /// Time when the subtask was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Time when the subtask was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_update_time: std::option::Option<wkt::Timestamp>,

    /// The metrics for the subtask.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub metrics: std::vec::Vec<crate::model::TimeSeries>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MigrationSubtask {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MigrationSubtask::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [task_id][crate::model::MigrationSubtask::task_id].
    pub fn set_task_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.task_id = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::MigrationSubtask::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [state][crate::model::MigrationSubtask::state].
    pub fn set_state<T: std::convert::Into<crate::model::migration_subtask::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [processing_error][crate::model::MigrationSubtask::processing_error].
    pub fn set_processing_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::ErrorInfo>,
    {
        self.processing_error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [processing_error][crate::model::MigrationSubtask::processing_error].
    pub fn set_or_clear_processing_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::ErrorInfo>,
    {
        self.processing_error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resource_error_details][crate::model::MigrationSubtask::resource_error_details].
    pub fn set_resource_error_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ResourceErrorDetail>,
    {
        use std::iter::Iterator;
        self.resource_error_details = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [resource_error_count][crate::model::MigrationSubtask::resource_error_count].
    pub fn set_resource_error_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.resource_error_count = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::MigrationSubtask::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::MigrationSubtask::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_update_time][crate::model::MigrationSubtask::last_update_time].
    pub fn set_last_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_update_time][crate::model::MigrationSubtask::last_update_time].
    pub fn set_or_clear_last_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [metrics][crate::model::MigrationSubtask::metrics].
    pub fn set_metrics<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TimeSeries>,
    {
        use std::iter::Iterator;
        self.metrics = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for MigrationSubtask {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.MigrationSubtask"
    }
}

/// Defines additional types related to [MigrationSubtask].
pub mod migration_subtask {
    #[allow(unused_imports)]
    use super::*;

    /// Possible states of a migration subtask.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state is unspecified.
        Unspecified,
        /// The subtask is ready, i.e. it is ready for execution.
        Active,
        /// The subtask is running, i.e. it is assigned to a worker for execution.
        Running,
        /// The subtask finished successfully.
        Succeeded,
        /// The subtask finished unsuccessfully.
        Failed,
        /// The subtask is paused, i.e., it will not be scheduled. If it was already
        /// assigned,it might still finish but no new lease renewals will be granted.
        Paused,
        /// The subtask is pending a dependency. It will be scheduled once its
        /// dependencies are done.
        PendingDependency,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Active => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::Succeeded => std::option::Option::Some(3),
                Self::Failed => std::option::Option::Some(4),
                Self::Paused => std::option::Option::Some(5),
                Self::PendingDependency => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Paused => std::option::Option::Some("PAUSED"),
                Self::PendingDependency => std::option::Option::Some("PENDING_DEPENDENCY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Active,
                2 => Self::Running,
                3 => Self::Succeeded,
                4 => Self::Failed,
                5 => Self::Paused,
                6 => Self::PendingDependency,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ACTIVE" => Self::Active,
                "RUNNING" => Self::Running,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                "PAUSED" => Self::Paused,
                "PENDING_DEPENDENCY" => Self::PendingDependency,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Active => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::Succeeded => serializer.serialize_i32(3),
                Self::Failed => serializer.serialize_i32(4),
                Self::Paused => serializer.serialize_i32(5),
                Self::PendingDependency => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.bigquery.migration.v2.MigrationSubtask.State",
            ))
        }
    }
}

/// The migration task result.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MigrationTaskResult {
    /// Details specific to the task type.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub details: std::option::Option<crate::model::migration_task_result::Details>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MigrationTaskResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [details][crate::model::MigrationTaskResult::details].
    ///
    /// Note that all the setters affecting `details` are mutually
    /// exclusive.
    pub fn set_details<
        T: std::convert::Into<std::option::Option<crate::model::migration_task_result::Details>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = v.into();
        self
    }

    /// The value of [details][crate::model::MigrationTaskResult::details]
    /// if it holds a `TranslationTaskResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn translation_task_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TranslationTaskResult>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::migration_task_result::Details::TranslationTaskResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::MigrationTaskResult::details]
    /// to hold a `TranslationTaskResult`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_translation_task_result<
        T: std::convert::Into<std::boxed::Box<crate::model::TranslationTaskResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = std::option::Option::Some(
            crate::model::migration_task_result::Details::TranslationTaskResult(v.into()),
        );
        self
    }
}

impl wkt::message::Message for MigrationTaskResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.MigrationTaskResult"
    }
}

/// Defines additional types related to [MigrationTaskResult].
pub mod migration_task_result {
    #[allow(unused_imports)]
    use super::*;

    /// Details specific to the task type.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Details {
        /// Details specific to translation task types.
        TranslationTaskResult(std::boxed::Box<crate::model::TranslationTaskResult>),
    }
}

/// Translation specific result details from the migration task.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TranslationTaskResult {
    /// The list of the translated literals.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub translated_literals: std::vec::Vec<crate::model::Literal>,

    /// The records from the aggregate CSV report for a migration workflow.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub report_log_messages: std::vec::Vec<crate::model::GcsReportLogMessage>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TranslationTaskResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [translated_literals][crate::model::TranslationTaskResult::translated_literals].
    pub fn set_translated_literals<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Literal>,
    {
        use std::iter::Iterator;
        self.translated_literals = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [report_log_messages][crate::model::TranslationTaskResult::report_log_messages].
    pub fn set_report_log_messages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::GcsReportLogMessage>,
    {
        use std::iter::Iterator;
        self.report_log_messages = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TranslationTaskResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.TranslationTaskResult"
    }
}

/// Provides details for errors and the corresponding resources.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ResourceErrorDetail {
    /// Required. Information about the resource where the error is located.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub resource_info: std::option::Option<rpc::model::ResourceInfo>,

    /// Required. The error details for the resource.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub error_details: std::vec::Vec<crate::model::ErrorDetail>,

    /// Required. How many errors there are in total for the resource. Truncation
    /// can be indicated by having an `error_count` that is higher than the size of
    /// `error_details`.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub error_count: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResourceErrorDetail {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_info][crate::model::ResourceErrorDetail::resource_info].
    pub fn set_resource_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::ResourceInfo>,
    {
        self.resource_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resource_info][crate::model::ResourceErrorDetail::resource_info].
    pub fn set_or_clear_resource_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::ResourceInfo>,
    {
        self.resource_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [error_details][crate::model::ResourceErrorDetail::error_details].
    pub fn set_error_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ErrorDetail>,
    {
        use std::iter::Iterator;
        self.error_details = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [error_count][crate::model::ResourceErrorDetail::error_count].
    pub fn set_error_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.error_count = v.into();
        self
    }
}

impl wkt::message::Message for ResourceErrorDetail {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.ResourceErrorDetail"
    }
}

/// Provides details for errors, e.g. issues that where encountered when
/// processing a subtask.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ErrorDetail {
    /// Optional. The exact location within the resource (if applicable).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub location: std::option::Option<crate::model::ErrorLocation>,

    /// Required. Describes the cause of the error with structured detail.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error_info: std::option::Option<rpc::model::ErrorInfo>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ErrorDetail {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::ErrorDetail::location].
    pub fn set_location<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ErrorLocation>,
    {
        self.location = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [location][crate::model::ErrorDetail::location].
    pub fn set_or_clear_location<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ErrorLocation>,
    {
        self.location = v.map(|x| x.into());
        self
    }

    /// Sets the value of [error_info][crate::model::ErrorDetail::error_info].
    pub fn set_error_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::ErrorInfo>,
    {
        self.error_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error_info][crate::model::ErrorDetail::error_info].
    pub fn set_or_clear_error_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::ErrorInfo>,
    {
        self.error_info = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ErrorDetail {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.ErrorDetail"
    }
}

/// Holds information about where the error is located.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ErrorLocation {
    /// Optional. If applicable, denotes the line where the error occurred. A zero
    /// value means that there is no line information.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub line: i32,

    /// Optional. If applicable, denotes the column where the error occurred. A
    /// zero value means that there is no columns information.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub column: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ErrorLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [line][crate::model::ErrorLocation::line].
    pub fn set_line<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.line = v.into();
        self
    }

    /// Sets the value of [column][crate::model::ErrorLocation::column].
    pub fn set_column<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.column = v.into();
        self
    }
}

impl wkt::message::Message for ErrorLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.ErrorLocation"
    }
}

/// The metrics object for a SubTask.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TimeSeries {
    /// Required. The name of the metric.
    ///
    /// If the metric is not known by the service yet, it will be auto-created.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub metric: std::string::String,

    /// Required. The value type of the time series.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub value_type: api::model::metric_descriptor::ValueType,

    /// Optional. The metric kind of the time series.
    ///
    /// If present, it must be the same as the metric kind of the associated
    /// metric. If the associated metric's descriptor must be auto-created, then
    /// this field specifies the metric kind of the new descriptor and must be
    /// either `GAUGE` (the default) or `CUMULATIVE`.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub metric_kind: api::model::metric_descriptor::MetricKind,

    /// Required. The data points of this time series. When listing time series,
    /// points are returned in reverse time order.
    ///
    /// When creating a time series, this field must contain exactly one point and
    /// the point's type must be the same as the value type of the associated
    /// metric. If the associated metric's descriptor must be auto-created, then
    /// the value type of the descriptor is determined by the point's type, which
    /// must be `BOOL`, `INT64`, `DOUBLE`, or `DISTRIBUTION`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub points: std::vec::Vec<crate::model::Point>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TimeSeries {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric][crate::model::TimeSeries::metric].
    pub fn set_metric<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.metric = v.into();
        self
    }

    /// Sets the value of [value_type][crate::model::TimeSeries::value_type].
    pub fn set_value_type<T: std::convert::Into<api::model::metric_descriptor::ValueType>>(
        mut self,
        v: T,
    ) -> Self {
        self.value_type = v.into();
        self
    }

    /// Sets the value of [metric_kind][crate::model::TimeSeries::metric_kind].
    pub fn set_metric_kind<T: std::convert::Into<api::model::metric_descriptor::MetricKind>>(
        mut self,
        v: T,
    ) -> Self {
        self.metric_kind = v.into();
        self
    }

    /// Sets the value of [points][crate::model::TimeSeries::points].
    pub fn set_points<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Point>,
    {
        use std::iter::Iterator;
        self.points = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TimeSeries {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.TimeSeries"
    }
}

/// A single data point in a time series.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Point {
    /// The time interval to which the data point applies.  For `GAUGE` metrics,
    /// the start time does not need to be supplied, but if it is supplied, it must
    /// equal the end time.  For `DELTA` metrics, the start and end time should
    /// specify a non-zero interval, with subsequent points specifying contiguous
    /// and non-overlapping intervals.  For `CUMULATIVE` metrics, the start and end
    /// time should specify a non-zero interval, with subsequent points specifying
    /// the same start time and increasing end times, until an event resets the
    /// cumulative value to zero and sets a new start time for the following
    /// points.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub interval: std::option::Option<crate::model::TimeInterval>,

    /// The value of the data point.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub value: std::option::Option<crate::model::TypedValue>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Point {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [interval][crate::model::Point::interval].
    pub fn set_interval<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TimeInterval>,
    {
        self.interval = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [interval][crate::model::Point::interval].
    pub fn set_or_clear_interval<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TimeInterval>,
    {
        self.interval = v.map(|x| x.into());
        self
    }

    /// Sets the value of [value][crate::model::Point::value].
    pub fn set_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TypedValue>,
    {
        self.value = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [value][crate::model::Point::value].
    pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TypedValue>,
    {
        self.value = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Point {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.Point"
    }
}

/// A time interval extending just after a start time through an end time.
/// If the start time is the same as the end time, then the interval
/// represents a single point in time.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TimeInterval {
    /// Optional. The beginning of the time interval.  The default value
    /// for the start time is the end time. The start time must not be
    /// later than the end time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Required. The end of the time interval.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TimeInterval {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::TimeInterval::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::TimeInterval::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::TimeInterval::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::TimeInterval::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for TimeInterval {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.TimeInterval"
    }
}

/// A single strongly-typed value.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TypedValue {
    /// The typed value field.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub value: std::option::Option<crate::model::typed_value::Value>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TypedValue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [value][crate::model::TypedValue::value].
    ///
    /// Note that all the setters affecting `value` are mutually
    /// exclusive.
    pub fn set_value<
        T: std::convert::Into<std::option::Option<crate::model::typed_value::Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value = v.into();
        self
    }

    /// The value of [value][crate::model::TypedValue::value]
    /// if it holds a `BoolValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bool_value(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::typed_value::Value::BoolValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::TypedValue::value]
    /// to hold a `BoolValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_bool_value<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::typed_value::Value::BoolValue(v.into()));
        self
    }

    /// The value of [value][crate::model::TypedValue::value]
    /// if it holds a `Int64Value`, `None` if the field is not set or
    /// holds a different branch.
    pub fn int64_value(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::typed_value::Value::Int64Value(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::TypedValue::value]
    /// to hold a `Int64Value`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_int64_value<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::typed_value::Value::Int64Value(v.into()));
        self
    }

    /// The value of [value][crate::model::TypedValue::value]
    /// if it holds a `DoubleValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn double_value(&self) -> std::option::Option<&f64> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::typed_value::Value::DoubleValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::TypedValue::value]
    /// to hold a `DoubleValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_double_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::typed_value::Value::DoubleValue(v.into()));
        self
    }

    /// The value of [value][crate::model::TypedValue::value]
    /// if it holds a `StringValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn string_value(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::typed_value::Value::StringValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::TypedValue::value]
    /// to hold a `StringValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_string_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::typed_value::Value::StringValue(v.into()));
        self
    }

    /// The value of [value][crate::model::TypedValue::value]
    /// if it holds a `DistributionValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn distribution_value(
        &self,
    ) -> std::option::Option<&std::boxed::Box<api::model::Distribution>> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::typed_value::Value::DistributionValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::TypedValue::value]
    /// to hold a `DistributionValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_distribution_value<
        T: std::convert::Into<std::boxed::Box<api::model::Distribution>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value = std::option::Option::Some(
            crate::model::typed_value::Value::DistributionValue(v.into()),
        );
        self
    }
}

impl wkt::message::Message for TypedValue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.TypedValue"
    }
}

/// Defines additional types related to [TypedValue].
pub mod typed_value {
    #[allow(unused_imports)]
    use super::*;

    /// The typed value field.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Value {
        /// A Boolean value: `true` or `false`.
        BoolValue(bool),
        /// A 64-bit integer. Its range is approximately `+/-9.2x10^18`.
        Int64Value(#[serde_as(as = "wkt::internal::I64")] i64),
        /// A 64-bit double-precision floating-point number. Its magnitude
        /// is approximately `+/-10^(+/-300)` and it has 16 significant digits of
        /// precision.
        DoubleValue(#[serde_as(as = "wkt::internal::F64")] f64),
        /// A variable-length string value.
        StringValue(std::string::String),
        /// A distribution value.
        DistributionValue(std::boxed::Box<api::model::Distribution>),
    }
}

/// Request to create a migration workflow resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateMigrationWorkflowRequest {
    /// Required. The name of the project to which this migration workflow belongs.
    /// Example: `projects/foo/locations/bar`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The migration workflow to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub migration_workflow: std::option::Option<crate::model::MigrationWorkflow>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateMigrationWorkflowRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateMigrationWorkflowRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [migration_workflow][crate::model::CreateMigrationWorkflowRequest::migration_workflow].
    pub fn set_migration_workflow<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MigrationWorkflow>,
    {
        self.migration_workflow = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [migration_workflow][crate::model::CreateMigrationWorkflowRequest::migration_workflow].
    pub fn set_or_clear_migration_workflow<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MigrationWorkflow>,
    {
        self.migration_workflow = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateMigrationWorkflowRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.CreateMigrationWorkflowRequest"
    }
}

/// A request to get a previously created migration workflow.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetMigrationWorkflowRequest {
    /// Required. The unique identifier for the migration workflow.
    /// Example: `projects/123/locations/us/workflows/1234`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The list of fields to be retrieved.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetMigrationWorkflowRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetMigrationWorkflowRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::GetMigrationWorkflowRequest::read_mask].
    pub fn set_read_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.read_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [read_mask][crate::model::GetMigrationWorkflowRequest::read_mask].
    pub fn set_or_clear_read_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.read_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for GetMigrationWorkflowRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.GetMigrationWorkflowRequest"
    }
}

/// A request to list previously created migration workflows.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListMigrationWorkflowsRequest {
    /// Required. The project and location of the migration workflows to list.
    /// Example: `projects/123/locations/us`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The list of fields to be retrieved.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    /// The maximum number of migration workflows to return. The service may return
    /// fewer than this number.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// A page token, received from previous `ListMigrationWorkflows` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListMigrationWorkflows`
    /// must match the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMigrationWorkflowsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListMigrationWorkflowsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListMigrationWorkflowsRequest::read_mask].
    pub fn set_read_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.read_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [read_mask][crate::model::ListMigrationWorkflowsRequest::read_mask].
    pub fn set_or_clear_read_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.read_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [page_size][crate::model::ListMigrationWorkflowsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListMigrationWorkflowsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListMigrationWorkflowsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.ListMigrationWorkflowsRequest"
    }
}

/// Response object for a `ListMigrationWorkflows` call.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListMigrationWorkflowsResponse {
    /// The migration workflows for the specified project / location.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub migration_workflows: std::vec::Vec<crate::model::MigrationWorkflow>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMigrationWorkflowsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [migration_workflows][crate::model::ListMigrationWorkflowsResponse::migration_workflows].
    pub fn set_migration_workflows<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MigrationWorkflow>,
    {
        use std::iter::Iterator;
        self.migration_workflows = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListMigrationWorkflowsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListMigrationWorkflowsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.ListMigrationWorkflowsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListMigrationWorkflowsResponse {
    type PageItem = crate::model::MigrationWorkflow;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.migration_workflows
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// A request to delete a previously created migration workflow.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteMigrationWorkflowRequest {
    /// Required. The unique identifier for the migration workflow.
    /// Example: `projects/123/locations/us/workflows/1234`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteMigrationWorkflowRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteMigrationWorkflowRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteMigrationWorkflowRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.DeleteMigrationWorkflowRequest"
    }
}

/// A request to start a previously created migration workflow.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StartMigrationWorkflowRequest {
    /// Required. The unique identifier for the migration workflow.
    /// Example: `projects/123/locations/us/workflows/1234`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StartMigrationWorkflowRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StartMigrationWorkflowRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for StartMigrationWorkflowRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.StartMigrationWorkflowRequest"
    }
}

/// A request to get a previously created migration subtasks.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetMigrationSubtaskRequest {
    /// Required. The unique identifier for the migration subtask.
    /// Example: `projects/123/locations/us/workflows/1234/subtasks/543`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The list of fields to be retrieved.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetMigrationSubtaskRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetMigrationSubtaskRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::GetMigrationSubtaskRequest::read_mask].
    pub fn set_read_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.read_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [read_mask][crate::model::GetMigrationSubtaskRequest::read_mask].
    pub fn set_or_clear_read_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.read_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for GetMigrationSubtaskRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.GetMigrationSubtaskRequest"
    }
}

/// A request to list previously created migration subtasks.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListMigrationSubtasksRequest {
    /// Required. The migration task of the subtasks to list.
    /// Example: `projects/123/locations/us/workflows/1234`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The list of fields to be retrieved.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. The maximum number of migration tasks to return. The service may
    /// return fewer than this number.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// Optional. A page token, received from previous `ListMigrationSubtasks`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListMigrationSubtasks`
    /// must match the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. The filter to apply. This can be used to get the subtasks of a
    /// specific tasks in a workflow, e.g. `migration_task = "ab012"` where
    /// `"ab012"` is the task ID (not the name in the named map).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMigrationSubtasksRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListMigrationSubtasksRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListMigrationSubtasksRequest::read_mask].
    pub fn set_read_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.read_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [read_mask][crate::model::ListMigrationSubtasksRequest::read_mask].
    pub fn set_or_clear_read_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.read_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [page_size][crate::model::ListMigrationSubtasksRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListMigrationSubtasksRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListMigrationSubtasksRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListMigrationSubtasksRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.ListMigrationSubtasksRequest"
    }
}

/// Response object for a `ListMigrationSubtasks` call.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListMigrationSubtasksResponse {
    /// The migration subtasks for the specified task.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub migration_subtasks: std::vec::Vec<crate::model::MigrationSubtask>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMigrationSubtasksResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [migration_subtasks][crate::model::ListMigrationSubtasksResponse::migration_subtasks].
    pub fn set_migration_subtasks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MigrationSubtask>,
    {
        use std::iter::Iterator;
        self.migration_subtasks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListMigrationSubtasksResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListMigrationSubtasksResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.ListMigrationSubtasksResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListMigrationSubtasksResponse {
    type PageItem = crate::model::MigrationSubtask;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.migration_subtasks
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The translation config to capture necessary settings for a translation task
/// and subtask.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TranslationConfigDetails {
    /// The dialect of the input files.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source_dialect: std::option::Option<crate::model::Dialect>,

    /// The target dialect for the engine to translate the input to.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub target_dialect: std::option::Option<crate::model::Dialect>,

    /// The default source environment values for the translation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source_env: std::option::Option<crate::model::SourceEnv>,

    /// The indicator to show translation request initiator.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_source: std::string::String,

    /// The types of output to generate, e.g. sql, metadata etc. If not specified,
    /// a default set of targets will be generated. Some additional target types
    /// may be slower to generate. See the documentation for the set of available
    /// target types.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub target_types: std::vec::Vec<std::string::String>,

    /// The chosen path where the source for input files will be found.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source_location:
        std::option::Option<crate::model::translation_config_details::SourceLocation>,

    /// The chosen path where the destination for output files will be found.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub target_location:
        std::option::Option<crate::model::translation_config_details::TargetLocation>,

    /// The mapping of full SQL object names from their current state to the
    /// desired output.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub output_name_mapping:
        std::option::Option<crate::model::translation_config_details::OutputNameMapping>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TranslationConfigDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_dialect][crate::model::TranslationConfigDetails::source_dialect].
    pub fn set_source_dialect<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Dialect>,
    {
        self.source_dialect = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_dialect][crate::model::TranslationConfigDetails::source_dialect].
    pub fn set_or_clear_source_dialect<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Dialect>,
    {
        self.source_dialect = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target_dialect][crate::model::TranslationConfigDetails::target_dialect].
    pub fn set_target_dialect<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Dialect>,
    {
        self.target_dialect = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [target_dialect][crate::model::TranslationConfigDetails::target_dialect].
    pub fn set_or_clear_target_dialect<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Dialect>,
    {
        self.target_dialect = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_env][crate::model::TranslationConfigDetails::source_env].
    pub fn set_source_env<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SourceEnv>,
    {
        self.source_env = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_env][crate::model::TranslationConfigDetails::source_env].
    pub fn set_or_clear_source_env<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SourceEnv>,
    {
        self.source_env = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_source][crate::model::TranslationConfigDetails::request_source].
    pub fn set_request_source<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_source = v.into();
        self
    }

    /// Sets the value of [target_types][crate::model::TranslationConfigDetails::target_types].
    pub fn set_target_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.target_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [source_location][crate::model::TranslationConfigDetails::source_location].
    ///
    /// Note that all the setters affecting `source_location` are mutually
    /// exclusive.
    pub fn set_source_location<
        T: std::convert::Into<
                std::option::Option<crate::model::translation_config_details::SourceLocation>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_location = v.into();
        self
    }

    /// The value of [source_location][crate::model::TranslationConfigDetails::source_location]
    /// if it holds a `GcsSourcePath`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_source_path(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source_location.as_ref().and_then(|v| match v {
            crate::model::translation_config_details::SourceLocation::GcsSourcePath(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_location][crate::model::TranslationConfigDetails::source_location]
    /// to hold a `GcsSourcePath`.
    ///
    /// Note that all the setters affecting `source_location` are
    /// mutually exclusive.
    pub fn set_gcs_source_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_location = std::option::Option::Some(
            crate::model::translation_config_details::SourceLocation::GcsSourcePath(v.into()),
        );
        self
    }

    /// Sets the value of [target_location][crate::model::TranslationConfigDetails::target_location].
    ///
    /// Note that all the setters affecting `target_location` are mutually
    /// exclusive.
    pub fn set_target_location<
        T: std::convert::Into<
                std::option::Option<crate::model::translation_config_details::TargetLocation>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target_location = v.into();
        self
    }

    /// The value of [target_location][crate::model::TranslationConfigDetails::target_location]
    /// if it holds a `GcsTargetPath`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_target_path(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.target_location.as_ref().and_then(|v| match v {
            crate::model::translation_config_details::TargetLocation::GcsTargetPath(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target_location][crate::model::TranslationConfigDetails::target_location]
    /// to hold a `GcsTargetPath`.
    ///
    /// Note that all the setters affecting `target_location` are
    /// mutually exclusive.
    pub fn set_gcs_target_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_location = std::option::Option::Some(
            crate::model::translation_config_details::TargetLocation::GcsTargetPath(v.into()),
        );
        self
    }

    /// Sets the value of [output_name_mapping][crate::model::TranslationConfigDetails::output_name_mapping].
    ///
    /// Note that all the setters affecting `output_name_mapping` are mutually
    /// exclusive.
    pub fn set_output_name_mapping<
        T: std::convert::Into<
                std::option::Option<crate::model::translation_config_details::OutputNameMapping>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_name_mapping = v.into();
        self
    }

    /// The value of [output_name_mapping][crate::model::TranslationConfigDetails::output_name_mapping]
    /// if it holds a `NameMappingList`, `None` if the field is not set or
    /// holds a different branch.
    pub fn name_mapping_list(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ObjectNameMappingList>> {
        #[allow(unreachable_patterns)]
        self.output_name_mapping.as_ref().and_then(|v| match v {
            crate::model::translation_config_details::OutputNameMapping::NameMappingList(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [output_name_mapping][crate::model::TranslationConfigDetails::output_name_mapping]
    /// to hold a `NameMappingList`.
    ///
    /// Note that all the setters affecting `output_name_mapping` are
    /// mutually exclusive.
    pub fn set_name_mapping_list<
        T: std::convert::Into<std::boxed::Box<crate::model::ObjectNameMappingList>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_name_mapping = std::option::Option::Some(
            crate::model::translation_config_details::OutputNameMapping::NameMappingList(v.into()),
        );
        self
    }
}

impl wkt::message::Message for TranslationConfigDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.TranslationConfigDetails"
    }
}

/// Defines additional types related to [TranslationConfigDetails].
pub mod translation_config_details {
    #[allow(unused_imports)]
    use super::*;

    /// The chosen path where the source for input files will be found.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum SourceLocation {
        /// The Cloud Storage path for a directory of files to translate in a task.
        GcsSourcePath(std::string::String),
    }

    /// The chosen path where the destination for output files will be found.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum TargetLocation {
        /// The Cloud Storage path to write back the corresponding input files to.
        GcsTargetPath(std::string::String),
    }

    /// The mapping of full SQL object names from their current state to the
    /// desired output.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum OutputNameMapping {
        /// The mapping of objects to their desired output names in list form.
        NameMappingList(std::boxed::Box<crate::model::ObjectNameMappingList>),
    }
}

/// The possible dialect options for translation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Dialect {
    /// The possible dialect options that this message represents.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub dialect_value: std::option::Option<crate::model::dialect::DialectValue>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Dialect {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dialect_value][crate::model::Dialect::dialect_value].
    ///
    /// Note that all the setters affecting `dialect_value` are mutually
    /// exclusive.
    pub fn set_dialect_value<
        T: std::convert::Into<std::option::Option<crate::model::dialect::DialectValue>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dialect_value = v.into();
        self
    }

    /// The value of [dialect_value][crate::model::Dialect::dialect_value]
    /// if it holds a `BigqueryDialect`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bigquery_dialect(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryDialect>> {
        #[allow(unreachable_patterns)]
        self.dialect_value.as_ref().and_then(|v| match v {
            crate::model::dialect::DialectValue::BigqueryDialect(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [dialect_value][crate::model::Dialect::dialect_value]
    /// to hold a `BigqueryDialect`.
    ///
    /// Note that all the setters affecting `dialect_value` are
    /// mutually exclusive.
    pub fn set_bigquery_dialect<
        T: std::convert::Into<std::boxed::Box<crate::model::BigQueryDialect>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dialect_value = std::option::Option::Some(
            crate::model::dialect::DialectValue::BigqueryDialect(v.into()),
        );
        self
    }

    /// The value of [dialect_value][crate::model::Dialect::dialect_value]
    /// if it holds a `HiveqlDialect`, `None` if the field is not set or
    /// holds a different branch.
    pub fn hiveql_dialect(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::HiveQLDialect>> {
        #[allow(unreachable_patterns)]
        self.dialect_value.as_ref().and_then(|v| match v {
            crate::model::dialect::DialectValue::HiveqlDialect(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [dialect_value][crate::model::Dialect::dialect_value]
    /// to hold a `HiveqlDialect`.
    ///
    /// Note that all the setters affecting `dialect_value` are
    /// mutually exclusive.
    pub fn set_hiveql_dialect<
        T: std::convert::Into<std::boxed::Box<crate::model::HiveQLDialect>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dialect_value =
            std::option::Option::Some(crate::model::dialect::DialectValue::HiveqlDialect(v.into()));
        self
    }

    /// The value of [dialect_value][crate::model::Dialect::dialect_value]
    /// if it holds a `RedshiftDialect`, `None` if the field is not set or
    /// holds a different branch.
    pub fn redshift_dialect(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::RedshiftDialect>> {
        #[allow(unreachable_patterns)]
        self.dialect_value.as_ref().and_then(|v| match v {
            crate::model::dialect::DialectValue::RedshiftDialect(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [dialect_value][crate::model::Dialect::dialect_value]
    /// to hold a `RedshiftDialect`.
    ///
    /// Note that all the setters affecting `dialect_value` are
    /// mutually exclusive.
    pub fn set_redshift_dialect<
        T: std::convert::Into<std::boxed::Box<crate::model::RedshiftDialect>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dialect_value = std::option::Option::Some(
            crate::model::dialect::DialectValue::RedshiftDialect(v.into()),
        );
        self
    }

    /// The value of [dialect_value][crate::model::Dialect::dialect_value]
    /// if it holds a `TeradataDialect`, `None` if the field is not set or
    /// holds a different branch.
    pub fn teradata_dialect(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TeradataDialect>> {
        #[allow(unreachable_patterns)]
        self.dialect_value.as_ref().and_then(|v| match v {
            crate::model::dialect::DialectValue::TeradataDialect(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [dialect_value][crate::model::Dialect::dialect_value]
    /// to hold a `TeradataDialect`.
    ///
    /// Note that all the setters affecting `dialect_value` are
    /// mutually exclusive.
    pub fn set_teradata_dialect<
        T: std::convert::Into<std::boxed::Box<crate::model::TeradataDialect>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dialect_value = std::option::Option::Some(
            crate::model::dialect::DialectValue::TeradataDialect(v.into()),
        );
        self
    }

    /// The value of [dialect_value][crate::model::Dialect::dialect_value]
    /// if it holds a `OracleDialect`, `None` if the field is not set or
    /// holds a different branch.
    pub fn oracle_dialect(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::OracleDialect>> {
        #[allow(unreachable_patterns)]
        self.dialect_value.as_ref().and_then(|v| match v {
            crate::model::dialect::DialectValue::OracleDialect(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [dialect_value][crate::model::Dialect::dialect_value]
    /// to hold a `OracleDialect`.
    ///
    /// Note that all the setters affecting `dialect_value` are
    /// mutually exclusive.
    pub fn set_oracle_dialect<
        T: std::convert::Into<std::boxed::Box<crate::model::OracleDialect>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dialect_value =
            std::option::Option::Some(crate::model::dialect::DialectValue::OracleDialect(v.into()));
        self
    }

    /// The value of [dialect_value][crate::model::Dialect::dialect_value]
    /// if it holds a `SparksqlDialect`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sparksql_dialect(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SparkSQLDialect>> {
        #[allow(unreachable_patterns)]
        self.dialect_value.as_ref().and_then(|v| match v {
            crate::model::dialect::DialectValue::SparksqlDialect(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [dialect_value][crate::model::Dialect::dialect_value]
    /// to hold a `SparksqlDialect`.
    ///
    /// Note that all the setters affecting `dialect_value` are
    /// mutually exclusive.
    pub fn set_sparksql_dialect<
        T: std::convert::Into<std::boxed::Box<crate::model::SparkSQLDialect>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dialect_value = std::option::Option::Some(
            crate::model::dialect::DialectValue::SparksqlDialect(v.into()),
        );
        self
    }

    /// The value of [dialect_value][crate::model::Dialect::dialect_value]
    /// if it holds a `SnowflakeDialect`, `None` if the field is not set or
    /// holds a different branch.
    pub fn snowflake_dialect(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SnowflakeDialect>> {
        #[allow(unreachable_patterns)]
        self.dialect_value.as_ref().and_then(|v| match v {
            crate::model::dialect::DialectValue::SnowflakeDialect(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [dialect_value][crate::model::Dialect::dialect_value]
    /// to hold a `SnowflakeDialect`.
    ///
    /// Note that all the setters affecting `dialect_value` are
    /// mutually exclusive.
    pub fn set_snowflake_dialect<
        T: std::convert::Into<std::boxed::Box<crate::model::SnowflakeDialect>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dialect_value = std::option::Option::Some(
            crate::model::dialect::DialectValue::SnowflakeDialect(v.into()),
        );
        self
    }

    /// The value of [dialect_value][crate::model::Dialect::dialect_value]
    /// if it holds a `NetezzaDialect`, `None` if the field is not set or
    /// holds a different branch.
    pub fn netezza_dialect(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::NetezzaDialect>> {
        #[allow(unreachable_patterns)]
        self.dialect_value.as_ref().and_then(|v| match v {
            crate::model::dialect::DialectValue::NetezzaDialect(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [dialect_value][crate::model::Dialect::dialect_value]
    /// to hold a `NetezzaDialect`.
    ///
    /// Note that all the setters affecting `dialect_value` are
    /// mutually exclusive.
    pub fn set_netezza_dialect<
        T: std::convert::Into<std::boxed::Box<crate::model::NetezzaDialect>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dialect_value = std::option::Option::Some(
            crate::model::dialect::DialectValue::NetezzaDialect(v.into()),
        );
        self
    }

    /// The value of [dialect_value][crate::model::Dialect::dialect_value]
    /// if it holds a `AzureSynapseDialect`, `None` if the field is not set or
    /// holds a different branch.
    pub fn azure_synapse_dialect(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AzureSynapseDialect>> {
        #[allow(unreachable_patterns)]
        self.dialect_value.as_ref().and_then(|v| match v {
            crate::model::dialect::DialectValue::AzureSynapseDialect(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [dialect_value][crate::model::Dialect::dialect_value]
    /// to hold a `AzureSynapseDialect`.
    ///
    /// Note that all the setters affecting `dialect_value` are
    /// mutually exclusive.
    pub fn set_azure_synapse_dialect<
        T: std::convert::Into<std::boxed::Box<crate::model::AzureSynapseDialect>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dialect_value = std::option::Option::Some(
            crate::model::dialect::DialectValue::AzureSynapseDialect(v.into()),
        );
        self
    }

    /// The value of [dialect_value][crate::model::Dialect::dialect_value]
    /// if it holds a `VerticaDialect`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vertica_dialect(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VerticaDialect>> {
        #[allow(unreachable_patterns)]
        self.dialect_value.as_ref().and_then(|v| match v {
            crate::model::dialect::DialectValue::VerticaDialect(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [dialect_value][crate::model::Dialect::dialect_value]
    /// to hold a `VerticaDialect`.
    ///
    /// Note that all the setters affecting `dialect_value` are
    /// mutually exclusive.
    pub fn set_vertica_dialect<
        T: std::convert::Into<std::boxed::Box<crate::model::VerticaDialect>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dialect_value = std::option::Option::Some(
            crate::model::dialect::DialectValue::VerticaDialect(v.into()),
        );
        self
    }

    /// The value of [dialect_value][crate::model::Dialect::dialect_value]
    /// if it holds a `SqlServerDialect`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sql_server_dialect(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SQLServerDialect>> {
        #[allow(unreachable_patterns)]
        self.dialect_value.as_ref().and_then(|v| match v {
            crate::model::dialect::DialectValue::SqlServerDialect(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [dialect_value][crate::model::Dialect::dialect_value]
    /// to hold a `SqlServerDialect`.
    ///
    /// Note that all the setters affecting `dialect_value` are
    /// mutually exclusive.
    pub fn set_sql_server_dialect<
        T: std::convert::Into<std::boxed::Box<crate::model::SQLServerDialect>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dialect_value = std::option::Option::Some(
            crate::model::dialect::DialectValue::SqlServerDialect(v.into()),
        );
        self
    }

    /// The value of [dialect_value][crate::model::Dialect::dialect_value]
    /// if it holds a `PostgresqlDialect`, `None` if the field is not set or
    /// holds a different branch.
    pub fn postgresql_dialect(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PostgresqlDialect>> {
        #[allow(unreachable_patterns)]
        self.dialect_value.as_ref().and_then(|v| match v {
            crate::model::dialect::DialectValue::PostgresqlDialect(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [dialect_value][crate::model::Dialect::dialect_value]
    /// to hold a `PostgresqlDialect`.
    ///
    /// Note that all the setters affecting `dialect_value` are
    /// mutually exclusive.
    pub fn set_postgresql_dialect<
        T: std::convert::Into<std::boxed::Box<crate::model::PostgresqlDialect>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dialect_value = std::option::Option::Some(
            crate::model::dialect::DialectValue::PostgresqlDialect(v.into()),
        );
        self
    }

    /// The value of [dialect_value][crate::model::Dialect::dialect_value]
    /// if it holds a `PrestoDialect`, `None` if the field is not set or
    /// holds a different branch.
    pub fn presto_dialect(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PrestoDialect>> {
        #[allow(unreachable_patterns)]
        self.dialect_value.as_ref().and_then(|v| match v {
            crate::model::dialect::DialectValue::PrestoDialect(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [dialect_value][crate::model::Dialect::dialect_value]
    /// to hold a `PrestoDialect`.
    ///
    /// Note that all the setters affecting `dialect_value` are
    /// mutually exclusive.
    pub fn set_presto_dialect<
        T: std::convert::Into<std::boxed::Box<crate::model::PrestoDialect>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dialect_value =
            std::option::Option::Some(crate::model::dialect::DialectValue::PrestoDialect(v.into()));
        self
    }

    /// The value of [dialect_value][crate::model::Dialect::dialect_value]
    /// if it holds a `MysqlDialect`, `None` if the field is not set or
    /// holds a different branch.
    pub fn mysql_dialect(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::MySQLDialect>> {
        #[allow(unreachable_patterns)]
        self.dialect_value.as_ref().and_then(|v| match v {
            crate::model::dialect::DialectValue::MysqlDialect(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [dialect_value][crate::model::Dialect::dialect_value]
    /// to hold a `MysqlDialect`.
    ///
    /// Note that all the setters affecting `dialect_value` are
    /// mutually exclusive.
    pub fn set_mysql_dialect<T: std::convert::Into<std::boxed::Box<crate::model::MySQLDialect>>>(
        mut self,
        v: T,
    ) -> Self {
        self.dialect_value =
            std::option::Option::Some(crate::model::dialect::DialectValue::MysqlDialect(v.into()));
        self
    }

    /// The value of [dialect_value][crate::model::Dialect::dialect_value]
    /// if it holds a `Db2Dialect`, `None` if the field is not set or
    /// holds a different branch.
    pub fn db2_dialect(&self) -> std::option::Option<&std::boxed::Box<crate::model::DB2Dialect>> {
        #[allow(unreachable_patterns)]
        self.dialect_value.as_ref().and_then(|v| match v {
            crate::model::dialect::DialectValue::Db2Dialect(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [dialect_value][crate::model::Dialect::dialect_value]
    /// to hold a `Db2Dialect`.
    ///
    /// Note that all the setters affecting `dialect_value` are
    /// mutually exclusive.
    pub fn set_db2_dialect<T: std::convert::Into<std::boxed::Box<crate::model::DB2Dialect>>>(
        mut self,
        v: T,
    ) -> Self {
        self.dialect_value =
            std::option::Option::Some(crate::model::dialect::DialectValue::Db2Dialect(v.into()));
        self
    }

    /// The value of [dialect_value][crate::model::Dialect::dialect_value]
    /// if it holds a `SqliteDialect`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sqlite_dialect(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SQLiteDialect>> {
        #[allow(unreachable_patterns)]
        self.dialect_value.as_ref().and_then(|v| match v {
            crate::model::dialect::DialectValue::SqliteDialect(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [dialect_value][crate::model::Dialect::dialect_value]
    /// to hold a `SqliteDialect`.
    ///
    /// Note that all the setters affecting `dialect_value` are
    /// mutually exclusive.
    pub fn set_sqlite_dialect<
        T: std::convert::Into<std::boxed::Box<crate::model::SQLiteDialect>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dialect_value =
            std::option::Option::Some(crate::model::dialect::DialectValue::SqliteDialect(v.into()));
        self
    }

    /// The value of [dialect_value][crate::model::Dialect::dialect_value]
    /// if it holds a `GreenplumDialect`, `None` if the field is not set or
    /// holds a different branch.
    pub fn greenplum_dialect(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GreenplumDialect>> {
        #[allow(unreachable_patterns)]
        self.dialect_value.as_ref().and_then(|v| match v {
            crate::model::dialect::DialectValue::GreenplumDialect(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [dialect_value][crate::model::Dialect::dialect_value]
    /// to hold a `GreenplumDialect`.
    ///
    /// Note that all the setters affecting `dialect_value` are
    /// mutually exclusive.
    pub fn set_greenplum_dialect<
        T: std::convert::Into<std::boxed::Box<crate::model::GreenplumDialect>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dialect_value = std::option::Option::Some(
            crate::model::dialect::DialectValue::GreenplumDialect(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Dialect {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.Dialect"
    }
}

/// Defines additional types related to [Dialect].
pub mod dialect {
    #[allow(unused_imports)]
    use super::*;

    /// The possible dialect options that this message represents.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum DialectValue {
        /// The BigQuery dialect
        BigqueryDialect(std::boxed::Box<crate::model::BigQueryDialect>),
        /// The HiveQL dialect
        HiveqlDialect(std::boxed::Box<crate::model::HiveQLDialect>),
        /// The Redshift dialect
        RedshiftDialect(std::boxed::Box<crate::model::RedshiftDialect>),
        /// The Teradata dialect
        TeradataDialect(std::boxed::Box<crate::model::TeradataDialect>),
        /// The Oracle dialect
        OracleDialect(std::boxed::Box<crate::model::OracleDialect>),
        /// The SparkSQL dialect
        SparksqlDialect(std::boxed::Box<crate::model::SparkSQLDialect>),
        /// The Snowflake dialect
        SnowflakeDialect(std::boxed::Box<crate::model::SnowflakeDialect>),
        /// The Netezza dialect
        NetezzaDialect(std::boxed::Box<crate::model::NetezzaDialect>),
        /// The Azure Synapse dialect
        AzureSynapseDialect(std::boxed::Box<crate::model::AzureSynapseDialect>),
        /// The Vertica dialect
        VerticaDialect(std::boxed::Box<crate::model::VerticaDialect>),
        /// The SQL Server dialect
        SqlServerDialect(std::boxed::Box<crate::model::SQLServerDialect>),
        /// The Postgresql dialect
        PostgresqlDialect(std::boxed::Box<crate::model::PostgresqlDialect>),
        /// The Presto dialect
        PrestoDialect(std::boxed::Box<crate::model::PrestoDialect>),
        /// The MySQL dialect
        MysqlDialect(std::boxed::Box<crate::model::MySQLDialect>),
        /// DB2 dialect
        Db2Dialect(std::boxed::Box<crate::model::DB2Dialect>),
        /// SQLite dialect
        SqliteDialect(std::boxed::Box<crate::model::SQLiteDialect>),
        /// Greenplum dialect
        GreenplumDialect(std::boxed::Box<crate::model::GreenplumDialect>),
    }
}

/// The dialect definition for BigQuery.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BigQueryDialect {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigQueryDialect {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for BigQueryDialect {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.BigQueryDialect"
    }
}

/// The dialect definition for HiveQL.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HiveQLDialect {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HiveQLDialect {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for HiveQLDialect {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.HiveQLDialect"
    }
}

/// The dialect definition for Redshift.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RedshiftDialect {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RedshiftDialect {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for RedshiftDialect {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.RedshiftDialect"
    }
}

/// The dialect definition for Teradata.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TeradataDialect {
    /// Which Teradata sub-dialect mode the user specifies.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub mode: crate::model::teradata_dialect::Mode,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TeradataDialect {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mode][crate::model::TeradataDialect::mode].
    pub fn set_mode<T: std::convert::Into<crate::model::teradata_dialect::Mode>>(
        mut self,
        v: T,
    ) -> Self {
        self.mode = v.into();
        self
    }
}

impl wkt::message::Message for TeradataDialect {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.TeradataDialect"
    }
}

/// Defines additional types related to [TeradataDialect].
pub mod teradata_dialect {
    #[allow(unused_imports)]
    use super::*;

    /// The sub-dialect options for Teradata.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Mode {
        /// Unspecified mode.
        Unspecified,
        /// Teradata SQL mode.
        Sql,
        /// BTEQ mode (which includes SQL).
        Bteq,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Mode::value] or
        /// [Mode::name].
        UnknownValue(mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Mode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Sql => std::option::Option::Some(1),
                Self::Bteq => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MODE_UNSPECIFIED"),
                Self::Sql => std::option::Option::Some("SQL"),
                Self::Bteq => std::option::Option::Some("BTEQ"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Mode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Mode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Mode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Sql,
                2 => Self::Bteq,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Mode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MODE_UNSPECIFIED" => Self::Unspecified,
                "SQL" => Self::Sql,
                "BTEQ" => Self::Bteq,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Mode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Sql => serializer.serialize_i32(1),
                Self::Bteq => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Mode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Mode>::new(
                ".google.cloud.bigquery.migration.v2.TeradataDialect.Mode",
            ))
        }
    }
}

/// The dialect definition for Oracle.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OracleDialect {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OracleDialect {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for OracleDialect {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.OracleDialect"
    }
}

/// The dialect definition for SparkSQL.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SparkSQLDialect {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SparkSQLDialect {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for SparkSQLDialect {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.SparkSQLDialect"
    }
}

/// The dialect definition for Snowflake.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SnowflakeDialect {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SnowflakeDialect {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for SnowflakeDialect {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.SnowflakeDialect"
    }
}

/// The dialect definition for Netezza.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NetezzaDialect {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NetezzaDialect {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for NetezzaDialect {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.NetezzaDialect"
    }
}

/// The dialect definition for Azure Synapse.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AzureSynapseDialect {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AzureSynapseDialect {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for AzureSynapseDialect {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.AzureSynapseDialect"
    }
}

/// The dialect definition for Vertica.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VerticaDialect {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VerticaDialect {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for VerticaDialect {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.VerticaDialect"
    }
}

/// The dialect definition for SQL Server.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SQLServerDialect {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SQLServerDialect {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for SQLServerDialect {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.SQLServerDialect"
    }
}

/// The dialect definition for Postgresql.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PostgresqlDialect {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PostgresqlDialect {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for PostgresqlDialect {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.PostgresqlDialect"
    }
}

/// The dialect definition for Presto.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PrestoDialect {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PrestoDialect {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for PrestoDialect {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.PrestoDialect"
    }
}

/// The dialect definition for MySQL.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MySQLDialect {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MySQLDialect {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for MySQLDialect {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.MySQLDialect"
    }
}

/// The dialect definition for DB2.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DB2Dialect {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DB2Dialect {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for DB2Dialect {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.DB2Dialect"
    }
}

/// The dialect definition for SQLite.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SQLiteDialect {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SQLiteDialect {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for SQLiteDialect {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.SQLiteDialect"
    }
}

/// The dialect definition for Greenplum.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GreenplumDialect {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GreenplumDialect {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for GreenplumDialect {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.GreenplumDialect"
    }
}

/// Represents a map of name mappings using a list of key:value proto messages of
/// existing name to desired output name.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ObjectNameMappingList {
    /// The elements of the object name map.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub name_map: std::vec::Vec<crate::model::ObjectNameMapping>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ObjectNameMappingList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name_map][crate::model::ObjectNameMappingList::name_map].
    pub fn set_name_map<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ObjectNameMapping>,
    {
        use std::iter::Iterator;
        self.name_map = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ObjectNameMappingList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.ObjectNameMappingList"
    }
}

/// Represents a key-value pair of NameMappingKey to NameMappingValue to
/// represent the mapping of SQL names from the input value to desired output.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ObjectNameMapping {
    /// The name of the object in source that is being mapped.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::NameMappingKey>,

    /// The desired target name of the object that is being mapped.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub target: std::option::Option<crate::model::NameMappingValue>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ObjectNameMapping {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source][crate::model::ObjectNameMapping::source].
    pub fn set_source<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NameMappingKey>,
    {
        self.source = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source][crate::model::ObjectNameMapping::source].
    pub fn set_or_clear_source<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NameMappingKey>,
    {
        self.source = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::ObjectNameMapping::target].
    pub fn set_target<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NameMappingValue>,
    {
        self.target = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [target][crate::model::ObjectNameMapping::target].
    pub fn set_or_clear_target<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NameMappingValue>,
    {
        self.target = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ObjectNameMapping {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.ObjectNameMapping"
    }
}

/// The potential components of a full name mapping that will be mapped
/// during translation in the source data warehouse.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NameMappingKey {
    /// The type of object that is being mapped.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub r#type: crate::model::name_mapping_key::Type,

    /// The database name (BigQuery project ID equivalent in the source data
    /// warehouse).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub database: std::string::String,

    /// The schema name (BigQuery dataset equivalent in the source data warehouse).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub schema: std::string::String,

    /// The relation name (BigQuery table or view equivalent in the source data
    /// warehouse).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub relation: std::string::String,

    /// The attribute name (BigQuery column equivalent in the source data
    /// warehouse).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub attribute: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NameMappingKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::NameMappingKey::type].
    pub fn set_type<T: std::convert::Into<crate::model::name_mapping_key::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [database][crate::model::NameMappingKey::database].
    pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [schema][crate::model::NameMappingKey::schema].
    pub fn set_schema<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schema = v.into();
        self
    }

    /// Sets the value of [relation][crate::model::NameMappingKey::relation].
    pub fn set_relation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.relation = v.into();
        self
    }

    /// Sets the value of [attribute][crate::model::NameMappingKey::attribute].
    pub fn set_attribute<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.attribute = v.into();
        self
    }
}

impl wkt::message::Message for NameMappingKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.NameMappingKey"
    }
}

/// Defines additional types related to [NameMappingKey].
pub mod name_mapping_key {
    #[allow(unused_imports)]
    use super::*;

    /// The type of the object that is being mapped.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Unspecified name mapping type.
        Unspecified,
        /// The object being mapped is a database.
        Database,
        /// The object being mapped is a schema.
        Schema,
        /// The object being mapped is a relation.
        Relation,
        /// The object being mapped is an attribute.
        Attribute,
        /// The object being mapped is a relation alias.
        RelationAlias,
        /// The object being mapped is a an attribute alias.
        AttributeAlias,
        /// The object being mapped is a function.
        Function,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Database => std::option::Option::Some(1),
                Self::Schema => std::option::Option::Some(2),
                Self::Relation => std::option::Option::Some(3),
                Self::Attribute => std::option::Option::Some(4),
                Self::RelationAlias => std::option::Option::Some(5),
                Self::AttributeAlias => std::option::Option::Some(6),
                Self::Function => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::Database => std::option::Option::Some("DATABASE"),
                Self::Schema => std::option::Option::Some("SCHEMA"),
                Self::Relation => std::option::Option::Some("RELATION"),
                Self::Attribute => std::option::Option::Some("ATTRIBUTE"),
                Self::RelationAlias => std::option::Option::Some("RELATION_ALIAS"),
                Self::AttributeAlias => std::option::Option::Some("ATTRIBUTE_ALIAS"),
                Self::Function => std::option::Option::Some("FUNCTION"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Database,
                2 => Self::Schema,
                3 => Self::Relation,
                4 => Self::Attribute,
                5 => Self::RelationAlias,
                6 => Self::AttributeAlias,
                7 => Self::Function,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "DATABASE" => Self::Database,
                "SCHEMA" => Self::Schema,
                "RELATION" => Self::Relation,
                "ATTRIBUTE" => Self::Attribute,
                "RELATION_ALIAS" => Self::RelationAlias,
                "ATTRIBUTE_ALIAS" => Self::AttributeAlias,
                "FUNCTION" => Self::Function,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Database => serializer.serialize_i32(1),
                Self::Schema => serializer.serialize_i32(2),
                Self::Relation => serializer.serialize_i32(3),
                Self::Attribute => serializer.serialize_i32(4),
                Self::RelationAlias => serializer.serialize_i32(5),
                Self::AttributeAlias => serializer.serialize_i32(6),
                Self::Function => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.bigquery.migration.v2.NameMappingKey.Type",
            ))
        }
    }
}

/// The potential components of a full name mapping that will be mapped
/// during translation in the target data warehouse.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NameMappingValue {
    /// The database name (BigQuery project ID equivalent in the target data
    /// warehouse).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub database: std::string::String,

    /// The schema name (BigQuery dataset equivalent in the target data warehouse).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub schema: std::string::String,

    /// The relation name (BigQuery table or view equivalent in the target data
    /// warehouse).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub relation: std::string::String,

    /// The attribute name (BigQuery column equivalent in the target data
    /// warehouse).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub attribute: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NameMappingValue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [database][crate::model::NameMappingValue::database].
    pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [schema][crate::model::NameMappingValue::schema].
    pub fn set_schema<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schema = v.into();
        self
    }

    /// Sets the value of [relation][crate::model::NameMappingValue::relation].
    pub fn set_relation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.relation = v.into();
        self
    }

    /// Sets the value of [attribute][crate::model::NameMappingValue::attribute].
    pub fn set_attribute<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.attribute = v.into();
        self
    }
}

impl wkt::message::Message for NameMappingValue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.NameMappingValue"
    }
}

/// Represents the default source environment values for the translation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SourceEnv {
    /// The default database name to fully qualify SQL objects when their database
    /// name is missing.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub default_database: std::string::String,

    /// The schema search path. When SQL objects are missing schema name,
    /// translation engine will search through this list to find the value.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub schema_search_path: std::vec::Vec<std::string::String>,

    /// Optional. Expects a valid BigQuery dataset ID that exists, e.g.,
    /// project-123.metadata_store_123.  If specified, translation will search and
    /// read the required schema information from a metadata store in this dataset.
    /// If metadata store doesn't exist, translation will parse the metadata file
    /// and upload the schema info to a temp table in the dataset to speed up
    /// future translation jobs.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub metadata_store_dataset: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SourceEnv {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [default_database][crate::model::SourceEnv::default_database].
    pub fn set_default_database<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.default_database = v.into();
        self
    }

    /// Sets the value of [schema_search_path][crate::model::SourceEnv::schema_search_path].
    pub fn set_schema_search_path<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.schema_search_path = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [metadata_store_dataset][crate::model::SourceEnv::metadata_store_dataset].
    pub fn set_metadata_store_dataset<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.metadata_store_dataset = v.into();
        self
    }
}

impl wkt::message::Message for SourceEnv {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.SourceEnv"
    }
}

/// The translation details to capture the necessary settings for a translation
/// job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TranslationDetails {
    /// The mapping from source to target SQL.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub source_target_mapping: std::vec::Vec<crate::model::SourceTargetMapping>,

    /// The base URI for all writes to persistent storage.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target_base_uri: std::string::String,

    /// The default source environment values for the translation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source_environment: std::option::Option<crate::model::SourceEnvironment>,

    /// The list of literal targets that will be directly returned to the response.
    /// Each entry consists of the constructed path, EXCLUDING the base path. Not
    /// providing a target_base_uri will prevent writing to persistent storage.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub target_return_literals: std::vec::Vec<std::string::String>,

    /// The types of output to generate, e.g. sql, metadata,
    /// lineage_from_sql_scripts, etc. If not specified, a default set of
    /// targets will be generated. Some additional target types may be slower to
    /// generate. See the documentation for the set of available target types.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub target_types: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TranslationDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_target_mapping][crate::model::TranslationDetails::source_target_mapping].
    pub fn set_source_target_mapping<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SourceTargetMapping>,
    {
        use std::iter::Iterator;
        self.source_target_mapping = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [target_base_uri][crate::model::TranslationDetails::target_base_uri].
    pub fn set_target_base_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_base_uri = v.into();
        self
    }

    /// Sets the value of [source_environment][crate::model::TranslationDetails::source_environment].
    pub fn set_source_environment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SourceEnvironment>,
    {
        self.source_environment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_environment][crate::model::TranslationDetails::source_environment].
    pub fn set_or_clear_source_environment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SourceEnvironment>,
    {
        self.source_environment = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target_return_literals][crate::model::TranslationDetails::target_return_literals].
    pub fn set_target_return_literals<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.target_return_literals = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [target_types][crate::model::TranslationDetails::target_types].
    pub fn set_target_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.target_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TranslationDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.TranslationDetails"
    }
}

/// Represents one mapping from a source SQL to a target SQL.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SourceTargetMapping {
    /// The source SQL or the path to it.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source_spec: std::option::Option<crate::model::SourceSpec>,

    /// The target SQL or the path for it.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub target_spec: std::option::Option<crate::model::TargetSpec>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SourceTargetMapping {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_spec][crate::model::SourceTargetMapping::source_spec].
    pub fn set_source_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SourceSpec>,
    {
        self.source_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_spec][crate::model::SourceTargetMapping::source_spec].
    pub fn set_or_clear_source_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SourceSpec>,
    {
        self.source_spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target_spec][crate::model::SourceTargetMapping::target_spec].
    pub fn set_target_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TargetSpec>,
    {
        self.target_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [target_spec][crate::model::SourceTargetMapping::target_spec].
    pub fn set_or_clear_target_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TargetSpec>,
    {
        self.target_spec = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SourceTargetMapping {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.SourceTargetMapping"
    }
}

/// Represents one path to the location that holds source data.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SourceSpec {
    /// Optional. The optional field to specify the encoding of the sql bytes.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub encoding: std::string::String,

    /// The specific source SQL.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::source_spec::Source>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SourceSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [encoding][crate::model::SourceSpec::encoding].
    pub fn set_encoding<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.encoding = v.into();
        self
    }

    /// Sets the value of [source][crate::model::SourceSpec::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::source_spec::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::SourceSpec::source]
    /// if it holds a `BaseUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn base_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::source_spec::Source::BaseUri(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::SourceSpec::source]
    /// to hold a `BaseUri`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_base_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source =
            std::option::Option::Some(crate::model::source_spec::Source::BaseUri(v.into()));
        self
    }

    /// The value of [source][crate::model::SourceSpec::source]
    /// if it holds a `Literal`, `None` if the field is not set or
    /// holds a different branch.
    pub fn literal(&self) -> std::option::Option<&std::boxed::Box<crate::model::Literal>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::source_spec::Source::Literal(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::SourceSpec::source]
    /// to hold a `Literal`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_literal<T: std::convert::Into<std::boxed::Box<crate::model::Literal>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source =
            std::option::Option::Some(crate::model::source_spec::Source::Literal(v.into()));
        self
    }
}

impl wkt::message::Message for SourceSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.SourceSpec"
    }
}

/// Defines additional types related to [SourceSpec].
pub mod source_spec {
    #[allow(unused_imports)]
    use super::*;

    /// The specific source SQL.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// The base URI for all files to be read in as sources for translation.
        BaseUri(std::string::String),
        /// Source literal.
        Literal(std::boxed::Box<crate::model::Literal>),
    }
}

/// Represents one path to the location that holds target data.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TargetSpec {
    /// The relative path for the target data. Given source file
    /// `base_uri/input/sql`, the output would be
    /// `target_base_uri/sql/relative_path/input.sql`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub relative_path: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TargetSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [relative_path][crate::model::TargetSpec::relative_path].
    pub fn set_relative_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.relative_path = v.into();
        self
    }
}

impl wkt::message::Message for TargetSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.TargetSpec"
    }
}

/// Literal data.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Literal {
    /// Required. The identifier of the literal entry.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub relative_path: std::string::String,

    /// The literal SQL contents.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub literal_data: std::option::Option<crate::model::literal::LiteralData>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Literal {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [relative_path][crate::model::Literal::relative_path].
    pub fn set_relative_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.relative_path = v.into();
        self
    }

    /// Sets the value of [literal_data][crate::model::Literal::literal_data].
    ///
    /// Note that all the setters affecting `literal_data` are mutually
    /// exclusive.
    pub fn set_literal_data<
        T: std::convert::Into<std::option::Option<crate::model::literal::LiteralData>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.literal_data = v.into();
        self
    }

    /// The value of [literal_data][crate::model::Literal::literal_data]
    /// if it holds a `LiteralString`, `None` if the field is not set or
    /// holds a different branch.
    pub fn literal_string(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.literal_data.as_ref().and_then(|v| match v {
            crate::model::literal::LiteralData::LiteralString(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [literal_data][crate::model::Literal::literal_data]
    /// to hold a `LiteralString`.
    ///
    /// Note that all the setters affecting `literal_data` are
    /// mutually exclusive.
    pub fn set_literal_string<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.literal_data =
            std::option::Option::Some(crate::model::literal::LiteralData::LiteralString(v.into()));
        self
    }

    /// The value of [literal_data][crate::model::Literal::literal_data]
    /// if it holds a `LiteralBytes`, `None` if the field is not set or
    /// holds a different branch.
    pub fn literal_bytes(&self) -> std::option::Option<&::bytes::Bytes> {
        #[allow(unreachable_patterns)]
        self.literal_data.as_ref().and_then(|v| match v {
            crate::model::literal::LiteralData::LiteralBytes(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [literal_data][crate::model::Literal::literal_data]
    /// to hold a `LiteralBytes`.
    ///
    /// Note that all the setters affecting `literal_data` are
    /// mutually exclusive.
    pub fn set_literal_bytes<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.literal_data =
            std::option::Option::Some(crate::model::literal::LiteralData::LiteralBytes(v.into()));
        self
    }
}

impl wkt::message::Message for Literal {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.Literal"
    }
}

/// Defines additional types related to [Literal].
pub mod literal {
    #[allow(unused_imports)]
    use super::*;

    /// The literal SQL contents.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum LiteralData {
        /// Literal string data.
        LiteralString(std::string::String),
        /// Literal byte data.
        LiteralBytes(#[serde_as(as = "serde_with::base64::Base64")] ::bytes::Bytes),
    }
}

/// Represents the default source environment values for the translation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SourceEnvironment {
    /// The default database name to fully qualify SQL objects when their database
    /// name is missing.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub default_database: std::string::String,

    /// The schema search path. When SQL objects are missing schema name,
    /// translation engine will search through this list to find the value.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub schema_search_path: std::vec::Vec<std::string::String>,

    /// Optional. Expects a validQ BigQuery dataset ID that exists, e.g.,
    /// project-123.metadata_store_123.  If specified, translation will search and
    /// read the required schema information from a metadata store in this dataset.
    /// If metadata store doesn't exist, translation will parse the metadata file
    /// and upload the schema info to a temp table in the dataset to speed up
    /// future translation jobs.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub metadata_store_dataset: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SourceEnvironment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [default_database][crate::model::SourceEnvironment::default_database].
    pub fn set_default_database<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.default_database = v.into();
        self
    }

    /// Sets the value of [schema_search_path][crate::model::SourceEnvironment::schema_search_path].
    pub fn set_schema_search_path<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.schema_search_path = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [metadata_store_dataset][crate::model::SourceEnvironment::metadata_store_dataset].
    pub fn set_metadata_store_dataset<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.metadata_store_dataset = v.into();
        self
    }
}

impl wkt::message::Message for SourceEnvironment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.SourceEnvironment"
    }
}

/// Details about a record.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TranslationReportRecord {
    /// Severity of the translation record.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub severity: crate::model::translation_report_record::Severity,

    /// Specifies the row from the source text where the error occurred (0 based).
    /// Example: 2
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub script_line: i32,

    /// Specifies the column from the source texts where the error occurred. (0
    /// based) example: 6
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub script_column: i32,

    /// Category of the error/warning. Example: SyntaxError
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub category: std::string::String,

    /// Detailed message of the record.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub message: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TranslationReportRecord {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [severity][crate::model::TranslationReportRecord::severity].
    pub fn set_severity<
        T: std::convert::Into<crate::model::translation_report_record::Severity>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.severity = v.into();
        self
    }

    /// Sets the value of [script_line][crate::model::TranslationReportRecord::script_line].
    pub fn set_script_line<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.script_line = v.into();
        self
    }

    /// Sets the value of [script_column][crate::model::TranslationReportRecord::script_column].
    pub fn set_script_column<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.script_column = v.into();
        self
    }

    /// Sets the value of [category][crate::model::TranslationReportRecord::category].
    pub fn set_category<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.category = v.into();
        self
    }

    /// Sets the value of [message][crate::model::TranslationReportRecord::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }
}

impl wkt::message::Message for TranslationReportRecord {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.TranslationReportRecord"
    }
}

/// Defines additional types related to [TranslationReportRecord].
pub mod translation_report_record {
    #[allow(unused_imports)]
    use super::*;

    /// The severity type of the record.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Severity {
        /// SeverityType not specified.
        Unspecified,
        /// INFO type.
        Info,
        /// WARNING type. The translated query may still provide useful information
        /// if all the report records are WARNING.
        Warning,
        /// ERROR type. Translation failed.
        Error,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Severity::value] or
        /// [Severity::name].
        UnknownValue(severity::UnknownValue),
    }

    #[doc(hidden)]
    pub mod severity {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Severity {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Info => std::option::Option::Some(1),
                Self::Warning => std::option::Option::Some(2),
                Self::Error => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SEVERITY_UNSPECIFIED"),
                Self::Info => std::option::Option::Some("INFO"),
                Self::Warning => std::option::Option::Some("WARNING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Severity {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Severity {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Severity {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Info,
                2 => Self::Warning,
                3 => Self::Error,
                _ => Self::UnknownValue(severity::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Severity {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SEVERITY_UNSPECIFIED" => Self::Unspecified,
                "INFO" => Self::Info,
                "WARNING" => Self::Warning,
                "ERROR" => Self::Error,
                _ => Self::UnknownValue(severity::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Severity {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Info => serializer.serialize_i32(1),
                Self::Warning => serializer.serialize_i32(2),
                Self::Error => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Severity {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Severity>::new(
                ".google.cloud.bigquery.migration.v2.TranslationReportRecord.Severity",
            ))
        }
    }
}

/// A record in the aggregate CSV report for a migration workflow
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GcsReportLogMessage {
    /// Severity of the translation record.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub severity: std::string::String,

    /// Category of the error/warning. Example: SyntaxError
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub category: std::string::String,

    /// The file path in which the error occurred
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub file_path: std::string::String,

    /// The file name in which the error occurred
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filename: std::string::String,

    /// Specifies the row from the source text where the error occurred (0 based,
    /// -1 for messages without line location). Example: 2
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub source_script_line: i32,

    /// Specifies the column from the source texts where the error occurred. (0
    /// based, -1 for messages without column location) example: 6
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub source_script_column: i32,

    /// Detailed message of the record.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub message: std::string::String,

    /// The script context (obfuscated) in which the error occurred
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub script_context: std::string::String,

    /// Category of the error/warning. Example: SyntaxError
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub action: std::string::String,

    /// Effect of the error/warning. Example: COMPATIBILITY
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub effect: std::string::String,

    /// Name of the affected object in the log message.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub object_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcsReportLogMessage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [severity][crate::model::GcsReportLogMessage::severity].
    pub fn set_severity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.severity = v.into();
        self
    }

    /// Sets the value of [category][crate::model::GcsReportLogMessage::category].
    pub fn set_category<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.category = v.into();
        self
    }

    /// Sets the value of [file_path][crate::model::GcsReportLogMessage::file_path].
    pub fn set_file_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.file_path = v.into();
        self
    }

    /// Sets the value of [filename][crate::model::GcsReportLogMessage::filename].
    pub fn set_filename<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filename = v.into();
        self
    }

    /// Sets the value of [source_script_line][crate::model::GcsReportLogMessage::source_script_line].
    pub fn set_source_script_line<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.source_script_line = v.into();
        self
    }

    /// Sets the value of [source_script_column][crate::model::GcsReportLogMessage::source_script_column].
    pub fn set_source_script_column<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.source_script_column = v.into();
        self
    }

    /// Sets the value of [message][crate::model::GcsReportLogMessage::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [script_context][crate::model::GcsReportLogMessage::script_context].
    pub fn set_script_context<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.script_context = v.into();
        self
    }

    /// Sets the value of [action][crate::model::GcsReportLogMessage::action].
    pub fn set_action<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.action = v.into();
        self
    }

    /// Sets the value of [effect][crate::model::GcsReportLogMessage::effect].
    pub fn set_effect<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.effect = v.into();
        self
    }

    /// Sets the value of [object_name][crate::model::GcsReportLogMessage::object_name].
    pub fn set_object_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.object_name = v.into();
        self
    }
}

impl wkt::message::Message for GcsReportLogMessage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.bigquery.migration.v2.GcsReportLogMessage"
    }
}
