// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// The request for calculating conversation statistics.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CalculateStatsRequest {
    /// Required. The location of the conversations.
    pub location: std::string::String,

    /// A filter to reduce results to a specific subset. This field is useful for
    /// getting statistics about conversations with specific properties.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CalculateStatsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::CalculateStatsRequest::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::CalculateStatsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for CalculateStatsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.CalculateStatsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CalculateStatsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __location,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CalculateStatsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "location" => Ok(__FieldTag::__location),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CalculateStatsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CalculateStatsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CalculateStatsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CalculateStatsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CalculateStatsRequest");
        debug_struct.field("location", &self.location);
        debug_struct.field("filter", &self.filter);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response for calculating conversation statistics.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CalculateStatsResponse {
    /// The average duration of all conversations. The average is calculated using
    /// only conversations that have a time duration.
    pub average_duration: std::option::Option<wkt::Duration>,

    /// The average number of turns per conversation.
    pub average_turn_count: i32,

    /// The total number of conversations.
    pub conversation_count: i32,

    /// A map associating each smart highlighter display name with its respective
    /// number of matches in the set of conversations.
    pub smart_highlighter_matches: std::collections::HashMap<std::string::String, i32>,

    /// A map associating each custom highlighter resource name with its respective
    /// number of matches in the set of conversations.
    pub custom_highlighter_matches: std::collections::HashMap<std::string::String, i32>,

    /// A map associating each issue resource name with its respective number of
    /// matches in the set of conversations. Key has the format:
    /// `projects/<Project-ID>/locations/<Location-ID>/issueModels/<Issue-Model-ID>/issues/<Issue-ID>`
    /// Deprecated, use `issue_matches_stats` field instead.
    #[deprecated]
    pub issue_matches: std::collections::HashMap<std::string::String, i32>,

    /// A map associating each issue resource name with its respective number of
    /// matches in the set of conversations. Key has the format:
    /// `projects/<Project-ID>/locations/<Location-ID>/issueModels/<Issue-Model-ID>/issues/<Issue-ID>`
    pub issue_matches_stats: std::collections::HashMap<
        std::string::String,
        crate::model::issue_model_label_stats::IssueStats,
    >,

    /// A time series representing the count of conversations created over time
    /// that match that requested filter criteria.
    pub conversation_count_time_series:
        std::option::Option<crate::model::calculate_stats_response::TimeSeries>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CalculateStatsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [average_duration][crate::model::CalculateStatsResponse::average_duration].
    pub fn set_average_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.average_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [average_duration][crate::model::CalculateStatsResponse::average_duration].
    pub fn set_or_clear_average_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.average_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [average_turn_count][crate::model::CalculateStatsResponse::average_turn_count].
    pub fn set_average_turn_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.average_turn_count = v.into();
        self
    }

    /// Sets the value of [conversation_count][crate::model::CalculateStatsResponse::conversation_count].
    pub fn set_conversation_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.conversation_count = v.into();
        self
    }

    /// Sets the value of [smart_highlighter_matches][crate::model::CalculateStatsResponse::smart_highlighter_matches].
    pub fn set_smart_highlighter_matches<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.smart_highlighter_matches = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [custom_highlighter_matches][crate::model::CalculateStatsResponse::custom_highlighter_matches].
    pub fn set_custom_highlighter_matches<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.custom_highlighter_matches =
            v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [issue_matches][crate::model::CalculateStatsResponse::issue_matches].
    #[deprecated]
    pub fn set_issue_matches<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.issue_matches = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [issue_matches_stats][crate::model::CalculateStatsResponse::issue_matches_stats].
    pub fn set_issue_matches_stats<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::issue_model_label_stats::IssueStats>,
    {
        use std::iter::Iterator;
        self.issue_matches_stats = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [conversation_count_time_series][crate::model::CalculateStatsResponse::conversation_count_time_series].
    pub fn set_conversation_count_time_series<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::calculate_stats_response::TimeSeries>,
    {
        self.conversation_count_time_series = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [conversation_count_time_series][crate::model::CalculateStatsResponse::conversation_count_time_series].
    pub fn set_or_clear_conversation_count_time_series<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::calculate_stats_response::TimeSeries>,
    {
        self.conversation_count_time_series = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CalculateStatsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.CalculateStatsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CalculateStatsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __average_duration,
            __average_turn_count,
            __conversation_count,
            __smart_highlighter_matches,
            __custom_highlighter_matches,
            __issue_matches,
            __issue_matches_stats,
            __conversation_count_time_series,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CalculateStatsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "averageDuration" => Ok(__FieldTag::__average_duration),
                            "average_duration" => Ok(__FieldTag::__average_duration),
                            "averageTurnCount" => Ok(__FieldTag::__average_turn_count),
                            "average_turn_count" => Ok(__FieldTag::__average_turn_count),
                            "conversationCount" => Ok(__FieldTag::__conversation_count),
                            "conversation_count" => Ok(__FieldTag::__conversation_count),
                            "smartHighlighterMatches" => {
                                Ok(__FieldTag::__smart_highlighter_matches)
                            }
                            "smart_highlighter_matches" => {
                                Ok(__FieldTag::__smart_highlighter_matches)
                            }
                            "customHighlighterMatches" => {
                                Ok(__FieldTag::__custom_highlighter_matches)
                            }
                            "custom_highlighter_matches" => {
                                Ok(__FieldTag::__custom_highlighter_matches)
                            }
                            "issueMatches" => Ok(__FieldTag::__issue_matches),
                            "issue_matches" => Ok(__FieldTag::__issue_matches),
                            "issueMatchesStats" => Ok(__FieldTag::__issue_matches_stats),
                            "issue_matches_stats" => Ok(__FieldTag::__issue_matches_stats),
                            "conversationCountTimeSeries" => {
                                Ok(__FieldTag::__conversation_count_time_series)
                            }
                            "conversation_count_time_series" => {
                                Ok(__FieldTag::__conversation_count_time_series)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CalculateStatsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CalculateStatsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__average_duration => {
                            if !fields.insert(__FieldTag::__average_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for average_duration",
                                ));
                            }
                            result.average_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__average_turn_count => {
                            if !fields.insert(__FieldTag::__average_turn_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for average_turn_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.average_turn_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__conversation_count => {
                            if !fields.insert(__FieldTag::__conversation_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.conversation_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__smart_highlighter_matches => {
                            if !fields.insert(__FieldTag::__smart_highlighter_matches) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for smart_highlighter_matches",
                                ));
                            }
                            struct __With(
                                std::option::Option<
                                    std::collections::HashMap<std::string::String, i32>,
                                >,
                            );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                serde_with::Same,
                                                wkt::internal::I32,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.smart_highlighter_matches =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__custom_highlighter_matches => {
                            if !fields.insert(__FieldTag::__custom_highlighter_matches) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_highlighter_matches",
                                ));
                            }
                            struct __With(
                                std::option::Option<
                                    std::collections::HashMap<std::string::String, i32>,
                                >,
                            );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                serde_with::Same,
                                                wkt::internal::I32,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.custom_highlighter_matches =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__issue_matches => {
                            if !fields.insert(__FieldTag::__issue_matches) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for issue_matches",
                                ));
                            }
                            struct __With(
                                std::option::Option<
                                    std::collections::HashMap<std::string::String, i32>,
                                >,
                            );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                serde_with::Same,
                                                wkt::internal::I32,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.issue_matches =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__issue_matches_stats => {
                            if !fields.insert(__FieldTag::__issue_matches_stats) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for issue_matches_stats",
                                ));
                            }
                            result.issue_matches_stats = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::issue_model_label_stats::IssueStats,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__conversation_count_time_series => {
                            if !fields.insert(__FieldTag::__conversation_count_time_series) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation_count_time_series",
                                ));
                            }
                            result.conversation_count_time_series = map
                                .next_value::<std::option::Option<
                                    crate::model::calculate_stats_response::TimeSeries,
                                >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CalculateStatsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.average_duration.is_some() {
            state.serialize_entry("averageDuration", &self.average_duration)?;
        }
        if !wkt::internal::is_default(&self.average_turn_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("averageTurnCount", &__With(&self.average_turn_count))?;
        }
        if !wkt::internal::is_default(&self.conversation_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("conversationCount", &__With(&self.conversation_count))?;
        }
        if !self.smart_highlighter_matches.is_empty() {
            struct __With<'a>(&'a std::collections::HashMap<std::string::String, i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::collections::HashMap<serde_with::Same, wkt::internal::I32> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "smartHighlighterMatches",
                &__With(&self.smart_highlighter_matches),
            )?;
        }
        if !self.custom_highlighter_matches.is_empty() {
            struct __With<'a>(&'a std::collections::HashMap<std::string::String, i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::collections::HashMap<serde_with::Same, wkt::internal::I32> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "customHighlighterMatches",
                &__With(&self.custom_highlighter_matches),
            )?;
        }
        if !self.issue_matches.is_empty() {
            struct __With<'a>(&'a std::collections::HashMap<std::string::String, i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::collections::HashMap<serde_with::Same, wkt::internal::I32> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("issueMatches", &__With(&self.issue_matches))?;
        }
        if !self.issue_matches_stats.is_empty() {
            state.serialize_entry("issueMatchesStats", &self.issue_matches_stats)?;
        }
        if self.conversation_count_time_series.is_some() {
            state.serialize_entry(
                "conversationCountTimeSeries",
                &self.conversation_count_time_series,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CalculateStatsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CalculateStatsResponse");
        debug_struct.field("average_duration", &self.average_duration);
        debug_struct.field("average_turn_count", &self.average_turn_count);
        debug_struct.field("conversation_count", &self.conversation_count);
        debug_struct.field("smart_highlighter_matches", &self.smart_highlighter_matches);
        debug_struct.field(
            "custom_highlighter_matches",
            &self.custom_highlighter_matches,
        );
        debug_struct.field("issue_matches", &self.issue_matches);
        debug_struct.field("issue_matches_stats", &self.issue_matches_stats);
        debug_struct.field(
            "conversation_count_time_series",
            &self.conversation_count_time_series,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [CalculateStatsResponse].
pub mod calculate_stats_response {
    #[allow(unused_imports)]
    use super::*;

    /// A time series representing conversations over time.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TimeSeries {
        /// The duration of each interval.
        pub interval_duration: std::option::Option<wkt::Duration>,

        /// An ordered list of intervals from earliest to latest, where each interval
        /// represents the number of conversations that transpired during the time
        /// window.
        pub points: std::vec::Vec<crate::model::calculate_stats_response::time_series::Interval>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TimeSeries {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [interval_duration][crate::model::calculate_stats_response::TimeSeries::interval_duration].
        pub fn set_interval_duration<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.interval_duration = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [interval_duration][crate::model::calculate_stats_response::TimeSeries::interval_duration].
        pub fn set_or_clear_interval_duration<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.interval_duration = v.map(|x| x.into());
            self
        }

        /// Sets the value of [points][crate::model::calculate_stats_response::TimeSeries::points].
        pub fn set_points<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::calculate_stats_response::time_series::Interval>,
        {
            use std::iter::Iterator;
            self.points = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for TimeSeries {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.CalculateStatsResponse.TimeSeries"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for TimeSeries {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __interval_duration,
                __points,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for TimeSeries")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "intervalDuration" => Ok(__FieldTag::__interval_duration),
                                "interval_duration" => Ok(__FieldTag::__interval_duration),
                                "points" => Ok(__FieldTag::__points),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = TimeSeries;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct TimeSeries")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__interval_duration => {
                                if !fields.insert(__FieldTag::__interval_duration) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for interval_duration",
                                    ));
                                }
                                result.interval_duration =
                                    map.next_value::<std::option::Option<wkt::Duration>>()?;
                            }
                            __FieldTag::__points => {
                                if !fields.insert(__FieldTag::__points) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for points",
                                    ));
                                }
                                result.points = map.next_value::<std::option::Option<std::vec::Vec<crate::model::calculate_stats_response::time_series::Interval>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for TimeSeries {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.interval_duration.is_some() {
                state.serialize_entry("intervalDuration", &self.interval_duration)?;
            }
            if !self.points.is_empty() {
                state.serialize_entry("points", &self.points)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for TimeSeries {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("TimeSeries");
            debug_struct.field("interval_duration", &self.interval_duration);
            debug_struct.field("points", &self.points);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [TimeSeries].
    pub mod time_series {
        #[allow(unused_imports)]
        use super::*;

        /// A single interval in a time series.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Interval {
            /// The start time of this interval.
            pub start_time: std::option::Option<wkt::Timestamp>,

            /// The number of conversations created in this interval.
            pub conversation_count: i32,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Interval {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [start_time][crate::model::calculate_stats_response::time_series::Interval::start_time].
            pub fn set_start_time<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::Timestamp>,
            {
                self.start_time = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [start_time][crate::model::calculate_stats_response::time_series::Interval::start_time].
            pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::Timestamp>,
            {
                self.start_time = v.map(|x| x.into());
                self
            }

            /// Sets the value of [conversation_count][crate::model::calculate_stats_response::time_series::Interval::conversation_count].
            pub fn set_conversation_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.conversation_count = v.into();
                self
            }
        }

        impl wkt::message::Message for Interval {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.contactcenterinsights.v1.CalculateStatsResponse.TimeSeries.Interval"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Interval {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __start_time,
                    __conversation_count,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Interval")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "startTime" => Ok(__FieldTag::__start_time),
                                    "start_time" => Ok(__FieldTag::__start_time),
                                    "conversationCount" => Ok(__FieldTag::__conversation_count),
                                    "conversation_count" => Ok(__FieldTag::__conversation_count),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Interval;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Interval")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__start_time => {
                                    if !fields.insert(__FieldTag::__start_time) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for start_time",
                                            ),
                                        );
                                    }
                                    result.start_time =
                                        map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                                }
                                __FieldTag::__conversation_count => {
                                    if !fields.insert(__FieldTag::__conversation_count) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for conversation_count",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.conversation_count =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Interval {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if self.start_time.is_some() {
                    state.serialize_entry("startTime", &self.start_time)?;
                }
                if !wkt::internal::is_default(&self.conversation_count) {
                    struct __With<'a>(&'a i32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                        }
                    }
                    state
                        .serialize_entry("conversationCount", &__With(&self.conversation_count))?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for Interval {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("Interval");
                debug_struct.field("start_time", &self.start_time);
                debug_struct.field("conversation_count", &self.conversation_count);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }
    }
}

/// Metadata for a create analysis operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateAnalysisOperationMetadata {
    /// Output only. The time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The Conversation that this Analysis Operation belongs to.
    pub conversation: std::string::String,

    /// Output only. The annotator selector used for the analysis (if any).
    pub annotator_selector: std::option::Option<crate::model::AnnotatorSelector>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateAnalysisOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::CreateAnalysisOperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::CreateAnalysisOperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::CreateAnalysisOperationMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::CreateAnalysisOperationMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [conversation][crate::model::CreateAnalysisOperationMetadata::conversation].
    pub fn set_conversation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.conversation = v.into();
        self
    }

    /// Sets the value of [annotator_selector][crate::model::CreateAnalysisOperationMetadata::annotator_selector].
    pub fn set_annotator_selector<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AnnotatorSelector>,
    {
        self.annotator_selector = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [annotator_selector][crate::model::CreateAnalysisOperationMetadata::annotator_selector].
    pub fn set_or_clear_annotator_selector<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AnnotatorSelector>,
    {
        self.annotator_selector = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateAnalysisOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.CreateAnalysisOperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateAnalysisOperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __end_time,
            __conversation,
            __annotator_selector,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateAnalysisOperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "conversation" => Ok(__FieldTag::__conversation),
                            "annotatorSelector" => Ok(__FieldTag::__annotator_selector),
                            "annotator_selector" => Ok(__FieldTag::__annotator_selector),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateAnalysisOperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateAnalysisOperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__conversation => {
                            if !fields.insert(__FieldTag::__conversation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation",
                                ));
                            }
                            result.conversation = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__annotator_selector => {
                            if !fields.insert(__FieldTag::__annotator_selector) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotator_selector",
                                ));
                            }
                            result.annotator_selector = map
                                .next_value::<std::option::Option<crate::model::AnnotatorSelector>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateAnalysisOperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.conversation.is_empty() {
            state.serialize_entry("conversation", &self.conversation)?;
        }
        if self.annotator_selector.is_some() {
            state.serialize_entry("annotatorSelector", &self.annotator_selector)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateAnalysisOperationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateAnalysisOperationMetadata");
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("conversation", &self.conversation);
        debug_struct.field("annotator_selector", &self.annotator_selector);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request to create a conversation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateConversationRequest {
    /// Required. The parent resource of the conversation.
    pub parent: std::string::String,

    /// Required. The conversation resource to create.
    pub conversation: std::option::Option<crate::model::Conversation>,

    /// A unique ID for the new conversation. This ID will become the final
    /// component of the conversation's resource name. If no ID is specified, a
    /// server-generated ID will be used.
    ///
    /// This value should be 4-64 characters and must match the regular
    /// expression `^[a-z0-9-]{4,64}$`. Valid characters are `[a-z][0-9]-`
    pub conversation_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateConversationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateConversationRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [conversation][crate::model::CreateConversationRequest::conversation].
    pub fn set_conversation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Conversation>,
    {
        self.conversation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [conversation][crate::model::CreateConversationRequest::conversation].
    pub fn set_or_clear_conversation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Conversation>,
    {
        self.conversation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [conversation_id][crate::model::CreateConversationRequest::conversation_id].
    pub fn set_conversation_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.conversation_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateConversationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.CreateConversationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateConversationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __conversation,
            __conversation_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateConversationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "conversation" => Ok(__FieldTag::__conversation),
                            "conversationId" => Ok(__FieldTag::__conversation_id),
                            "conversation_id" => Ok(__FieldTag::__conversation_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateConversationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateConversationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__conversation => {
                            if !fields.insert(__FieldTag::__conversation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation",
                                ));
                            }
                            result.conversation = map
                                .next_value::<std::option::Option<crate::model::Conversation>>()?;
                        }
                        __FieldTag::__conversation_id => {
                            if !fields.insert(__FieldTag::__conversation_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation_id",
                                ));
                            }
                            result.conversation_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateConversationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.conversation.is_some() {
            state.serialize_entry("conversation", &self.conversation)?;
        }
        if !self.conversation_id.is_empty() {
            state.serialize_entry("conversationId", &self.conversation_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateConversationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateConversationRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("conversation", &self.conversation);
        debug_struct.field("conversation_id", &self.conversation_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request to upload a conversation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UploadConversationRequest {
    /// Required. The parent resource of the conversation.
    pub parent: std::string::String,

    /// Required. The conversation resource to create.
    pub conversation: std::option::Option<crate::model::Conversation>,

    /// Optional. A unique ID for the new conversation. This ID will become the
    /// final component of the conversation's resource name. If no ID is specified,
    /// a server-generated ID will be used.
    ///
    /// This value should be 4-64 characters and must match the regular
    /// expression `^[a-z0-9-]{4,64}$`. Valid characters are `[a-z][0-9]-`
    pub conversation_id: std::string::String,

    /// Optional. DLP settings for transcript redaction. Will default to the config
    /// specified in Settings.
    pub redaction_config: std::option::Option<crate::model::RedactionConfig>,

    /// Optional. Speech-to-Text configuration. Will default to the config
    /// specified in Settings.
    pub speech_config: std::option::Option<crate::model::SpeechConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UploadConversationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::UploadConversationRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [conversation][crate::model::UploadConversationRequest::conversation].
    pub fn set_conversation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Conversation>,
    {
        self.conversation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [conversation][crate::model::UploadConversationRequest::conversation].
    pub fn set_or_clear_conversation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Conversation>,
    {
        self.conversation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [conversation_id][crate::model::UploadConversationRequest::conversation_id].
    pub fn set_conversation_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.conversation_id = v.into();
        self
    }

    /// Sets the value of [redaction_config][crate::model::UploadConversationRequest::redaction_config].
    pub fn set_redaction_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RedactionConfig>,
    {
        self.redaction_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [redaction_config][crate::model::UploadConversationRequest::redaction_config].
    pub fn set_or_clear_redaction_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RedactionConfig>,
    {
        self.redaction_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [speech_config][crate::model::UploadConversationRequest::speech_config].
    pub fn set_speech_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SpeechConfig>,
    {
        self.speech_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [speech_config][crate::model::UploadConversationRequest::speech_config].
    pub fn set_or_clear_speech_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SpeechConfig>,
    {
        self.speech_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UploadConversationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.UploadConversationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UploadConversationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __conversation,
            __conversation_id,
            __redaction_config,
            __speech_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UploadConversationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "conversation" => Ok(__FieldTag::__conversation),
                            "conversationId" => Ok(__FieldTag::__conversation_id),
                            "conversation_id" => Ok(__FieldTag::__conversation_id),
                            "redactionConfig" => Ok(__FieldTag::__redaction_config),
                            "redaction_config" => Ok(__FieldTag::__redaction_config),
                            "speechConfig" => Ok(__FieldTag::__speech_config),
                            "speech_config" => Ok(__FieldTag::__speech_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UploadConversationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UploadConversationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__conversation => {
                            if !fields.insert(__FieldTag::__conversation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation",
                                ));
                            }
                            result.conversation = map
                                .next_value::<std::option::Option<crate::model::Conversation>>()?;
                        }
                        __FieldTag::__conversation_id => {
                            if !fields.insert(__FieldTag::__conversation_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation_id",
                                ));
                            }
                            result.conversation_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__redaction_config => {
                            if !fields.insert(__FieldTag::__redaction_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for redaction_config",
                                ));
                            }
                            result.redaction_config = map
                                .next_value::<std::option::Option<crate::model::RedactionConfig>>(
                                )?;
                        }
                        __FieldTag::__speech_config => {
                            if !fields.insert(__FieldTag::__speech_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for speech_config",
                                ));
                            }
                            result.speech_config = map
                                .next_value::<std::option::Option<crate::model::SpeechConfig>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UploadConversationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.conversation.is_some() {
            state.serialize_entry("conversation", &self.conversation)?;
        }
        if !self.conversation_id.is_empty() {
            state.serialize_entry("conversationId", &self.conversation_id)?;
        }
        if self.redaction_config.is_some() {
            state.serialize_entry("redactionConfig", &self.redaction_config)?;
        }
        if self.speech_config.is_some() {
            state.serialize_entry("speechConfig", &self.speech_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UploadConversationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UploadConversationRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("conversation", &self.conversation);
        debug_struct.field("conversation_id", &self.conversation_id);
        debug_struct.field("redaction_config", &self.redaction_config);
        debug_struct.field("speech_config", &self.speech_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The metadata for an `UploadConversation` operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UploadConversationMetadata {
    /// Output only. The time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The original request.
    pub request: std::option::Option<crate::model::UploadConversationRequest>,

    /// Output only. The operation name for a successfully created analysis
    /// operation, if any.
    pub analysis_operation: std::string::String,

    /// Output only. The redaction config applied to the uploaded conversation.
    pub applied_redaction_config: std::option::Option<crate::model::RedactionConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UploadConversationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::UploadConversationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::UploadConversationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::UploadConversationMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::UploadConversationMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request][crate::model::UploadConversationMetadata::request].
    pub fn set_request<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UploadConversationRequest>,
    {
        self.request = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [request][crate::model::UploadConversationMetadata::request].
    pub fn set_or_clear_request<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UploadConversationRequest>,
    {
        self.request = v.map(|x| x.into());
        self
    }

    /// Sets the value of [analysis_operation][crate::model::UploadConversationMetadata::analysis_operation].
    pub fn set_analysis_operation<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.analysis_operation = v.into();
        self
    }

    /// Sets the value of [applied_redaction_config][crate::model::UploadConversationMetadata::applied_redaction_config].
    pub fn set_applied_redaction_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RedactionConfig>,
    {
        self.applied_redaction_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [applied_redaction_config][crate::model::UploadConversationMetadata::applied_redaction_config].
    pub fn set_or_clear_applied_redaction_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RedactionConfig>,
    {
        self.applied_redaction_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UploadConversationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.UploadConversationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UploadConversationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __end_time,
            __request,
            __analysis_operation,
            __applied_redaction_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UploadConversationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "request" => Ok(__FieldTag::__request),
                            "analysisOperation" => Ok(__FieldTag::__analysis_operation),
                            "analysis_operation" => Ok(__FieldTag::__analysis_operation),
                            "appliedRedactionConfig" => Ok(__FieldTag::__applied_redaction_config),
                            "applied_redaction_config" => {
                                Ok(__FieldTag::__applied_redaction_config)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UploadConversationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UploadConversationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__request => {
                            if !fields.insert(__FieldTag::__request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request",
                                ));
                            }
                            result.request = map.next_value::<std::option::Option<crate::model::UploadConversationRequest>>()?
                                ;
                        }
                        __FieldTag::__analysis_operation => {
                            if !fields.insert(__FieldTag::__analysis_operation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for analysis_operation",
                                ));
                            }
                            result.analysis_operation = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__applied_redaction_config => {
                            if !fields.insert(__FieldTag::__applied_redaction_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for applied_redaction_config",
                                ));
                            }
                            result.applied_redaction_config = map
                                .next_value::<std::option::Option<crate::model::RedactionConfig>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UploadConversationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if self.request.is_some() {
            state.serialize_entry("request", &self.request)?;
        }
        if !self.analysis_operation.is_empty() {
            state.serialize_entry("analysisOperation", &self.analysis_operation)?;
        }
        if self.applied_redaction_config.is_some() {
            state.serialize_entry("appliedRedactionConfig", &self.applied_redaction_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UploadConversationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UploadConversationMetadata");
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("request", &self.request);
        debug_struct.field("analysis_operation", &self.analysis_operation);
        debug_struct.field("applied_redaction_config", &self.applied_redaction_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request to list conversations.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListConversationsRequest {
    /// Required. The parent resource of the conversation.
    pub parent: std::string::String,

    /// The maximum number of conversations to return in the response. A valid page
    /// size ranges from 0 to 100,000 inclusive. If the page size is zero or
    /// unspecified, a default page size of 100 will be chosen. Note that a call
    /// might return fewer results than the requested page size.
    pub page_size: i32,

    /// The value returned by the last `ListConversationsResponse`. This value
    /// indicates that this is a continuation of a prior `ListConversations` call
    /// and that the system should return the next page of data.
    pub page_token: std::string::String,

    /// A filter to reduce results to a specific subset. Useful for querying
    /// conversations with specific properties.
    pub filter: std::string::String,

    /// Optional. The attribute by which to order conversations in the response.
    /// If empty, conversations will be ordered by descending creation time.
    /// Supported values are one of the following:
    ///
    /// * create_time
    /// * customer_satisfaction_rating
    /// * duration
    /// * latest_analysis
    /// * start_time
    /// * turn_count
    ///
    /// The default sort order is ascending. To specify order, append `asc` or
    /// `desc` (`create_time desc`).
    /// For more details, see [Google AIPs
    /// Ordering](https://google.aip.dev/132#ordering).
    pub order_by: std::string::String,

    /// The level of details of the conversation. Default is `BASIC`.
    pub view: crate::model::ConversationView,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConversationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListConversationsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListConversationsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListConversationsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListConversationsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListConversationsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListConversationsRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::ConversationView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for ListConversationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ListConversationsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListConversationsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            __view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListConversationsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            "view" => Ok(__FieldTag::__view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListConversationsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListConversationsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<crate::model::ConversationView>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListConversationsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListConversationsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListConversationsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        debug_struct.field("view", &self.view);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response of listing conversations.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListConversationsResponse {
    /// The conversations that match the request.
    pub conversations: std::vec::Vec<crate::model::Conversation>,

    /// A token which can be sent as `page_token` to retrieve the next page. If
    /// this field is set, it means there is another page available. If it is not
    /// set, it means no other pages are available.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConversationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [conversations][crate::model::ListConversationsResponse::conversations].
    pub fn set_conversations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Conversation>,
    {
        use std::iter::Iterator;
        self.conversations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListConversationsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListConversationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ListConversationsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListConversationsResponse {
    type PageItem = crate::model::Conversation;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.conversations
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListConversationsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversations,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListConversationsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversations" => Ok(__FieldTag::__conversations),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListConversationsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListConversationsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversations => {
                            if !fields.insert(__FieldTag::__conversations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversations",
                                ));
                            }
                            result.conversations = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Conversation>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListConversationsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.conversations.is_empty() {
            state.serialize_entry("conversations", &self.conversations)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListConversationsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListConversationsResponse");
        debug_struct.field("conversations", &self.conversations);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request to get a conversation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetConversationRequest {
    /// Required. The name of the conversation to get.
    pub name: std::string::String,

    /// The level of details of the conversation. Default is `FULL`.
    pub view: crate::model::ConversationView,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetConversationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetConversationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetConversationRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::ConversationView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetConversationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.GetConversationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetConversationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetConversationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "view" => Ok(__FieldTag::__view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetConversationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetConversationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<crate::model::ConversationView>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetConversationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetConversationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetConversationRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("view", &self.view);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request to update a conversation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateConversationRequest {
    /// Required. The new values for the conversation.
    pub conversation: std::option::Option<crate::model::Conversation>,

    /// The list of fields to be updated. All possible fields can be updated by
    /// passing `*`, or a subset of the following updateable fields can be
    /// provided:
    ///
    /// * `agent_id`
    /// * `language_code`
    /// * `labels`
    /// * `metadata`
    /// * `quality_metadata`
    /// * `call_metadata`
    /// * `start_time`
    /// * `expire_time` or `ttl`
    /// * `data_source.gcs_source.audio_uri` or
    ///   `data_source.dialogflow_source.audio_uri`
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateConversationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [conversation][crate::model::UpdateConversationRequest::conversation].
    pub fn set_conversation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Conversation>,
    {
        self.conversation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [conversation][crate::model::UpdateConversationRequest::conversation].
    pub fn set_or_clear_conversation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Conversation>,
    {
        self.conversation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateConversationRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateConversationRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateConversationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.UpdateConversationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateConversationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversation,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateConversationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversation" => Ok(__FieldTag::__conversation),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateConversationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateConversationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversation => {
                            if !fields.insert(__FieldTag::__conversation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation",
                                ));
                            }
                            result.conversation = map
                                .next_value::<std::option::Option<crate::model::Conversation>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateConversationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.conversation.is_some() {
            state.serialize_entry("conversation", &self.conversation)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateConversationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateConversationRequest");
        debug_struct.field("conversation", &self.conversation);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request to delete a conversation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteConversationRequest {
    /// Required. The name of the conversation to delete.
    pub name: std::string::String,

    /// If set to true, all of this conversation's analyses will also be deleted.
    /// Otherwise, the request will only succeed if the conversation has no
    /// analyses.
    pub force: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteConversationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteConversationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteConversationRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteConversationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.DeleteConversationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteConversationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteConversationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteConversationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteConversationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteConversationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteConversationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteConversationRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("force", &self.force);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request to ingest conversations.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct IngestConversationsRequest {
    /// Required. The parent resource for new conversations.
    pub parent: std::string::String,

    /// Configuration that applies to all conversations.
    pub conversation_config:
        std::option::Option<crate::model::ingest_conversations_request::ConversationConfig>,

    /// Optional. DLP settings for transcript redaction. Optional, will default to
    /// the config specified in Settings.
    pub redaction_config: std::option::Option<crate::model::RedactionConfig>,

    /// Optional. Default Speech-to-Text configuration. Optional, will default to
    /// the config specified in Settings.
    pub speech_config: std::option::Option<crate::model::SpeechConfig>,

    /// Optional. If set, this fields indicates the number of objects to ingest
    /// from the Cloud Storage bucket. If empty, the entire bucket will be
    /// ingested. Unless they are first deleted, conversations produced through
    /// sampling won't be ingested by subsequent ingest requests.
    pub sample_size: std::option::Option<i32>,

    /// Configuration for an external data store containing objects that will
    /// be converted to conversations.
    pub source: std::option::Option<crate::model::ingest_conversations_request::Source>,

    /// Configuration for converting individual `source` objects to conversations.
    pub object_config:
        std::option::Option<crate::model::ingest_conversations_request::ObjectConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IngestConversationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::IngestConversationsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [conversation_config][crate::model::IngestConversationsRequest::conversation_config].
    pub fn set_conversation_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ingest_conversations_request::ConversationConfig>,
    {
        self.conversation_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [conversation_config][crate::model::IngestConversationsRequest::conversation_config].
    pub fn set_or_clear_conversation_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ingest_conversations_request::ConversationConfig>,
    {
        self.conversation_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [redaction_config][crate::model::IngestConversationsRequest::redaction_config].
    pub fn set_redaction_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RedactionConfig>,
    {
        self.redaction_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [redaction_config][crate::model::IngestConversationsRequest::redaction_config].
    pub fn set_or_clear_redaction_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RedactionConfig>,
    {
        self.redaction_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [speech_config][crate::model::IngestConversationsRequest::speech_config].
    pub fn set_speech_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SpeechConfig>,
    {
        self.speech_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [speech_config][crate::model::IngestConversationsRequest::speech_config].
    pub fn set_or_clear_speech_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SpeechConfig>,
    {
        self.speech_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [sample_size][crate::model::IngestConversationsRequest::sample_size].
    pub fn set_sample_size<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.sample_size = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sample_size][crate::model::IngestConversationsRequest::sample_size].
    pub fn set_or_clear_sample_size<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.sample_size = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source][crate::model::IngestConversationsRequest::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::ingest_conversations_request::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::IngestConversationsRequest::source]
    /// if it holds a `GcsSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ingest_conversations_request::GcsSource>>
    {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::ingest_conversations_request::Source::GcsSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::IngestConversationsRequest::source]
    /// to hold a `GcsSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_gcs_source<
        T: std::convert::Into<std::boxed::Box<crate::model::ingest_conversations_request::GcsSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::ingest_conversations_request::Source::GcsSource(v.into()),
        );
        self
    }

    /// Sets the value of [object_config][crate::model::IngestConversationsRequest::object_config].
    ///
    /// Note that all the setters affecting `object_config` are mutually
    /// exclusive.
    pub fn set_object_config<
        T: std::convert::Into<
                std::option::Option<crate::model::ingest_conversations_request::ObjectConfig>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.object_config = v.into();
        self
    }

    /// The value of [object_config][crate::model::IngestConversationsRequest::object_config]
    /// if it holds a `TranscriptObjectConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn transcript_object_config(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::ingest_conversations_request::TranscriptObjectConfig>,
    > {
        #[allow(unreachable_patterns)]
        self.object_config.as_ref().and_then(|v| match v {
            crate::model::ingest_conversations_request::ObjectConfig::TranscriptObjectConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [object_config][crate::model::IngestConversationsRequest::object_config]
    /// to hold a `TranscriptObjectConfig`.
    ///
    /// Note that all the setters affecting `object_config` are
    /// mutually exclusive.
    pub fn set_transcript_object_config<
        T: std::convert::Into<
                std::boxed::Box<crate::model::ingest_conversations_request::TranscriptObjectConfig>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.object_config = std::option::Option::Some(
            crate::model::ingest_conversations_request::ObjectConfig::TranscriptObjectConfig(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for IngestConversationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.IngestConversationsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for IngestConversationsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcs_source,
            __transcript_object_config,
            __parent,
            __conversation_config,
            __redaction_config,
            __speech_config,
            __sample_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IngestConversationsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcsSource" => Ok(__FieldTag::__gcs_source),
                            "gcs_source" => Ok(__FieldTag::__gcs_source),
                            "transcriptObjectConfig" => Ok(__FieldTag::__transcript_object_config),
                            "transcript_object_config" => {
                                Ok(__FieldTag::__transcript_object_config)
                            }
                            "parent" => Ok(__FieldTag::__parent),
                            "conversationConfig" => Ok(__FieldTag::__conversation_config),
                            "conversation_config" => Ok(__FieldTag::__conversation_config),
                            "redactionConfig" => Ok(__FieldTag::__redaction_config),
                            "redaction_config" => Ok(__FieldTag::__redaction_config),
                            "speechConfig" => Ok(__FieldTag::__speech_config),
                            "speech_config" => Ok(__FieldTag::__speech_config),
                            "sampleSize" => Ok(__FieldTag::__sample_size),
                            "sample_size" => Ok(__FieldTag::__sample_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = IngestConversationsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IngestConversationsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcs_source => {
                            if !fields.insert(__FieldTag::__gcs_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_source",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.contactcenterinsights.v1.IngestConversationsRequest.gcs_source, latest field was gcsSource",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::ingest_conversations_request::Source::GcsSource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::ingest_conversations_request::GcsSource,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__transcript_object_config => {
                            if !fields.insert(__FieldTag::__transcript_object_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transcript_object_config",
                                ));
                            }
                            if result.object_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `object_config`, a oneof with full ID .google.cloud.contactcenterinsights.v1.IngestConversationsRequest.transcript_object_config, latest field was transcriptObjectConfig",
                                ));
                            }
                            result.object_config = std::option::Option::Some(
                                crate::model::ingest_conversations_request::ObjectConfig::TranscriptObjectConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ingest_conversations_request::TranscriptObjectConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__conversation_config => {
                            if !fields.insert(__FieldTag::__conversation_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation_config",
                                ));
                            }
                            result.conversation_config = map.next_value::<std::option::Option<
                                crate::model::ingest_conversations_request::ConversationConfig,
                            >>()?;
                        }
                        __FieldTag::__redaction_config => {
                            if !fields.insert(__FieldTag::__redaction_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for redaction_config",
                                ));
                            }
                            result.redaction_config = map
                                .next_value::<std::option::Option<crate::model::RedactionConfig>>(
                                )?;
                        }
                        __FieldTag::__speech_config => {
                            if !fields.insert(__FieldTag::__speech_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for speech_config",
                                ));
                            }
                            result.speech_config = map
                                .next_value::<std::option::Option<crate::model::SpeechConfig>>()?;
                        }
                        __FieldTag::__sample_size => {
                            if !fields.insert(__FieldTag::__sample_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sample_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.sample_size = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for IngestConversationsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.gcs_source() {
            state.serialize_entry("gcsSource", value)?;
        }
        if let Some(value) = self.transcript_object_config() {
            state.serialize_entry("transcriptObjectConfig", value)?;
        }
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.conversation_config.is_some() {
            state.serialize_entry("conversationConfig", &self.conversation_config)?;
        }
        if self.redaction_config.is_some() {
            state.serialize_entry("redactionConfig", &self.redaction_config)?;
        }
        if self.speech_config.is_some() {
            state.serialize_entry("speechConfig", &self.speech_config)?;
        }
        if self.sample_size.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("sampleSize", &__With(&self.sample_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for IngestConversationsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IngestConversationsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("conversation_config", &self.conversation_config);
        debug_struct.field("redaction_config", &self.redaction_config);
        debug_struct.field("speech_config", &self.speech_config);
        debug_struct.field("sample_size", &self.sample_size);
        debug_struct.field("source", &self.source);
        debug_struct.field("object_config", &self.object_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [IngestConversationsRequest].
pub mod ingest_conversations_request {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration for Cloud Storage bucket sources.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GcsSource {
        /// Required. The Cloud Storage bucket containing source objects.
        pub bucket_uri: std::string::String,

        /// Optional. Specifies the type of the objects in `bucket_uri`.
        pub bucket_object_type:
            crate::model::ingest_conversations_request::gcs_source::BucketObjectType,

        /// Optional. The Cloud Storage path to the conversation metadata. Note that:
        /// [1] Metadata files are expected to be in JSON format.
        /// [2] Metadata and source files (transcripts or audio) must be in
        /// separate buckets.
        /// [3] A source file and its corresponding metadata file must share the same
        /// name to
        /// be properly ingested, E.g. `gs://bucket/audio/conversation1.mp3` and
        /// `gs://bucket/metadata/conversation1.json`.
        pub metadata_bucket_uri: std::option::Option<std::string::String>,

        /// Optional. Custom keys to extract as conversation labels from metadata
        /// files in `metadata_bucket_uri`. Keys not included in this field will be
        /// ignored. Note that there is a limit of 100 labels per conversation.
        pub custom_metadata_keys: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GcsSource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [bucket_uri][crate::model::ingest_conversations_request::GcsSource::bucket_uri].
        pub fn set_bucket_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.bucket_uri = v.into();
            self
        }

        /// Sets the value of [bucket_object_type][crate::model::ingest_conversations_request::GcsSource::bucket_object_type].
        pub fn set_bucket_object_type<
            T: std::convert::Into<
                    crate::model::ingest_conversations_request::gcs_source::BucketObjectType,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.bucket_object_type = v.into();
            self
        }

        /// Sets the value of [metadata_bucket_uri][crate::model::ingest_conversations_request::GcsSource::metadata_bucket_uri].
        pub fn set_metadata_bucket_uri<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.metadata_bucket_uri = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [metadata_bucket_uri][crate::model::ingest_conversations_request::GcsSource::metadata_bucket_uri].
        pub fn set_or_clear_metadata_bucket_uri<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.metadata_bucket_uri = v.map(|x| x.into());
            self
        }

        /// Sets the value of [custom_metadata_keys][crate::model::ingest_conversations_request::GcsSource::custom_metadata_keys].
        pub fn set_custom_metadata_keys<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.custom_metadata_keys = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for GcsSource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.IngestConversationsRequest.GcsSource"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for GcsSource {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __bucket_uri,
                __bucket_object_type,
                __metadata_bucket_uri,
                __custom_metadata_keys,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for GcsSource")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "bucketUri" => Ok(__FieldTag::__bucket_uri),
                                "bucket_uri" => Ok(__FieldTag::__bucket_uri),
                                "bucketObjectType" => Ok(__FieldTag::__bucket_object_type),
                                "bucket_object_type" => Ok(__FieldTag::__bucket_object_type),
                                "metadataBucketUri" => Ok(__FieldTag::__metadata_bucket_uri),
                                "metadata_bucket_uri" => Ok(__FieldTag::__metadata_bucket_uri),
                                "customMetadataKeys" => Ok(__FieldTag::__custom_metadata_keys),
                                "custom_metadata_keys" => Ok(__FieldTag::__custom_metadata_keys),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = GcsSource;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct GcsSource")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__bucket_uri => {
                                if !fields.insert(__FieldTag::__bucket_uri) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for bucket_uri",
                                    ));
                                }
                                result.bucket_uri = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__bucket_object_type => {
                                if !fields.insert(__FieldTag::__bucket_object_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for bucket_object_type",
                                    ));
                                }
                                result.bucket_object_type = map.next_value::<std::option::Option<crate::model::ingest_conversations_request::gcs_source::BucketObjectType>>()?.unwrap_or_default();
                            }
                            __FieldTag::__metadata_bucket_uri => {
                                if !fields.insert(__FieldTag::__metadata_bucket_uri) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for metadata_bucket_uri",
                                    ));
                                }
                                result.metadata_bucket_uri =
                                    map.next_value::<std::option::Option<std::string::String>>()?;
                            }
                            __FieldTag::__custom_metadata_keys => {
                                if !fields.insert(__FieldTag::__custom_metadata_keys) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for custom_metadata_keys",
                                    ));
                                }
                                result.custom_metadata_keys = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for GcsSource {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.bucket_uri.is_empty() {
                state.serialize_entry("bucketUri", &self.bucket_uri)?;
            }
            if !wkt::internal::is_default(&self.bucket_object_type) {
                state.serialize_entry("bucketObjectType", &self.bucket_object_type)?;
            }
            if self.metadata_bucket_uri.is_some() {
                state.serialize_entry("metadataBucketUri", &self.metadata_bucket_uri)?;
            }
            if !self.custom_metadata_keys.is_empty() {
                state.serialize_entry("customMetadataKeys", &self.custom_metadata_keys)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for GcsSource {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("GcsSource");
            debug_struct.field("bucket_uri", &self.bucket_uri);
            debug_struct.field("bucket_object_type", &self.bucket_object_type);
            debug_struct.field("metadata_bucket_uri", &self.metadata_bucket_uri);
            debug_struct.field("custom_metadata_keys", &self.custom_metadata_keys);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [GcsSource].
    pub mod gcs_source {
        #[allow(unused_imports)]
        use super::*;

        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum BucketObjectType {
            /// The object type is unspecified and will default to `TRANSCRIPT`.
            Unspecified,
            /// The object is a transcript.
            Transcript,
            /// The object is an audio file.
            Audio,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [BucketObjectType::value] or
            /// [BucketObjectType::name].
            UnknownValue(bucket_object_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod bucket_object_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl BucketObjectType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Transcript => std::option::Option::Some(1),
                    Self::Audio => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => {
                        std::option::Option::Some("BUCKET_OBJECT_TYPE_UNSPECIFIED")
                    }
                    Self::Transcript => std::option::Option::Some("TRANSCRIPT"),
                    Self::Audio => std::option::Option::Some("AUDIO"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for BucketObjectType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for BucketObjectType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for BucketObjectType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Transcript,
                    2 => Self::Audio,
                    _ => Self::UnknownValue(bucket_object_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for BucketObjectType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "BUCKET_OBJECT_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "TRANSCRIPT" => Self::Transcript,
                    "AUDIO" => Self::Audio,
                    _ => Self::UnknownValue(bucket_object_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for BucketObjectType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Transcript => serializer.serialize_i32(1),
                    Self::Audio => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for BucketObjectType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<BucketObjectType>::new(
                    ".google.cloud.contactcenterinsights.v1.IngestConversationsRequest.GcsSource.BucketObjectType"))
            }
        }
    }

    /// Configuration for processing transcript objects.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TranscriptObjectConfig {
        /// Required. The medium transcript objects represent.
        pub medium: crate::model::conversation::Medium,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TranscriptObjectConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [medium][crate::model::ingest_conversations_request::TranscriptObjectConfig::medium].
        pub fn set_medium<T: std::convert::Into<crate::model::conversation::Medium>>(
            mut self,
            v: T,
        ) -> Self {
            self.medium = v.into();
            self
        }
    }

    impl wkt::message::Message for TranscriptObjectConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.IngestConversationsRequest.TranscriptObjectConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for TranscriptObjectConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __medium,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for TranscriptObjectConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "medium" => Ok(__FieldTag::__medium),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = TranscriptObjectConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct TranscriptObjectConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__medium => {
                                if !fields.insert(__FieldTag::__medium) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for medium",
                                    ));
                                }
                                result.medium = map.next_value::<std::option::Option<crate::model::conversation::Medium>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for TranscriptObjectConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.medium) {
                state.serialize_entry("medium", &self.medium)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for TranscriptObjectConfig {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("TranscriptObjectConfig");
            debug_struct.field("medium", &self.medium);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Configuration that applies to all conversations.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ConversationConfig {
        /// Optional. An opaque, user-specified string representing a human agent who
        /// handled all conversations in the import. Note that this will be
        /// overridden if per-conversation metadata is provided through the
        /// `metadata_bucket_uri`.
        pub agent_id: std::string::String,

        /// Optional. Indicates which of the channels, 1 or 2, contains the agent.
        /// Note that this must be set for conversations to be properly displayed and
        /// analyzed.
        pub agent_channel: i32,

        /// Optional. Indicates which of the channels, 1 or 2, contains the agent.
        /// Note that this must be set for conversations to be properly displayed and
        /// analyzed.
        pub customer_channel: i32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ConversationConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [agent_id][crate::model::ingest_conversations_request::ConversationConfig::agent_id].
        pub fn set_agent_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.agent_id = v.into();
            self
        }

        /// Sets the value of [agent_channel][crate::model::ingest_conversations_request::ConversationConfig::agent_channel].
        pub fn set_agent_channel<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.agent_channel = v.into();
            self
        }

        /// Sets the value of [customer_channel][crate::model::ingest_conversations_request::ConversationConfig::customer_channel].
        pub fn set_customer_channel<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.customer_channel = v.into();
            self
        }
    }

    impl wkt::message::Message for ConversationConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.IngestConversationsRequest.ConversationConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ConversationConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __agent_id,
                __agent_channel,
                __customer_channel,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ConversationConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "agentId" => Ok(__FieldTag::__agent_id),
                                "agent_id" => Ok(__FieldTag::__agent_id),
                                "agentChannel" => Ok(__FieldTag::__agent_channel),
                                "agent_channel" => Ok(__FieldTag::__agent_channel),
                                "customerChannel" => Ok(__FieldTag::__customer_channel),
                                "customer_channel" => Ok(__FieldTag::__customer_channel),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ConversationConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ConversationConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__agent_id => {
                                if !fields.insert(__FieldTag::__agent_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for agent_id",
                                    ));
                                }
                                result.agent_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__agent_channel => {
                                if !fields.insert(__FieldTag::__agent_channel) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for agent_channel",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.agent_channel =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__customer_channel => {
                                if !fields.insert(__FieldTag::__customer_channel) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for customer_channel",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.customer_channel =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ConversationConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.agent_id.is_empty() {
                state.serialize_entry("agentId", &self.agent_id)?;
            }
            if !wkt::internal::is_default(&self.agent_channel) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("agentChannel", &__With(&self.agent_channel))?;
            }
            if !wkt::internal::is_default(&self.customer_channel) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("customerChannel", &__With(&self.customer_channel))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ConversationConfig {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ConversationConfig");
            debug_struct.field("agent_id", &self.agent_id);
            debug_struct.field("agent_channel", &self.agent_channel);
            debug_struct.field("customer_channel", &self.customer_channel);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Configuration for an external data store containing objects that will
    /// be converted to conversations.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// A cloud storage bucket source. Note that any previously ingested objects
        /// from the source will be skipped to avoid duplication.
        GcsSource(std::boxed::Box<crate::model::ingest_conversations_request::GcsSource>),
    }

    /// Configuration for converting individual `source` objects to conversations.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ObjectConfig {
        /// Configuration for when `source` contains conversation transcripts.
        TranscriptObjectConfig(
            std::boxed::Box<crate::model::ingest_conversations_request::TranscriptObjectConfig>,
        ),
    }
}

/// The metadata for an IngestConversations operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct IngestConversationsMetadata {
    /// Output only. The time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The original request for ingest.
    pub request: std::option::Option<crate::model::IngestConversationsRequest>,

    /// Output only. Partial errors during ingest operation that might cause the
    /// operation output to be incomplete.
    pub partial_errors: std::vec::Vec<rpc::model::Status>,

    /// Output only. Statistics for IngestConversations operation.
    pub ingest_conversations_stats:
        std::option::Option<crate::model::ingest_conversations_metadata::IngestConversationsStats>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IngestConversationsMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::IngestConversationsMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::IngestConversationsMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::IngestConversationsMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::IngestConversationsMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request][crate::model::IngestConversationsMetadata::request].
    pub fn set_request<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::IngestConversationsRequest>,
    {
        self.request = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [request][crate::model::IngestConversationsMetadata::request].
    pub fn set_or_clear_request<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::IngestConversationsRequest>,
    {
        self.request = v.map(|x| x.into());
        self
    }

    /// Sets the value of [partial_errors][crate::model::IngestConversationsMetadata::partial_errors].
    pub fn set_partial_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.partial_errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [ingest_conversations_stats][crate::model::IngestConversationsMetadata::ingest_conversations_stats].
    pub fn set_ingest_conversations_stats<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<
                crate::model::ingest_conversations_metadata::IngestConversationsStats,
            >,
    {
        self.ingest_conversations_stats = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ingest_conversations_stats][crate::model::IngestConversationsMetadata::ingest_conversations_stats].
    pub fn set_or_clear_ingest_conversations_stats<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<
                crate::model::ingest_conversations_metadata::IngestConversationsStats,
            >,
    {
        self.ingest_conversations_stats = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for IngestConversationsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.IngestConversationsMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for IngestConversationsMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __end_time,
            __request,
            __partial_errors,
            __ingest_conversations_stats,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IngestConversationsMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "request" => Ok(__FieldTag::__request),
                            "partialErrors" => Ok(__FieldTag::__partial_errors),
                            "partial_errors" => Ok(__FieldTag::__partial_errors),
                            "ingestConversationsStats" => {
                                Ok(__FieldTag::__ingest_conversations_stats)
                            }
                            "ingest_conversations_stats" => {
                                Ok(__FieldTag::__ingest_conversations_stats)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = IngestConversationsMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IngestConversationsMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__request => {
                            if !fields.insert(__FieldTag::__request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request",
                                ));
                            }
                            result.request = map.next_value::<std::option::Option<crate::model::IngestConversationsRequest>>()?
                                ;
                        }
                        __FieldTag::__partial_errors => {
                            if !fields.insert(__FieldTag::__partial_errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for partial_errors",
                                ));
                            }
                            result.partial_errors = map.next_value::<std::option::Option<std::vec::Vec<rpc::model::Status>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__ingest_conversations_stats => {
                            if !fields.insert(__FieldTag::__ingest_conversations_stats) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ingest_conversations_stats",
                                ));
                            }
                            result.ingest_conversations_stats = map.next_value::<std::option::Option<crate::model::ingest_conversations_metadata::IngestConversationsStats>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for IngestConversationsMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if self.request.is_some() {
            state.serialize_entry("request", &self.request)?;
        }
        if !self.partial_errors.is_empty() {
            state.serialize_entry("partialErrors", &self.partial_errors)?;
        }
        if self.ingest_conversations_stats.is_some() {
            state.serialize_entry("ingestConversationsStats", &self.ingest_conversations_stats)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for IngestConversationsMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IngestConversationsMetadata");
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("request", &self.request);
        debug_struct.field("partial_errors", &self.partial_errors);
        debug_struct.field(
            "ingest_conversations_stats",
            &self.ingest_conversations_stats,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [IngestConversationsMetadata].
pub mod ingest_conversations_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Statistics for IngestConversations operation.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct IngestConversationsStats {
        /// Output only. The number of objects processed during the ingest operation.
        pub processed_object_count: i32,

        /// Output only. The number of objects skipped because another conversation
        /// with the same transcript uri had already been ingested.
        pub duplicates_skipped_count: i32,

        /// Output only. The number of new conversations added during this ingest
        /// operation.
        pub successful_ingest_count: i32,

        /// Output only. The number of objects which were unable to be ingested due
        /// to errors. The errors are populated in the partial_errors field.
        pub failed_ingest_count: i32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl IngestConversationsStats {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [processed_object_count][crate::model::ingest_conversations_metadata::IngestConversationsStats::processed_object_count].
        pub fn set_processed_object_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.processed_object_count = v.into();
            self
        }

        /// Sets the value of [duplicates_skipped_count][crate::model::ingest_conversations_metadata::IngestConversationsStats::duplicates_skipped_count].
        pub fn set_duplicates_skipped_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.duplicates_skipped_count = v.into();
            self
        }

        /// Sets the value of [successful_ingest_count][crate::model::ingest_conversations_metadata::IngestConversationsStats::successful_ingest_count].
        pub fn set_successful_ingest_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.successful_ingest_count = v.into();
            self
        }

        /// Sets the value of [failed_ingest_count][crate::model::ingest_conversations_metadata::IngestConversationsStats::failed_ingest_count].
        pub fn set_failed_ingest_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.failed_ingest_count = v.into();
            self
        }
    }

    impl wkt::message::Message for IngestConversationsStats {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.IngestConversationsMetadata.IngestConversationsStats"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for IngestConversationsStats {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __processed_object_count,
                __duplicates_skipped_count,
                __successful_ingest_count,
                __failed_ingest_count,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for IngestConversationsStats")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "processedObjectCount" => Ok(__FieldTag::__processed_object_count),
                                "processed_object_count" => {
                                    Ok(__FieldTag::__processed_object_count)
                                }
                                "duplicatesSkippedCount" => {
                                    Ok(__FieldTag::__duplicates_skipped_count)
                                }
                                "duplicates_skipped_count" => {
                                    Ok(__FieldTag::__duplicates_skipped_count)
                                }
                                "successfulIngestCount" => {
                                    Ok(__FieldTag::__successful_ingest_count)
                                }
                                "successful_ingest_count" => {
                                    Ok(__FieldTag::__successful_ingest_count)
                                }
                                "failedIngestCount" => Ok(__FieldTag::__failed_ingest_count),
                                "failed_ingest_count" => Ok(__FieldTag::__failed_ingest_count),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = IngestConversationsStats;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct IngestConversationsStats")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__processed_object_count => {
                                if !fields.insert(__FieldTag::__processed_object_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for processed_object_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.processed_object_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__duplicates_skipped_count => {
                                if !fields.insert(__FieldTag::__duplicates_skipped_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for duplicates_skipped_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.duplicates_skipped_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__successful_ingest_count => {
                                if !fields.insert(__FieldTag::__successful_ingest_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for successful_ingest_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.successful_ingest_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__failed_ingest_count => {
                                if !fields.insert(__FieldTag::__failed_ingest_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for failed_ingest_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.failed_ingest_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for IngestConversationsStats {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.processed_object_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "processedObjectCount",
                    &__With(&self.processed_object_count),
                )?;
            }
            if !wkt::internal::is_default(&self.duplicates_skipped_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "duplicatesSkippedCount",
                    &__With(&self.duplicates_skipped_count),
                )?;
            }
            if !wkt::internal::is_default(&self.successful_ingest_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "successfulIngestCount",
                    &__With(&self.successful_ingest_count),
                )?;
            }
            if !wkt::internal::is_default(&self.failed_ingest_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("failedIngestCount", &__With(&self.failed_ingest_count))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for IngestConversationsStats {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("IngestConversationsStats");
            debug_struct.field("processed_object_count", &self.processed_object_count);
            debug_struct.field("duplicates_skipped_count", &self.duplicates_skipped_count);
            debug_struct.field("successful_ingest_count", &self.successful_ingest_count);
            debug_struct.field("failed_ingest_count", &self.failed_ingest_count);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// The response to an IngestConversations operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct IngestConversationsResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IngestConversationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for IngestConversationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.IngestConversationsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for IngestConversationsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IngestConversationsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = IngestConversationsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IngestConversationsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for IngestConversationsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for IngestConversationsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IngestConversationsResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request to create an analysis.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateAnalysisRequest {
    /// Required. The parent resource of the analysis.
    pub parent: std::string::String,

    /// Required. The analysis to create.
    pub analysis: std::option::Option<crate::model::Analysis>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateAnalysisRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateAnalysisRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [analysis][crate::model::CreateAnalysisRequest::analysis].
    pub fn set_analysis<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Analysis>,
    {
        self.analysis = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [analysis][crate::model::CreateAnalysisRequest::analysis].
    pub fn set_or_clear_analysis<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Analysis>,
    {
        self.analysis = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateAnalysisRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.CreateAnalysisRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateAnalysisRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __analysis,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateAnalysisRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "analysis" => Ok(__FieldTag::__analysis),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateAnalysisRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateAnalysisRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__analysis => {
                            if !fields.insert(__FieldTag::__analysis) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for analysis",
                                ));
                            }
                            result.analysis =
                                map.next_value::<std::option::Option<crate::model::Analysis>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateAnalysisRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.analysis.is_some() {
            state.serialize_entry("analysis", &self.analysis)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateAnalysisRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateAnalysisRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("analysis", &self.analysis);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request to list analyses.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAnalysesRequest {
    /// Required. The parent resource of the analyses.
    pub parent: std::string::String,

    /// The maximum number of analyses to return in the response. If this
    /// value is zero, the service will select a default size. A call might return
    /// fewer objects than requested. A non-empty `next_page_token` in the response
    /// indicates that more data is available.
    pub page_size: i32,

    /// The value returned by the last `ListAnalysesResponse`; indicates
    /// that this is a continuation of a prior `ListAnalyses` call and
    /// the system should return the next page of data.
    pub page_token: std::string::String,

    /// A filter to reduce results to a specific subset. Useful for querying
    /// conversations with specific properties.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAnalysesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAnalysesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAnalysesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAnalysesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListAnalysesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListAnalysesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ListAnalysesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAnalysesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAnalysesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAnalysesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAnalysesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAnalysesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListAnalysesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListAnalysesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response to list analyses.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAnalysesResponse {
    /// The analyses that match the request.
    pub analyses: std::vec::Vec<crate::model::Analysis>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAnalysesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [analyses][crate::model::ListAnalysesResponse::analyses].
    pub fn set_analyses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Analysis>,
    {
        use std::iter::Iterator;
        self.analyses = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAnalysesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAnalysesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ListAnalysesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAnalysesResponse {
    type PageItem = crate::model::Analysis;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.analyses
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAnalysesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __analyses,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAnalysesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "analyses" => Ok(__FieldTag::__analyses),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAnalysesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAnalysesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__analyses => {
                            if !fields.insert(__FieldTag::__analyses) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for analyses",
                                ));
                            }
                            result.analyses = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Analysis>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAnalysesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.analyses.is_empty() {
            state.serialize_entry("analyses", &self.analyses)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListAnalysesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListAnalysesResponse");
        debug_struct.field("analyses", &self.analyses);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request to get an analysis.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetAnalysisRequest {
    /// Required. The name of the analysis to get.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetAnalysisRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAnalysisRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAnalysisRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.GetAnalysisRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetAnalysisRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetAnalysisRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetAnalysisRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetAnalysisRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetAnalysisRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetAnalysisRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetAnalysisRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request to delete an analysis.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteAnalysisRequest {
    /// Required. The name of the analysis to delete.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteAnalysisRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteAnalysisRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAnalysisRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.DeleteAnalysisRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteAnalysisRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteAnalysisRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteAnalysisRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteAnalysisRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteAnalysisRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteAnalysisRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteAnalysisRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request to analyze conversations in bulk.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BulkAnalyzeConversationsRequest {
    /// Required. The parent resource to create analyses in.
    pub parent: std::string::String,

    /// Required. Filter used to select the subset of conversations to analyze.
    pub filter: std::string::String,

    /// Required. Percentage of selected conversation to analyze, between
    /// [0, 100].
    pub analysis_percentage: f32,

    /// To select the annotators to run and the phrase matchers to use
    /// (if any). If not specified, all annotators will be run.
    pub annotator_selector: std::option::Option<crate::model::AnnotatorSelector>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BulkAnalyzeConversationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BulkAnalyzeConversationsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::BulkAnalyzeConversationsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [analysis_percentage][crate::model::BulkAnalyzeConversationsRequest::analysis_percentage].
    pub fn set_analysis_percentage<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.analysis_percentage = v.into();
        self
    }

    /// Sets the value of [annotator_selector][crate::model::BulkAnalyzeConversationsRequest::annotator_selector].
    pub fn set_annotator_selector<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AnnotatorSelector>,
    {
        self.annotator_selector = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [annotator_selector][crate::model::BulkAnalyzeConversationsRequest::annotator_selector].
    pub fn set_or_clear_annotator_selector<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AnnotatorSelector>,
    {
        self.annotator_selector = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for BulkAnalyzeConversationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.BulkAnalyzeConversationsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BulkAnalyzeConversationsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            __analysis_percentage,
            __annotator_selector,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BulkAnalyzeConversationsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "analysisPercentage" => Ok(__FieldTag::__analysis_percentage),
                            "analysis_percentage" => Ok(__FieldTag::__analysis_percentage),
                            "annotatorSelector" => Ok(__FieldTag::__annotator_selector),
                            "annotator_selector" => Ok(__FieldTag::__annotator_selector),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BulkAnalyzeConversationsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BulkAnalyzeConversationsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__analysis_percentage => {
                            if !fields.insert(__FieldTag::__analysis_percentage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for analysis_percentage",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.analysis_percentage =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__annotator_selector => {
                            if !fields.insert(__FieldTag::__annotator_selector) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotator_selector",
                                ));
                            }
                            result.annotator_selector = map
                                .next_value::<std::option::Option<crate::model::AnnotatorSelector>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BulkAnalyzeConversationsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.analysis_percentage) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("analysisPercentage", &__With(&self.analysis_percentage))?;
        }
        if self.annotator_selector.is_some() {
            state.serialize_entry("annotatorSelector", &self.annotator_selector)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BulkAnalyzeConversationsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BulkAnalyzeConversationsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("analysis_percentage", &self.analysis_percentage);
        debug_struct.field("annotator_selector", &self.annotator_selector);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The metadata for a bulk analyze conversations operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BulkAnalyzeConversationsMetadata {
    /// The time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The time the operation finished running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The original request for bulk analyze.
    pub request: std::option::Option<crate::model::BulkAnalyzeConversationsRequest>,

    /// The number of requested analyses that have completed successfully so far.
    pub completed_analyses_count: i32,

    /// The number of requested analyses that have failed so far.
    pub failed_analyses_count: i32,

    /// Total number of analyses requested. Computed by the number of conversations
    /// returned by `filter` multiplied by `analysis_percentage` in the request.
    pub total_requested_analyses_count: i32,

    /// Output only. Partial errors during bulk analyze operation that might cause
    /// the operation output to be incomplete.
    pub partial_errors: std::vec::Vec<rpc::model::Status>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BulkAnalyzeConversationsMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::BulkAnalyzeConversationsMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::BulkAnalyzeConversationsMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::BulkAnalyzeConversationsMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::BulkAnalyzeConversationsMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request][crate::model::BulkAnalyzeConversationsMetadata::request].
    pub fn set_request<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BulkAnalyzeConversationsRequest>,
    {
        self.request = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [request][crate::model::BulkAnalyzeConversationsMetadata::request].
    pub fn set_or_clear_request<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BulkAnalyzeConversationsRequest>,
    {
        self.request = v.map(|x| x.into());
        self
    }

    /// Sets the value of [completed_analyses_count][crate::model::BulkAnalyzeConversationsMetadata::completed_analyses_count].
    pub fn set_completed_analyses_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.completed_analyses_count = v.into();
        self
    }

    /// Sets the value of [failed_analyses_count][crate::model::BulkAnalyzeConversationsMetadata::failed_analyses_count].
    pub fn set_failed_analyses_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.failed_analyses_count = v.into();
        self
    }

    /// Sets the value of [total_requested_analyses_count][crate::model::BulkAnalyzeConversationsMetadata::total_requested_analyses_count].
    pub fn set_total_requested_analyses_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_requested_analyses_count = v.into();
        self
    }

    /// Sets the value of [partial_errors][crate::model::BulkAnalyzeConversationsMetadata::partial_errors].
    pub fn set_partial_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.partial_errors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BulkAnalyzeConversationsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.BulkAnalyzeConversationsMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BulkAnalyzeConversationsMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __end_time,
            __request,
            __completed_analyses_count,
            __failed_analyses_count,
            __total_requested_analyses_count,
            __partial_errors,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BulkAnalyzeConversationsMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "request" => Ok(__FieldTag::__request),
                            "completedAnalysesCount" => Ok(__FieldTag::__completed_analyses_count),
                            "completed_analyses_count" => {
                                Ok(__FieldTag::__completed_analyses_count)
                            }
                            "failedAnalysesCount" => Ok(__FieldTag::__failed_analyses_count),
                            "failed_analyses_count" => Ok(__FieldTag::__failed_analyses_count),
                            "totalRequestedAnalysesCount" => {
                                Ok(__FieldTag::__total_requested_analyses_count)
                            }
                            "total_requested_analyses_count" => {
                                Ok(__FieldTag::__total_requested_analyses_count)
                            }
                            "partialErrors" => Ok(__FieldTag::__partial_errors),
                            "partial_errors" => Ok(__FieldTag::__partial_errors),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BulkAnalyzeConversationsMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BulkAnalyzeConversationsMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__request => {
                            if !fields.insert(__FieldTag::__request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request",
                                ));
                            }
                            result.request = map.next_value::<std::option::Option<
                                crate::model::BulkAnalyzeConversationsRequest,
                            >>()?;
                        }
                        __FieldTag::__completed_analyses_count => {
                            if !fields.insert(__FieldTag::__completed_analyses_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for completed_analyses_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.completed_analyses_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__failed_analyses_count => {
                            if !fields.insert(__FieldTag::__failed_analyses_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for failed_analyses_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.failed_analyses_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__total_requested_analyses_count => {
                            if !fields.insert(__FieldTag::__total_requested_analyses_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_requested_analyses_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_requested_analyses_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__partial_errors => {
                            if !fields.insert(__FieldTag::__partial_errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for partial_errors",
                                ));
                            }
                            result.partial_errors = map.next_value::<std::option::Option<std::vec::Vec<rpc::model::Status>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BulkAnalyzeConversationsMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if self.request.is_some() {
            state.serialize_entry("request", &self.request)?;
        }
        if !wkt::internal::is_default(&self.completed_analyses_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "completedAnalysesCount",
                &__With(&self.completed_analyses_count),
            )?;
        }
        if !wkt::internal::is_default(&self.failed_analyses_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("failedAnalysesCount", &__With(&self.failed_analyses_count))?;
        }
        if !wkt::internal::is_default(&self.total_requested_analyses_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "totalRequestedAnalysesCount",
                &__With(&self.total_requested_analyses_count),
            )?;
        }
        if !self.partial_errors.is_empty() {
            state.serialize_entry("partialErrors", &self.partial_errors)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BulkAnalyzeConversationsMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BulkAnalyzeConversationsMetadata");
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("request", &self.request);
        debug_struct.field("completed_analyses_count", &self.completed_analyses_count);
        debug_struct.field("failed_analyses_count", &self.failed_analyses_count);
        debug_struct.field(
            "total_requested_analyses_count",
            &self.total_requested_analyses_count,
        );
        debug_struct.field("partial_errors", &self.partial_errors);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response for a bulk analyze conversations operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BulkAnalyzeConversationsResponse {
    /// Count of successful analyses.
    pub successful_analysis_count: i32,

    /// Count of failed analyses.
    pub failed_analysis_count: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BulkAnalyzeConversationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [successful_analysis_count][crate::model::BulkAnalyzeConversationsResponse::successful_analysis_count].
    pub fn set_successful_analysis_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.successful_analysis_count = v.into();
        self
    }

    /// Sets the value of [failed_analysis_count][crate::model::BulkAnalyzeConversationsResponse::failed_analysis_count].
    pub fn set_failed_analysis_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.failed_analysis_count = v.into();
        self
    }
}

impl wkt::message::Message for BulkAnalyzeConversationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.BulkAnalyzeConversationsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BulkAnalyzeConversationsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __successful_analysis_count,
            __failed_analysis_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BulkAnalyzeConversationsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "successfulAnalysisCount" => {
                                Ok(__FieldTag::__successful_analysis_count)
                            }
                            "successful_analysis_count" => {
                                Ok(__FieldTag::__successful_analysis_count)
                            }
                            "failedAnalysisCount" => Ok(__FieldTag::__failed_analysis_count),
                            "failed_analysis_count" => Ok(__FieldTag::__failed_analysis_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BulkAnalyzeConversationsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BulkAnalyzeConversationsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__successful_analysis_count => {
                            if !fields.insert(__FieldTag::__successful_analysis_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for successful_analysis_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.successful_analysis_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__failed_analysis_count => {
                            if !fields.insert(__FieldTag::__failed_analysis_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for failed_analysis_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.failed_analysis_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BulkAnalyzeConversationsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.successful_analysis_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "successfulAnalysisCount",
                &__With(&self.successful_analysis_count),
            )?;
        }
        if !wkt::internal::is_default(&self.failed_analysis_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("failedAnalysisCount", &__With(&self.failed_analysis_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BulkAnalyzeConversationsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BulkAnalyzeConversationsResponse");
        debug_struct.field("successful_analysis_count", &self.successful_analysis_count);
        debug_struct.field("failed_analysis_count", &self.failed_analysis_count);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request to delete conversations in bulk.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BulkDeleteConversationsRequest {
    /// Required. The parent resource to delete conversations from.
    /// Format:
    /// projects/{project}/locations/{location}
    pub parent: std::string::String,

    /// Filter used to select the subset of conversations to delete.
    pub filter: std::string::String,

    /// Maximum number of conversations to delete.
    pub max_delete_count: i32,

    /// If set to true, all of this conversation's analyses will also be deleted.
    /// Otherwise, the request will only succeed if the conversation has no
    /// analyses.
    pub force: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BulkDeleteConversationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BulkDeleteConversationsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::BulkDeleteConversationsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [max_delete_count][crate::model::BulkDeleteConversationsRequest::max_delete_count].
    pub fn set_max_delete_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_delete_count = v.into();
        self
    }

    /// Sets the value of [force][crate::model::BulkDeleteConversationsRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for BulkDeleteConversationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.BulkDeleteConversationsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BulkDeleteConversationsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            __max_delete_count,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BulkDeleteConversationsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "maxDeleteCount" => Ok(__FieldTag::__max_delete_count),
                            "max_delete_count" => Ok(__FieldTag::__max_delete_count),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BulkDeleteConversationsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BulkDeleteConversationsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__max_delete_count => {
                            if !fields.insert(__FieldTag::__max_delete_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_delete_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_delete_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BulkDeleteConversationsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.max_delete_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxDeleteCount", &__With(&self.max_delete_count))?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BulkDeleteConversationsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BulkDeleteConversationsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("max_delete_count", &self.max_delete_count);
        debug_struct.field("force", &self.force);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The metadata for a bulk delete conversations operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BulkDeleteConversationsMetadata {
    /// The time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The time the operation finished running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The original request for bulk delete.
    pub request: std::option::Option<crate::model::BulkDeleteConversationsRequest>,

    /// Partial errors during bulk delete conversations operation that might cause
    /// the operation output to be incomplete.
    pub partial_errors: std::vec::Vec<rpc::model::Status>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BulkDeleteConversationsMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::BulkDeleteConversationsMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::BulkDeleteConversationsMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::BulkDeleteConversationsMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::BulkDeleteConversationsMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request][crate::model::BulkDeleteConversationsMetadata::request].
    pub fn set_request<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BulkDeleteConversationsRequest>,
    {
        self.request = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [request][crate::model::BulkDeleteConversationsMetadata::request].
    pub fn set_or_clear_request<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BulkDeleteConversationsRequest>,
    {
        self.request = v.map(|x| x.into());
        self
    }

    /// Sets the value of [partial_errors][crate::model::BulkDeleteConversationsMetadata::partial_errors].
    pub fn set_partial_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.partial_errors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BulkDeleteConversationsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.BulkDeleteConversationsMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BulkDeleteConversationsMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __end_time,
            __request,
            __partial_errors,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BulkDeleteConversationsMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "request" => Ok(__FieldTag::__request),
                            "partialErrors" => Ok(__FieldTag::__partial_errors),
                            "partial_errors" => Ok(__FieldTag::__partial_errors),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BulkDeleteConversationsMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BulkDeleteConversationsMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__request => {
                            if !fields.insert(__FieldTag::__request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request",
                                ));
                            }
                            result.request =
                                map.next_value::<std::option::Option<
                                    crate::model::BulkDeleteConversationsRequest,
                                >>()?;
                        }
                        __FieldTag::__partial_errors => {
                            if !fields.insert(__FieldTag::__partial_errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for partial_errors",
                                ));
                            }
                            result.partial_errors = map.next_value::<std::option::Option<std::vec::Vec<rpc::model::Status>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BulkDeleteConversationsMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if self.request.is_some() {
            state.serialize_entry("request", &self.request)?;
        }
        if !self.partial_errors.is_empty() {
            state.serialize_entry("partialErrors", &self.partial_errors)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BulkDeleteConversationsMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BulkDeleteConversationsMetadata");
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("request", &self.request);
        debug_struct.field("partial_errors", &self.partial_errors);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response for a bulk delete conversations operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BulkDeleteConversationsResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BulkDeleteConversationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for BulkDeleteConversationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.BulkDeleteConversationsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BulkDeleteConversationsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BulkDeleteConversationsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BulkDeleteConversationsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BulkDeleteConversationsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BulkDeleteConversationsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BulkDeleteConversationsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BulkDeleteConversationsResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request to export insights.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportInsightsDataRequest {
    /// Required. The parent resource to export data from.
    pub parent: std::string::String,

    /// A filter to reduce results to a specific subset. Useful for exporting
    /// conversations with specific properties.
    pub filter: std::string::String,

    /// A fully qualified KMS key name for BigQuery tables protected by CMEK.
    /// Format:
    /// projects/{project}/locations/{location}/keyRings/{keyring}/cryptoKeys/{key}/cryptoKeyVersions/{version}
    pub kms_key: std::string::String,

    /// Options for what to do if the destination table already exists.
    pub write_disposition: crate::model::export_insights_data_request::WriteDisposition,

    /// Exporter destination.
    pub destination: std::option::Option<crate::model::export_insights_data_request::Destination>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExportInsightsDataRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ExportInsightsDataRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ExportInsightsDataRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [kms_key][crate::model::ExportInsightsDataRequest::kms_key].
    pub fn set_kms_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key = v.into();
        self
    }

    /// Sets the value of [write_disposition][crate::model::ExportInsightsDataRequest::write_disposition].
    pub fn set_write_disposition<
        T: std::convert::Into<crate::model::export_insights_data_request::WriteDisposition>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.write_disposition = v.into();
        self
    }

    /// Sets the value of [destination][crate::model::ExportInsightsDataRequest::destination].
    ///
    /// Note that all the setters affecting `destination` are mutually
    /// exclusive.
    pub fn set_destination<
        T: std::convert::Into<
                std::option::Option<crate::model::export_insights_data_request::Destination>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::ExportInsightsDataRequest::destination]
    /// if it holds a `BigQueryDestination`, `None` if the field is not set or
    /// holds a different branch.
    pub fn big_query_destination(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::export_insights_data_request::BigQueryDestination>,
    > {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::export_insights_data_request::Destination::BigQueryDestination(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::ExportInsightsDataRequest::destination]
    /// to hold a `BigQueryDestination`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_big_query_destination<
        T: std::convert::Into<
                std::boxed::Box<crate::model::export_insights_data_request::BigQueryDestination>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::export_insights_data_request::Destination::BigQueryDestination(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ExportInsightsDataRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ExportInsightsDataRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExportInsightsDataRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __big_query_destination,
            __parent,
            __filter,
            __kms_key,
            __write_disposition,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportInsightsDataRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bigQueryDestination" => Ok(__FieldTag::__big_query_destination),
                            "big_query_destination" => Ok(__FieldTag::__big_query_destination),
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "kmsKey" => Ok(__FieldTag::__kms_key),
                            "kms_key" => Ok(__FieldTag::__kms_key),
                            "writeDisposition" => Ok(__FieldTag::__write_disposition),
                            "write_disposition" => Ok(__FieldTag::__write_disposition),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExportInsightsDataRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportInsightsDataRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__big_query_destination => {
                            if !fields.insert(__FieldTag::__big_query_destination) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for big_query_destination",
                                ));
                            }
                            if result.destination.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `destination`, a oneof with full ID .google.cloud.contactcenterinsights.v1.ExportInsightsDataRequest.big_query_destination, latest field was bigQueryDestination",
                                ));
                            }
                            result.destination = std::option::Option::Some(
                                crate::model::export_insights_data_request::Destination::BigQueryDestination(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::export_insights_data_request::BigQueryDestination>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kms_key => {
                            if !fields.insert(__FieldTag::__kms_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key",
                                ));
                            }
                            result.kms_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__write_disposition => {
                            if !fields.insert(__FieldTag::__write_disposition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for write_disposition",
                                ));
                            }
                            result.write_disposition = map
                                .next_value::<std::option::Option<
                                    crate::model::export_insights_data_request::WriteDisposition,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExportInsightsDataRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.big_query_destination() {
            state.serialize_entry("bigQueryDestination", value)?;
        }
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.kms_key.is_empty() {
            state.serialize_entry("kmsKey", &self.kms_key)?;
        }
        if !wkt::internal::is_default(&self.write_disposition) {
            state.serialize_entry("writeDisposition", &self.write_disposition)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ExportInsightsDataRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExportInsightsDataRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("kms_key", &self.kms_key);
        debug_struct.field("write_disposition", &self.write_disposition);
        debug_struct.field("destination", &self.destination);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ExportInsightsDataRequest].
pub mod export_insights_data_request {
    #[allow(unused_imports)]
    use super::*;

    /// A BigQuery Table Reference.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct BigQueryDestination {
        /// A project ID or number. If specified, then export will attempt to
        /// write data to this project instead of the resource project. Otherwise,
        /// the resource project will be used.
        pub project_id: std::string::String,

        /// Required. The name of the BigQuery dataset that the snapshot result
        /// should be exported to. If this dataset does not exist, the export call
        /// returns an INVALID_ARGUMENT error.
        pub dataset: std::string::String,

        /// The BigQuery table name to which the insights data should be written.
        /// If this table does not exist, the export call returns an INVALID_ARGUMENT
        /// error.
        pub table: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BigQueryDestination {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [project_id][crate::model::export_insights_data_request::BigQueryDestination::project_id].
        pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project_id = v.into();
            self
        }

        /// Sets the value of [dataset][crate::model::export_insights_data_request::BigQueryDestination::dataset].
        pub fn set_dataset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.dataset = v.into();
            self
        }

        /// Sets the value of [table][crate::model::export_insights_data_request::BigQueryDestination::table].
        pub fn set_table<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.table = v.into();
            self
        }
    }

    impl wkt::message::Message for BigQueryDestination {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.ExportInsightsDataRequest.BigQueryDestination"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for BigQueryDestination {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __project_id,
                __dataset,
                __table,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for BigQueryDestination")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "projectId" => Ok(__FieldTag::__project_id),
                                "project_id" => Ok(__FieldTag::__project_id),
                                "dataset" => Ok(__FieldTag::__dataset),
                                "table" => Ok(__FieldTag::__table),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = BigQueryDestination;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct BigQueryDestination")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__project_id => {
                                if !fields.insert(__FieldTag::__project_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for project_id",
                                    ));
                                }
                                result.project_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__dataset => {
                                if !fields.insert(__FieldTag::__dataset) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for dataset",
                                    ));
                                }
                                result.dataset = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__table => {
                                if !fields.insert(__FieldTag::__table) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for table",
                                    ));
                                }
                                result.table = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for BigQueryDestination {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.project_id.is_empty() {
                state.serialize_entry("projectId", &self.project_id)?;
            }
            if !self.dataset.is_empty() {
                state.serialize_entry("dataset", &self.dataset)?;
            }
            if !self.table.is_empty() {
                state.serialize_entry("table", &self.table)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for BigQueryDestination {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("BigQueryDestination");
            debug_struct.field("project_id", &self.project_id);
            debug_struct.field("dataset", &self.dataset);
            debug_struct.field("table", &self.table);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Specifies the action that occurs if the destination table already exists.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum WriteDisposition {
        /// Write disposition is not specified. Defaults to WRITE_TRUNCATE.
        Unspecified,
        /// If the table already exists, BigQuery will overwrite the table data and
        /// use the schema from the load.
        WriteTruncate,
        /// If the table already exists, BigQuery will append data to the table.
        WriteAppend,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [WriteDisposition::value] or
        /// [WriteDisposition::name].
        UnknownValue(write_disposition::UnknownValue),
    }

    #[doc(hidden)]
    pub mod write_disposition {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl WriteDisposition {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::WriteTruncate => std::option::Option::Some(1),
                Self::WriteAppend => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("WRITE_DISPOSITION_UNSPECIFIED"),
                Self::WriteTruncate => std::option::Option::Some("WRITE_TRUNCATE"),
                Self::WriteAppend => std::option::Option::Some("WRITE_APPEND"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for WriteDisposition {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for WriteDisposition {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for WriteDisposition {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::WriteTruncate,
                2 => Self::WriteAppend,
                _ => Self::UnknownValue(write_disposition::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for WriteDisposition {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "WRITE_DISPOSITION_UNSPECIFIED" => Self::Unspecified,
                "WRITE_TRUNCATE" => Self::WriteTruncate,
                "WRITE_APPEND" => Self::WriteAppend,
                _ => Self::UnknownValue(write_disposition::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for WriteDisposition {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::WriteTruncate => serializer.serialize_i32(1),
                Self::WriteAppend => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for WriteDisposition {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<WriteDisposition>::new(
                ".google.cloud.contactcenterinsights.v1.ExportInsightsDataRequest.WriteDisposition",
            ))
        }
    }

    /// Exporter destination.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Destination {
        /// Specified if sink is a BigQuery table.
        BigQueryDestination(
            std::boxed::Box<crate::model::export_insights_data_request::BigQueryDestination>,
        ),
    }
}

/// Metadata for an export insights operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportInsightsDataMetadata {
    /// Output only. The time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The original request for export.
    pub request: std::option::Option<crate::model::ExportInsightsDataRequest>,

    /// Partial errors during export operation that might cause the operation
    /// output to be incomplete.
    pub partial_errors: std::vec::Vec<rpc::model::Status>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExportInsightsDataMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::ExportInsightsDataMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ExportInsightsDataMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::ExportInsightsDataMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::ExportInsightsDataMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request][crate::model::ExportInsightsDataMetadata::request].
    pub fn set_request<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ExportInsightsDataRequest>,
    {
        self.request = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [request][crate::model::ExportInsightsDataMetadata::request].
    pub fn set_or_clear_request<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ExportInsightsDataRequest>,
    {
        self.request = v.map(|x| x.into());
        self
    }

    /// Sets the value of [partial_errors][crate::model::ExportInsightsDataMetadata::partial_errors].
    pub fn set_partial_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.partial_errors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ExportInsightsDataMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ExportInsightsDataMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExportInsightsDataMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __end_time,
            __request,
            __partial_errors,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportInsightsDataMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "request" => Ok(__FieldTag::__request),
                            "partialErrors" => Ok(__FieldTag::__partial_errors),
                            "partial_errors" => Ok(__FieldTag::__partial_errors),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExportInsightsDataMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportInsightsDataMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__request => {
                            if !fields.insert(__FieldTag::__request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request",
                                ));
                            }
                            result.request = map.next_value::<std::option::Option<crate::model::ExportInsightsDataRequest>>()?
                                ;
                        }
                        __FieldTag::__partial_errors => {
                            if !fields.insert(__FieldTag::__partial_errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for partial_errors",
                                ));
                            }
                            result.partial_errors = map.next_value::<std::option::Option<std::vec::Vec<rpc::model::Status>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExportInsightsDataMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if self.request.is_some() {
            state.serialize_entry("request", &self.request)?;
        }
        if !self.partial_errors.is_empty() {
            state.serialize_entry("partialErrors", &self.partial_errors)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ExportInsightsDataMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExportInsightsDataMetadata");
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("request", &self.request);
        debug_struct.field("partial_errors", &self.partial_errors);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response for an export insights operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportInsightsDataResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExportInsightsDataResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ExportInsightsDataResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ExportInsightsDataResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExportInsightsDataResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportInsightsDataResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExportInsightsDataResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportInsightsDataResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExportInsightsDataResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ExportInsightsDataResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExportInsightsDataResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request to create an issue model.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateIssueModelRequest {
    /// Required. The parent resource of the issue model.
    pub parent: std::string::String,

    /// Required. The issue model to create.
    pub issue_model: std::option::Option<crate::model::IssueModel>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateIssueModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateIssueModelRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [issue_model][crate::model::CreateIssueModelRequest::issue_model].
    pub fn set_issue_model<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::IssueModel>,
    {
        self.issue_model = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [issue_model][crate::model::CreateIssueModelRequest::issue_model].
    pub fn set_or_clear_issue_model<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::IssueModel>,
    {
        self.issue_model = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateIssueModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.CreateIssueModelRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateIssueModelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __issue_model,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateIssueModelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "issueModel" => Ok(__FieldTag::__issue_model),
                            "issue_model" => Ok(__FieldTag::__issue_model),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateIssueModelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateIssueModelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__issue_model => {
                            if !fields.insert(__FieldTag::__issue_model) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for issue_model",
                                ));
                            }
                            result.issue_model =
                                map.next_value::<std::option::Option<crate::model::IssueModel>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateIssueModelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.issue_model.is_some() {
            state.serialize_entry("issueModel", &self.issue_model)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateIssueModelRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateIssueModelRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("issue_model", &self.issue_model);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Metadata for creating an issue model.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateIssueModelMetadata {
    /// Output only. The time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The original request for creation.
    pub request: std::option::Option<crate::model::CreateIssueModelRequest>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateIssueModelMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::CreateIssueModelMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::CreateIssueModelMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::CreateIssueModelMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::CreateIssueModelMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request][crate::model::CreateIssueModelMetadata::request].
    pub fn set_request<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CreateIssueModelRequest>,
    {
        self.request = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [request][crate::model::CreateIssueModelMetadata::request].
    pub fn set_or_clear_request<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CreateIssueModelRequest>,
    {
        self.request = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateIssueModelMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.CreateIssueModelMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateIssueModelMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __end_time,
            __request,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateIssueModelMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "request" => Ok(__FieldTag::__request),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateIssueModelMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateIssueModelMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__request => {
                            if !fields.insert(__FieldTag::__request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request",
                                ));
                            }
                            result.request = map.next_value::<std::option::Option<crate::model::CreateIssueModelRequest>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateIssueModelMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if self.request.is_some() {
            state.serialize_entry("request", &self.request)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateIssueModelMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateIssueModelMetadata");
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("request", &self.request);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request to update an issue model.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateIssueModelRequest {
    /// Required. The new values for the issue model.
    pub issue_model: std::option::Option<crate::model::IssueModel>,

    /// The list of fields to be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateIssueModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [issue_model][crate::model::UpdateIssueModelRequest::issue_model].
    pub fn set_issue_model<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::IssueModel>,
    {
        self.issue_model = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [issue_model][crate::model::UpdateIssueModelRequest::issue_model].
    pub fn set_or_clear_issue_model<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::IssueModel>,
    {
        self.issue_model = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateIssueModelRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateIssueModelRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateIssueModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.UpdateIssueModelRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateIssueModelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __issue_model,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateIssueModelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "issueModel" => Ok(__FieldTag::__issue_model),
                            "issue_model" => Ok(__FieldTag::__issue_model),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateIssueModelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateIssueModelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__issue_model => {
                            if !fields.insert(__FieldTag::__issue_model) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for issue_model",
                                ));
                            }
                            result.issue_model =
                                map.next_value::<std::option::Option<crate::model::IssueModel>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateIssueModelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.issue_model.is_some() {
            state.serialize_entry("issueModel", &self.issue_model)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateIssueModelRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateIssueModelRequest");
        debug_struct.field("issue_model", &self.issue_model);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request to list issue models.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListIssueModelsRequest {
    /// Required. The parent resource of the issue model.
    pub parent: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListIssueModelsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListIssueModelsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for ListIssueModelsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ListIssueModelsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListIssueModelsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListIssueModelsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListIssueModelsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListIssueModelsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListIssueModelsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListIssueModelsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListIssueModelsRequest");
        debug_struct.field("parent", &self.parent);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response of listing issue models.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListIssueModelsResponse {
    /// The issue models that match the request.
    pub issue_models: std::vec::Vec<crate::model::IssueModel>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListIssueModelsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [issue_models][crate::model::ListIssueModelsResponse::issue_models].
    pub fn set_issue_models<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::IssueModel>,
    {
        use std::iter::Iterator;
        self.issue_models = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListIssueModelsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ListIssueModelsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListIssueModelsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __issue_models,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListIssueModelsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "issueModels" => Ok(__FieldTag::__issue_models),
                            "issue_models" => Ok(__FieldTag::__issue_models),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListIssueModelsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListIssueModelsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__issue_models => {
                            if !fields.insert(__FieldTag::__issue_models) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for issue_models",
                                ));
                            }
                            result.issue_models = map.next_value::<std::option::Option<std::vec::Vec<crate::model::IssueModel>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListIssueModelsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.issue_models.is_empty() {
            state.serialize_entry("issueModels", &self.issue_models)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListIssueModelsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListIssueModelsResponse");
        debug_struct.field("issue_models", &self.issue_models);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request to get an issue model.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetIssueModelRequest {
    /// Required. The name of the issue model to get.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetIssueModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetIssueModelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetIssueModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.GetIssueModelRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetIssueModelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetIssueModelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetIssueModelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetIssueModelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetIssueModelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetIssueModelRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetIssueModelRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request to delete an issue model.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteIssueModelRequest {
    /// Required. The name of the issue model to delete.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteIssueModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteIssueModelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteIssueModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.DeleteIssueModelRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteIssueModelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteIssueModelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteIssueModelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteIssueModelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteIssueModelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteIssueModelRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteIssueModelRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Metadata for deleting an issue model.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteIssueModelMetadata {
    /// Output only. The time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The original request for deletion.
    pub request: std::option::Option<crate::model::DeleteIssueModelRequest>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteIssueModelMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::DeleteIssueModelMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::DeleteIssueModelMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::DeleteIssueModelMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::DeleteIssueModelMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request][crate::model::DeleteIssueModelMetadata::request].
    pub fn set_request<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DeleteIssueModelRequest>,
    {
        self.request = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [request][crate::model::DeleteIssueModelMetadata::request].
    pub fn set_or_clear_request<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DeleteIssueModelRequest>,
    {
        self.request = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DeleteIssueModelMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.DeleteIssueModelMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteIssueModelMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __end_time,
            __request,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteIssueModelMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "request" => Ok(__FieldTag::__request),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteIssueModelMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteIssueModelMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__request => {
                            if !fields.insert(__FieldTag::__request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request",
                                ));
                            }
                            result.request = map.next_value::<std::option::Option<crate::model::DeleteIssueModelRequest>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteIssueModelMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if self.request.is_some() {
            state.serialize_entry("request", &self.request)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteIssueModelMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteIssueModelMetadata");
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("request", &self.request);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request to deploy an issue model.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeployIssueModelRequest {
    /// Required. The issue model to deploy.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeployIssueModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeployIssueModelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeployIssueModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.DeployIssueModelRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeployIssueModelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeployIssueModelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeployIssueModelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeployIssueModelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeployIssueModelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeployIssueModelRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeployIssueModelRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response to deploy an issue model.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeployIssueModelResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeployIssueModelResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for DeployIssueModelResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.DeployIssueModelResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeployIssueModelResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeployIssueModelResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeployIssueModelResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeployIssueModelResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeployIssueModelResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeployIssueModelResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeployIssueModelResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Metadata for deploying an issue model.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeployIssueModelMetadata {
    /// Output only. The time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The original request for deployment.
    pub request: std::option::Option<crate::model::DeployIssueModelRequest>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeployIssueModelMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::DeployIssueModelMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::DeployIssueModelMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::DeployIssueModelMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::DeployIssueModelMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request][crate::model::DeployIssueModelMetadata::request].
    pub fn set_request<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DeployIssueModelRequest>,
    {
        self.request = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [request][crate::model::DeployIssueModelMetadata::request].
    pub fn set_or_clear_request<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DeployIssueModelRequest>,
    {
        self.request = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DeployIssueModelMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.DeployIssueModelMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeployIssueModelMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __end_time,
            __request,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeployIssueModelMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "request" => Ok(__FieldTag::__request),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeployIssueModelMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeployIssueModelMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__request => {
                            if !fields.insert(__FieldTag::__request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request",
                                ));
                            }
                            result.request = map.next_value::<std::option::Option<crate::model::DeployIssueModelRequest>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeployIssueModelMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if self.request.is_some() {
            state.serialize_entry("request", &self.request)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeployIssueModelMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeployIssueModelMetadata");
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("request", &self.request);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request to undeploy an issue model.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UndeployIssueModelRequest {
    /// Required. The issue model to undeploy.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UndeployIssueModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UndeployIssueModelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for UndeployIssueModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.UndeployIssueModelRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UndeployIssueModelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UndeployIssueModelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UndeployIssueModelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UndeployIssueModelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UndeployIssueModelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UndeployIssueModelRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UndeployIssueModelRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response to undeploy an issue model.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UndeployIssueModelResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UndeployIssueModelResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for UndeployIssueModelResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.UndeployIssueModelResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UndeployIssueModelResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UndeployIssueModelResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UndeployIssueModelResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UndeployIssueModelResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UndeployIssueModelResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UndeployIssueModelResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UndeployIssueModelResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Metadata for undeploying an issue model.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UndeployIssueModelMetadata {
    /// Output only. The time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The original request for undeployment.
    pub request: std::option::Option<crate::model::UndeployIssueModelRequest>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UndeployIssueModelMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::UndeployIssueModelMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::UndeployIssueModelMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::UndeployIssueModelMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::UndeployIssueModelMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request][crate::model::UndeployIssueModelMetadata::request].
    pub fn set_request<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UndeployIssueModelRequest>,
    {
        self.request = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [request][crate::model::UndeployIssueModelMetadata::request].
    pub fn set_or_clear_request<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UndeployIssueModelRequest>,
    {
        self.request = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UndeployIssueModelMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.UndeployIssueModelMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UndeployIssueModelMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __end_time,
            __request,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UndeployIssueModelMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "request" => Ok(__FieldTag::__request),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UndeployIssueModelMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UndeployIssueModelMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__request => {
                            if !fields.insert(__FieldTag::__request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request",
                                ));
                            }
                            result.request = map.next_value::<std::option::Option<crate::model::UndeployIssueModelRequest>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UndeployIssueModelMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if self.request.is_some() {
            state.serialize_entry("request", &self.request)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UndeployIssueModelMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UndeployIssueModelMetadata");
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("request", &self.request);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request to export an issue model.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportIssueModelRequest {
    /// Required. The issue model to export.
    pub name: std::string::String,

    pub destination: std::option::Option<crate::model::export_issue_model_request::Destination>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExportIssueModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ExportIssueModelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [destination][crate::model::ExportIssueModelRequest::destination].
    ///
    /// Note that all the setters affecting `destination` are mutually
    /// exclusive.
    pub fn set_destination<
        T: std::convert::Into<
                std::option::Option<crate::model::export_issue_model_request::Destination>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::ExportIssueModelRequest::destination]
    /// if it holds a `GcsDestination`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_destination(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::export_issue_model_request::GcsDestination>,
    > {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::export_issue_model_request::Destination::GcsDestination(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::ExportIssueModelRequest::destination]
    /// to hold a `GcsDestination`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_gcs_destination<
        T: std::convert::Into<
                std::boxed::Box<crate::model::export_issue_model_request::GcsDestination>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::export_issue_model_request::Destination::GcsDestination(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ExportIssueModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ExportIssueModelRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExportIssueModelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcs_destination,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportIssueModelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcsDestination" => Ok(__FieldTag::__gcs_destination),
                            "gcs_destination" => Ok(__FieldTag::__gcs_destination),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExportIssueModelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportIssueModelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcs_destination => {
                            if !fields.insert(__FieldTag::__gcs_destination) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_destination",
                                ));
                            }
                            if result.destination.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `destination`, a oneof with full ID .google.cloud.contactcenterinsights.v1.ExportIssueModelRequest.gcs_destination, latest field was gcsDestination",
                                ));
                            }
                            result.destination = std::option::Option::Some(
                                crate::model::export_issue_model_request::Destination::GcsDestination(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::export_issue_model_request::GcsDestination>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExportIssueModelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.gcs_destination() {
            state.serialize_entry("gcsDestination", value)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ExportIssueModelRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExportIssueModelRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("destination", &self.destination);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ExportIssueModelRequest].
pub mod export_issue_model_request {
    #[allow(unused_imports)]
    use super::*;

    /// Google Cloud Storage Object URI to save the issue model to.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GcsDestination {
        /// Required. Format: `gs://<bucket-name>/<object-name>`
        pub object_uri: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GcsDestination {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [object_uri][crate::model::export_issue_model_request::GcsDestination::object_uri].
        pub fn set_object_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.object_uri = v.into();
            self
        }
    }

    impl wkt::message::Message for GcsDestination {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.ExportIssueModelRequest.GcsDestination"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for GcsDestination {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __object_uri,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for GcsDestination")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "objectUri" => Ok(__FieldTag::__object_uri),
                                "object_uri" => Ok(__FieldTag::__object_uri),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = GcsDestination;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct GcsDestination")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__object_uri => {
                                if !fields.insert(__FieldTag::__object_uri) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for object_uri",
                                    ));
                                }
                                result.object_uri = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for GcsDestination {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.object_uri.is_empty() {
                state.serialize_entry("objectUri", &self.object_uri)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for GcsDestination {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("GcsDestination");
            debug_struct.field("object_uri", &self.object_uri);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Destination {
        /// Google Cloud Storage URI to export the issue model to.
        GcsDestination(std::boxed::Box<crate::model::export_issue_model_request::GcsDestination>),
    }
}

/// Response from export issue model
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportIssueModelResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExportIssueModelResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ExportIssueModelResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ExportIssueModelResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExportIssueModelResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportIssueModelResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExportIssueModelResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportIssueModelResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExportIssueModelResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ExportIssueModelResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExportIssueModelResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Metadata used for export issue model.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportIssueModelMetadata {
    /// The time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The time the operation finished running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The original export request.
    pub request: std::option::Option<crate::model::ExportIssueModelRequest>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExportIssueModelMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::ExportIssueModelMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ExportIssueModelMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::ExportIssueModelMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::ExportIssueModelMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request][crate::model::ExportIssueModelMetadata::request].
    pub fn set_request<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ExportIssueModelRequest>,
    {
        self.request = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [request][crate::model::ExportIssueModelMetadata::request].
    pub fn set_or_clear_request<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ExportIssueModelRequest>,
    {
        self.request = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ExportIssueModelMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ExportIssueModelMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExportIssueModelMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __end_time,
            __request,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportIssueModelMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "request" => Ok(__FieldTag::__request),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExportIssueModelMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportIssueModelMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__request => {
                            if !fields.insert(__FieldTag::__request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request",
                                ));
                            }
                            result.request = map.next_value::<std::option::Option<crate::model::ExportIssueModelRequest>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExportIssueModelMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if self.request.is_some() {
            state.serialize_entry("request", &self.request)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ExportIssueModelMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExportIssueModelMetadata");
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("request", &self.request);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request to import an issue model.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportIssueModelRequest {
    /// Required. The parent resource of the issue model.
    pub parent: std::string::String,

    /// Optional. If set to true, will create an issue model from the imported file
    /// with randomly generated IDs for the issue model and corresponding issues.
    /// Otherwise, replaces an existing model with the same ID as the file.
    pub create_new_model: bool,

    pub source: std::option::Option<crate::model::import_issue_model_request::Source>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportIssueModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ImportIssueModelRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [create_new_model][crate::model::ImportIssueModelRequest::create_new_model].
    pub fn set_create_new_model<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.create_new_model = v.into();
        self
    }

    /// Sets the value of [source][crate::model::ImportIssueModelRequest::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::import_issue_model_request::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::ImportIssueModelRequest::source]
    /// if it holds a `GcsSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::import_issue_model_request::GcsSource>>
    {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_issue_model_request::Source::GcsSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ImportIssueModelRequest::source]
    /// to hold a `GcsSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_gcs_source<
        T: std::convert::Into<std::boxed::Box<crate::model::import_issue_model_request::GcsSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_issue_model_request::Source::GcsSource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ImportIssueModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ImportIssueModelRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportIssueModelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcs_source,
            __parent,
            __create_new_model,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportIssueModelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcsSource" => Ok(__FieldTag::__gcs_source),
                            "gcs_source" => Ok(__FieldTag::__gcs_source),
                            "parent" => Ok(__FieldTag::__parent),
                            "createNewModel" => Ok(__FieldTag::__create_new_model),
                            "create_new_model" => Ok(__FieldTag::__create_new_model),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportIssueModelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportIssueModelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcs_source => {
                            if !fields.insert(__FieldTag::__gcs_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_source",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.contactcenterinsights.v1.ImportIssueModelRequest.gcs_source, latest field was gcsSource",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::import_issue_model_request::Source::GcsSource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::import_issue_model_request::GcsSource,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_new_model => {
                            if !fields.insert(__FieldTag::__create_new_model) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_new_model",
                                ));
                            }
                            result.create_new_model = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImportIssueModelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.gcs_source() {
            state.serialize_entry("gcsSource", value)?;
        }
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.create_new_model) {
            state.serialize_entry("createNewModel", &self.create_new_model)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ImportIssueModelRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ImportIssueModelRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("create_new_model", &self.create_new_model);
        debug_struct.field("source", &self.source);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ImportIssueModelRequest].
pub mod import_issue_model_request {
    #[allow(unused_imports)]
    use super::*;

    /// Google Cloud Storage Object URI to get the issue model file from.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GcsSource {
        /// Required. Format: `gs://<bucket-name>/<object-name>`
        pub object_uri: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GcsSource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [object_uri][crate::model::import_issue_model_request::GcsSource::object_uri].
        pub fn set_object_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.object_uri = v.into();
            self
        }
    }

    impl wkt::message::Message for GcsSource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.ImportIssueModelRequest.GcsSource"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for GcsSource {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __object_uri,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for GcsSource")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "objectUri" => Ok(__FieldTag::__object_uri),
                                "object_uri" => Ok(__FieldTag::__object_uri),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = GcsSource;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct GcsSource")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__object_uri => {
                                if !fields.insert(__FieldTag::__object_uri) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for object_uri",
                                    ));
                                }
                                result.object_uri = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for GcsSource {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.object_uri.is_empty() {
                state.serialize_entry("objectUri", &self.object_uri)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for GcsSource {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("GcsSource");
            debug_struct.field("object_uri", &self.object_uri);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// Google Cloud Storage source message.
        GcsSource(std::boxed::Box<crate::model::import_issue_model_request::GcsSource>),
    }
}

/// Response from import issue model
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportIssueModelResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportIssueModelResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ImportIssueModelResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ImportIssueModelResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportIssueModelResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportIssueModelResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportIssueModelResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportIssueModelResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImportIssueModelResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ImportIssueModelResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ImportIssueModelResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Metadata used for import issue model.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportIssueModelMetadata {
    /// The time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The time the operation finished running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The original import request.
    pub request: std::option::Option<crate::model::ImportIssueModelRequest>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportIssueModelMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::ImportIssueModelMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ImportIssueModelMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::ImportIssueModelMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::ImportIssueModelMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request][crate::model::ImportIssueModelMetadata::request].
    pub fn set_request<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ImportIssueModelRequest>,
    {
        self.request = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [request][crate::model::ImportIssueModelMetadata::request].
    pub fn set_or_clear_request<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ImportIssueModelRequest>,
    {
        self.request = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ImportIssueModelMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ImportIssueModelMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportIssueModelMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __end_time,
            __request,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportIssueModelMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "request" => Ok(__FieldTag::__request),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportIssueModelMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportIssueModelMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__request => {
                            if !fields.insert(__FieldTag::__request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request",
                                ));
                            }
                            result.request = map.next_value::<std::option::Option<crate::model::ImportIssueModelRequest>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImportIssueModelMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if self.request.is_some() {
            state.serialize_entry("request", &self.request)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ImportIssueModelMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ImportIssueModelMetadata");
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("request", &self.request);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request to get an issue.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetIssueRequest {
    /// Required. The name of the issue to get.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetIssueRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetIssueRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetIssueRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.GetIssueRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetIssueRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetIssueRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetIssueRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetIssueRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetIssueRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetIssueRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetIssueRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request to list issues.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListIssuesRequest {
    /// Required. The parent resource of the issue.
    pub parent: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListIssuesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListIssuesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for ListIssuesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ListIssuesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListIssuesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListIssuesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListIssuesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListIssuesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListIssuesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListIssuesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListIssuesRequest");
        debug_struct.field("parent", &self.parent);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response of listing issues.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListIssuesResponse {
    /// The issues that match the request.
    pub issues: std::vec::Vec<crate::model::Issue>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListIssuesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [issues][crate::model::ListIssuesResponse::issues].
    pub fn set_issues<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Issue>,
    {
        use std::iter::Iterator;
        self.issues = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListIssuesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ListIssuesResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListIssuesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __issues,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListIssuesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "issues" => Ok(__FieldTag::__issues),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListIssuesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListIssuesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__issues => {
                            if !fields.insert(__FieldTag::__issues) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for issues",
                                ));
                            }
                            result.issues = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Issue>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListIssuesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.issues.is_empty() {
            state.serialize_entry("issues", &self.issues)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListIssuesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListIssuesResponse");
        debug_struct.field("issues", &self.issues);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request to update an issue.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateIssueRequest {
    /// Required. The new values for the issue.
    pub issue: std::option::Option<crate::model::Issue>,

    /// The list of fields to be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateIssueRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [issue][crate::model::UpdateIssueRequest::issue].
    pub fn set_issue<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Issue>,
    {
        self.issue = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [issue][crate::model::UpdateIssueRequest::issue].
    pub fn set_or_clear_issue<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Issue>,
    {
        self.issue = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateIssueRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateIssueRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateIssueRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.UpdateIssueRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateIssueRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __issue,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateIssueRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "issue" => Ok(__FieldTag::__issue),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateIssueRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateIssueRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__issue => {
                            if !fields.insert(__FieldTag::__issue) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for issue",
                                ));
                            }
                            result.issue =
                                map.next_value::<std::option::Option<crate::model::Issue>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateIssueRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.issue.is_some() {
            state.serialize_entry("issue", &self.issue)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateIssueRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateIssueRequest");
        debug_struct.field("issue", &self.issue);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request to delete an issue.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteIssueRequest {
    /// Required. The name of the issue to delete.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteIssueRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteIssueRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteIssueRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.DeleteIssueRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteIssueRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteIssueRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteIssueRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteIssueRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteIssueRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteIssueRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteIssueRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request to get statistics of an issue model.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CalculateIssueModelStatsRequest {
    /// Required. The resource name of the issue model to query against.
    pub issue_model: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CalculateIssueModelStatsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [issue_model][crate::model::CalculateIssueModelStatsRequest::issue_model].
    pub fn set_issue_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.issue_model = v.into();
        self
    }
}

impl wkt::message::Message for CalculateIssueModelStatsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.CalculateIssueModelStatsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CalculateIssueModelStatsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __issue_model,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CalculateIssueModelStatsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "issueModel" => Ok(__FieldTag::__issue_model),
                            "issue_model" => Ok(__FieldTag::__issue_model),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CalculateIssueModelStatsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CalculateIssueModelStatsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__issue_model => {
                            if !fields.insert(__FieldTag::__issue_model) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for issue_model",
                                ));
                            }
                            result.issue_model = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CalculateIssueModelStatsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.issue_model.is_empty() {
            state.serialize_entry("issueModel", &self.issue_model)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CalculateIssueModelStatsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CalculateIssueModelStatsRequest");
        debug_struct.field("issue_model", &self.issue_model);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response of querying an issue model's statistics.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CalculateIssueModelStatsResponse {
    /// The latest label statistics for the queried issue model. Includes results
    /// on both training data and data labeled after deployment.
    pub current_stats: std::option::Option<crate::model::IssueModelLabelStats>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CalculateIssueModelStatsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [current_stats][crate::model::CalculateIssueModelStatsResponse::current_stats].
    pub fn set_current_stats<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::IssueModelLabelStats>,
    {
        self.current_stats = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [current_stats][crate::model::CalculateIssueModelStatsResponse::current_stats].
    pub fn set_or_clear_current_stats<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::IssueModelLabelStats>,
    {
        self.current_stats = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CalculateIssueModelStatsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.CalculateIssueModelStatsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CalculateIssueModelStatsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __current_stats,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CalculateIssueModelStatsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "currentStats" => Ok(__FieldTag::__current_stats),
                            "current_stats" => Ok(__FieldTag::__current_stats),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CalculateIssueModelStatsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CalculateIssueModelStatsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__current_stats => {
                            if !fields.insert(__FieldTag::__current_stats) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for current_stats",
                                ));
                            }
                            result.current_stats = map.next_value::<std::option::Option<crate::model::IssueModelLabelStats>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CalculateIssueModelStatsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.current_stats.is_some() {
            state.serialize_entry("currentStats", &self.current_stats)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CalculateIssueModelStatsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CalculateIssueModelStatsResponse");
        debug_struct.field("current_stats", &self.current_stats);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request to create a phrase matcher.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreatePhraseMatcherRequest {
    /// Required. The parent resource of the phrase matcher. Required. The location
    /// to create a phrase matcher for. Format: `projects/<Project
    /// ID>/locations/<Location ID>` or `projects/<Project
    /// Number>/locations/<Location ID>`
    pub parent: std::string::String,

    /// Required. The phrase matcher resource to create.
    pub phrase_matcher: std::option::Option<crate::model::PhraseMatcher>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreatePhraseMatcherRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreatePhraseMatcherRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [phrase_matcher][crate::model::CreatePhraseMatcherRequest::phrase_matcher].
    pub fn set_phrase_matcher<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PhraseMatcher>,
    {
        self.phrase_matcher = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [phrase_matcher][crate::model::CreatePhraseMatcherRequest::phrase_matcher].
    pub fn set_or_clear_phrase_matcher<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PhraseMatcher>,
    {
        self.phrase_matcher = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreatePhraseMatcherRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.CreatePhraseMatcherRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreatePhraseMatcherRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __phrase_matcher,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreatePhraseMatcherRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "phraseMatcher" => Ok(__FieldTag::__phrase_matcher),
                            "phrase_matcher" => Ok(__FieldTag::__phrase_matcher),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreatePhraseMatcherRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreatePhraseMatcherRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__phrase_matcher => {
                            if !fields.insert(__FieldTag::__phrase_matcher) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for phrase_matcher",
                                ));
                            }
                            result.phrase_matcher = map
                                .next_value::<std::option::Option<crate::model::PhraseMatcher>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreatePhraseMatcherRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.phrase_matcher.is_some() {
            state.serialize_entry("phraseMatcher", &self.phrase_matcher)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreatePhraseMatcherRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreatePhraseMatcherRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("phrase_matcher", &self.phrase_matcher);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request to list phrase matchers.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListPhraseMatchersRequest {
    /// Required. The parent resource of the phrase matcher.
    pub parent: std::string::String,

    /// The maximum number of phrase matchers to return in the response. If this
    /// value is zero, the service will select a default size. A call might return
    /// fewer objects than requested. A non-empty `next_page_token` in the response
    /// indicates that more data is available.
    pub page_size: i32,

    /// The value returned by the last `ListPhraseMatchersResponse`. This value
    /// indicates that this is a continuation of a prior `ListPhraseMatchers` call
    /// and that the system should return the next page of data.
    pub page_token: std::string::String,

    /// A filter to reduce results to a specific subset. Useful for querying
    /// phrase matchers with specific properties.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPhraseMatchersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListPhraseMatchersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListPhraseMatchersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListPhraseMatchersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListPhraseMatchersRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListPhraseMatchersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ListPhraseMatchersRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListPhraseMatchersRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListPhraseMatchersRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListPhraseMatchersRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListPhraseMatchersRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListPhraseMatchersRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListPhraseMatchersRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListPhraseMatchersRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response of listing phrase matchers.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListPhraseMatchersResponse {
    /// The phrase matchers that match the request.
    pub phrase_matchers: std::vec::Vec<crate::model::PhraseMatcher>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPhraseMatchersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [phrase_matchers][crate::model::ListPhraseMatchersResponse::phrase_matchers].
    pub fn set_phrase_matchers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PhraseMatcher>,
    {
        use std::iter::Iterator;
        self.phrase_matchers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListPhraseMatchersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListPhraseMatchersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ListPhraseMatchersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListPhraseMatchersResponse {
    type PageItem = crate::model::PhraseMatcher;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.phrase_matchers
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListPhraseMatchersResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __phrase_matchers,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListPhraseMatchersResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "phraseMatchers" => Ok(__FieldTag::__phrase_matchers),
                            "phrase_matchers" => Ok(__FieldTag::__phrase_matchers),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListPhraseMatchersResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListPhraseMatchersResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__phrase_matchers => {
                            if !fields.insert(__FieldTag::__phrase_matchers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for phrase_matchers",
                                ));
                            }
                            result.phrase_matchers = map.next_value::<std::option::Option<std::vec::Vec<crate::model::PhraseMatcher>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListPhraseMatchersResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.phrase_matchers.is_empty() {
            state.serialize_entry("phraseMatchers", &self.phrase_matchers)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListPhraseMatchersResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListPhraseMatchersResponse");
        debug_struct.field("phrase_matchers", &self.phrase_matchers);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request to get a a phrase matcher.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetPhraseMatcherRequest {
    /// Required. The name of the phrase matcher to get.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetPhraseMatcherRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPhraseMatcherRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetPhraseMatcherRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.GetPhraseMatcherRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetPhraseMatcherRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetPhraseMatcherRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetPhraseMatcherRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetPhraseMatcherRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetPhraseMatcherRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetPhraseMatcherRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetPhraseMatcherRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request to delete a phrase matcher.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeletePhraseMatcherRequest {
    /// Required. The name of the phrase matcher to delete.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeletePhraseMatcherRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeletePhraseMatcherRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeletePhraseMatcherRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.DeletePhraseMatcherRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeletePhraseMatcherRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeletePhraseMatcherRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeletePhraseMatcherRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeletePhraseMatcherRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeletePhraseMatcherRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeletePhraseMatcherRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeletePhraseMatcherRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request to update a phrase matcher.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdatePhraseMatcherRequest {
    /// Required. The new values for the phrase matcher.
    pub phrase_matcher: std::option::Option<crate::model::PhraseMatcher>,

    /// The list of fields to be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdatePhraseMatcherRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [phrase_matcher][crate::model::UpdatePhraseMatcherRequest::phrase_matcher].
    pub fn set_phrase_matcher<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PhraseMatcher>,
    {
        self.phrase_matcher = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [phrase_matcher][crate::model::UpdatePhraseMatcherRequest::phrase_matcher].
    pub fn set_or_clear_phrase_matcher<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PhraseMatcher>,
    {
        self.phrase_matcher = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdatePhraseMatcherRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdatePhraseMatcherRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdatePhraseMatcherRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.UpdatePhraseMatcherRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdatePhraseMatcherRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __phrase_matcher,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdatePhraseMatcherRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "phraseMatcher" => Ok(__FieldTag::__phrase_matcher),
                            "phrase_matcher" => Ok(__FieldTag::__phrase_matcher),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdatePhraseMatcherRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdatePhraseMatcherRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__phrase_matcher => {
                            if !fields.insert(__FieldTag::__phrase_matcher) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for phrase_matcher",
                                ));
                            }
                            result.phrase_matcher = map
                                .next_value::<std::option::Option<crate::model::PhraseMatcher>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdatePhraseMatcherRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.phrase_matcher.is_some() {
            state.serialize_entry("phraseMatcher", &self.phrase_matcher)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdatePhraseMatcherRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdatePhraseMatcherRequest");
        debug_struct.field("phrase_matcher", &self.phrase_matcher);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request to get project-level settings.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetSettingsRequest {
    /// Required. The name of the settings resource to get.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSettingsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSettingsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetSettingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.GetSettingsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetSettingsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetSettingsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetSettingsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetSettingsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetSettingsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetSettingsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetSettingsRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request to update project-level settings.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateSettingsRequest {
    /// Required. The new settings values.
    pub settings: std::option::Option<crate::model::Settings>,

    /// Required. The list of fields to be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateSettingsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [settings][crate::model::UpdateSettingsRequest::settings].
    pub fn set_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Settings>,
    {
        self.settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [settings][crate::model::UpdateSettingsRequest::settings].
    pub fn set_or_clear_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Settings>,
    {
        self.settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateSettingsRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateSettingsRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateSettingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.UpdateSettingsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateSettingsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __settings,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateSettingsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "settings" => Ok(__FieldTag::__settings),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateSettingsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateSettingsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__settings => {
                            if !fields.insert(__FieldTag::__settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for settings",
                                ));
                            }
                            result.settings =
                                map.next_value::<std::option::Option<crate::model::Settings>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateSettingsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.settings.is_some() {
            state.serialize_entry("settings", &self.settings)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateSettingsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateSettingsRequest");
        debug_struct.field("settings", &self.settings);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request to create a analysis rule.
/// analysis_rule_id will be generated by the server.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateAnalysisRuleRequest {
    /// Required. The parent resource of the analysis rule. Required. The location
    /// to create a analysis rule for. Format: `projects/<Project
    /// ID>/locations/<Location ID>` or `projects/<Project
    /// Number>/locations/<Location ID>`
    pub parent: std::string::String,

    /// Required. The analysis rule resource to create.
    pub analysis_rule: std::option::Option<crate::model::AnalysisRule>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateAnalysisRuleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateAnalysisRuleRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [analysis_rule][crate::model::CreateAnalysisRuleRequest::analysis_rule].
    pub fn set_analysis_rule<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AnalysisRule>,
    {
        self.analysis_rule = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [analysis_rule][crate::model::CreateAnalysisRuleRequest::analysis_rule].
    pub fn set_or_clear_analysis_rule<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AnalysisRule>,
    {
        self.analysis_rule = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateAnalysisRuleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.CreateAnalysisRuleRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateAnalysisRuleRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __analysis_rule,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateAnalysisRuleRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "analysisRule" => Ok(__FieldTag::__analysis_rule),
                            "analysis_rule" => Ok(__FieldTag::__analysis_rule),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateAnalysisRuleRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateAnalysisRuleRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__analysis_rule => {
                            if !fields.insert(__FieldTag::__analysis_rule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for analysis_rule",
                                ));
                            }
                            result.analysis_rule = map
                                .next_value::<std::option::Option<crate::model::AnalysisRule>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateAnalysisRuleRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.analysis_rule.is_some() {
            state.serialize_entry("analysisRule", &self.analysis_rule)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateAnalysisRuleRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateAnalysisRuleRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("analysis_rule", &self.analysis_rule);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for getting a analysis rule.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetAnalysisRuleRequest {
    /// Required. The name of the AnalysisRule to get.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetAnalysisRuleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAnalysisRuleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAnalysisRuleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.GetAnalysisRuleRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetAnalysisRuleRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetAnalysisRuleRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetAnalysisRuleRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetAnalysisRuleRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetAnalysisRuleRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetAnalysisRuleRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetAnalysisRuleRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request to update a analysis rule.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateAnalysisRuleRequest {
    /// Required. The new analysis rule.
    pub analysis_rule: std::option::Option<crate::model::AnalysisRule>,

    /// Optional. The list of fields to be updated.
    /// If the update_mask is not provided, the update will be applied to all
    /// fields.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateAnalysisRuleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [analysis_rule][crate::model::UpdateAnalysisRuleRequest::analysis_rule].
    pub fn set_analysis_rule<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AnalysisRule>,
    {
        self.analysis_rule = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [analysis_rule][crate::model::UpdateAnalysisRuleRequest::analysis_rule].
    pub fn set_or_clear_analysis_rule<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AnalysisRule>,
    {
        self.analysis_rule = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateAnalysisRuleRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateAnalysisRuleRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateAnalysisRuleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.UpdateAnalysisRuleRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateAnalysisRuleRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __analysis_rule,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateAnalysisRuleRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "analysisRule" => Ok(__FieldTag::__analysis_rule),
                            "analysis_rule" => Ok(__FieldTag::__analysis_rule),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateAnalysisRuleRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateAnalysisRuleRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__analysis_rule => {
                            if !fields.insert(__FieldTag::__analysis_rule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for analysis_rule",
                                ));
                            }
                            result.analysis_rule = map
                                .next_value::<std::option::Option<crate::model::AnalysisRule>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateAnalysisRuleRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.analysis_rule.is_some() {
            state.serialize_entry("analysisRule", &self.analysis_rule)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateAnalysisRuleRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateAnalysisRuleRequest");
        debug_struct.field("analysis_rule", &self.analysis_rule);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request to delete a analysis rule.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteAnalysisRuleRequest {
    /// Required. The name of the analysis rule to delete.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteAnalysisRuleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteAnalysisRuleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAnalysisRuleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.DeleteAnalysisRuleRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteAnalysisRuleRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteAnalysisRuleRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteAnalysisRuleRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteAnalysisRuleRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteAnalysisRuleRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteAnalysisRuleRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteAnalysisRuleRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request to list analysis rules.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAnalysisRulesRequest {
    /// Required. The parent resource of the analysis rules.
    pub parent: std::string::String,

    /// Optional. The maximum number of analysis rule to return in the response. If
    /// this value is zero, the service will select a default size. A call may
    /// return fewer objects than requested. A non-empty `next_page_token` in the
    /// response indicates that more data is available.
    pub page_size: i32,

    /// Optional. The value returned by the last `ListAnalysisRulesResponse`;
    /// indicates that this is a continuation of a prior `ListAnalysisRules` call
    /// and the system should return the next page of data.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAnalysisRulesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAnalysisRulesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAnalysisRulesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAnalysisRulesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAnalysisRulesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ListAnalysisRulesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAnalysisRulesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAnalysisRulesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAnalysisRulesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAnalysisRulesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAnalysisRulesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListAnalysisRulesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListAnalysisRulesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response of listing views.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAnalysisRulesResponse {
    /// The analysis_rule that match the request.
    pub analysis_rules: std::vec::Vec<crate::model::AnalysisRule>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAnalysisRulesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [analysis_rules][crate::model::ListAnalysisRulesResponse::analysis_rules].
    pub fn set_analysis_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AnalysisRule>,
    {
        use std::iter::Iterator;
        self.analysis_rules = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAnalysisRulesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAnalysisRulesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ListAnalysisRulesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAnalysisRulesResponse {
    type PageItem = crate::model::AnalysisRule;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.analysis_rules
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAnalysisRulesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __analysis_rules,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAnalysisRulesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "analysisRules" => Ok(__FieldTag::__analysis_rules),
                            "analysis_rules" => Ok(__FieldTag::__analysis_rules),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAnalysisRulesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAnalysisRulesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__analysis_rules => {
                            if !fields.insert(__FieldTag::__analysis_rules) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for analysis_rules",
                                ));
                            }
                            result.analysis_rules = map.next_value::<std::option::Option<std::vec::Vec<crate::model::AnalysisRule>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAnalysisRulesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.analysis_rules.is_empty() {
            state.serialize_entry("analysisRules", &self.analysis_rules)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListAnalysisRulesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListAnalysisRulesResponse");
        debug_struct.field("analysis_rules", &self.analysis_rules);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request to get location-level encryption specification.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetEncryptionSpecRequest {
    /// Required. The name of the encryption spec resource to get.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetEncryptionSpecRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEncryptionSpecRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetEncryptionSpecRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.GetEncryptionSpecRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetEncryptionSpecRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetEncryptionSpecRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetEncryptionSpecRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetEncryptionSpecRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetEncryptionSpecRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetEncryptionSpecRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetEncryptionSpecRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request to initialize a location-level encryption specification.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InitializeEncryptionSpecRequest {
    /// Required. The encryption spec used for CMEK encryption. It is required that
    /// the kms key is in the same region as the endpoint. The same key will be
    /// used for all provisioned resources, if encryption is available. If the
    /// `kms_key_name` field is left empty, no encryption will be enforced.
    pub encryption_spec: std::option::Option<crate::model::EncryptionSpec>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InitializeEncryptionSpecRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [encryption_spec][crate::model::InitializeEncryptionSpecRequest::encryption_spec].
    pub fn set_encryption_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionSpec>,
    {
        self.encryption_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [encryption_spec][crate::model::InitializeEncryptionSpecRequest::encryption_spec].
    pub fn set_or_clear_encryption_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionSpec>,
    {
        self.encryption_spec = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for InitializeEncryptionSpecRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.InitializeEncryptionSpecRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InitializeEncryptionSpecRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __encryption_spec,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InitializeEncryptionSpecRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "encryptionSpec" => Ok(__FieldTag::__encryption_spec),
                            "encryption_spec" => Ok(__FieldTag::__encryption_spec),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InitializeEncryptionSpecRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InitializeEncryptionSpecRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__encryption_spec => {
                            if !fields.insert(__FieldTag::__encryption_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption_spec",
                                ));
                            }
                            result.encryption_spec = map
                                .next_value::<std::option::Option<crate::model::EncryptionSpec>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InitializeEncryptionSpecRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.encryption_spec.is_some() {
            state.serialize_entry("encryptionSpec", &self.encryption_spec)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for InitializeEncryptionSpecRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InitializeEncryptionSpecRequest");
        debug_struct.field("encryption_spec", &self.encryption_spec);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response to initialize a location-level encryption specification.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InitializeEncryptionSpecResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InitializeEncryptionSpecResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for InitializeEncryptionSpecResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.InitializeEncryptionSpecResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InitializeEncryptionSpecResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InitializeEncryptionSpecResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InitializeEncryptionSpecResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InitializeEncryptionSpecResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InitializeEncryptionSpecResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for InitializeEncryptionSpecResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InitializeEncryptionSpecResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Metadata for initializing a location-level encryption specification.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InitializeEncryptionSpecMetadata {
    /// Output only. The time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The original request for initialization.
    pub request: std::option::Option<crate::model::InitializeEncryptionSpecRequest>,

    /// Partial errors during initializing operation that might cause the operation
    /// output to be incomplete.
    pub partial_errors: std::vec::Vec<rpc::model::Status>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InitializeEncryptionSpecMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::InitializeEncryptionSpecMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::InitializeEncryptionSpecMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::InitializeEncryptionSpecMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::InitializeEncryptionSpecMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request][crate::model::InitializeEncryptionSpecMetadata::request].
    pub fn set_request<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InitializeEncryptionSpecRequest>,
    {
        self.request = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [request][crate::model::InitializeEncryptionSpecMetadata::request].
    pub fn set_or_clear_request<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InitializeEncryptionSpecRequest>,
    {
        self.request = v.map(|x| x.into());
        self
    }

    /// Sets the value of [partial_errors][crate::model::InitializeEncryptionSpecMetadata::partial_errors].
    pub fn set_partial_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.partial_errors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for InitializeEncryptionSpecMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.InitializeEncryptionSpecMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InitializeEncryptionSpecMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __end_time,
            __request,
            __partial_errors,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InitializeEncryptionSpecMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "request" => Ok(__FieldTag::__request),
                            "partialErrors" => Ok(__FieldTag::__partial_errors),
                            "partial_errors" => Ok(__FieldTag::__partial_errors),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InitializeEncryptionSpecMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InitializeEncryptionSpecMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__request => {
                            if !fields.insert(__FieldTag::__request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request",
                                ));
                            }
                            result.request = map.next_value::<std::option::Option<
                                crate::model::InitializeEncryptionSpecRequest,
                            >>()?;
                        }
                        __FieldTag::__partial_errors => {
                            if !fields.insert(__FieldTag::__partial_errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for partial_errors",
                                ));
                            }
                            result.partial_errors = map.next_value::<std::option::Option<std::vec::Vec<rpc::model::Status>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InitializeEncryptionSpecMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if self.request.is_some() {
            state.serialize_entry("request", &self.request)?;
        }
        if !self.partial_errors.is_empty() {
            state.serialize_entry("partialErrors", &self.partial_errors)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for InitializeEncryptionSpecMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InitializeEncryptionSpecMetadata");
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("request", &self.request);
        debug_struct.field("partial_errors", &self.partial_errors);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request to create a view.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateViewRequest {
    /// Required. The parent resource of the view. Required. The location to create
    /// a view for.
    /// Format: `projects/<Project ID>/locations/<Location ID>` or
    /// `projects/<Project Number>/locations/<Location ID>`
    pub parent: std::string::String,

    /// Required. The view resource to create.
    pub view: std::option::Option<crate::model::View>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateViewRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateViewRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [view][crate::model::CreateViewRequest::view].
    pub fn set_view<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::View>,
    {
        self.view = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [view][crate::model::CreateViewRequest::view].
    pub fn set_or_clear_view<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::View>,
    {
        self.view = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateViewRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.CreateViewRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateViewRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateViewRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "view" => Ok(__FieldTag::__view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateViewRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateViewRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view =
                                map.next_value::<std::option::Option<crate::model::View>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateViewRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.view.is_some() {
            state.serialize_entry("view", &self.view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateViewRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateViewRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("view", &self.view);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request to get a view.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetViewRequest {
    /// Required. The name of the view to get.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetViewRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetViewRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetViewRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.GetViewRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetViewRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetViewRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetViewRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetViewRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetViewRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetViewRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetViewRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request to list views.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListViewsRequest {
    /// Required. The parent resource of the views.
    pub parent: std::string::String,

    /// The maximum number of views to return in the response. If this
    /// value is zero, the service will select a default size. A call may return
    /// fewer objects than requested. A non-empty `next_page_token` in the response
    /// indicates that more data is available.
    pub page_size: i32,

    /// The value returned by the last `ListViewsResponse`; indicates
    /// that this is a continuation of a prior `ListViews` call and
    /// the system should return the next page of data.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListViewsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListViewsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListViewsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListViewsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListViewsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ListViewsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListViewsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListViewsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListViewsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListViewsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListViewsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListViewsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListViewsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response of listing views.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListViewsResponse {
    /// The views that match the request.
    pub views: std::vec::Vec<crate::model::View>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListViewsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [views][crate::model::ListViewsResponse::views].
    pub fn set_views<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::View>,
    {
        use std::iter::Iterator;
        self.views = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListViewsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListViewsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ListViewsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListViewsResponse {
    type PageItem = crate::model::View;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.views
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListViewsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __views,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListViewsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "views" => Ok(__FieldTag::__views),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListViewsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListViewsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__views => {
                            if !fields.insert(__FieldTag::__views) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for views",
                                ));
                            }
                            result.views = map.next_value::<std::option::Option<std::vec::Vec<crate::model::View>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListViewsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.views.is_empty() {
            state.serialize_entry("views", &self.views)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListViewsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListViewsResponse");
        debug_struct.field("views", &self.views);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request to update a view.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateViewRequest {
    /// Required. The new view.
    pub view: std::option::Option<crate::model::View>,

    /// The list of fields to be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateViewRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [view][crate::model::UpdateViewRequest::view].
    pub fn set_view<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::View>,
    {
        self.view = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [view][crate::model::UpdateViewRequest::view].
    pub fn set_or_clear_view<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::View>,
    {
        self.view = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateViewRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateViewRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateViewRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.UpdateViewRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateViewRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __view,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateViewRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "view" => Ok(__FieldTag::__view),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateViewRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateViewRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view =
                                map.next_value::<std::option::Option<crate::model::View>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateViewRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.view.is_some() {
            state.serialize_entry("view", &self.view)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateViewRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateViewRequest");
        debug_struct.field("view", &self.view);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request to delete a view.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteViewRequest {
    /// Required. The name of the view to delete.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteViewRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteViewRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteViewRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.DeleteViewRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteViewRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteViewRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteViewRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteViewRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteViewRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteViewRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteViewRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A dimension determines the grouping key for the query. In SQL terms, these
/// would be part of both the "SELECT" and "GROUP BY" clauses.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Dimension {
    /// The key of the dimension.
    pub dimension_key: crate::model::dimension::DimensionKey,

    /// Output-only metadata about the dimension.
    pub dimension_metadata: std::option::Option<crate::model::dimension::DimensionMetadata>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Dimension {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dimension_key][crate::model::Dimension::dimension_key].
    pub fn set_dimension_key<T: std::convert::Into<crate::model::dimension::DimensionKey>>(
        mut self,
        v: T,
    ) -> Self {
        self.dimension_key = v.into();
        self
    }

    /// Sets the value of [dimension_metadata][crate::model::Dimension::dimension_metadata].
    ///
    /// Note that all the setters affecting `dimension_metadata` are mutually
    /// exclusive.
    pub fn set_dimension_metadata<
        T: std::convert::Into<std::option::Option<crate::model::dimension::DimensionMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dimension_metadata = v.into();
        self
    }

    /// The value of [dimension_metadata][crate::model::Dimension::dimension_metadata]
    /// if it holds a `IssueDimensionMetadata`, `None` if the field is not set or
    /// holds a different branch.
    pub fn issue_dimension_metadata(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::dimension::IssueDimensionMetadata>>
    {
        #[allow(unreachable_patterns)]
        self.dimension_metadata.as_ref().and_then(|v| match v {
            crate::model::dimension::DimensionMetadata::IssueDimensionMetadata(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [dimension_metadata][crate::model::Dimension::dimension_metadata]
    /// to hold a `IssueDimensionMetadata`.
    ///
    /// Note that all the setters affecting `dimension_metadata` are
    /// mutually exclusive.
    pub fn set_issue_dimension_metadata<
        T: std::convert::Into<std::boxed::Box<crate::model::dimension::IssueDimensionMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dimension_metadata = std::option::Option::Some(
            crate::model::dimension::DimensionMetadata::IssueDimensionMetadata(v.into()),
        );
        self
    }

    /// The value of [dimension_metadata][crate::model::Dimension::dimension_metadata]
    /// if it holds a `AgentDimensionMetadata`, `None` if the field is not set or
    /// holds a different branch.
    pub fn agent_dimension_metadata(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::dimension::AgentDimensionMetadata>>
    {
        #[allow(unreachable_patterns)]
        self.dimension_metadata.as_ref().and_then(|v| match v {
            crate::model::dimension::DimensionMetadata::AgentDimensionMetadata(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [dimension_metadata][crate::model::Dimension::dimension_metadata]
    /// to hold a `AgentDimensionMetadata`.
    ///
    /// Note that all the setters affecting `dimension_metadata` are
    /// mutually exclusive.
    pub fn set_agent_dimension_metadata<
        T: std::convert::Into<std::boxed::Box<crate::model::dimension::AgentDimensionMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dimension_metadata = std::option::Option::Some(
            crate::model::dimension::DimensionMetadata::AgentDimensionMetadata(v.into()),
        );
        self
    }

    /// The value of [dimension_metadata][crate::model::Dimension::dimension_metadata]
    /// if it holds a `QaQuestionDimensionMetadata`, `None` if the field is not set or
    /// holds a different branch.
    pub fn qa_question_dimension_metadata(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::dimension::QaQuestionDimensionMetadata>>
    {
        #[allow(unreachable_patterns)]
        self.dimension_metadata.as_ref().and_then(|v| match v {
            crate::model::dimension::DimensionMetadata::QaQuestionDimensionMetadata(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [dimension_metadata][crate::model::Dimension::dimension_metadata]
    /// to hold a `QaQuestionDimensionMetadata`.
    ///
    /// Note that all the setters affecting `dimension_metadata` are
    /// mutually exclusive.
    pub fn set_qa_question_dimension_metadata<
        T: std::convert::Into<std::boxed::Box<crate::model::dimension::QaQuestionDimensionMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dimension_metadata = std::option::Option::Some(
            crate::model::dimension::DimensionMetadata::QaQuestionDimensionMetadata(v.into()),
        );
        self
    }

    /// The value of [dimension_metadata][crate::model::Dimension::dimension_metadata]
    /// if it holds a `QaQuestionAnswerDimensionMetadata`, `None` if the field is not set or
    /// holds a different branch.
    pub fn qa_question_answer_dimension_metadata(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::dimension::QaQuestionAnswerDimensionMetadata>,
    > {
        #[allow(unreachable_patterns)]
        self.dimension_metadata.as_ref().and_then(|v| match v {
            crate::model::dimension::DimensionMetadata::QaQuestionAnswerDimensionMetadata(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [dimension_metadata][crate::model::Dimension::dimension_metadata]
    /// to hold a `QaQuestionAnswerDimensionMetadata`.
    ///
    /// Note that all the setters affecting `dimension_metadata` are
    /// mutually exclusive.
    pub fn set_qa_question_answer_dimension_metadata<
        T: std::convert::Into<
                std::boxed::Box<crate::model::dimension::QaQuestionAnswerDimensionMetadata>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dimension_metadata = std::option::Option::Some(
            crate::model::dimension::DimensionMetadata::QaQuestionAnswerDimensionMetadata(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Dimension {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.Dimension"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Dimension {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __issue_dimension_metadata,
            __agent_dimension_metadata,
            __qa_question_dimension_metadata,
            __qa_question_answer_dimension_metadata,
            __dimension_key,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Dimension")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "issueDimensionMetadata" => Ok(__FieldTag::__issue_dimension_metadata),
                            "issue_dimension_metadata" => {
                                Ok(__FieldTag::__issue_dimension_metadata)
                            }
                            "agentDimensionMetadata" => Ok(__FieldTag::__agent_dimension_metadata),
                            "agent_dimension_metadata" => {
                                Ok(__FieldTag::__agent_dimension_metadata)
                            }
                            "qaQuestionDimensionMetadata" => {
                                Ok(__FieldTag::__qa_question_dimension_metadata)
                            }
                            "qa_question_dimension_metadata" => {
                                Ok(__FieldTag::__qa_question_dimension_metadata)
                            }
                            "qaQuestionAnswerDimensionMetadata" => {
                                Ok(__FieldTag::__qa_question_answer_dimension_metadata)
                            }
                            "qa_question_answer_dimension_metadata" => {
                                Ok(__FieldTag::__qa_question_answer_dimension_metadata)
                            }
                            "dimensionKey" => Ok(__FieldTag::__dimension_key),
                            "dimension_key" => Ok(__FieldTag::__dimension_key),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Dimension;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Dimension")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__issue_dimension_metadata => {
                            if !fields.insert(__FieldTag::__issue_dimension_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for issue_dimension_metadata",
                                ));
                            }
                            if result.dimension_metadata.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `dimension_metadata`, a oneof with full ID .google.cloud.contactcenterinsights.v1.Dimension.issue_dimension_metadata, latest field was issueDimensionMetadata",
                                ));
                            }
                            result.dimension_metadata = std::option::Option::Some(
                                crate::model::dimension::DimensionMetadata::IssueDimensionMetadata(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::dimension::IssueDimensionMetadata,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__agent_dimension_metadata => {
                            if !fields.insert(__FieldTag::__agent_dimension_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for agent_dimension_metadata",
                                ));
                            }
                            if result.dimension_metadata.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `dimension_metadata`, a oneof with full ID .google.cloud.contactcenterinsights.v1.Dimension.agent_dimension_metadata, latest field was agentDimensionMetadata",
                                ));
                            }
                            result.dimension_metadata = std::option::Option::Some(
                                crate::model::dimension::DimensionMetadata::AgentDimensionMetadata(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::dimension::AgentDimensionMetadata,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__qa_question_dimension_metadata => {
                            if !fields.insert(__FieldTag::__qa_question_dimension_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for qa_question_dimension_metadata",
                                ));
                            }
                            if result.dimension_metadata.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `dimension_metadata`, a oneof with full ID .google.cloud.contactcenterinsights.v1.Dimension.qa_question_dimension_metadata, latest field was qaQuestionDimensionMetadata",
                                ));
                            }
                            result.dimension_metadata = std::option::Option::Some(
                                crate::model::dimension::DimensionMetadata::QaQuestionDimensionMetadata(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::dimension::QaQuestionDimensionMetadata>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__qa_question_answer_dimension_metadata => {
                            if !fields.insert(__FieldTag::__qa_question_answer_dimension_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for qa_question_answer_dimension_metadata",
                                ));
                            }
                            if result.dimension_metadata.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `dimension_metadata`, a oneof with full ID .google.cloud.contactcenterinsights.v1.Dimension.qa_question_answer_dimension_metadata, latest field was qaQuestionAnswerDimensionMetadata",
                                ));
                            }
                            result.dimension_metadata = std::option::Option::Some(
                                crate::model::dimension::DimensionMetadata::QaQuestionAnswerDimensionMetadata(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::dimension::QaQuestionAnswerDimensionMetadata>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__dimension_key => {
                            if !fields.insert(__FieldTag::__dimension_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dimension_key",
                                ));
                            }
                            result.dimension_key = map.next_value::<std::option::Option<crate::model::dimension::DimensionKey>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Dimension {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.issue_dimension_metadata() {
            state.serialize_entry("issueDimensionMetadata", value)?;
        }
        if let Some(value) = self.agent_dimension_metadata() {
            state.serialize_entry("agentDimensionMetadata", value)?;
        }
        if let Some(value) = self.qa_question_dimension_metadata() {
            state.serialize_entry("qaQuestionDimensionMetadata", value)?;
        }
        if let Some(value) = self.qa_question_answer_dimension_metadata() {
            state.serialize_entry("qaQuestionAnswerDimensionMetadata", value)?;
        }
        if !wkt::internal::is_default(&self.dimension_key) {
            state.serialize_entry("dimensionKey", &self.dimension_key)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Dimension {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Dimension");
        debug_struct.field("dimension_key", &self.dimension_key);
        debug_struct.field("dimension_metadata", &self.dimension_metadata);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Dimension].
pub mod dimension {
    #[allow(unused_imports)]
    use super::*;

    /// Metadata about the issue dimension.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct IssueDimensionMetadata {
        /// The issue ID.
        pub issue_id: std::string::String,

        /// The issue display name.
        pub issue_display_name: std::string::String,

        /// The parent issue model ID.
        pub issue_model_id: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl IssueDimensionMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [issue_id][crate::model::dimension::IssueDimensionMetadata::issue_id].
        pub fn set_issue_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.issue_id = v.into();
            self
        }

        /// Sets the value of [issue_display_name][crate::model::dimension::IssueDimensionMetadata::issue_display_name].
        pub fn set_issue_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.issue_display_name = v.into();
            self
        }

        /// Sets the value of [issue_model_id][crate::model::dimension::IssueDimensionMetadata::issue_model_id].
        pub fn set_issue_model_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.issue_model_id = v.into();
            self
        }
    }

    impl wkt::message::Message for IssueDimensionMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.Dimension.IssueDimensionMetadata"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for IssueDimensionMetadata {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __issue_id,
                __issue_display_name,
                __issue_model_id,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for IssueDimensionMetadata")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "issueId" => Ok(__FieldTag::__issue_id),
                                "issue_id" => Ok(__FieldTag::__issue_id),
                                "issueDisplayName" => Ok(__FieldTag::__issue_display_name),
                                "issue_display_name" => Ok(__FieldTag::__issue_display_name),
                                "issueModelId" => Ok(__FieldTag::__issue_model_id),
                                "issue_model_id" => Ok(__FieldTag::__issue_model_id),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = IssueDimensionMetadata;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct IssueDimensionMetadata")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__issue_id => {
                                if !fields.insert(__FieldTag::__issue_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for issue_id",
                                    ));
                                }
                                result.issue_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__issue_display_name => {
                                if !fields.insert(__FieldTag::__issue_display_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for issue_display_name",
                                    ));
                                }
                                result.issue_display_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__issue_model_id => {
                                if !fields.insert(__FieldTag::__issue_model_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for issue_model_id",
                                    ));
                                }
                                result.issue_model_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for IssueDimensionMetadata {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.issue_id.is_empty() {
                state.serialize_entry("issueId", &self.issue_id)?;
            }
            if !self.issue_display_name.is_empty() {
                state.serialize_entry("issueDisplayName", &self.issue_display_name)?;
            }
            if !self.issue_model_id.is_empty() {
                state.serialize_entry("issueModelId", &self.issue_model_id)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for IssueDimensionMetadata {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("IssueDimensionMetadata");
            debug_struct.field("issue_id", &self.issue_id);
            debug_struct.field("issue_display_name", &self.issue_display_name);
            debug_struct.field("issue_model_id", &self.issue_model_id);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Metadata about the agent dimension.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AgentDimensionMetadata {
        /// Optional. A user-specified string representing the agent.
        pub agent_id: std::string::String,

        /// Optional. The agent's name
        pub agent_display_name: std::string::String,

        /// Optional. A user-specified string representing the agent's team.
        pub agent_team: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AgentDimensionMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [agent_id][crate::model::dimension::AgentDimensionMetadata::agent_id].
        pub fn set_agent_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.agent_id = v.into();
            self
        }

        /// Sets the value of [agent_display_name][crate::model::dimension::AgentDimensionMetadata::agent_display_name].
        pub fn set_agent_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.agent_display_name = v.into();
            self
        }

        /// Sets the value of [agent_team][crate::model::dimension::AgentDimensionMetadata::agent_team].
        pub fn set_agent_team<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.agent_team = v.into();
            self
        }
    }

    impl wkt::message::Message for AgentDimensionMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.Dimension.AgentDimensionMetadata"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AgentDimensionMetadata {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __agent_id,
                __agent_display_name,
                __agent_team,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AgentDimensionMetadata")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "agentId" => Ok(__FieldTag::__agent_id),
                                "agent_id" => Ok(__FieldTag::__agent_id),
                                "agentDisplayName" => Ok(__FieldTag::__agent_display_name),
                                "agent_display_name" => Ok(__FieldTag::__agent_display_name),
                                "agentTeam" => Ok(__FieldTag::__agent_team),
                                "agent_team" => Ok(__FieldTag::__agent_team),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AgentDimensionMetadata;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AgentDimensionMetadata")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__agent_id => {
                                if !fields.insert(__FieldTag::__agent_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for agent_id",
                                    ));
                                }
                                result.agent_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__agent_display_name => {
                                if !fields.insert(__FieldTag::__agent_display_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for agent_display_name",
                                    ));
                                }
                                result.agent_display_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__agent_team => {
                                if !fields.insert(__FieldTag::__agent_team) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for agent_team",
                                    ));
                                }
                                result.agent_team = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AgentDimensionMetadata {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.agent_id.is_empty() {
                state.serialize_entry("agentId", &self.agent_id)?;
            }
            if !self.agent_display_name.is_empty() {
                state.serialize_entry("agentDisplayName", &self.agent_display_name)?;
            }
            if !self.agent_team.is_empty() {
                state.serialize_entry("agentTeam", &self.agent_team)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for AgentDimensionMetadata {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("AgentDimensionMetadata");
            debug_struct.field("agent_id", &self.agent_id);
            debug_struct.field("agent_display_name", &self.agent_display_name);
            debug_struct.field("agent_team", &self.agent_team);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Metadata about the QA question dimension.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct QaQuestionDimensionMetadata {
        /// Optional. The QA scorecard ID.
        pub qa_scorecard_id: std::string::String,

        /// Optional. The QA question ID.
        pub qa_question_id: std::string::String,

        /// Optional. The full body of the question.
        pub question_body: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl QaQuestionDimensionMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [qa_scorecard_id][crate::model::dimension::QaQuestionDimensionMetadata::qa_scorecard_id].
        pub fn set_qa_scorecard_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.qa_scorecard_id = v.into();
            self
        }

        /// Sets the value of [qa_question_id][crate::model::dimension::QaQuestionDimensionMetadata::qa_question_id].
        pub fn set_qa_question_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.qa_question_id = v.into();
            self
        }

        /// Sets the value of [question_body][crate::model::dimension::QaQuestionDimensionMetadata::question_body].
        pub fn set_question_body<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.question_body = v.into();
            self
        }
    }

    impl wkt::message::Message for QaQuestionDimensionMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.Dimension.QaQuestionDimensionMetadata"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for QaQuestionDimensionMetadata {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __qa_scorecard_id,
                __qa_question_id,
                __question_body,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for QaQuestionDimensionMetadata")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "qaScorecardId" => Ok(__FieldTag::__qa_scorecard_id),
                                "qa_scorecard_id" => Ok(__FieldTag::__qa_scorecard_id),
                                "qaQuestionId" => Ok(__FieldTag::__qa_question_id),
                                "qa_question_id" => Ok(__FieldTag::__qa_question_id),
                                "questionBody" => Ok(__FieldTag::__question_body),
                                "question_body" => Ok(__FieldTag::__question_body),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = QaQuestionDimensionMetadata;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct QaQuestionDimensionMetadata")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__qa_scorecard_id => {
                                if !fields.insert(__FieldTag::__qa_scorecard_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for qa_scorecard_id",
                                    ));
                                }
                                result.qa_scorecard_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__qa_question_id => {
                                if !fields.insert(__FieldTag::__qa_question_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for qa_question_id",
                                    ));
                                }
                                result.qa_question_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__question_body => {
                                if !fields.insert(__FieldTag::__question_body) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for question_body",
                                    ));
                                }
                                result.question_body = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for QaQuestionDimensionMetadata {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.qa_scorecard_id.is_empty() {
                state.serialize_entry("qaScorecardId", &self.qa_scorecard_id)?;
            }
            if !self.qa_question_id.is_empty() {
                state.serialize_entry("qaQuestionId", &self.qa_question_id)?;
            }
            if !self.question_body.is_empty() {
                state.serialize_entry("questionBody", &self.question_body)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for QaQuestionDimensionMetadata {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("QaQuestionDimensionMetadata");
            debug_struct.field("qa_scorecard_id", &self.qa_scorecard_id);
            debug_struct.field("qa_question_id", &self.qa_question_id);
            debug_struct.field("question_body", &self.question_body);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Metadata about the QA question-answer dimension.
    /// This is useful for showing the answer distribution for questions for a
    /// given scorecard.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct QaQuestionAnswerDimensionMetadata {
        /// Optional. The QA scorecard ID.
        pub qa_scorecard_id: std::string::String,

        /// Optional. The QA question ID.
        pub qa_question_id: std::string::String,

        /// Optional. The full body of the question.
        pub question_body: std::string::String,

        /// Optional. The full body of the question.
        pub answer_value: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl QaQuestionAnswerDimensionMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [qa_scorecard_id][crate::model::dimension::QaQuestionAnswerDimensionMetadata::qa_scorecard_id].
        pub fn set_qa_scorecard_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.qa_scorecard_id = v.into();
            self
        }

        /// Sets the value of [qa_question_id][crate::model::dimension::QaQuestionAnswerDimensionMetadata::qa_question_id].
        pub fn set_qa_question_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.qa_question_id = v.into();
            self
        }

        /// Sets the value of [question_body][crate::model::dimension::QaQuestionAnswerDimensionMetadata::question_body].
        pub fn set_question_body<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.question_body = v.into();
            self
        }

        /// Sets the value of [answer_value][crate::model::dimension::QaQuestionAnswerDimensionMetadata::answer_value].
        pub fn set_answer_value<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.answer_value = v.into();
            self
        }
    }

    impl wkt::message::Message for QaQuestionAnswerDimensionMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.Dimension.QaQuestionAnswerDimensionMetadata"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for QaQuestionAnswerDimensionMetadata {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __qa_scorecard_id,
                __qa_question_id,
                __question_body,
                __answer_value,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter
                                .write_str("a field name for QaQuestionAnswerDimensionMetadata")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "qaScorecardId" => Ok(__FieldTag::__qa_scorecard_id),
                                "qa_scorecard_id" => Ok(__FieldTag::__qa_scorecard_id),
                                "qaQuestionId" => Ok(__FieldTag::__qa_question_id),
                                "qa_question_id" => Ok(__FieldTag::__qa_question_id),
                                "questionBody" => Ok(__FieldTag::__question_body),
                                "question_body" => Ok(__FieldTag::__question_body),
                                "answerValue" => Ok(__FieldTag::__answer_value),
                                "answer_value" => Ok(__FieldTag::__answer_value),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = QaQuestionAnswerDimensionMetadata;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct QaQuestionAnswerDimensionMetadata")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__qa_scorecard_id => {
                                if !fields.insert(__FieldTag::__qa_scorecard_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for qa_scorecard_id",
                                    ));
                                }
                                result.qa_scorecard_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__qa_question_id => {
                                if !fields.insert(__FieldTag::__qa_question_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for qa_question_id",
                                    ));
                                }
                                result.qa_question_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__question_body => {
                                if !fields.insert(__FieldTag::__question_body) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for question_body",
                                    ));
                                }
                                result.question_body = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__answer_value => {
                                if !fields.insert(__FieldTag::__answer_value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for answer_value",
                                    ));
                                }
                                result.answer_value = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for QaQuestionAnswerDimensionMetadata {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.qa_scorecard_id.is_empty() {
                state.serialize_entry("qaScorecardId", &self.qa_scorecard_id)?;
            }
            if !self.qa_question_id.is_empty() {
                state.serialize_entry("qaQuestionId", &self.qa_question_id)?;
            }
            if !self.question_body.is_empty() {
                state.serialize_entry("questionBody", &self.question_body)?;
            }
            if !self.answer_value.is_empty() {
                state.serialize_entry("answerValue", &self.answer_value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for QaQuestionAnswerDimensionMetadata {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("QaQuestionAnswerDimensionMetadata");
            debug_struct.field("qa_scorecard_id", &self.qa_scorecard_id);
            debug_struct.field("qa_question_id", &self.qa_question_id);
            debug_struct.field("question_body", &self.question_body);
            debug_struct.field("answer_value", &self.answer_value);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// The key of the dimension.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DimensionKey {
        /// The key of the dimension is unspecified.
        Unspecified,
        /// The dimension is keyed by issues.
        Issue,
        /// The dimension is keyed by agents.
        Agent,
        /// The dimension is keyed by agent teams.
        AgentTeam,
        /// The dimension is keyed by QaQuestionIds.
        /// Note that: We only group by the QuestionId and not the revision-id of the
        /// scorecard this question is a part of. This allows for showing stats for
        /// the same question across different scorecard revisions.
        QaQuestionId,
        /// The dimension is keyed by QaQuestionIds-Answer value pairs.
        /// Note that: We only group by the QuestionId and not the revision-id of the
        /// scorecard this question is a part of. This allows for showing
        /// distribution of answers per question across different scorecard
        /// revisions.
        QaQuestionAnswerValue,
        /// The dimension is keyed by the conversation profile ID.
        ConversationProfileId,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DimensionKey::value] or
        /// [DimensionKey::name].
        UnknownValue(dimension_key::UnknownValue),
    }

    #[doc(hidden)]
    pub mod dimension_key {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DimensionKey {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Issue => std::option::Option::Some(1),
                Self::Agent => std::option::Option::Some(2),
                Self::AgentTeam => std::option::Option::Some(3),
                Self::QaQuestionId => std::option::Option::Some(4),
                Self::QaQuestionAnswerValue => std::option::Option::Some(5),
                Self::ConversationProfileId => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DIMENSION_KEY_UNSPECIFIED"),
                Self::Issue => std::option::Option::Some("ISSUE"),
                Self::Agent => std::option::Option::Some("AGENT"),
                Self::AgentTeam => std::option::Option::Some("AGENT_TEAM"),
                Self::QaQuestionId => std::option::Option::Some("QA_QUESTION_ID"),
                Self::QaQuestionAnswerValue => {
                    std::option::Option::Some("QA_QUESTION_ANSWER_VALUE")
                }
                Self::ConversationProfileId => std::option::Option::Some("CONVERSATION_PROFILE_ID"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DimensionKey {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DimensionKey {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DimensionKey {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Issue,
                2 => Self::Agent,
                3 => Self::AgentTeam,
                4 => Self::QaQuestionId,
                5 => Self::QaQuestionAnswerValue,
                6 => Self::ConversationProfileId,
                _ => Self::UnknownValue(dimension_key::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DimensionKey {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DIMENSION_KEY_UNSPECIFIED" => Self::Unspecified,
                "ISSUE" => Self::Issue,
                "AGENT" => Self::Agent,
                "AGENT_TEAM" => Self::AgentTeam,
                "QA_QUESTION_ID" => Self::QaQuestionId,
                "QA_QUESTION_ANSWER_VALUE" => Self::QaQuestionAnswerValue,
                "CONVERSATION_PROFILE_ID" => Self::ConversationProfileId,
                _ => Self::UnknownValue(dimension_key::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DimensionKey {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Issue => serializer.serialize_i32(1),
                Self::Agent => serializer.serialize_i32(2),
                Self::AgentTeam => serializer.serialize_i32(3),
                Self::QaQuestionId => serializer.serialize_i32(4),
                Self::QaQuestionAnswerValue => serializer.serialize_i32(5),
                Self::ConversationProfileId => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DimensionKey {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DimensionKey>::new(
                ".google.cloud.contactcenterinsights.v1.Dimension.DimensionKey",
            ))
        }
    }

    /// Output-only metadata about the dimension.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DimensionMetadata {
        /// Output only. Metadata about the issue dimension.
        IssueDimensionMetadata(std::boxed::Box<crate::model::dimension::IssueDimensionMetadata>),
        /// Output only. Metadata about the agent dimension.
        AgentDimensionMetadata(std::boxed::Box<crate::model::dimension::AgentDimensionMetadata>),
        /// Output only. Metadata about the QA question dimension.
        QaQuestionDimensionMetadata(
            std::boxed::Box<crate::model::dimension::QaQuestionDimensionMetadata>,
        ),
        /// Output only. Metadata about the QA question-answer dimension.
        QaQuestionAnswerDimensionMetadata(
            std::boxed::Box<crate::model::dimension::QaQuestionAnswerDimensionMetadata>,
        ),
    }
}

/// The request for querying metrics.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct QueryMetricsRequest {
    /// Required. The location of the data.
    /// "projects/{project}/locations/{location}"
    pub location: std::string::String,

    /// Required. Filter to select a subset of conversations to compute the
    /// metrics. Must specify a window of the conversation create time to compute
    /// the metrics. The returned metrics will be from the range [DATE(starting
    /// create time), DATE(ending create time)).
    pub filter: std::string::String,

    /// The time granularity of each data point in the time series.
    /// Defaults to NONE if this field is unspecified.
    pub time_granularity: crate::model::query_metrics_request::TimeGranularity,

    /// The dimensions that determine the grouping key for the query. Defaults to
    /// no dimension if this field is unspecified. If a dimension is specified,
    /// its key must also be specified. Each dimension's key must be unique.
    ///
    /// If a time granularity is also specified, metric values in the dimension
    /// will be bucketed by this granularity.
    ///
    /// Up to one dimension is supported for now.
    pub dimensions: std::vec::Vec<crate::model::Dimension>,

    /// Measures to return. Defaults to all measures if this field is unspecified.
    /// A valid mask should traverse from the `measure` field from the response.
    /// For example, a path from a measure mask to get the conversation count is
    /// "conversation_measure.count".
    pub measure_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QueryMetricsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::QueryMetricsRequest::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::QueryMetricsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [time_granularity][crate::model::QueryMetricsRequest::time_granularity].
    pub fn set_time_granularity<
        T: std::convert::Into<crate::model::query_metrics_request::TimeGranularity>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.time_granularity = v.into();
        self
    }

    /// Sets the value of [dimensions][crate::model::QueryMetricsRequest::dimensions].
    pub fn set_dimensions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Dimension>,
    {
        use std::iter::Iterator;
        self.dimensions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [measure_mask][crate::model::QueryMetricsRequest::measure_mask].
    pub fn set_measure_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.measure_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [measure_mask][crate::model::QueryMetricsRequest::measure_mask].
    pub fn set_or_clear_measure_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.measure_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for QueryMetricsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.QueryMetricsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for QueryMetricsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __location,
            __filter,
            __time_granularity,
            __dimensions,
            __measure_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QueryMetricsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "location" => Ok(__FieldTag::__location),
                            "filter" => Ok(__FieldTag::__filter),
                            "timeGranularity" => Ok(__FieldTag::__time_granularity),
                            "time_granularity" => Ok(__FieldTag::__time_granularity),
                            "dimensions" => Ok(__FieldTag::__dimensions),
                            "measureMask" => Ok(__FieldTag::__measure_mask),
                            "measure_mask" => Ok(__FieldTag::__measure_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = QueryMetricsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QueryMetricsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__time_granularity => {
                            if !fields.insert(__FieldTag::__time_granularity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_granularity",
                                ));
                            }
                            result.time_granularity = map
                                .next_value::<std::option::Option<
                                    crate::model::query_metrics_request::TimeGranularity,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dimensions => {
                            if !fields.insert(__FieldTag::__dimensions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dimensions",
                                ));
                            }
                            result.dimensions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Dimension>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__measure_mask => {
                            if !fields.insert(__FieldTag::__measure_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for measure_mask",
                                ));
                            }
                            result.measure_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for QueryMetricsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.time_granularity) {
            state.serialize_entry("timeGranularity", &self.time_granularity)?;
        }
        if !self.dimensions.is_empty() {
            state.serialize_entry("dimensions", &self.dimensions)?;
        }
        if self.measure_mask.is_some() {
            state.serialize_entry("measureMask", &self.measure_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for QueryMetricsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("QueryMetricsRequest");
        debug_struct.field("location", &self.location);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("time_granularity", &self.time_granularity);
        debug_struct.field("dimensions", &self.dimensions);
        debug_struct.field("measure_mask", &self.measure_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [QueryMetricsRequest].
pub mod query_metrics_request {
    #[allow(unused_imports)]
    use super::*;

    /// A time granularity divides the time line into discrete time periods.
    /// This is useful for defining buckets over which filtering and aggregation
    /// should be performed.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TimeGranularity {
        /// The time granularity is unspecified and will default to NONE.
        Unspecified,
        /// No time granularity. The response won't contain a time series.
        /// This is the default value if no time granularity is specified.
        None,
        /// Data points in the time series will aggregate at a daily granularity.
        /// 1 day means [midnight to midnight).
        Daily,
        /// Data points in the time series will aggregate at a daily granularity.
        /// 1 HOUR means [01:00 to 02:00).
        Hourly,
        /// Data points in the time series will aggregate at a daily granularity.
        /// PER_MINUTE means [01:00 to 01:01).
        PerMinute,
        /// Data points in the time series will aggregate at a 1 minute  granularity.
        /// PER_5_MINUTES means [01:00 to 01:05).
        Per5Minutes,
        /// Data points in the time series will aggregate at a monthly granularity.
        /// 1 MONTH means [01st of the month to 1st of the next month).
        Monthly,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TimeGranularity::value] or
        /// [TimeGranularity::name].
        UnknownValue(time_granularity::UnknownValue),
    }

    #[doc(hidden)]
    pub mod time_granularity {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TimeGranularity {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::None => std::option::Option::Some(1),
                Self::Daily => std::option::Option::Some(2),
                Self::Hourly => std::option::Option::Some(3),
                Self::PerMinute => std::option::Option::Some(4),
                Self::Per5Minutes => std::option::Option::Some(5),
                Self::Monthly => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TIME_GRANULARITY_UNSPECIFIED"),
                Self::None => std::option::Option::Some("NONE"),
                Self::Daily => std::option::Option::Some("DAILY"),
                Self::Hourly => std::option::Option::Some("HOURLY"),
                Self::PerMinute => std::option::Option::Some("PER_MINUTE"),
                Self::Per5Minutes => std::option::Option::Some("PER_5_MINUTES"),
                Self::Monthly => std::option::Option::Some("MONTHLY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TimeGranularity {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TimeGranularity {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TimeGranularity {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::None,
                2 => Self::Daily,
                3 => Self::Hourly,
                4 => Self::PerMinute,
                5 => Self::Per5Minutes,
                6 => Self::Monthly,
                _ => Self::UnknownValue(time_granularity::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TimeGranularity {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TIME_GRANULARITY_UNSPECIFIED" => Self::Unspecified,
                "NONE" => Self::None,
                "DAILY" => Self::Daily,
                "HOURLY" => Self::Hourly,
                "PER_MINUTE" => Self::PerMinute,
                "PER_5_MINUTES" => Self::Per5Minutes,
                "MONTHLY" => Self::Monthly,
                _ => Self::UnknownValue(time_granularity::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TimeGranularity {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::None => serializer.serialize_i32(1),
                Self::Daily => serializer.serialize_i32(2),
                Self::Hourly => serializer.serialize_i32(3),
                Self::PerMinute => serializer.serialize_i32(4),
                Self::Per5Minutes => serializer.serialize_i32(5),
                Self::Monthly => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TimeGranularity {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TimeGranularity>::new(
                ".google.cloud.contactcenterinsights.v1.QueryMetricsRequest.TimeGranularity",
            ))
        }
    }
}

/// The response for querying metrics.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct QueryMetricsResponse {
    /// Required. The location of the data.
    /// "projects/{project}/locations/{location}"
    pub location: std::string::String,

    /// The metrics last update time.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// A slice contains a total and (if the request specified a time granularity)
    /// a time series of metric values. Each slice contains a unique combination of
    /// the cardinality of dimensions from the request.
    pub slices: std::vec::Vec<crate::model::query_metrics_response::Slice>,

    /// The macro average slice contains aggregated averages across the selected
    /// dimension. i.e. if group_by agent is specified this field will contain the
    /// average across all agents.
    /// This field is only populated if the request specifies a Dimension.
    pub macro_average_slice: std::option::Option<crate::model::query_metrics_response::Slice>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QueryMetricsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::QueryMetricsResponse::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::QueryMetricsResponse::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::QueryMetricsResponse::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [slices][crate::model::QueryMetricsResponse::slices].
    pub fn set_slices<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::query_metrics_response::Slice>,
    {
        use std::iter::Iterator;
        self.slices = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [macro_average_slice][crate::model::QueryMetricsResponse::macro_average_slice].
    pub fn set_macro_average_slice<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::query_metrics_response::Slice>,
    {
        self.macro_average_slice = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [macro_average_slice][crate::model::QueryMetricsResponse::macro_average_slice].
    pub fn set_or_clear_macro_average_slice<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::query_metrics_response::Slice>,
    {
        self.macro_average_slice = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for QueryMetricsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.QueryMetricsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for QueryMetricsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __location,
            __update_time,
            __slices,
            __macro_average_slice,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QueryMetricsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "location" => Ok(__FieldTag::__location),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "slices" => Ok(__FieldTag::__slices),
                            "macroAverageSlice" => Ok(__FieldTag::__macro_average_slice),
                            "macro_average_slice" => Ok(__FieldTag::__macro_average_slice),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = QueryMetricsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QueryMetricsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__slices => {
                            if !fields.insert(__FieldTag::__slices) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for slices",
                                ));
                            }
                            result.slices = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::query_metrics_response::Slice>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__macro_average_slice => {
                            if !fields.insert(__FieldTag::__macro_average_slice) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for macro_average_slice",
                                ));
                            }
                            result.macro_average_slice =
                                map.next_value::<std::option::Option<
                                    crate::model::query_metrics_response::Slice,
                                >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for QueryMetricsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.slices.is_empty() {
            state.serialize_entry("slices", &self.slices)?;
        }
        if self.macro_average_slice.is_some() {
            state.serialize_entry("macroAverageSlice", &self.macro_average_slice)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for QueryMetricsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("QueryMetricsResponse");
        debug_struct.field("location", &self.location);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("slices", &self.slices);
        debug_struct.field("macro_average_slice", &self.macro_average_slice);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [QueryMetricsResponse].
pub mod query_metrics_response {
    #[allow(unused_imports)]
    use super::*;

    /// A slice contains a total and (if the request specified a time granularity)
    /// a time series of metric values. Each slice contains a unique combination of
    /// the cardinality of dimensions from the request.
    ///
    /// For example, if the request specifies a single ISSUE dimension and it has a
    /// cardinality of 2 (i.e. the data used to compute the metrics has 2 issues in
    /// total), the response will have 2 slices:
    ///
    /// * Slice 1 -> dimensions=[Issue 1]
    /// * Slice 2 -> dimensions=[Issue 2]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Slice {
        /// A unique combination of dimensions that this slice represents.
        pub dimensions: std::vec::Vec<crate::model::Dimension>,

        /// The total metric value. The interval of this data point is
        /// [starting create time, ending create time) from the request.
        pub total: std::option::Option<crate::model::query_metrics_response::slice::DataPoint>,

        /// A time series of metric values. This is only populated if the request
        /// specifies a time granularity other than NONE.
        pub time_series:
            std::option::Option<crate::model::query_metrics_response::slice::TimeSeries>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Slice {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [dimensions][crate::model::query_metrics_response::Slice::dimensions].
        pub fn set_dimensions<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::Dimension>,
        {
            use std::iter::Iterator;
            self.dimensions = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [total][crate::model::query_metrics_response::Slice::total].
        pub fn set_total<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::query_metrics_response::slice::DataPoint>,
        {
            self.total = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [total][crate::model::query_metrics_response::Slice::total].
        pub fn set_or_clear_total<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::query_metrics_response::slice::DataPoint>,
        {
            self.total = v.map(|x| x.into());
            self
        }

        /// Sets the value of [time_series][crate::model::query_metrics_response::Slice::time_series].
        pub fn set_time_series<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::query_metrics_response::slice::TimeSeries>,
        {
            self.time_series = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [time_series][crate::model::query_metrics_response::Slice::time_series].
        pub fn set_or_clear_time_series<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::query_metrics_response::slice::TimeSeries>,
        {
            self.time_series = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for Slice {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.QueryMetricsResponse.Slice"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Slice {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __dimensions,
                __total,
                __time_series,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Slice")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "dimensions" => Ok(__FieldTag::__dimensions),
                                "total" => Ok(__FieldTag::__total),
                                "timeSeries" => Ok(__FieldTag::__time_series),
                                "time_series" => Ok(__FieldTag::__time_series),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Slice;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Slice")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__dimensions => {
                                if !fields.insert(__FieldTag::__dimensions) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for dimensions",
                                    ));
                                }
                                result.dimensions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Dimension>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__total => {
                                if !fields.insert(__FieldTag::__total) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for total",
                                    ));
                                }
                                result.total = map.next_value::<std::option::Option<
                                    crate::model::query_metrics_response::slice::DataPoint,
                                >>()?;
                            }
                            __FieldTag::__time_series => {
                                if !fields.insert(__FieldTag::__time_series) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for time_series",
                                    ));
                                }
                                result.time_series = map.next_value::<std::option::Option<
                                    crate::model::query_metrics_response::slice::TimeSeries,
                                >>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Slice {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.dimensions.is_empty() {
                state.serialize_entry("dimensions", &self.dimensions)?;
            }
            if self.total.is_some() {
                state.serialize_entry("total", &self.total)?;
            }
            if self.time_series.is_some() {
                state.serialize_entry("timeSeries", &self.time_series)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Slice {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Slice");
            debug_struct.field("dimensions", &self.dimensions);
            debug_struct.field("total", &self.total);
            debug_struct.field("time_series", &self.time_series);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [Slice].
    pub mod slice {
        #[allow(unused_imports)]
        use super::*;

        /// A data point contains the metric values mapped to an interval.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct DataPoint {
            /// The interval that this data point represents.
            ///
            /// * If this is the total data point, the interval is
            ///   [starting create time, ending create time) from the request.
            /// * If this a data point from the time series, the interval is
            ///   [time, time + time granularity from the request).
            pub interval: std::option::Option<gtype::model::Interval>,

            /// The measure included in this data point.
            pub measure: std::option::Option<
                crate::model::query_metrics_response::slice::data_point::Measure,
            >,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl DataPoint {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [interval][crate::model::query_metrics_response::slice::DataPoint::interval].
            pub fn set_interval<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<gtype::model::Interval>,
            {
                self.interval = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [interval][crate::model::query_metrics_response::slice::DataPoint::interval].
            pub fn set_or_clear_interval<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<gtype::model::Interval>,
            {
                self.interval = v.map(|x| x.into());
                self
            }

            /// Sets the value of [measure][crate::model::query_metrics_response::slice::DataPoint::measure].
            ///
            /// Note that all the setters affecting `measure` are mutually
            /// exclusive.
            pub fn set_measure<
                T: std::convert::Into<
                        std::option::Option<
                            crate::model::query_metrics_response::slice::data_point::Measure,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.measure = v.into();
                self
            }

            /// The value of [measure][crate::model::query_metrics_response::slice::DataPoint::measure]
            /// if it holds a `ConversationMeasure`, `None` if the field is not set or
            /// holds a different branch.
            pub fn conversation_measure(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<
                    crate::model::query_metrics_response::slice::data_point::ConversationMeasure,
                >,
            > {
                #[allow(unreachable_patterns)]
                self.measure.as_ref().and_then(|v| match v {
                    crate::model::query_metrics_response::slice::data_point::Measure::ConversationMeasure(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [measure][crate::model::query_metrics_response::slice::DataPoint::measure]
            /// to hold a `ConversationMeasure`.
            ///
            /// Note that all the setters affecting `measure` are
            /// mutually exclusive.
            pub fn set_conversation_measure<T: std::convert::Into<std::boxed::Box<crate::model::query_metrics_response::slice::data_point::ConversationMeasure>>>(mut self, v: T) -> Self{
                self.measure = std::option::Option::Some(
                    crate::model::query_metrics_response::slice::data_point::Measure::ConversationMeasure(
                        v.into()
                    )
                );
                self
            }
        }

        impl wkt::message::Message for DataPoint {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.contactcenterinsights.v1.QueryMetricsResponse.Slice.DataPoint"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for DataPoint {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __conversation_measure,
                    __interval,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for DataPoint")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "conversationMeasure" => Ok(__FieldTag::__conversation_measure),
                                    "conversation_measure" => {
                                        Ok(__FieldTag::__conversation_measure)
                                    }
                                    "interval" => Ok(__FieldTag::__interval),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = DataPoint;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct DataPoint")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__conversation_measure => {
                                    if !fields.insert(__FieldTag::__conversation_measure) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for conversation_measure",
                                            ),
                                        );
                                    }
                                    if result.measure.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `measure`, a oneof with full ID .google.cloud.contactcenterinsights.v1.QueryMetricsResponse.Slice.DataPoint.conversation_measure, latest field was conversationMeasure",
                                            ),
                                        );
                                    }
                                    result.measure = std::option::Option::Some(
                                        crate::model::query_metrics_response::slice::data_point::Measure::ConversationMeasure(
                                            map.next_value::<std::option::Option<std::boxed::Box<crate::model::query_metrics_response::slice::data_point::ConversationMeasure>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__interval => {
                                    if !fields.insert(__FieldTag::__interval) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for interval",
                                            ),
                                        );
                                    }
                                    result.interval = map
                                        .next_value::<std::option::Option<gtype::model::Interval>>(
                                        )?;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for DataPoint {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if let Some(value) = self.conversation_measure() {
                    state.serialize_entry("conversationMeasure", value)?;
                }
                if self.interval.is_some() {
                    state.serialize_entry("interval", &self.interval)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for DataPoint {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("DataPoint");
                debug_struct.field("interval", &self.interval);
                debug_struct.field("measure", &self.measure);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// Defines additional types related to [DataPoint].
        pub mod data_point {
            #[allow(unused_imports)]
            use super::*;

            /// The measure related to conversations.
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct ConversationMeasure {

                /// The conversation count.
                pub conversation_count: std::option::Option<i32>,

                /// The average silence percentage.
                pub average_silence_percentage: std::option::Option<f32>,

                /// The average duration.
                pub average_duration: std::option::Option<wkt::Duration>,

                /// The average turn count.
                pub average_turn_count: std::option::Option<f32>,

                /// The average agent's sentiment score.
                pub average_agent_sentiment_score: std::option::Option<f32>,

                /// The average client's sentiment score.
                pub average_client_sentiment_score: std::option::Option<f32>,

                /// The average customer satisfaction rating.
                pub average_customer_satisfaction_rating: std::option::Option<f64>,

                /// Average QA normalized score.
                /// Will exclude 0's in average calculation.
                pub average_qa_normalized_score: std::option::Option<f64>,

                /// Average QA normalized score for all the tags.
                pub qa_tag_scores: std::vec::Vec<crate::model::query_metrics_response::slice::data_point::conversation_measure::QaTagScore>,

                /// Average QA normalized score averaged for questions averaged across
                /// all revisions of the parent scorecard.
                /// Will be only populated if the request specifies a dimension of
                /// QA_QUESTION_ID.
                pub average_qa_question_normalized_score: std::option::Option<f64>,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl ConversationMeasure {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [conversation_count][crate::model::query_metrics_response::slice::data_point::ConversationMeasure::conversation_count].
                pub fn set_conversation_count<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<i32>,
                {
                    self.conversation_count = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [conversation_count][crate::model::query_metrics_response::slice::data_point::ConversationMeasure::conversation_count].
                pub fn set_or_clear_conversation_count<T>(
                    mut self,
                    v: std::option::Option<T>,
                ) -> Self
                where
                    T: std::convert::Into<i32>,
                {
                    self.conversation_count = v.map(|x| x.into());
                    self
                }

                /// Sets the value of [average_silence_percentage][crate::model::query_metrics_response::slice::data_point::ConversationMeasure::average_silence_percentage].
                pub fn set_average_silence_percentage<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<f32>,
                {
                    self.average_silence_percentage = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [average_silence_percentage][crate::model::query_metrics_response::slice::data_point::ConversationMeasure::average_silence_percentage].
                pub fn set_or_clear_average_silence_percentage<T>(
                    mut self,
                    v: std::option::Option<T>,
                ) -> Self
                where
                    T: std::convert::Into<f32>,
                {
                    self.average_silence_percentage = v.map(|x| x.into());
                    self
                }

                /// Sets the value of [average_duration][crate::model::query_metrics_response::slice::data_point::ConversationMeasure::average_duration].
                pub fn set_average_duration<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<wkt::Duration>,
                {
                    self.average_duration = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [average_duration][crate::model::query_metrics_response::slice::data_point::ConversationMeasure::average_duration].
                pub fn set_or_clear_average_duration<T>(mut self, v: std::option::Option<T>) -> Self
                where
                    T: std::convert::Into<wkt::Duration>,
                {
                    self.average_duration = v.map(|x| x.into());
                    self
                }

                /// Sets the value of [average_turn_count][crate::model::query_metrics_response::slice::data_point::ConversationMeasure::average_turn_count].
                pub fn set_average_turn_count<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<f32>,
                {
                    self.average_turn_count = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [average_turn_count][crate::model::query_metrics_response::slice::data_point::ConversationMeasure::average_turn_count].
                pub fn set_or_clear_average_turn_count<T>(
                    mut self,
                    v: std::option::Option<T>,
                ) -> Self
                where
                    T: std::convert::Into<f32>,
                {
                    self.average_turn_count = v.map(|x| x.into());
                    self
                }

                /// Sets the value of [average_agent_sentiment_score][crate::model::query_metrics_response::slice::data_point::ConversationMeasure::average_agent_sentiment_score].
                pub fn set_average_agent_sentiment_score<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<f32>,
                {
                    self.average_agent_sentiment_score = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [average_agent_sentiment_score][crate::model::query_metrics_response::slice::data_point::ConversationMeasure::average_agent_sentiment_score].
                pub fn set_or_clear_average_agent_sentiment_score<T>(
                    mut self,
                    v: std::option::Option<T>,
                ) -> Self
                where
                    T: std::convert::Into<f32>,
                {
                    self.average_agent_sentiment_score = v.map(|x| x.into());
                    self
                }

                /// Sets the value of [average_client_sentiment_score][crate::model::query_metrics_response::slice::data_point::ConversationMeasure::average_client_sentiment_score].
                pub fn set_average_client_sentiment_score<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<f32>,
                {
                    self.average_client_sentiment_score = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [average_client_sentiment_score][crate::model::query_metrics_response::slice::data_point::ConversationMeasure::average_client_sentiment_score].
                pub fn set_or_clear_average_client_sentiment_score<T>(
                    mut self,
                    v: std::option::Option<T>,
                ) -> Self
                where
                    T: std::convert::Into<f32>,
                {
                    self.average_client_sentiment_score = v.map(|x| x.into());
                    self
                }

                /// Sets the value of [average_customer_satisfaction_rating][crate::model::query_metrics_response::slice::data_point::ConversationMeasure::average_customer_satisfaction_rating].
                pub fn set_average_customer_satisfaction_rating<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<f64>,
                {
                    self.average_customer_satisfaction_rating = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [average_customer_satisfaction_rating][crate::model::query_metrics_response::slice::data_point::ConversationMeasure::average_customer_satisfaction_rating].
                pub fn set_or_clear_average_customer_satisfaction_rating<T>(
                    mut self,
                    v: std::option::Option<T>,
                ) -> Self
                where
                    T: std::convert::Into<f64>,
                {
                    self.average_customer_satisfaction_rating = v.map(|x| x.into());
                    self
                }

                /// Sets the value of [average_qa_normalized_score][crate::model::query_metrics_response::slice::data_point::ConversationMeasure::average_qa_normalized_score].
                pub fn set_average_qa_normalized_score<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<f64>,
                {
                    self.average_qa_normalized_score = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [average_qa_normalized_score][crate::model::query_metrics_response::slice::data_point::ConversationMeasure::average_qa_normalized_score].
                pub fn set_or_clear_average_qa_normalized_score<T>(
                    mut self,
                    v: std::option::Option<T>,
                ) -> Self
                where
                    T: std::convert::Into<f64>,
                {
                    self.average_qa_normalized_score = v.map(|x| x.into());
                    self
                }

                /// Sets the value of [qa_tag_scores][crate::model::query_metrics_response::slice::data_point::ConversationMeasure::qa_tag_scores].
                pub fn set_qa_tag_scores<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<crate::model::query_metrics_response::slice::data_point::conversation_measure::QaTagScore>
                {
                    use std::iter::Iterator;
                    self.qa_tag_scores = v.into_iter().map(|i| i.into()).collect();
                    self
                }

                /// Sets the value of [average_qa_question_normalized_score][crate::model::query_metrics_response::slice::data_point::ConversationMeasure::average_qa_question_normalized_score].
                pub fn set_average_qa_question_normalized_score<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<f64>,
                {
                    self.average_qa_question_normalized_score = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [average_qa_question_normalized_score][crate::model::query_metrics_response::slice::data_point::ConversationMeasure::average_qa_question_normalized_score].
                pub fn set_or_clear_average_qa_question_normalized_score<T>(
                    mut self,
                    v: std::option::Option<T>,
                ) -> Self
                where
                    T: std::convert::Into<f64>,
                {
                    self.average_qa_question_normalized_score = v.map(|x| x.into());
                    self
                }
            }

            impl wkt::message::Message for ConversationMeasure {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.contactcenterinsights.v1.QueryMetricsResponse.Slice.DataPoint.ConversationMeasure"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for ConversationMeasure {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __conversation_count,
                        __average_silence_percentage,
                        __average_duration,
                        __average_turn_count,
                        __average_agent_sentiment_score,
                        __average_client_sentiment_score,
                        __average_customer_satisfaction_rating,
                        __average_qa_normalized_score,
                        __qa_tag_scores,
                        __average_qa_question_normalized_score,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for ConversationMeasure")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "conversationCount" => Ok(__FieldTag::__conversation_count),
                                        "conversation_count" => {
                                            Ok(__FieldTag::__conversation_count)
                                        }
                                        "averageSilencePercentage" => {
                                            Ok(__FieldTag::__average_silence_percentage)
                                        }
                                        "average_silence_percentage" => {
                                            Ok(__FieldTag::__average_silence_percentage)
                                        }
                                        "averageDuration" => Ok(__FieldTag::__average_duration),
                                        "average_duration" => Ok(__FieldTag::__average_duration),
                                        "averageTurnCount" => Ok(__FieldTag::__average_turn_count),
                                        "average_turn_count" => {
                                            Ok(__FieldTag::__average_turn_count)
                                        }
                                        "averageAgentSentimentScore" => {
                                            Ok(__FieldTag::__average_agent_sentiment_score)
                                        }
                                        "average_agent_sentiment_score" => {
                                            Ok(__FieldTag::__average_agent_sentiment_score)
                                        }
                                        "averageClientSentimentScore" => {
                                            Ok(__FieldTag::__average_client_sentiment_score)
                                        }
                                        "average_client_sentiment_score" => {
                                            Ok(__FieldTag::__average_client_sentiment_score)
                                        }
                                        "averageCustomerSatisfactionRating" => {
                                            Ok(__FieldTag::__average_customer_satisfaction_rating)
                                        }
                                        "average_customer_satisfaction_rating" => {
                                            Ok(__FieldTag::__average_customer_satisfaction_rating)
                                        }
                                        "averageQaNormalizedScore" => {
                                            Ok(__FieldTag::__average_qa_normalized_score)
                                        }
                                        "average_qa_normalized_score" => {
                                            Ok(__FieldTag::__average_qa_normalized_score)
                                        }
                                        "qaTagScores" => Ok(__FieldTag::__qa_tag_scores),
                                        "qa_tag_scores" => Ok(__FieldTag::__qa_tag_scores),
                                        "averageQaQuestionNormalizedScore" => {
                                            Ok(__FieldTag::__average_qa_question_normalized_score)
                                        }
                                        "average_qa_question_normalized_score" => {
                                            Ok(__FieldTag::__average_qa_question_normalized_score)
                                        }
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = ConversationMeasure;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct ConversationMeasure")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__conversation_count => {
                                        if !fields.insert(__FieldTag::__conversation_count) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for conversation_count",
                                                ),
                                            );
                                        }
                                        struct __With(std::option::Option<i32>);
                                        impl<'de> serde::de::Deserialize<'de> for __With {
                                            fn deserialize<D>(
                                                deserializer: D,
                                            ) -> std::result::Result<Self, D::Error>
                                            where
                                                D: serde::de::Deserializer<'de>,
                                            {
                                                serde_with::As::<
                                                    std::option::Option<wkt::internal::I32>,
                                                >::deserialize(
                                                    deserializer
                                                )
                                                .map(__With)
                                            }
                                        }
                                        result.conversation_count = map.next_value::<__With>()?.0;
                                    }
                                    __FieldTag::__average_silence_percentage => {
                                        if !fields.insert(__FieldTag::__average_silence_percentage)
                                        {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for average_silence_percentage",
                                                ),
                                            );
                                        }
                                        struct __With(std::option::Option<f32>);
                                        impl<'de> serde::de::Deserialize<'de> for __With {
                                            fn deserialize<D>(
                                                deserializer: D,
                                            ) -> std::result::Result<Self, D::Error>
                                            where
                                                D: serde::de::Deserializer<'de>,
                                            {
                                                serde_with::As::<
                                                    std::option::Option<wkt::internal::F32>,
                                                >::deserialize(
                                                    deserializer
                                                )
                                                .map(__With)
                                            }
                                        }
                                        result.average_silence_percentage =
                                            map.next_value::<__With>()?.0;
                                    }
                                    __FieldTag::__average_duration => {
                                        if !fields.insert(__FieldTag::__average_duration) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for average_duration",
                                                ),
                                            );
                                        }
                                        result.average_duration =
                                            map.next_value::<std::option::Option<wkt::Duration>>()?;
                                    }
                                    __FieldTag::__average_turn_count => {
                                        if !fields.insert(__FieldTag::__average_turn_count) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for average_turn_count",
                                                ),
                                            );
                                        }
                                        struct __With(std::option::Option<f32>);
                                        impl<'de> serde::de::Deserialize<'de> for __With {
                                            fn deserialize<D>(
                                                deserializer: D,
                                            ) -> std::result::Result<Self, D::Error>
                                            where
                                                D: serde::de::Deserializer<'de>,
                                            {
                                                serde_with::As::<
                                                    std::option::Option<wkt::internal::F32>,
                                                >::deserialize(
                                                    deserializer
                                                )
                                                .map(__With)
                                            }
                                        }
                                        result.average_turn_count = map.next_value::<__With>()?.0;
                                    }
                                    __FieldTag::__average_agent_sentiment_score => {
                                        if !fields
                                            .insert(__FieldTag::__average_agent_sentiment_score)
                                        {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for average_agent_sentiment_score",
                                                ),
                                            );
                                        }
                                        struct __With(std::option::Option<f32>);
                                        impl<'de> serde::de::Deserialize<'de> for __With {
                                            fn deserialize<D>(
                                                deserializer: D,
                                            ) -> std::result::Result<Self, D::Error>
                                            where
                                                D: serde::de::Deserializer<'de>,
                                            {
                                                serde_with::As::<
                                                    std::option::Option<wkt::internal::F32>,
                                                >::deserialize(
                                                    deserializer
                                                )
                                                .map(__With)
                                            }
                                        }
                                        result.average_agent_sentiment_score =
                                            map.next_value::<__With>()?.0;
                                    }
                                    __FieldTag::__average_client_sentiment_score => {
                                        if !fields
                                            .insert(__FieldTag::__average_client_sentiment_score)
                                        {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for average_client_sentiment_score",
                                                ),
                                            );
                                        }
                                        struct __With(std::option::Option<f32>);
                                        impl<'de> serde::de::Deserialize<'de> for __With {
                                            fn deserialize<D>(
                                                deserializer: D,
                                            ) -> std::result::Result<Self, D::Error>
                                            where
                                                D: serde::de::Deserializer<'de>,
                                            {
                                                serde_with::As::<
                                                    std::option::Option<wkt::internal::F32>,
                                                >::deserialize(
                                                    deserializer
                                                )
                                                .map(__With)
                                            }
                                        }
                                        result.average_client_sentiment_score =
                                            map.next_value::<__With>()?.0;
                                    }
                                    __FieldTag::__average_customer_satisfaction_rating => {
                                        if !fields.insert(
                                            __FieldTag::__average_customer_satisfaction_rating,
                                        ) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for average_customer_satisfaction_rating",
                                                ),
                                            );
                                        }
                                        struct __With(std::option::Option<f64>);
                                        impl<'de> serde::de::Deserialize<'de> for __With {
                                            fn deserialize<D>(
                                                deserializer: D,
                                            ) -> std::result::Result<Self, D::Error>
                                            where
                                                D: serde::de::Deserializer<'de>,
                                            {
                                                serde_with::As::<
                                                    std::option::Option<wkt::internal::F64>,
                                                >::deserialize(
                                                    deserializer
                                                )
                                                .map(__With)
                                            }
                                        }
                                        result.average_customer_satisfaction_rating =
                                            map.next_value::<__With>()?.0;
                                    }
                                    __FieldTag::__average_qa_normalized_score => {
                                        if !fields.insert(__FieldTag::__average_qa_normalized_score)
                                        {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for average_qa_normalized_score",
                                                ),
                                            );
                                        }
                                        struct __With(std::option::Option<f64>);
                                        impl<'de> serde::de::Deserialize<'de> for __With {
                                            fn deserialize<D>(
                                                deserializer: D,
                                            ) -> std::result::Result<Self, D::Error>
                                            where
                                                D: serde::de::Deserializer<'de>,
                                            {
                                                serde_with::As::<
                                                    std::option::Option<wkt::internal::F64>,
                                                >::deserialize(
                                                    deserializer
                                                )
                                                .map(__With)
                                            }
                                        }
                                        result.average_qa_normalized_score =
                                            map.next_value::<__With>()?.0;
                                    }
                                    __FieldTag::__qa_tag_scores => {
                                        if !fields.insert(__FieldTag::__qa_tag_scores) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for qa_tag_scores",
                                                ),
                                            );
                                        }
                                        result.qa_tag_scores = map.next_value::<std::option::Option<std::vec::Vec<crate::model::query_metrics_response::slice::data_point::conversation_measure::QaTagScore>>>()?.unwrap_or_default();
                                    }
                                    __FieldTag::__average_qa_question_normalized_score => {
                                        if !fields.insert(
                                            __FieldTag::__average_qa_question_normalized_score,
                                        ) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for average_qa_question_normalized_score",
                                                ),
                                            );
                                        }
                                        struct __With(std::option::Option<f64>);
                                        impl<'de> serde::de::Deserialize<'de> for __With {
                                            fn deserialize<D>(
                                                deserializer: D,
                                            ) -> std::result::Result<Self, D::Error>
                                            where
                                                D: serde::de::Deserializer<'de>,
                                            {
                                                serde_with::As::<
                                                    std::option::Option<wkt::internal::F64>,
                                                >::deserialize(
                                                    deserializer
                                                )
                                                .map(__With)
                                            }
                                        }
                                        result.average_qa_question_normalized_score =
                                            map.next_value::<__With>()?.0;
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for ConversationMeasure {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if self.conversation_count.is_some() {
                        struct __With<'a>(&'a std::option::Option<i32>);
                        impl<'a> serde::ser::Serialize for __With<'a> {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::ser::Serializer,
                            {
                                serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                                    self.0, serializer,
                                )
                            }
                        }
                        state.serialize_entry(
                            "conversationCount",
                            &__With(&self.conversation_count),
                        )?;
                    }
                    if self.average_silence_percentage.is_some() {
                        struct __With<'a>(&'a std::option::Option<f32>);
                        impl<'a> serde::ser::Serialize for __With<'a> {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::ser::Serializer,
                            {
                                serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                                    self.0, serializer,
                                )
                            }
                        }
                        state.serialize_entry(
                            "averageSilencePercentage",
                            &__With(&self.average_silence_percentage),
                        )?;
                    }
                    if self.average_duration.is_some() {
                        state.serialize_entry("averageDuration", &self.average_duration)?;
                    }
                    if self.average_turn_count.is_some() {
                        struct __With<'a>(&'a std::option::Option<f32>);
                        impl<'a> serde::ser::Serialize for __With<'a> {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::ser::Serializer,
                            {
                                serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                                    self.0, serializer,
                                )
                            }
                        }
                        state.serialize_entry(
                            "averageTurnCount",
                            &__With(&self.average_turn_count),
                        )?;
                    }
                    if self.average_agent_sentiment_score.is_some() {
                        struct __With<'a>(&'a std::option::Option<f32>);
                        impl<'a> serde::ser::Serialize for __With<'a> {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::ser::Serializer,
                            {
                                serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                                    self.0, serializer,
                                )
                            }
                        }
                        state.serialize_entry(
                            "averageAgentSentimentScore",
                            &__With(&self.average_agent_sentiment_score),
                        )?;
                    }
                    if self.average_client_sentiment_score.is_some() {
                        struct __With<'a>(&'a std::option::Option<f32>);
                        impl<'a> serde::ser::Serialize for __With<'a> {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::ser::Serializer,
                            {
                                serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                                    self.0, serializer,
                                )
                            }
                        }
                        state.serialize_entry(
                            "averageClientSentimentScore",
                            &__With(&self.average_client_sentiment_score),
                        )?;
                    }
                    if self.average_customer_satisfaction_rating.is_some() {
                        struct __With<'a>(&'a std::option::Option<f64>);
                        impl<'a> serde::ser::Serialize for __With<'a> {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::ser::Serializer,
                            {
                                serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                                    self.0, serializer,
                                )
                            }
                        }
                        state.serialize_entry(
                            "averageCustomerSatisfactionRating",
                            &__With(&self.average_customer_satisfaction_rating),
                        )?;
                    }
                    if self.average_qa_normalized_score.is_some() {
                        struct __With<'a>(&'a std::option::Option<f64>);
                        impl<'a> serde::ser::Serialize for __With<'a> {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::ser::Serializer,
                            {
                                serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                                    self.0, serializer,
                                )
                            }
                        }
                        state.serialize_entry(
                            "averageQaNormalizedScore",
                            &__With(&self.average_qa_normalized_score),
                        )?;
                    }
                    if !self.qa_tag_scores.is_empty() {
                        state.serialize_entry("qaTagScores", &self.qa_tag_scores)?;
                    }
                    if self.average_qa_question_normalized_score.is_some() {
                        struct __With<'a>(&'a std::option::Option<f64>);
                        impl<'a> serde::ser::Serialize for __With<'a> {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::ser::Serializer,
                            {
                                serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                                    self.0, serializer,
                                )
                            }
                        }
                        state.serialize_entry(
                            "averageQaQuestionNormalizedScore",
                            &__With(&self.average_qa_question_normalized_score),
                        )?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            impl std::fmt::Debug for ConversationMeasure {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    let mut debug_struct = f.debug_struct("ConversationMeasure");
                    debug_struct.field("conversation_count", &self.conversation_count);
                    debug_struct.field(
                        "average_silence_percentage",
                        &self.average_silence_percentage,
                    );
                    debug_struct.field("average_duration", &self.average_duration);
                    debug_struct.field("average_turn_count", &self.average_turn_count);
                    debug_struct.field(
                        "average_agent_sentiment_score",
                        &self.average_agent_sentiment_score,
                    );
                    debug_struct.field(
                        "average_client_sentiment_score",
                        &self.average_client_sentiment_score,
                    );
                    debug_struct.field(
                        "average_customer_satisfaction_rating",
                        &self.average_customer_satisfaction_rating,
                    );
                    debug_struct.field(
                        "average_qa_normalized_score",
                        &self.average_qa_normalized_score,
                    );
                    debug_struct.field("qa_tag_scores", &self.qa_tag_scores);
                    debug_struct.field(
                        "average_qa_question_normalized_score",
                        &self.average_qa_question_normalized_score,
                    );
                    if !self._unknown_fields.is_empty() {
                        debug_struct.field("_unknown_fields", &self._unknown_fields);
                    }
                    debug_struct.finish()
                }
            }

            /// Defines additional types related to [ConversationMeasure].
            pub mod conversation_measure {
                #[allow(unused_imports)]
                use super::*;

                /// Average QA normalized score for the tag.
                #[derive(Clone, Default, PartialEq)]
                #[non_exhaustive]
                pub struct QaTagScore {
                    /// Tag name.
                    pub tag: std::string::String,

                    /// Average tag normalized score per tag.
                    pub average_tag_normalized_score: f64,

                    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
                }

                impl QaTagScore {
                    pub fn new() -> Self {
                        std::default::Default::default()
                    }

                    /// Sets the value of [tag][crate::model::query_metrics_response::slice::data_point::conversation_measure::QaTagScore::tag].
                    pub fn set_tag<T: std::convert::Into<std::string::String>>(
                        mut self,
                        v: T,
                    ) -> Self {
                        self.tag = v.into();
                        self
                    }

                    /// Sets the value of [average_tag_normalized_score][crate::model::query_metrics_response::slice::data_point::conversation_measure::QaTagScore::average_tag_normalized_score].
                    pub fn set_average_tag_normalized_score<T: std::convert::Into<f64>>(
                        mut self,
                        v: T,
                    ) -> Self {
                        self.average_tag_normalized_score = v.into();
                        self
                    }
                }

                impl wkt::message::Message for QaTagScore {
                    fn typename() -> &'static str {
                        "type.googleapis.com/google.cloud.contactcenterinsights.v1.QueryMetricsResponse.Slice.DataPoint.ConversationMeasure.QaTagScore"
                    }
                }

                #[doc(hidden)]
                impl<'de> serde::de::Deserialize<'de> for QaTagScore {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        #[derive(PartialEq, Eq, Hash)]
                        enum __FieldTag {
                            __tag,
                            __average_tag_normalized_score,
                            Unknown(std::string::String),
                        }
                        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                            fn deserialize<D>(
                                deserializer: D,
                            ) -> std::result::Result<Self, D::Error>
                            where
                                D: serde::Deserializer<'de>,
                            {
                                struct Visitor;
                                impl<'de> serde::de::Visitor<'de> for Visitor {
                                    type Value = __FieldTag;
                                    fn expecting(
                                        &self,
                                        formatter: &mut std::fmt::Formatter,
                                    ) -> std::fmt::Result {
                                        formatter.write_str("a field name for QaTagScore")
                                    }
                                    fn visit_str<E>(
                                        self,
                                        value: &str,
                                    ) -> std::result::Result<Self::Value, E>
                                    where
                                        E: serde::de::Error,
                                    {
                                        use std::result::Result::Ok;
                                        use std::string::ToString;
                                        match value {
                                            "tag" => Ok(__FieldTag::__tag),
                                            "averageTagNormalizedScore" => {
                                                Ok(__FieldTag::__average_tag_normalized_score)
                                            }
                                            "average_tag_normalized_score" => {
                                                Ok(__FieldTag::__average_tag_normalized_score)
                                            }
                                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                                        }
                                    }
                                }
                                deserializer.deserialize_identifier(Visitor)
                            }
                        }
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = QaTagScore;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("struct QaTagScore")
                            }
                            fn visit_map<A>(
                                self,
                                mut map: A,
                            ) -> std::result::Result<Self::Value, A::Error>
                            where
                                A: serde::de::MapAccess<'de>,
                            {
                                #[allow(unused_imports)]
                                use serde::de::Error;
                                use std::option::Option::Some;
                                let mut fields = std::collections::HashSet::new();
                                let mut result = Self::Value::new();
                                while let Some(tag) = map.next_key::<__FieldTag>()? {
                                    #[allow(clippy::match_single_binding)]
                                    match tag {
                                        __FieldTag::__tag => {
                                            if !fields.insert(__FieldTag::__tag) {
                                                return std::result::Result::Err(
                                                    A::Error::duplicate_field(
                                                        "multiple values for tag",
                                                    ),
                                                );
                                            }
                                            result.tag = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                                        }
                                        __FieldTag::__average_tag_normalized_score => {
                                            if !fields
                                                .insert(__FieldTag::__average_tag_normalized_score)
                                            {
                                                return std::result::Result::Err(
                                                    A::Error::duplicate_field(
                                                        "multiple values for average_tag_normalized_score",
                                                    ),
                                                );
                                            }
                                            struct __With(std::option::Option<f64>);
                                            impl<'de> serde::de::Deserialize<'de> for __With {
                                                fn deserialize<D>(
                                                    deserializer: D,
                                                ) -> std::result::Result<Self, D::Error>
                                                where
                                                    D: serde::de::Deserializer<'de>,
                                                {
                                                    serde_with::As::<
                                                        std::option::Option<wkt::internal::F64>,
                                                    >::deserialize(
                                                        deserializer
                                                    )
                                                    .map(__With)
                                                }
                                            }
                                            result.average_tag_normalized_score =
                                                map.next_value::<__With>()?.0.unwrap_or_default();
                                        }
                                        __FieldTag::Unknown(key) => {
                                            let value = map.next_value::<serde_json::Value>()?;
                                            result._unknown_fields.insert(key, value);
                                        }
                                    }
                                }
                                std::result::Result::Ok(result)
                            }
                        }
                        deserializer.deserialize_any(Visitor)
                    }
                }

                #[doc(hidden)]
                impl serde::ser::Serialize for QaTagScore {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        use serde::ser::SerializeMap;
                        #[allow(unused_imports)]
                        use std::option::Option::Some;
                        let mut state = serializer.serialize_map(std::option::Option::None)?;
                        if !self.tag.is_empty() {
                            state.serialize_entry("tag", &self.tag)?;
                        }
                        if !wkt::internal::is_default(&self.average_tag_normalized_score) {
                            struct __With<'a>(&'a f64);
                            impl<'a> serde::ser::Serialize for __With<'a> {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde_with::As::<wkt::internal::F64>::serialize(
                                        self.0, serializer,
                                    )
                                }
                            }
                            state.serialize_entry(
                                "averageTagNormalizedScore",
                                &__With(&self.average_tag_normalized_score),
                            )?;
                        }
                        if !self._unknown_fields.is_empty() {
                            for (key, value) in self._unknown_fields.iter() {
                                state.serialize_entry(key, &value)?;
                            }
                        }
                        state.end()
                    }
                }

                impl std::fmt::Debug for QaTagScore {
                    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        let mut debug_struct = f.debug_struct("QaTagScore");
                        debug_struct.field("tag", &self.tag);
                        debug_struct.field(
                            "average_tag_normalized_score",
                            &self.average_tag_normalized_score,
                        );
                        if !self._unknown_fields.is_empty() {
                            debug_struct.field("_unknown_fields", &self._unknown_fields);
                        }
                        debug_struct.finish()
                    }
                }
            }

            /// The measure included in this data point.
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum Measure {
                /// The measure related to conversations.
                ConversationMeasure(std::boxed::Box<crate::model::query_metrics_response::slice::data_point::ConversationMeasure>),
            }
        }

        /// A time series of metric values.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct TimeSeries {
            /// The data points that make up the time series .
            pub data_points: std::vec::Vec<crate::model::query_metrics_response::slice::DataPoint>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl TimeSeries {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [data_points][crate::model::query_metrics_response::slice::TimeSeries::data_points].
            pub fn set_data_points<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::query_metrics_response::slice::DataPoint>,
            {
                use std::iter::Iterator;
                self.data_points = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for TimeSeries {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.contactcenterinsights.v1.QueryMetricsResponse.Slice.TimeSeries"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for TimeSeries {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __data_points,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for TimeSeries")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "dataPoints" => Ok(__FieldTag::__data_points),
                                    "data_points" => Ok(__FieldTag::__data_points),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = TimeSeries;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct TimeSeries")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__data_points => {
                                    if !fields.insert(__FieldTag::__data_points) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for data_points",
                                            ),
                                        );
                                    }
                                    result.data_points = map.next_value::<std::option::Option<std::vec::Vec<crate::model::query_metrics_response::slice::DataPoint>>>()?.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for TimeSeries {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.data_points.is_empty() {
                    state.serialize_entry("dataPoints", &self.data_points)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for TimeSeries {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("TimeSeries");
                debug_struct.field("data_points", &self.data_points);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }
    }
}

/// The metadata from querying metrics.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct QueryMetricsMetadata {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QueryMetricsMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for QueryMetricsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.QueryMetricsMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for QueryMetricsMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QueryMetricsMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = QueryMetricsMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QueryMetricsMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for QueryMetricsMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for QueryMetricsMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("QueryMetricsMetadata");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for creating a QaQuestion.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateQaQuestionRequest {
    /// Required. The parent resource of the QaQuestion.
    pub parent: std::string::String,

    /// Required. The QaQuestion to create.
    pub qa_question: std::option::Option<crate::model::QaQuestion>,

    /// Optional. A unique ID for the new question. This ID will become the final
    /// component of the question's resource name. If no ID is specified, a
    /// server-generated ID will be used.
    ///
    /// This value should be 4-64 characters and must match the regular
    /// expression `^[a-z0-9-]{4,64}$`. Valid characters are `[a-z][0-9]-`.
    pub qa_question_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateQaQuestionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateQaQuestionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [qa_question][crate::model::CreateQaQuestionRequest::qa_question].
    pub fn set_qa_question<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::QaQuestion>,
    {
        self.qa_question = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [qa_question][crate::model::CreateQaQuestionRequest::qa_question].
    pub fn set_or_clear_qa_question<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::QaQuestion>,
    {
        self.qa_question = v.map(|x| x.into());
        self
    }

    /// Sets the value of [qa_question_id][crate::model::CreateQaQuestionRequest::qa_question_id].
    pub fn set_qa_question_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.qa_question_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateQaQuestionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.CreateQaQuestionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateQaQuestionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __qa_question,
            __qa_question_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateQaQuestionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "qaQuestion" => Ok(__FieldTag::__qa_question),
                            "qa_question" => Ok(__FieldTag::__qa_question),
                            "qaQuestionId" => Ok(__FieldTag::__qa_question_id),
                            "qa_question_id" => Ok(__FieldTag::__qa_question_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateQaQuestionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateQaQuestionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__qa_question => {
                            if !fields.insert(__FieldTag::__qa_question) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for qa_question",
                                ));
                            }
                            result.qa_question =
                                map.next_value::<std::option::Option<crate::model::QaQuestion>>()?;
                        }
                        __FieldTag::__qa_question_id => {
                            if !fields.insert(__FieldTag::__qa_question_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for qa_question_id",
                                ));
                            }
                            result.qa_question_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateQaQuestionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.qa_question.is_some() {
            state.serialize_entry("qaQuestion", &self.qa_question)?;
        }
        if !self.qa_question_id.is_empty() {
            state.serialize_entry("qaQuestionId", &self.qa_question_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateQaQuestionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateQaQuestionRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("qa_question", &self.qa_question);
        debug_struct.field("qa_question_id", &self.qa_question_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for a QaQuestion.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetQaQuestionRequest {
    /// Required. The name of the QaQuestion to get.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetQaQuestionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetQaQuestionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetQaQuestionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.GetQaQuestionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetQaQuestionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetQaQuestionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetQaQuestionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetQaQuestionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetQaQuestionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetQaQuestionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetQaQuestionRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request to list QaQuestions.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListQaQuestionsRequest {
    /// Required. The parent resource of the questions.
    pub parent: std::string::String,

    /// Optional. The maximum number of questions to return in the response. If the
    /// value is zero, the service will select a default size. A call might return
    /// fewer objects than requested. A non-empty `next_page_token` in the response
    /// indicates that more data is available.
    pub page_size: i32,

    /// Optional. The value returned by the last `ListQaQuestionsResponse`. This
    /// value indicates that this is a continuation of a prior `ListQaQuestions`
    /// call and that the system should return the next page of data.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListQaQuestionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListQaQuestionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListQaQuestionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListQaQuestionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListQaQuestionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ListQaQuestionsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListQaQuestionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListQaQuestionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListQaQuestionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListQaQuestionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListQaQuestionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListQaQuestionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListQaQuestionsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response from a ListQaQuestions request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListQaQuestionsResponse {
    /// The QaQuestions under the parent.
    pub qa_questions: std::vec::Vec<crate::model::QaQuestion>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListQaQuestionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [qa_questions][crate::model::ListQaQuestionsResponse::qa_questions].
    pub fn set_qa_questions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::QaQuestion>,
    {
        use std::iter::Iterator;
        self.qa_questions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListQaQuestionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListQaQuestionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ListQaQuestionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListQaQuestionsResponse {
    type PageItem = crate::model::QaQuestion;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.qa_questions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListQaQuestionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __qa_questions,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListQaQuestionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "qaQuestions" => Ok(__FieldTag::__qa_questions),
                            "qa_questions" => Ok(__FieldTag::__qa_questions),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListQaQuestionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListQaQuestionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__qa_questions => {
                            if !fields.insert(__FieldTag::__qa_questions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for qa_questions",
                                ));
                            }
                            result.qa_questions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::QaQuestion>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListQaQuestionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.qa_questions.is_empty() {
            state.serialize_entry("qaQuestions", &self.qa_questions)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListQaQuestionsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListQaQuestionsResponse");
        debug_struct.field("qa_questions", &self.qa_questions);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for updating a QaQuestion.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateQaQuestionRequest {
    /// Required. The QaQuestion to update.
    pub qa_question: std::option::Option<crate::model::QaQuestion>,

    /// Required. The list of fields to be updated. All possible fields can be
    /// updated by passing `*`, or a subset of the following updateable fields can
    /// be provided:
    ///
    /// * `abbreviation`
    /// * `answer_choices`
    /// * `answer_instructions`
    /// * `order`
    /// * `question_body`
    /// * `tags`
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateQaQuestionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [qa_question][crate::model::UpdateQaQuestionRequest::qa_question].
    pub fn set_qa_question<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::QaQuestion>,
    {
        self.qa_question = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [qa_question][crate::model::UpdateQaQuestionRequest::qa_question].
    pub fn set_or_clear_qa_question<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::QaQuestion>,
    {
        self.qa_question = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateQaQuestionRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateQaQuestionRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateQaQuestionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.UpdateQaQuestionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateQaQuestionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __qa_question,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateQaQuestionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "qaQuestion" => Ok(__FieldTag::__qa_question),
                            "qa_question" => Ok(__FieldTag::__qa_question),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateQaQuestionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateQaQuestionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__qa_question => {
                            if !fields.insert(__FieldTag::__qa_question) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for qa_question",
                                ));
                            }
                            result.qa_question =
                                map.next_value::<std::option::Option<crate::model::QaQuestion>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateQaQuestionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.qa_question.is_some() {
            state.serialize_entry("qaQuestion", &self.qa_question)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateQaQuestionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateQaQuestionRequest");
        debug_struct.field("qa_question", &self.qa_question);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for deleting a QaQuestion.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteQaQuestionRequest {
    /// Required. The name of the QaQuestion to delete.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteQaQuestionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteQaQuestionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteQaQuestionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.DeleteQaQuestionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteQaQuestionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteQaQuestionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteQaQuestionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteQaQuestionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteQaQuestionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteQaQuestionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteQaQuestionRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for creating a QaScorecard.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateQaScorecardRequest {
    /// Required. The parent resource of the QaScorecard.
    pub parent: std::string::String,

    /// Required. The QaScorecard to create.
    pub qa_scorecard: std::option::Option<crate::model::QaScorecard>,

    /// Optional. A unique ID for the new QaScorecard. This ID will become the
    /// final component of the QaScorecard's resource name. If no ID is specified,
    /// a server-generated ID will be used.
    ///
    /// This value should be 4-64 characters and must match the regular
    /// expression `^[a-z0-9-]{4,64}$`. Valid characters are `[a-z][0-9]-`.
    pub qa_scorecard_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateQaScorecardRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateQaScorecardRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [qa_scorecard][crate::model::CreateQaScorecardRequest::qa_scorecard].
    pub fn set_qa_scorecard<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::QaScorecard>,
    {
        self.qa_scorecard = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [qa_scorecard][crate::model::CreateQaScorecardRequest::qa_scorecard].
    pub fn set_or_clear_qa_scorecard<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::QaScorecard>,
    {
        self.qa_scorecard = v.map(|x| x.into());
        self
    }

    /// Sets the value of [qa_scorecard_id][crate::model::CreateQaScorecardRequest::qa_scorecard_id].
    pub fn set_qa_scorecard_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.qa_scorecard_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateQaScorecardRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.CreateQaScorecardRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateQaScorecardRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __qa_scorecard,
            __qa_scorecard_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateQaScorecardRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "qaScorecard" => Ok(__FieldTag::__qa_scorecard),
                            "qa_scorecard" => Ok(__FieldTag::__qa_scorecard),
                            "qaScorecardId" => Ok(__FieldTag::__qa_scorecard_id),
                            "qa_scorecard_id" => Ok(__FieldTag::__qa_scorecard_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateQaScorecardRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateQaScorecardRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__qa_scorecard => {
                            if !fields.insert(__FieldTag::__qa_scorecard) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for qa_scorecard",
                                ));
                            }
                            result.qa_scorecard =
                                map.next_value::<std::option::Option<crate::model::QaScorecard>>()?;
                        }
                        __FieldTag::__qa_scorecard_id => {
                            if !fields.insert(__FieldTag::__qa_scorecard_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for qa_scorecard_id",
                                ));
                            }
                            result.qa_scorecard_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateQaScorecardRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.qa_scorecard.is_some() {
            state.serialize_entry("qaScorecard", &self.qa_scorecard)?;
        }
        if !self.qa_scorecard_id.is_empty() {
            state.serialize_entry("qaScorecardId", &self.qa_scorecard_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateQaScorecardRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateQaScorecardRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("qa_scorecard", &self.qa_scorecard);
        debug_struct.field("qa_scorecard_id", &self.qa_scorecard_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for a QaScorecard. By default, returns the latest revision.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetQaScorecardRequest {
    /// Required. The name of the QaScorecard to get.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetQaScorecardRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetQaScorecardRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetQaScorecardRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.GetQaScorecardRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetQaScorecardRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetQaScorecardRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetQaScorecardRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetQaScorecardRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetQaScorecardRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetQaScorecardRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetQaScorecardRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for updating a QaScorecard.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateQaScorecardRequest {
    /// Required. The QaScorecard to update.
    pub qa_scorecard: std::option::Option<crate::model::QaScorecard>,

    /// Required. The list of fields to be updated. All possible fields can be
    /// updated by passing `*`, or a subset of the following updateable fields can
    /// be provided:
    ///
    /// * `description`
    /// * `display_name`
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateQaScorecardRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [qa_scorecard][crate::model::UpdateQaScorecardRequest::qa_scorecard].
    pub fn set_qa_scorecard<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::QaScorecard>,
    {
        self.qa_scorecard = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [qa_scorecard][crate::model::UpdateQaScorecardRequest::qa_scorecard].
    pub fn set_or_clear_qa_scorecard<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::QaScorecard>,
    {
        self.qa_scorecard = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateQaScorecardRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateQaScorecardRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateQaScorecardRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.UpdateQaScorecardRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateQaScorecardRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __qa_scorecard,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateQaScorecardRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "qaScorecard" => Ok(__FieldTag::__qa_scorecard),
                            "qa_scorecard" => Ok(__FieldTag::__qa_scorecard),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateQaScorecardRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateQaScorecardRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__qa_scorecard => {
                            if !fields.insert(__FieldTag::__qa_scorecard) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for qa_scorecard",
                                ));
                            }
                            result.qa_scorecard =
                                map.next_value::<std::option::Option<crate::model::QaScorecard>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateQaScorecardRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.qa_scorecard.is_some() {
            state.serialize_entry("qaScorecard", &self.qa_scorecard)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateQaScorecardRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateQaScorecardRequest");
        debug_struct.field("qa_scorecard", &self.qa_scorecard);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for deleting a QaScorecard.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteQaScorecardRequest {
    /// Required. The name of the QaScorecard to delete.
    pub name: std::string::String,

    /// Optional. If set to true, all of this QaScorecard's child resources will
    /// also be deleted. Otherwise, the request will only succeed if it has none.
    pub force: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteQaScorecardRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteQaScorecardRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteQaScorecardRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteQaScorecardRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.DeleteQaScorecardRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteQaScorecardRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteQaScorecardRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteQaScorecardRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteQaScorecardRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteQaScorecardRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteQaScorecardRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteQaScorecardRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("force", &self.force);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for creating a QaScorecardRevision.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateQaScorecardRevisionRequest {
    /// Required. The parent resource of the QaScorecardRevision.
    pub parent: std::string::String,

    /// Required. The QaScorecardRevision to create.
    pub qa_scorecard_revision: std::option::Option<crate::model::QaScorecardRevision>,

    /// Optional. A unique ID for the new QaScorecardRevision. This ID will become
    /// the final component of the QaScorecardRevision's resource name. If no ID is
    /// specified, a server-generated ID will be used.
    ///
    /// This value should be 4-64 characters and must match the regular
    /// expression `^[a-z0-9-]{4,64}$`. Valid characters are `[a-z][0-9]-`.
    pub qa_scorecard_revision_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateQaScorecardRevisionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateQaScorecardRevisionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [qa_scorecard_revision][crate::model::CreateQaScorecardRevisionRequest::qa_scorecard_revision].
    pub fn set_qa_scorecard_revision<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::QaScorecardRevision>,
    {
        self.qa_scorecard_revision = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [qa_scorecard_revision][crate::model::CreateQaScorecardRevisionRequest::qa_scorecard_revision].
    pub fn set_or_clear_qa_scorecard_revision<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::QaScorecardRevision>,
    {
        self.qa_scorecard_revision = v.map(|x| x.into());
        self
    }

    /// Sets the value of [qa_scorecard_revision_id][crate::model::CreateQaScorecardRevisionRequest::qa_scorecard_revision_id].
    pub fn set_qa_scorecard_revision_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.qa_scorecard_revision_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateQaScorecardRevisionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.CreateQaScorecardRevisionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateQaScorecardRevisionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __qa_scorecard_revision,
            __qa_scorecard_revision_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateQaScorecardRevisionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "qaScorecardRevision" => Ok(__FieldTag::__qa_scorecard_revision),
                            "qa_scorecard_revision" => Ok(__FieldTag::__qa_scorecard_revision),
                            "qaScorecardRevisionId" => Ok(__FieldTag::__qa_scorecard_revision_id),
                            "qa_scorecard_revision_id" => {
                                Ok(__FieldTag::__qa_scorecard_revision_id)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateQaScorecardRevisionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateQaScorecardRevisionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__qa_scorecard_revision => {
                            if !fields.insert(__FieldTag::__qa_scorecard_revision) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for qa_scorecard_revision",
                                ));
                            }
                            result.qa_scorecard_revision = map.next_value::<std::option::Option<crate::model::QaScorecardRevision>>()?
                                ;
                        }
                        __FieldTag::__qa_scorecard_revision_id => {
                            if !fields.insert(__FieldTag::__qa_scorecard_revision_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for qa_scorecard_revision_id",
                                ));
                            }
                            result.qa_scorecard_revision_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateQaScorecardRevisionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.qa_scorecard_revision.is_some() {
            state.serialize_entry("qaScorecardRevision", &self.qa_scorecard_revision)?;
        }
        if !self.qa_scorecard_revision_id.is_empty() {
            state.serialize_entry("qaScorecardRevisionId", &self.qa_scorecard_revision_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateQaScorecardRevisionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateQaScorecardRevisionRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("qa_scorecard_revision", &self.qa_scorecard_revision);
        debug_struct.field("qa_scorecard_revision_id", &self.qa_scorecard_revision_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for a QaScorecardRevision.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetQaScorecardRevisionRequest {
    /// Required. The name of the QaScorecardRevision to get.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetQaScorecardRevisionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetQaScorecardRevisionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetQaScorecardRevisionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.GetQaScorecardRevisionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetQaScorecardRevisionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetQaScorecardRevisionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetQaScorecardRevisionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetQaScorecardRevisionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetQaScorecardRevisionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetQaScorecardRevisionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetQaScorecardRevisionRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for TuneQaScorecardRevision endpoint.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TuneQaScorecardRevisionRequest {
    /// Required. The parent resource for new fine tuning job instance.
    pub parent: std::string::String,

    /// Required. Filter for selecting the feedback labels that needs to be
    /// used for training.
    /// This filter can be used to limit the feedback labels used for tuning to a
    /// feedback labels created or updated for a specific time-window etc.
    pub filter: std::string::String,

    /// Optional. Run in validate only mode, no fine tuning will actually run.
    /// Data quality validations like training data distributions will run.
    /// Even when set to false, the data quality validations will still run but
    /// once the validations complete we will proceed with the fine tune, if
    /// applicable.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TuneQaScorecardRevisionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::TuneQaScorecardRevisionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::TuneQaScorecardRevisionRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::TuneQaScorecardRevisionRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for TuneQaScorecardRevisionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.TuneQaScorecardRevisionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TuneQaScorecardRevisionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TuneQaScorecardRevisionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TuneQaScorecardRevisionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TuneQaScorecardRevisionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TuneQaScorecardRevisionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TuneQaScorecardRevisionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TuneQaScorecardRevisionRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("validate_only", &self.validate_only);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response for TuneQaScorecardRevision endpoint.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TuneQaScorecardRevisionResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TuneQaScorecardRevisionResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for TuneQaScorecardRevisionResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.TuneQaScorecardRevisionResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TuneQaScorecardRevisionResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TuneQaScorecardRevisionResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TuneQaScorecardRevisionResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TuneQaScorecardRevisionResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TuneQaScorecardRevisionResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TuneQaScorecardRevisionResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TuneQaScorecardRevisionResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Metadata for TuneQaScorecardRevision endpoint.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TuneQaScorecardRevisionMetadata {
    /// Output only. The time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The original request.
    pub request: std::option::Option<crate::model::TuneQaScorecardRevisionRequest>,

    /// Output only. The results of data validation per question in the request.
    pub qa_question_dataset_validation_results: std::vec::Vec<
        crate::model::tune_qa_scorecard_revision_metadata::QaQuestionDatasetValidationResult,
    >,

    /// Output only. The metrics for each QaQuestion in the TuneScorecardRevision
    /// request.
    pub qa_question_dataset_tuning_metrics: std::vec::Vec<
        crate::model::tune_qa_scorecard_revision_metadata::QaQuestionDatasetTuningMetrics,
    >,

    /// Output only. The percentage of the tuning job that has completed. Always
    /// between 0 and 1 where 0 indicates the job has not started i.e. 0% and 1
    /// indicates the job has completed i.e. 100%.
    pub tuning_completion_ratio: f64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TuneQaScorecardRevisionMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::TuneQaScorecardRevisionMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::TuneQaScorecardRevisionMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::TuneQaScorecardRevisionMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::TuneQaScorecardRevisionMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request][crate::model::TuneQaScorecardRevisionMetadata::request].
    pub fn set_request<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TuneQaScorecardRevisionRequest>,
    {
        self.request = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [request][crate::model::TuneQaScorecardRevisionMetadata::request].
    pub fn set_or_clear_request<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TuneQaScorecardRevisionRequest>,
    {
        self.request = v.map(|x| x.into());
        self
    }

    /// Sets the value of [qa_question_dataset_validation_results][crate::model::TuneQaScorecardRevisionMetadata::qa_question_dataset_validation_results].
    pub fn set_qa_question_dataset_validation_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::tune_qa_scorecard_revision_metadata::QaQuestionDatasetValidationResult>
    {
        use std::iter::Iterator;
        self.qa_question_dataset_validation_results = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [qa_question_dataset_tuning_metrics][crate::model::TuneQaScorecardRevisionMetadata::qa_question_dataset_tuning_metrics].
    pub fn set_qa_question_dataset_tuning_metrics<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<
                crate::model::tune_qa_scorecard_revision_metadata::QaQuestionDatasetTuningMetrics,
            >,
    {
        use std::iter::Iterator;
        self.qa_question_dataset_tuning_metrics = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [tuning_completion_ratio][crate::model::TuneQaScorecardRevisionMetadata::tuning_completion_ratio].
    pub fn set_tuning_completion_ratio<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.tuning_completion_ratio = v.into();
        self
    }
}

impl wkt::message::Message for TuneQaScorecardRevisionMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.TuneQaScorecardRevisionMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TuneQaScorecardRevisionMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __end_time,
            __request,
            __qa_question_dataset_validation_results,
            __qa_question_dataset_tuning_metrics,
            __tuning_completion_ratio,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TuneQaScorecardRevisionMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "request" => Ok(__FieldTag::__request),
                            "qaQuestionDatasetValidationResults" => {
                                Ok(__FieldTag::__qa_question_dataset_validation_results)
                            }
                            "qa_question_dataset_validation_results" => {
                                Ok(__FieldTag::__qa_question_dataset_validation_results)
                            }
                            "qaQuestionDatasetTuningMetrics" => {
                                Ok(__FieldTag::__qa_question_dataset_tuning_metrics)
                            }
                            "qa_question_dataset_tuning_metrics" => {
                                Ok(__FieldTag::__qa_question_dataset_tuning_metrics)
                            }
                            "tuningCompletionRatio" => Ok(__FieldTag::__tuning_completion_ratio),
                            "tuning_completion_ratio" => Ok(__FieldTag::__tuning_completion_ratio),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TuneQaScorecardRevisionMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TuneQaScorecardRevisionMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__request => {
                            if !fields.insert(__FieldTag::__request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request",
                                ));
                            }
                            result.request =
                                map.next_value::<std::option::Option<
                                    crate::model::TuneQaScorecardRevisionRequest,
                                >>()?;
                        }
                        __FieldTag::__qa_question_dataset_validation_results => {
                            if !fields.insert(__FieldTag::__qa_question_dataset_validation_results)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for qa_question_dataset_validation_results",
                                ));
                            }
                            result.qa_question_dataset_validation_results = map.next_value::<std::option::Option<std::vec::Vec<crate::model::tune_qa_scorecard_revision_metadata::QaQuestionDatasetValidationResult>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__qa_question_dataset_tuning_metrics => {
                            if !fields.insert(__FieldTag::__qa_question_dataset_tuning_metrics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for qa_question_dataset_tuning_metrics",
                                ));
                            }
                            result.qa_question_dataset_tuning_metrics = map.next_value::<std::option::Option<std::vec::Vec<crate::model::tune_qa_scorecard_revision_metadata::QaQuestionDatasetTuningMetrics>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__tuning_completion_ratio => {
                            if !fields.insert(__FieldTag::__tuning_completion_ratio) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tuning_completion_ratio",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.tuning_completion_ratio =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TuneQaScorecardRevisionMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if self.request.is_some() {
            state.serialize_entry("request", &self.request)?;
        }
        if !self.qa_question_dataset_validation_results.is_empty() {
            state.serialize_entry(
                "qaQuestionDatasetValidationResults",
                &self.qa_question_dataset_validation_results,
            )?;
        }
        if !self.qa_question_dataset_tuning_metrics.is_empty() {
            state.serialize_entry(
                "qaQuestionDatasetTuningMetrics",
                &self.qa_question_dataset_tuning_metrics,
            )?;
        }
        if !wkt::internal::is_default(&self.tuning_completion_ratio) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "tuningCompletionRatio",
                &__With(&self.tuning_completion_ratio),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TuneQaScorecardRevisionMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TuneQaScorecardRevisionMetadata");
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("request", &self.request);
        debug_struct.field(
            "qa_question_dataset_validation_results",
            &self.qa_question_dataset_validation_results,
        );
        debug_struct.field(
            "qa_question_dataset_tuning_metrics",
            &self.qa_question_dataset_tuning_metrics,
        );
        debug_struct.field("tuning_completion_ratio", &self.tuning_completion_ratio);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [TuneQaScorecardRevisionMetadata].
pub mod tune_qa_scorecard_revision_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Contains validation results for a question in the tuning request.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct QaQuestionDatasetValidationResult {
        /// Output only. The resource path of the question whose dataset was
        /// evaluated for tuning.
        pub question: std::string::String,

        /// A list of any applicable data validation warnings about the question's
        /// feedback labels.
        pub dataset_validation_warnings: std::vec::Vec<crate::model::DatasetValidationWarning>,

        /// The number of valid feedback labels in the question's dataset.
        pub valid_feedback_labels_count: i32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl QaQuestionDatasetValidationResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [question][crate::model::tune_qa_scorecard_revision_metadata::QaQuestionDatasetValidationResult::question].
        pub fn set_question<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.question = v.into();
            self
        }

        /// Sets the value of [dataset_validation_warnings][crate::model::tune_qa_scorecard_revision_metadata::QaQuestionDatasetValidationResult::dataset_validation_warnings].
        pub fn set_dataset_validation_warnings<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::DatasetValidationWarning>,
        {
            use std::iter::Iterator;
            self.dataset_validation_warnings = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [valid_feedback_labels_count][crate::model::tune_qa_scorecard_revision_metadata::QaQuestionDatasetValidationResult::valid_feedback_labels_count].
        pub fn set_valid_feedback_labels_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.valid_feedback_labels_count = v.into();
            self
        }
    }

    impl wkt::message::Message for QaQuestionDatasetValidationResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.TuneQaScorecardRevisionMetadata.QaQuestionDatasetValidationResult"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for QaQuestionDatasetValidationResult {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __question,
                __dataset_validation_warnings,
                __valid_feedback_labels_count,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter
                                .write_str("a field name for QaQuestionDatasetValidationResult")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "question" => Ok(__FieldTag::__question),
                                "datasetValidationWarnings" => {
                                    Ok(__FieldTag::__dataset_validation_warnings)
                                }
                                "dataset_validation_warnings" => {
                                    Ok(__FieldTag::__dataset_validation_warnings)
                                }
                                "validFeedbackLabelsCount" => {
                                    Ok(__FieldTag::__valid_feedback_labels_count)
                                }
                                "valid_feedback_labels_count" => {
                                    Ok(__FieldTag::__valid_feedback_labels_count)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = QaQuestionDatasetValidationResult;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct QaQuestionDatasetValidationResult")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__question => {
                                if !fields.insert(__FieldTag::__question) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for question",
                                    ));
                                }
                                result.question = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__dataset_validation_warnings => {
                                if !fields.insert(__FieldTag::__dataset_validation_warnings) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for dataset_validation_warnings",
                                    ));
                                }
                                result.dataset_validation_warnings = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::DatasetValidationWarning>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__valid_feedback_labels_count => {
                                if !fields.insert(__FieldTag::__valid_feedback_labels_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for valid_feedback_labels_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.valid_feedback_labels_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for QaQuestionDatasetValidationResult {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.question.is_empty() {
                state.serialize_entry("question", &self.question)?;
            }
            if !self.dataset_validation_warnings.is_empty() {
                state.serialize_entry(
                    "datasetValidationWarnings",
                    &self.dataset_validation_warnings,
                )?;
            }
            if !wkt::internal::is_default(&self.valid_feedback_labels_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "validFeedbackLabelsCount",
                    &__With(&self.valid_feedback_labels_count),
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for QaQuestionDatasetValidationResult {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("QaQuestionDatasetValidationResult");
            debug_struct.field("question", &self.question);
            debug_struct.field(
                "dataset_validation_warnings",
                &self.dataset_validation_warnings,
            );
            debug_struct.field(
                "valid_feedback_labels_count",
                &self.valid_feedback_labels_count,
            );
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Contains performance metrics for each QaQuestion in the
    /// TuneScorecardRevision request.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct QaQuestionDatasetTuningMetrics {

        /// Output only. The resource path of the question whose dataset was
        /// evaluated for tuning.
        pub question: std::string::String,

        /// Output only. The metrics for the question's dataset.
        pub metrics: std::option::Option<crate::model::tune_qa_scorecard_revision_metadata::qa_question_dataset_tuning_metrics::Metrics>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl QaQuestionDatasetTuningMetrics {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [question][crate::model::tune_qa_scorecard_revision_metadata::QaQuestionDatasetTuningMetrics::question].
        pub fn set_question<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.question = v.into();
            self
        }

        /// Sets the value of [metrics][crate::model::tune_qa_scorecard_revision_metadata::QaQuestionDatasetTuningMetrics::metrics].
        pub fn set_metrics<T>(mut self, v: T) -> Self
        where T: std::convert::Into<crate::model::tune_qa_scorecard_revision_metadata::qa_question_dataset_tuning_metrics::Metrics>
        {
            self.metrics = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [metrics][crate::model::tune_qa_scorecard_revision_metadata::QaQuestionDatasetTuningMetrics::metrics].
        pub fn set_or_clear_metrics<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<crate::model::tune_qa_scorecard_revision_metadata::qa_question_dataset_tuning_metrics::Metrics>
        {
            self.metrics = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for QaQuestionDatasetTuningMetrics {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.TuneQaScorecardRevisionMetadata.QaQuestionDatasetTuningMetrics"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for QaQuestionDatasetTuningMetrics {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __question,
                __metrics,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for QaQuestionDatasetTuningMetrics")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "question" => Ok(__FieldTag::__question),
                                "metrics" => Ok(__FieldTag::__metrics),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = QaQuestionDatasetTuningMetrics;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct QaQuestionDatasetTuningMetrics")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__question => {
                                if !fields.insert(__FieldTag::__question) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for question",
                                    ));
                                }
                                result.question = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__metrics => {
                                if !fields.insert(__FieldTag::__metrics) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for metrics",
                                    ));
                                }
                                result.metrics = map.next_value::<std::option::Option<crate::model::tune_qa_scorecard_revision_metadata::qa_question_dataset_tuning_metrics::Metrics>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for QaQuestionDatasetTuningMetrics {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.question.is_empty() {
                state.serialize_entry("question", &self.question)?;
            }
            if self.metrics.is_some() {
                state.serialize_entry("metrics", &self.metrics)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for QaQuestionDatasetTuningMetrics {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("QaQuestionDatasetTuningMetrics");
            debug_struct.field("question", &self.question);
            debug_struct.field("metrics", &self.metrics);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [QaQuestionDatasetTuningMetrics].
    pub mod qa_question_dataset_tuning_metrics {
        #[allow(unused_imports)]
        use super::*;

        /// Performance metrics for the question's dataset calculated over the tuned
        /// model.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Metrics {
            /// Accuracy of the question's dataset.
            pub accuracy: f64,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Metrics {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [accuracy][crate::model::tune_qa_scorecard_revision_metadata::qa_question_dataset_tuning_metrics::Metrics::accuracy].
            pub fn set_accuracy<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                self.accuracy = v.into();
                self
            }
        }

        impl wkt::message::Message for Metrics {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.contactcenterinsights.v1.TuneQaScorecardRevisionMetadata.QaQuestionDatasetTuningMetrics.Metrics"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Metrics {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __accuracy,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Metrics")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "accuracy" => Ok(__FieldTag::__accuracy),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Metrics;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Metrics")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__accuracy => {
                                    if !fields.insert(__FieldTag::__accuracy) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for accuracy",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<f64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.accuracy =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Metrics {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.accuracy) {
                    struct __With<'a>(&'a f64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("accuracy", &__With(&self.accuracy))?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for Metrics {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("Metrics");
                debug_struct.field("accuracy", &self.accuracy);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }
    }
}

/// The request to deploy a QaScorecardRevision
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeployQaScorecardRevisionRequest {
    /// Required. The name of the QaScorecardRevision to deploy.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeployQaScorecardRevisionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeployQaScorecardRevisionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeployQaScorecardRevisionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.DeployQaScorecardRevisionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeployQaScorecardRevisionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeployQaScorecardRevisionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeployQaScorecardRevisionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeployQaScorecardRevisionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeployQaScorecardRevisionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeployQaScorecardRevisionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeployQaScorecardRevisionRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request to undeploy a QaScorecardRevision
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UndeployQaScorecardRevisionRequest {
    /// Required. The name of the QaScorecardRevision to undeploy.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UndeployQaScorecardRevisionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UndeployQaScorecardRevisionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for UndeployQaScorecardRevisionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.UndeployQaScorecardRevisionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UndeployQaScorecardRevisionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UndeployQaScorecardRevisionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UndeployQaScorecardRevisionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UndeployQaScorecardRevisionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UndeployQaScorecardRevisionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UndeployQaScorecardRevisionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UndeployQaScorecardRevisionRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request to delete a QaScorecardRevision.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteQaScorecardRevisionRequest {
    /// Required. The name of the QaScorecardRevision to delete.
    pub name: std::string::String,

    /// Optional. If set to true, all of this QaScorecardRevision's child resources
    /// will also be deleted. Otherwise, the request will only succeed if it has
    /// none.
    pub force: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteQaScorecardRevisionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteQaScorecardRevisionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteQaScorecardRevisionRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteQaScorecardRevisionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.DeleteQaScorecardRevisionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteQaScorecardRevisionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteQaScorecardRevisionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteQaScorecardRevisionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteQaScorecardRevisionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteQaScorecardRevisionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteQaScorecardRevisionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteQaScorecardRevisionRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("force", &self.force);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request to list QaScorecards.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListQaScorecardsRequest {
    /// Required. The parent resource of the scorecards.
    pub parent: std::string::String,

    /// Optional. The maximum number of scorecards to return in the response. If
    /// the value is zero, the service will select a default size. A call might
    /// return fewer objects than requested. A non-empty `next_page_token` in the
    /// response indicates that more data is available.
    pub page_size: i32,

    /// Optional. The value returned by the last `ListQaScorecardsResponse`. This
    /// value indicates that this is a continuation of a prior `ListQaScorecards`
    /// call and that the system should return the next page of data.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListQaScorecardsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListQaScorecardsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListQaScorecardsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListQaScorecardsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListQaScorecardsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ListQaScorecardsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListQaScorecardsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListQaScorecardsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListQaScorecardsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListQaScorecardsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListQaScorecardsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListQaScorecardsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListQaScorecardsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response from a ListQaScorecards request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListQaScorecardsResponse {
    /// The QaScorecards under the parent.
    pub qa_scorecards: std::vec::Vec<crate::model::QaScorecard>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListQaScorecardsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [qa_scorecards][crate::model::ListQaScorecardsResponse::qa_scorecards].
    pub fn set_qa_scorecards<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::QaScorecard>,
    {
        use std::iter::Iterator;
        self.qa_scorecards = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListQaScorecardsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListQaScorecardsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ListQaScorecardsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListQaScorecardsResponse {
    type PageItem = crate::model::QaScorecard;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.qa_scorecards
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListQaScorecardsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __qa_scorecards,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListQaScorecardsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "qaScorecards" => Ok(__FieldTag::__qa_scorecards),
                            "qa_scorecards" => Ok(__FieldTag::__qa_scorecards),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListQaScorecardsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListQaScorecardsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__qa_scorecards => {
                            if !fields.insert(__FieldTag::__qa_scorecards) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for qa_scorecards",
                                ));
                            }
                            result.qa_scorecards = map.next_value::<std::option::Option<std::vec::Vec<crate::model::QaScorecard>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListQaScorecardsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.qa_scorecards.is_empty() {
            state.serialize_entry("qaScorecards", &self.qa_scorecards)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListQaScorecardsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListQaScorecardsResponse");
        debug_struct.field("qa_scorecards", &self.qa_scorecards);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request to list QaScorecardRevisions
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListQaScorecardRevisionsRequest {
    /// Required. The parent resource of the scorecard revisions. To list all
    /// revisions of all scorecards, substitute the QaScorecard ID with a '-'
    /// character.
    pub parent: std::string::String,

    /// Optional. The maximum number of scorecard revisions to return in the
    /// response. If the value is zero, the service will select a default size. A
    /// call might return fewer objects than requested. A non-empty
    /// `next_page_token` in the response indicates that more data is available.
    pub page_size: i32,

    /// Optional. The value returned by the last
    /// `ListQaScorecardRevisionsResponse`. This value indicates that this is a
    /// continuation of a prior `ListQaScorecardRevisions` call and that the system
    /// should return the next page of data.
    pub page_token: std::string::String,

    /// Optional. A filter to reduce results to a specific subset. Useful for
    /// querying scorecard revisions with specific properties.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListQaScorecardRevisionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListQaScorecardRevisionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListQaScorecardRevisionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListQaScorecardRevisionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListQaScorecardRevisionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListQaScorecardRevisionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ListQaScorecardRevisionsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListQaScorecardRevisionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListQaScorecardRevisionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListQaScorecardRevisionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListQaScorecardRevisionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListQaScorecardRevisionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListQaScorecardRevisionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListQaScorecardRevisionsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response from a ListQaScorecardRevisions request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListQaScorecardRevisionsResponse {
    /// The QaScorecards under the parent.
    pub qa_scorecard_revisions: std::vec::Vec<crate::model::QaScorecardRevision>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListQaScorecardRevisionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [qa_scorecard_revisions][crate::model::ListQaScorecardRevisionsResponse::qa_scorecard_revisions].
    pub fn set_qa_scorecard_revisions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::QaScorecardRevision>,
    {
        use std::iter::Iterator;
        self.qa_scorecard_revisions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListQaScorecardRevisionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListQaScorecardRevisionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ListQaScorecardRevisionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListQaScorecardRevisionsResponse {
    type PageItem = crate::model::QaScorecardRevision;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.qa_scorecard_revisions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListQaScorecardRevisionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __qa_scorecard_revisions,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListQaScorecardRevisionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "qaScorecardRevisions" => Ok(__FieldTag::__qa_scorecard_revisions),
                            "qa_scorecard_revisions" => Ok(__FieldTag::__qa_scorecard_revisions),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListQaScorecardRevisionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListQaScorecardRevisionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__qa_scorecard_revisions => {
                            if !fields.insert(__FieldTag::__qa_scorecard_revisions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for qa_scorecard_revisions",
                                ));
                            }
                            result.qa_scorecard_revisions = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::QaScorecardRevision>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListQaScorecardRevisionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.qa_scorecard_revisions.is_empty() {
            state.serialize_entry("qaScorecardRevisions", &self.qa_scorecard_revisions)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListQaScorecardRevisionsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListQaScorecardRevisionsResponse");
        debug_struct.field("qa_scorecard_revisions", &self.qa_scorecard_revisions);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for creating a feedback label.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateFeedbackLabelRequest {
    /// Required. The parent resource of the feedback label.
    pub parent: std::string::String,

    /// Optional. The ID of the feedback label to create.
    /// If one is not specified it will be generated by the server.
    pub feedback_label_id: std::string::String,

    /// Required. The feedback label to create.
    pub feedback_label: std::option::Option<crate::model::FeedbackLabel>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateFeedbackLabelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateFeedbackLabelRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [feedback_label_id][crate::model::CreateFeedbackLabelRequest::feedback_label_id].
    pub fn set_feedback_label_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.feedback_label_id = v.into();
        self
    }

    /// Sets the value of [feedback_label][crate::model::CreateFeedbackLabelRequest::feedback_label].
    pub fn set_feedback_label<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FeedbackLabel>,
    {
        self.feedback_label = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [feedback_label][crate::model::CreateFeedbackLabelRequest::feedback_label].
    pub fn set_or_clear_feedback_label<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FeedbackLabel>,
    {
        self.feedback_label = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateFeedbackLabelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.CreateFeedbackLabelRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateFeedbackLabelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __feedback_label_id,
            __feedback_label,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateFeedbackLabelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "feedbackLabelId" => Ok(__FieldTag::__feedback_label_id),
                            "feedback_label_id" => Ok(__FieldTag::__feedback_label_id),
                            "feedbackLabel" => Ok(__FieldTag::__feedback_label),
                            "feedback_label" => Ok(__FieldTag::__feedback_label),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateFeedbackLabelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateFeedbackLabelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__feedback_label_id => {
                            if !fields.insert(__FieldTag::__feedback_label_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for feedback_label_id",
                                ));
                            }
                            result.feedback_label_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__feedback_label => {
                            if !fields.insert(__FieldTag::__feedback_label) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for feedback_label",
                                ));
                            }
                            result.feedback_label = map
                                .next_value::<std::option::Option<crate::model::FeedbackLabel>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateFeedbackLabelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.feedback_label_id.is_empty() {
            state.serialize_entry("feedbackLabelId", &self.feedback_label_id)?;
        }
        if self.feedback_label.is_some() {
            state.serialize_entry("feedbackLabel", &self.feedback_label)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateFeedbackLabelRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateFeedbackLabelRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("feedback_label_id", &self.feedback_label_id);
        debug_struct.field("feedback_label", &self.feedback_label);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for listing feedback labels.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListFeedbackLabelsRequest {
    /// Required. The parent resource of the feedback labels.
    pub parent: std::string::String,

    /// Optional. A filter to reduce results to a specific subset. Supports
    /// disjunctions (OR) and conjunctions (AND). Automatically sorts by
    /// conversation ID. To sort by all feedback labels in a project see
    /// ListAllFeedbackLabels.
    ///
    /// Supported fields:
    ///
    /// * `issue_model_id`
    /// * `qa_question_id`
    /// * `qa_scorecard_id`
    /// * `min_create_time`
    /// * `max_create_time`
    /// * `min_update_time`
    /// * `max_update_time`
    /// * `feedback_label_type`: QUALITY_AI, TOPIC_MODELING
    pub filter: std::string::String,

    /// Optional. The maximum number of feedback labels to return in the response.
    /// A valid page size ranges from 0 to 100,000 inclusive. If the page size is
    /// zero or unspecified, a default page size of 100 will be chosen. Note that a
    /// call might return fewer results than the requested page size.
    pub page_size: i32,

    /// Optional. The value returned by the last `ListFeedbackLabelsResponse`. This
    /// value indicates that this is a continuation of a prior `ListFeedbackLabels`
    /// call and that the system should return the next page of data.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListFeedbackLabelsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListFeedbackLabelsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListFeedbackLabelsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListFeedbackLabelsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListFeedbackLabelsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListFeedbackLabelsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ListFeedbackLabelsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListFeedbackLabelsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListFeedbackLabelsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListFeedbackLabelsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListFeedbackLabelsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListFeedbackLabelsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListFeedbackLabelsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListFeedbackLabelsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response for listing feedback labels.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListFeedbackLabelsResponse {
    /// The feedback labels that match the request.
    pub feedback_labels: std::vec::Vec<crate::model::FeedbackLabel>,

    /// The next page token.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListFeedbackLabelsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [feedback_labels][crate::model::ListFeedbackLabelsResponse::feedback_labels].
    pub fn set_feedback_labels<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FeedbackLabel>,
    {
        use std::iter::Iterator;
        self.feedback_labels = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListFeedbackLabelsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListFeedbackLabelsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ListFeedbackLabelsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListFeedbackLabelsResponse {
    type PageItem = crate::model::FeedbackLabel;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.feedback_labels
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListFeedbackLabelsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __feedback_labels,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListFeedbackLabelsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "feedbackLabels" => Ok(__FieldTag::__feedback_labels),
                            "feedback_labels" => Ok(__FieldTag::__feedback_labels),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListFeedbackLabelsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListFeedbackLabelsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__feedback_labels => {
                            if !fields.insert(__FieldTag::__feedback_labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for feedback_labels",
                                ));
                            }
                            result.feedback_labels = map.next_value::<std::option::Option<std::vec::Vec<crate::model::FeedbackLabel>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListFeedbackLabelsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.feedback_labels.is_empty() {
            state.serialize_entry("feedbackLabels", &self.feedback_labels)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListFeedbackLabelsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListFeedbackLabelsResponse");
        debug_struct.field("feedback_labels", &self.feedback_labels);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for getting a feedback label.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetFeedbackLabelRequest {
    /// Required. The name of the feedback label to get.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetFeedbackLabelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetFeedbackLabelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetFeedbackLabelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.GetFeedbackLabelRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetFeedbackLabelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetFeedbackLabelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetFeedbackLabelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetFeedbackLabelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetFeedbackLabelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetFeedbackLabelRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetFeedbackLabelRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for updating a feedback label.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateFeedbackLabelRequest {
    /// Required. The feedback label to update.
    pub feedback_label: std::option::Option<crate::model::FeedbackLabel>,

    /// Required. The list of fields to be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateFeedbackLabelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [feedback_label][crate::model::UpdateFeedbackLabelRequest::feedback_label].
    pub fn set_feedback_label<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FeedbackLabel>,
    {
        self.feedback_label = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [feedback_label][crate::model::UpdateFeedbackLabelRequest::feedback_label].
    pub fn set_or_clear_feedback_label<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FeedbackLabel>,
    {
        self.feedback_label = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateFeedbackLabelRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateFeedbackLabelRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateFeedbackLabelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.UpdateFeedbackLabelRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateFeedbackLabelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __feedback_label,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateFeedbackLabelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "feedbackLabel" => Ok(__FieldTag::__feedback_label),
                            "feedback_label" => Ok(__FieldTag::__feedback_label),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateFeedbackLabelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateFeedbackLabelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__feedback_label => {
                            if !fields.insert(__FieldTag::__feedback_label) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for feedback_label",
                                ));
                            }
                            result.feedback_label = map
                                .next_value::<std::option::Option<crate::model::FeedbackLabel>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateFeedbackLabelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.feedback_label.is_some() {
            state.serialize_entry("feedbackLabel", &self.feedback_label)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateFeedbackLabelRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateFeedbackLabelRequest");
        debug_struct.field("feedback_label", &self.feedback_label);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for deleting a feedback label.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteFeedbackLabelRequest {
    /// Required. The name of the feedback label to delete.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteFeedbackLabelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteFeedbackLabelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteFeedbackLabelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.DeleteFeedbackLabelRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteFeedbackLabelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteFeedbackLabelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteFeedbackLabelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteFeedbackLabelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteFeedbackLabelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteFeedbackLabelRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteFeedbackLabelRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for listing all feedback labels.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAllFeedbackLabelsRequest {
    /// Required. The parent resource of all feedback labels per project.
    pub parent: std::string::String,

    /// Optional. The maximum number of feedback labels to return in the response.
    /// A valid page size ranges from 0 to 100,000 inclusive. If the page size is
    /// zero or unspecified, a default page size of 100 will be chosen. Note that a
    /// call might return fewer results than the requested page size.
    pub page_size: i32,

    /// Optional. The value returned by the last `ListAllFeedbackLabelsResponse`.
    /// This value indicates that this is a continuation of a prior
    /// `ListAllFeedbackLabels` call and that the system should return the next
    /// page of data.
    pub page_token: std::string::String,

    /// Optional. A filter to reduce results to a specific subset in the entire
    /// project. Supports disjunctions (OR) and conjunctions (AND).
    ///
    /// Supported fields:
    ///
    /// * `issue_model_id`
    /// * `qa_question_id`
    /// * `min_create_time`
    /// * `max_create_time`
    /// * `min_update_time`
    /// * `max_update_time`
    /// * `feedback_label_type`: QUALITY_AI, TOPIC_MODELING
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAllFeedbackLabelsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAllFeedbackLabelsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAllFeedbackLabelsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAllFeedbackLabelsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListAllFeedbackLabelsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListAllFeedbackLabelsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ListAllFeedbackLabelsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAllFeedbackLabelsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAllFeedbackLabelsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAllFeedbackLabelsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAllFeedbackLabelsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAllFeedbackLabelsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListAllFeedbackLabelsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListAllFeedbackLabelsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response for listing all feedback labels.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAllFeedbackLabelsResponse {
    /// The feedback labels that match the request.
    pub feedback_labels: std::vec::Vec<crate::model::FeedbackLabel>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAllFeedbackLabelsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [feedback_labels][crate::model::ListAllFeedbackLabelsResponse::feedback_labels].
    pub fn set_feedback_labels<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FeedbackLabel>,
    {
        use std::iter::Iterator;
        self.feedback_labels = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAllFeedbackLabelsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAllFeedbackLabelsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ListAllFeedbackLabelsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAllFeedbackLabelsResponse {
    type PageItem = crate::model::FeedbackLabel;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.feedback_labels
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAllFeedbackLabelsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __feedback_labels,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAllFeedbackLabelsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "feedbackLabels" => Ok(__FieldTag::__feedback_labels),
                            "feedback_labels" => Ok(__FieldTag::__feedback_labels),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAllFeedbackLabelsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAllFeedbackLabelsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__feedback_labels => {
                            if !fields.insert(__FieldTag::__feedback_labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for feedback_labels",
                                ));
                            }
                            result.feedback_labels = map.next_value::<std::option::Option<std::vec::Vec<crate::model::FeedbackLabel>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAllFeedbackLabelsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.feedback_labels.is_empty() {
            state.serialize_entry("feedbackLabels", &self.feedback_labels)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListAllFeedbackLabelsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListAllFeedbackLabelsResponse");
        debug_struct.field("feedback_labels", &self.feedback_labels);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request for bulk uploading feedback labels.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BulkUploadFeedbackLabelsRequest {
    /// Required. The parent resource for new feedback labels.
    pub parent: std::string::String,

    /// Optional. If set, upload will not happen and the labels will be validated.
    /// If not set, then default behavior will be to upload the labels after
    /// validation is complete.
    pub validate_only: bool,

    /// Configuration for an external data store containing objects that will
    /// be converted to FeedbackLabels.
    pub source: std::option::Option<crate::model::bulk_upload_feedback_labels_request::Source>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BulkUploadFeedbackLabelsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BulkUploadFeedbackLabelsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::BulkUploadFeedbackLabelsRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [source][crate::model::BulkUploadFeedbackLabelsRequest::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<
                std::option::Option<crate::model::bulk_upload_feedback_labels_request::Source>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::BulkUploadFeedbackLabelsRequest::source]
    /// if it holds a `GcsSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_source(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::bulk_upload_feedback_labels_request::GcsSource>,
    > {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::bulk_upload_feedback_labels_request::Source::GcsSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::BulkUploadFeedbackLabelsRequest::source]
    /// to hold a `GcsSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_gcs_source<
        T: std::convert::Into<
                std::boxed::Box<crate::model::bulk_upload_feedback_labels_request::GcsSource>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::bulk_upload_feedback_labels_request::Source::GcsSource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BulkUploadFeedbackLabelsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.BulkUploadFeedbackLabelsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BulkUploadFeedbackLabelsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcs_source,
            __parent,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BulkUploadFeedbackLabelsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcsSource" => Ok(__FieldTag::__gcs_source),
                            "gcs_source" => Ok(__FieldTag::__gcs_source),
                            "parent" => Ok(__FieldTag::__parent),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BulkUploadFeedbackLabelsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BulkUploadFeedbackLabelsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcs_source => {
                            if !fields.insert(__FieldTag::__gcs_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_source",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.contactcenterinsights.v1.BulkUploadFeedbackLabelsRequest.gcs_source, latest field was gcsSource",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::bulk_upload_feedback_labels_request::Source::GcsSource(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::bulk_upload_feedback_labels_request::GcsSource>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BulkUploadFeedbackLabelsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.gcs_source() {
            state.serialize_entry("gcsSource", value)?;
        }
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BulkUploadFeedbackLabelsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BulkUploadFeedbackLabelsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("validate_only", &self.validate_only);
        debug_struct.field("source", &self.source);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [BulkUploadFeedbackLabelsRequest].
pub mod bulk_upload_feedback_labels_request {
    #[allow(unused_imports)]
    use super::*;

    /// Google Cloud Storage Object details to get the feedback label file from.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GcsSource {
        /// Required. File format which will be ingested.
        pub format: crate::model::bulk_upload_feedback_labels_request::gcs_source::Format,

        /// Required. The Google Cloud Storage URI of the file to import.
        /// Format: `gs://bucket_name/object_name`
        pub object_uri: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GcsSource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [format][crate::model::bulk_upload_feedback_labels_request::GcsSource::format].
        pub fn set_format<
            T: std::convert::Into<
                    crate::model::bulk_upload_feedback_labels_request::gcs_source::Format,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.format = v.into();
            self
        }

        /// Sets the value of [object_uri][crate::model::bulk_upload_feedback_labels_request::GcsSource::object_uri].
        pub fn set_object_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.object_uri = v.into();
            self
        }
    }

    impl wkt::message::Message for GcsSource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.BulkUploadFeedbackLabelsRequest.GcsSource"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for GcsSource {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __format,
                __object_uri,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for GcsSource")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "format" => Ok(__FieldTag::__format),
                                "objectUri" => Ok(__FieldTag::__object_uri),
                                "object_uri" => Ok(__FieldTag::__object_uri),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = GcsSource;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct GcsSource")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__format => {
                                if !fields.insert(__FieldTag::__format) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for format",
                                    ));
                                }
                                result.format = map.next_value::<std::option::Option<crate::model::bulk_upload_feedback_labels_request::gcs_source::Format>>()?.unwrap_or_default();
                            }
                            __FieldTag::__object_uri => {
                                if !fields.insert(__FieldTag::__object_uri) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for object_uri",
                                    ));
                                }
                                result.object_uri = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for GcsSource {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.format) {
                state.serialize_entry("format", &self.format)?;
            }
            if !self.object_uri.is_empty() {
                state.serialize_entry("objectUri", &self.object_uri)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for GcsSource {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("GcsSource");
            debug_struct.field("format", &self.format);
            debug_struct.field("object_uri", &self.object_uri);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [GcsSource].
    pub mod gcs_source {
        #[allow(unused_imports)]
        use super::*;

        /// All permissible file formats.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Format {
            /// Unspecified format.
            Unspecified,
            /// CSV format.
            Csv,
            /// JSON format.
            Json,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Format::value] or
            /// [Format::name].
            UnknownValue(format::UnknownValue),
        }

        #[doc(hidden)]
        pub mod format {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Format {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Csv => std::option::Option::Some(1),
                    Self::Json => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("FORMAT_UNSPECIFIED"),
                    Self::Csv => std::option::Option::Some("CSV"),
                    Self::Json => std::option::Option::Some("JSON"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Format {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Format {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Format {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Csv,
                    2 => Self::Json,
                    _ => Self::UnknownValue(format::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Format {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "FORMAT_UNSPECIFIED" => Self::Unspecified,
                    "CSV" => Self::Csv,
                    "JSON" => Self::Json,
                    _ => Self::UnknownValue(format::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Format {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Csv => serializer.serialize_i32(1),
                    Self::Json => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Format {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Format>::new(
                    ".google.cloud.contactcenterinsights.v1.BulkUploadFeedbackLabelsRequest.GcsSource.Format"))
            }
        }
    }

    /// Configuration for an external data store containing objects that will
    /// be converted to FeedbackLabels.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// A cloud storage bucket source.
        GcsSource(std::boxed::Box<crate::model::bulk_upload_feedback_labels_request::GcsSource>),
    }
}

/// Response for the Bulk Upload Feedback Labels API.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BulkUploadFeedbackLabelsResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BulkUploadFeedbackLabelsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for BulkUploadFeedbackLabelsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.BulkUploadFeedbackLabelsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BulkUploadFeedbackLabelsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BulkUploadFeedbackLabelsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BulkUploadFeedbackLabelsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BulkUploadFeedbackLabelsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BulkUploadFeedbackLabelsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BulkUploadFeedbackLabelsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BulkUploadFeedbackLabelsResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Metadata for the Bulk Upload Feedback Labels API.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BulkUploadFeedbackLabelsMetadata {
    /// Output only. The time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The original request for ingest.
    pub request: std::option::Option<crate::model::BulkUploadFeedbackLabelsRequest>,

    /// Partial errors during ingest operation that might cause the operation
    /// output to be incomplete.
    pub partial_errors: std::vec::Vec<rpc::model::Status>,

    /// Output only. Statistics for BulkUploadFeedbackLabels operation.
    pub upload_stats:
        std::option::Option<crate::model::bulk_upload_feedback_labels_metadata::UploadStats>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BulkUploadFeedbackLabelsMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::BulkUploadFeedbackLabelsMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::BulkUploadFeedbackLabelsMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::BulkUploadFeedbackLabelsMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::BulkUploadFeedbackLabelsMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request][crate::model::BulkUploadFeedbackLabelsMetadata::request].
    pub fn set_request<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BulkUploadFeedbackLabelsRequest>,
    {
        self.request = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [request][crate::model::BulkUploadFeedbackLabelsMetadata::request].
    pub fn set_or_clear_request<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BulkUploadFeedbackLabelsRequest>,
    {
        self.request = v.map(|x| x.into());
        self
    }

    /// Sets the value of [partial_errors][crate::model::BulkUploadFeedbackLabelsMetadata::partial_errors].
    pub fn set_partial_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.partial_errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [upload_stats][crate::model::BulkUploadFeedbackLabelsMetadata::upload_stats].
    pub fn set_upload_stats<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::bulk_upload_feedback_labels_metadata::UploadStats>,
    {
        self.upload_stats = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [upload_stats][crate::model::BulkUploadFeedbackLabelsMetadata::upload_stats].
    pub fn set_or_clear_upload_stats<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::bulk_upload_feedback_labels_metadata::UploadStats>,
    {
        self.upload_stats = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for BulkUploadFeedbackLabelsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.BulkUploadFeedbackLabelsMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BulkUploadFeedbackLabelsMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __end_time,
            __request,
            __partial_errors,
            __upload_stats,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BulkUploadFeedbackLabelsMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "request" => Ok(__FieldTag::__request),
                            "partialErrors" => Ok(__FieldTag::__partial_errors),
                            "partial_errors" => Ok(__FieldTag::__partial_errors),
                            "uploadStats" => Ok(__FieldTag::__upload_stats),
                            "upload_stats" => Ok(__FieldTag::__upload_stats),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BulkUploadFeedbackLabelsMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BulkUploadFeedbackLabelsMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__request => {
                            if !fields.insert(__FieldTag::__request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request",
                                ));
                            }
                            result.request = map.next_value::<std::option::Option<
                                crate::model::BulkUploadFeedbackLabelsRequest,
                            >>()?;
                        }
                        __FieldTag::__partial_errors => {
                            if !fields.insert(__FieldTag::__partial_errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for partial_errors",
                                ));
                            }
                            result.partial_errors = map.next_value::<std::option::Option<std::vec::Vec<rpc::model::Status>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__upload_stats => {
                            if !fields.insert(__FieldTag::__upload_stats) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for upload_stats",
                                ));
                            }
                            result.upload_stats = map.next_value::<std::option::Option<
                                crate::model::bulk_upload_feedback_labels_metadata::UploadStats,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BulkUploadFeedbackLabelsMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if self.request.is_some() {
            state.serialize_entry("request", &self.request)?;
        }
        if !self.partial_errors.is_empty() {
            state.serialize_entry("partialErrors", &self.partial_errors)?;
        }
        if self.upload_stats.is_some() {
            state.serialize_entry("uploadStats", &self.upload_stats)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BulkUploadFeedbackLabelsMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BulkUploadFeedbackLabelsMetadata");
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("request", &self.request);
        debug_struct.field("partial_errors", &self.partial_errors);
        debug_struct.field("upload_stats", &self.upload_stats);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [BulkUploadFeedbackLabelsMetadata].
pub mod bulk_upload_feedback_labels_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Statistics for BulkUploadFeedbackLabels operation.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct UploadStats {
        /// The number of objects processed during the upload operation.
        pub processed_object_count: i32,

        /// The number of objects skipped because of failed validation
        pub failed_validation_count: i32,

        /// The number of new feedback labels added during this ingest operation.
        pub successful_upload_count: i32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl UploadStats {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [processed_object_count][crate::model::bulk_upload_feedback_labels_metadata::UploadStats::processed_object_count].
        pub fn set_processed_object_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.processed_object_count = v.into();
            self
        }

        /// Sets the value of [failed_validation_count][crate::model::bulk_upload_feedback_labels_metadata::UploadStats::failed_validation_count].
        pub fn set_failed_validation_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.failed_validation_count = v.into();
            self
        }

        /// Sets the value of [successful_upload_count][crate::model::bulk_upload_feedback_labels_metadata::UploadStats::successful_upload_count].
        pub fn set_successful_upload_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.successful_upload_count = v.into();
            self
        }
    }

    impl wkt::message::Message for UploadStats {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.BulkUploadFeedbackLabelsMetadata.UploadStats"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for UploadStats {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __processed_object_count,
                __failed_validation_count,
                __successful_upload_count,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for UploadStats")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "processedObjectCount" => Ok(__FieldTag::__processed_object_count),
                                "processed_object_count" => {
                                    Ok(__FieldTag::__processed_object_count)
                                }
                                "failedValidationCount" => {
                                    Ok(__FieldTag::__failed_validation_count)
                                }
                                "failed_validation_count" => {
                                    Ok(__FieldTag::__failed_validation_count)
                                }
                                "successfulUploadCount" => {
                                    Ok(__FieldTag::__successful_upload_count)
                                }
                                "successful_upload_count" => {
                                    Ok(__FieldTag::__successful_upload_count)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = UploadStats;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct UploadStats")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__processed_object_count => {
                                if !fields.insert(__FieldTag::__processed_object_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for processed_object_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.processed_object_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__failed_validation_count => {
                                if !fields.insert(__FieldTag::__failed_validation_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for failed_validation_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.failed_validation_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__successful_upload_count => {
                                if !fields.insert(__FieldTag::__successful_upload_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for successful_upload_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.successful_upload_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for UploadStats {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.processed_object_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "processedObjectCount",
                    &__With(&self.processed_object_count),
                )?;
            }
            if !wkt::internal::is_default(&self.failed_validation_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "failedValidationCount",
                    &__With(&self.failed_validation_count),
                )?;
            }
            if !wkt::internal::is_default(&self.successful_upload_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "successfulUploadCount",
                    &__With(&self.successful_upload_count),
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for UploadStats {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("UploadStats");
            debug_struct.field("processed_object_count", &self.processed_object_count);
            debug_struct.field("failed_validation_count", &self.failed_validation_count);
            debug_struct.field("successful_upload_count", &self.successful_upload_count);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// Request for the BulkDownloadFeedbackLabel endpoint.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BulkDownloadFeedbackLabelsRequest {
    /// Required. The parent resource for new feedback labels.
    pub parent: std::string::String,

    /// Optional. A filter to reduce results to a specific subset. Supports
    /// disjunctions (OR) and conjunctions (AND).
    ///
    /// Supported fields:
    ///
    /// * `issue_model_id`
    /// * `qa_question_id`
    /// * `qa_scorecard_id`
    /// * `min_create_time`
    /// * `max_create_time`
    /// * `min_update_time`
    /// * `max_update_time`
    /// * `feedback_label_type`: QUALITY_AI, TOPIC_MODELING
    pub filter: std::string::String,

    /// Optional. Limits the maximum number of feedback labels that will be
    /// downloaded. The first `N` feedback labels will be downloaded.
    pub max_download_count: i32,

    /// Optional. The type of feedback labels that will be downloaded.
    pub feedback_label_type: crate::model::bulk_download_feedback_labels_request::FeedbackLabelType,

    /// Optional. Filter parent conversations to download feedback labels for.
    /// When specified, the feedback labels will be downloaded for the
    /// conversations that match the filter.
    /// If `template_qa_scorecard_id` is set, all the conversations that match the
    /// filter will be paired with the questions under the scorecard for labeling.
    pub conversation_filter: std::string::String,

    /// Optional. If set, a template for labeling conversations and scorecard
    /// questions will be created from the conversation_filter and the questions
    /// under the scorecard(s). The feedback label `filter` will be ignored.
    pub template_qa_scorecard_id: std::vec::Vec<std::string::String>,

    /// Configuration for an external data store to which the feedback labels
    /// will be written to.
    pub destination:
        std::option::Option<crate::model::bulk_download_feedback_labels_request::Destination>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BulkDownloadFeedbackLabelsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BulkDownloadFeedbackLabelsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::BulkDownloadFeedbackLabelsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [max_download_count][crate::model::BulkDownloadFeedbackLabelsRequest::max_download_count].
    pub fn set_max_download_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_download_count = v.into();
        self
    }

    /// Sets the value of [feedback_label_type][crate::model::BulkDownloadFeedbackLabelsRequest::feedback_label_type].
    pub fn set_feedback_label_type<
        T: std::convert::Into<crate::model::bulk_download_feedback_labels_request::FeedbackLabelType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.feedback_label_type = v.into();
        self
    }

    /// Sets the value of [conversation_filter][crate::model::BulkDownloadFeedbackLabelsRequest::conversation_filter].
    pub fn set_conversation_filter<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.conversation_filter = v.into();
        self
    }

    /// Sets the value of [template_qa_scorecard_id][crate::model::BulkDownloadFeedbackLabelsRequest::template_qa_scorecard_id].
    pub fn set_template_qa_scorecard_id<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.template_qa_scorecard_id = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [destination][crate::model::BulkDownloadFeedbackLabelsRequest::destination].
    ///
    /// Note that all the setters affecting `destination` are mutually
    /// exclusive.
    pub fn set_destination<
        T: std::convert::Into<
                std::option::Option<
                    crate::model::bulk_download_feedback_labels_request::Destination,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::BulkDownloadFeedbackLabelsRequest::destination]
    /// if it holds a `GcsDestination`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_destination(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::bulk_download_feedback_labels_request::GcsDestination>,
    > {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::bulk_download_feedback_labels_request::Destination::GcsDestination(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::BulkDownloadFeedbackLabelsRequest::destination]
    /// to hold a `GcsDestination`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_gcs_destination<
        T: std::convert::Into<
                std::boxed::Box<
                    crate::model::bulk_download_feedback_labels_request::GcsDestination,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::bulk_download_feedback_labels_request::Destination::GcsDestination(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for BulkDownloadFeedbackLabelsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.BulkDownloadFeedbackLabelsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BulkDownloadFeedbackLabelsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcs_destination,
            __parent,
            __filter,
            __max_download_count,
            __feedback_label_type,
            __conversation_filter,
            __template_qa_scorecard_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BulkDownloadFeedbackLabelsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcsDestination" => Ok(__FieldTag::__gcs_destination),
                            "gcs_destination" => Ok(__FieldTag::__gcs_destination),
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "maxDownloadCount" => Ok(__FieldTag::__max_download_count),
                            "max_download_count" => Ok(__FieldTag::__max_download_count),
                            "feedbackLabelType" => Ok(__FieldTag::__feedback_label_type),
                            "feedback_label_type" => Ok(__FieldTag::__feedback_label_type),
                            "conversationFilter" => Ok(__FieldTag::__conversation_filter),
                            "conversation_filter" => Ok(__FieldTag::__conversation_filter),
                            "templateQaScorecardId" => Ok(__FieldTag::__template_qa_scorecard_id),
                            "template_qa_scorecard_id" => {
                                Ok(__FieldTag::__template_qa_scorecard_id)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BulkDownloadFeedbackLabelsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BulkDownloadFeedbackLabelsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcs_destination => {
                            if !fields.insert(__FieldTag::__gcs_destination) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_destination",
                                ));
                            }
                            if result.destination.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `destination`, a oneof with full ID .google.cloud.contactcenterinsights.v1.BulkDownloadFeedbackLabelsRequest.gcs_destination, latest field was gcsDestination",
                                ));
                            }
                            result.destination = std::option::Option::Some(
                                crate::model::bulk_download_feedback_labels_request::Destination::GcsDestination(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::bulk_download_feedback_labels_request::GcsDestination>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__max_download_count => {
                            if !fields.insert(__FieldTag::__max_download_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_download_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_download_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__feedback_label_type => {
                            if !fields.insert(__FieldTag::__feedback_label_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for feedback_label_type",
                                ));
                            }
                            result.feedback_label_type = map.next_value::<std::option::Option<crate::model::bulk_download_feedback_labels_request::FeedbackLabelType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__conversation_filter => {
                            if !fields.insert(__FieldTag::__conversation_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation_filter",
                                ));
                            }
                            result.conversation_filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__template_qa_scorecard_id => {
                            if !fields.insert(__FieldTag::__template_qa_scorecard_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for template_qa_scorecard_id",
                                ));
                            }
                            result.template_qa_scorecard_id = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BulkDownloadFeedbackLabelsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.gcs_destination() {
            state.serialize_entry("gcsDestination", value)?;
        }
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.max_download_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxDownloadCount", &__With(&self.max_download_count))?;
        }
        if !wkt::internal::is_default(&self.feedback_label_type) {
            state.serialize_entry("feedbackLabelType", &self.feedback_label_type)?;
        }
        if !self.conversation_filter.is_empty() {
            state.serialize_entry("conversationFilter", &self.conversation_filter)?;
        }
        if !self.template_qa_scorecard_id.is_empty() {
            state.serialize_entry("templateQaScorecardId", &self.template_qa_scorecard_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BulkDownloadFeedbackLabelsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BulkDownloadFeedbackLabelsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("max_download_count", &self.max_download_count);
        debug_struct.field("feedback_label_type", &self.feedback_label_type);
        debug_struct.field("conversation_filter", &self.conversation_filter);
        debug_struct.field("template_qa_scorecard_id", &self.template_qa_scorecard_id);
        debug_struct.field("destination", &self.destination);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [BulkDownloadFeedbackLabelsRequest].
pub mod bulk_download_feedback_labels_request {
    #[allow(unused_imports)]
    use super::*;

    /// Google Cloud Storage Object details to write the feedback labels to.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GcsDestination {
        /// Required. File format in which the labels will be exported.
        pub format: crate::model::bulk_download_feedback_labels_request::gcs_destination::Format,

        /// Required. The Google Cloud Storage URI to write the feedback labels to.
        /// The file name will be used as a prefix for the files written to the
        /// bucket if the output needs to be split across multiple files, otherwise
        /// it will be used as is. The file extension will be appended to the file
        /// name based on the format selected.
        /// E.g. `gs://bucket_name/object_uri_prefix`
        pub object_uri: std::string::String,

        /// Optional. Add whitespace to the JSON file. Makes easier to read, but
        /// increases file size. Only applicable for JSON format.
        pub add_whitespace: bool,

        /// Optional. Always print fields with no presence.
        /// This is useful for printing fields that are not set, like implicit 0
        /// value or empty lists/maps. Only applicable for JSON format.
        pub always_print_empty_fields: bool,

        /// Optional. The number of records per file. Applicable for either format.
        pub records_per_file_count: i64,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GcsDestination {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [format][crate::model::bulk_download_feedback_labels_request::GcsDestination::format].
        pub fn set_format<
            T: std::convert::Into<
                    crate::model::bulk_download_feedback_labels_request::gcs_destination::Format,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.format = v.into();
            self
        }

        /// Sets the value of [object_uri][crate::model::bulk_download_feedback_labels_request::GcsDestination::object_uri].
        pub fn set_object_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.object_uri = v.into();
            self
        }

        /// Sets the value of [add_whitespace][crate::model::bulk_download_feedback_labels_request::GcsDestination::add_whitespace].
        pub fn set_add_whitespace<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.add_whitespace = v.into();
            self
        }

        /// Sets the value of [always_print_empty_fields][crate::model::bulk_download_feedback_labels_request::GcsDestination::always_print_empty_fields].
        pub fn set_always_print_empty_fields<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.always_print_empty_fields = v.into();
            self
        }

        /// Sets the value of [records_per_file_count][crate::model::bulk_download_feedback_labels_request::GcsDestination::records_per_file_count].
        pub fn set_records_per_file_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.records_per_file_count = v.into();
            self
        }
    }

    impl wkt::message::Message for GcsDestination {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.BulkDownloadFeedbackLabelsRequest.GcsDestination"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for GcsDestination {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __format,
                __object_uri,
                __add_whitespace,
                __always_print_empty_fields,
                __records_per_file_count,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for GcsDestination")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "format" => Ok(__FieldTag::__format),
                                "objectUri" => Ok(__FieldTag::__object_uri),
                                "object_uri" => Ok(__FieldTag::__object_uri),
                                "addWhitespace" => Ok(__FieldTag::__add_whitespace),
                                "add_whitespace" => Ok(__FieldTag::__add_whitespace),
                                "alwaysPrintEmptyFields" => {
                                    Ok(__FieldTag::__always_print_empty_fields)
                                }
                                "always_print_empty_fields" => {
                                    Ok(__FieldTag::__always_print_empty_fields)
                                }
                                "recordsPerFileCount" => Ok(__FieldTag::__records_per_file_count),
                                "records_per_file_count" => {
                                    Ok(__FieldTag::__records_per_file_count)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = GcsDestination;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct GcsDestination")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__format => {
                                if !fields.insert(__FieldTag::__format) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for format",
                                    ));
                                }
                                result.format = map.next_value::<std::option::Option<crate::model::bulk_download_feedback_labels_request::gcs_destination::Format>>()?.unwrap_or_default();
                            }
                            __FieldTag::__object_uri => {
                                if !fields.insert(__FieldTag::__object_uri) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for object_uri",
                                    ));
                                }
                                result.object_uri = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__add_whitespace => {
                                if !fields.insert(__FieldTag::__add_whitespace) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for add_whitespace",
                                    ));
                                }
                                result.add_whitespace = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__always_print_empty_fields => {
                                if !fields.insert(__FieldTag::__always_print_empty_fields) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for always_print_empty_fields",
                                    ));
                                }
                                result.always_print_empty_fields = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__records_per_file_count => {
                                if !fields.insert(__FieldTag::__records_per_file_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for records_per_file_count",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.records_per_file_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for GcsDestination {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.format) {
                state.serialize_entry("format", &self.format)?;
            }
            if !self.object_uri.is_empty() {
                state.serialize_entry("objectUri", &self.object_uri)?;
            }
            if !wkt::internal::is_default(&self.add_whitespace) {
                state.serialize_entry("addWhitespace", &self.add_whitespace)?;
            }
            if !wkt::internal::is_default(&self.always_print_empty_fields) {
                state.serialize_entry("alwaysPrintEmptyFields", &self.always_print_empty_fields)?;
            }
            if !wkt::internal::is_default(&self.records_per_file_count) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "recordsPerFileCount",
                    &__With(&self.records_per_file_count),
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for GcsDestination {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("GcsDestination");
            debug_struct.field("format", &self.format);
            debug_struct.field("object_uri", &self.object_uri);
            debug_struct.field("add_whitespace", &self.add_whitespace);
            debug_struct.field("always_print_empty_fields", &self.always_print_empty_fields);
            debug_struct.field("records_per_file_count", &self.records_per_file_count);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [GcsDestination].
    pub mod gcs_destination {
        #[allow(unused_imports)]
        use super::*;

        /// All permissible file formats.
        /// See `records_per_file_count` to override the default number of records
        /// per file.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Format {
            /// Unspecified format.
            Unspecified,
            /// CSV format.
            /// 1,000 labels are stored per CSV file by default.
            Csv,
            /// JSON format.
            /// 1 label stored per JSON file by default.
            Json,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Format::value] or
            /// [Format::name].
            UnknownValue(format::UnknownValue),
        }

        #[doc(hidden)]
        pub mod format {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Format {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Csv => std::option::Option::Some(1),
                    Self::Json => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("FORMAT_UNSPECIFIED"),
                    Self::Csv => std::option::Option::Some("CSV"),
                    Self::Json => std::option::Option::Some("JSON"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Format {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Format {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Format {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Csv,
                    2 => Self::Json,
                    _ => Self::UnknownValue(format::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Format {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "FORMAT_UNSPECIFIED" => Self::Unspecified,
                    "CSV" => Self::Csv,
                    "JSON" => Self::Json,
                    _ => Self::UnknownValue(format::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Format {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Csv => serializer.serialize_i32(1),
                    Self::Json => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Format {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Format>::new(
                    ".google.cloud.contactcenterinsights.v1.BulkDownloadFeedbackLabelsRequest.GcsDestination.Format"))
            }
        }
    }

    /// Possible feedback label types that will be downloaded.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum FeedbackLabelType {
        /// Unspecified format
        Unspecified,
        /// Downloaded file will contain all Quality AI labels from the latest
        /// scorecard revision.
        QualityAi,
        /// Downloaded file will contain only Topic Modeling labels.
        TopicModeling,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [FeedbackLabelType::value] or
        /// [FeedbackLabelType::name].
        UnknownValue(feedback_label_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod feedback_label_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl FeedbackLabelType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::QualityAi => std::option::Option::Some(1),
                Self::TopicModeling => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("FEEDBACK_LABEL_TYPE_UNSPECIFIED"),
                Self::QualityAi => std::option::Option::Some("QUALITY_AI"),
                Self::TopicModeling => std::option::Option::Some("TOPIC_MODELING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for FeedbackLabelType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for FeedbackLabelType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for FeedbackLabelType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::QualityAi,
                2 => Self::TopicModeling,
                _ => Self::UnknownValue(feedback_label_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for FeedbackLabelType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FEEDBACK_LABEL_TYPE_UNSPECIFIED" => Self::Unspecified,
                "QUALITY_AI" => Self::QualityAi,
                "TOPIC_MODELING" => Self::TopicModeling,
                _ => Self::UnknownValue(feedback_label_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for FeedbackLabelType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::QualityAi => serializer.serialize_i32(1),
                Self::TopicModeling => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for FeedbackLabelType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<FeedbackLabelType>::new(
                ".google.cloud.contactcenterinsights.v1.BulkDownloadFeedbackLabelsRequest.FeedbackLabelType"))
        }
    }

    /// Configuration for an external data store to which the feedback labels
    /// will be written to.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Destination {
        /// A cloud storage bucket destination.
        GcsDestination(
            std::boxed::Box<crate::model::bulk_download_feedback_labels_request::GcsDestination>,
        ),
    }
}

/// Response for the BulkDownloadFeedbackLabel endpoint.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BulkDownloadFeedbackLabelsResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BulkDownloadFeedbackLabelsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for BulkDownloadFeedbackLabelsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.BulkDownloadFeedbackLabelsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BulkDownloadFeedbackLabelsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BulkDownloadFeedbackLabelsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BulkDownloadFeedbackLabelsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BulkDownloadFeedbackLabelsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BulkDownloadFeedbackLabelsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BulkDownloadFeedbackLabelsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BulkDownloadFeedbackLabelsResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Metadata for the BulkDownloadFeedbackLabel endpoint.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BulkDownloadFeedbackLabelsMetadata {
    /// Output only. The time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The original request for download.
    pub request: std::option::Option<crate::model::BulkDownloadFeedbackLabelsRequest>,

    /// Partial errors during ingest operation that might cause the operation
    /// output to be incomplete.
    pub partial_errors: std::vec::Vec<rpc::model::Status>,

    /// Output only. Statistics for BulkDownloadFeedbackLabels operation.
    pub download_stats:
        std::option::Option<crate::model::bulk_download_feedback_labels_metadata::DownloadStats>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BulkDownloadFeedbackLabelsMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::BulkDownloadFeedbackLabelsMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::BulkDownloadFeedbackLabelsMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::BulkDownloadFeedbackLabelsMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::BulkDownloadFeedbackLabelsMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request][crate::model::BulkDownloadFeedbackLabelsMetadata::request].
    pub fn set_request<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BulkDownloadFeedbackLabelsRequest>,
    {
        self.request = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [request][crate::model::BulkDownloadFeedbackLabelsMetadata::request].
    pub fn set_or_clear_request<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BulkDownloadFeedbackLabelsRequest>,
    {
        self.request = v.map(|x| x.into());
        self
    }

    /// Sets the value of [partial_errors][crate::model::BulkDownloadFeedbackLabelsMetadata::partial_errors].
    pub fn set_partial_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.partial_errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [download_stats][crate::model::BulkDownloadFeedbackLabelsMetadata::download_stats].
    pub fn set_download_stats<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::bulk_download_feedback_labels_metadata::DownloadStats>,
    {
        self.download_stats = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [download_stats][crate::model::BulkDownloadFeedbackLabelsMetadata::download_stats].
    pub fn set_or_clear_download_stats<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::bulk_download_feedback_labels_metadata::DownloadStats>,
    {
        self.download_stats = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for BulkDownloadFeedbackLabelsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.BulkDownloadFeedbackLabelsMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BulkDownloadFeedbackLabelsMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __end_time,
            __request,
            __partial_errors,
            __download_stats,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BulkDownloadFeedbackLabelsMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "request" => Ok(__FieldTag::__request),
                            "partialErrors" => Ok(__FieldTag::__partial_errors),
                            "partial_errors" => Ok(__FieldTag::__partial_errors),
                            "downloadStats" => Ok(__FieldTag::__download_stats),
                            "download_stats" => Ok(__FieldTag::__download_stats),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BulkDownloadFeedbackLabelsMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BulkDownloadFeedbackLabelsMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__request => {
                            if !fields.insert(__FieldTag::__request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request",
                                ));
                            }
                            result.request = map.next_value::<std::option::Option<
                                crate::model::BulkDownloadFeedbackLabelsRequest,
                            >>()?;
                        }
                        __FieldTag::__partial_errors => {
                            if !fields.insert(__FieldTag::__partial_errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for partial_errors",
                                ));
                            }
                            result.partial_errors = map.next_value::<std::option::Option<std::vec::Vec<rpc::model::Status>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__download_stats => {
                            if !fields.insert(__FieldTag::__download_stats) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for download_stats",
                                ));
                            }
                            result.download_stats = map.next_value::<std::option::Option<
                                crate::model::bulk_download_feedback_labels_metadata::DownloadStats,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BulkDownloadFeedbackLabelsMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if self.request.is_some() {
            state.serialize_entry("request", &self.request)?;
        }
        if !self.partial_errors.is_empty() {
            state.serialize_entry("partialErrors", &self.partial_errors)?;
        }
        if self.download_stats.is_some() {
            state.serialize_entry("downloadStats", &self.download_stats)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BulkDownloadFeedbackLabelsMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BulkDownloadFeedbackLabelsMetadata");
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("request", &self.request);
        debug_struct.field("partial_errors", &self.partial_errors);
        debug_struct.field("download_stats", &self.download_stats);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [BulkDownloadFeedbackLabelsMetadata].
pub mod bulk_download_feedback_labels_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Statistics for BulkDownloadFeedbackLabels operation.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DownloadStats {
        /// The number of objects processed during the download operation.
        pub processed_object_count: i32,

        /// The number of new feedback labels downloaded during this operation.
        /// Different from "processed" because some labels might not be downloaded
        /// because an error.
        pub successful_download_count: i32,

        /// Total number of files written to the provided Cloud Storage bucket.
        pub total_files_written: i32,

        /// Output only. Full name of the files written to Cloud storage.
        pub file_names: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DownloadStats {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [processed_object_count][crate::model::bulk_download_feedback_labels_metadata::DownloadStats::processed_object_count].
        pub fn set_processed_object_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.processed_object_count = v.into();
            self
        }

        /// Sets the value of [successful_download_count][crate::model::bulk_download_feedback_labels_metadata::DownloadStats::successful_download_count].
        pub fn set_successful_download_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.successful_download_count = v.into();
            self
        }

        /// Sets the value of [total_files_written][crate::model::bulk_download_feedback_labels_metadata::DownloadStats::total_files_written].
        pub fn set_total_files_written<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.total_files_written = v.into();
            self
        }

        /// Sets the value of [file_names][crate::model::bulk_download_feedback_labels_metadata::DownloadStats::file_names].
        pub fn set_file_names<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.file_names = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for DownloadStats {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.BulkDownloadFeedbackLabelsMetadata.DownloadStats"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for DownloadStats {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __processed_object_count,
                __successful_download_count,
                __total_files_written,
                __file_names,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for DownloadStats")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "processedObjectCount" => Ok(__FieldTag::__processed_object_count),
                                "processed_object_count" => {
                                    Ok(__FieldTag::__processed_object_count)
                                }
                                "successfulDownloadCount" => {
                                    Ok(__FieldTag::__successful_download_count)
                                }
                                "successful_download_count" => {
                                    Ok(__FieldTag::__successful_download_count)
                                }
                                "totalFilesWritten" => Ok(__FieldTag::__total_files_written),
                                "total_files_written" => Ok(__FieldTag::__total_files_written),
                                "fileNames" => Ok(__FieldTag::__file_names),
                                "file_names" => Ok(__FieldTag::__file_names),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = DownloadStats;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct DownloadStats")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__processed_object_count => {
                                if !fields.insert(__FieldTag::__processed_object_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for processed_object_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.processed_object_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__successful_download_count => {
                                if !fields.insert(__FieldTag::__successful_download_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for successful_download_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.successful_download_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__total_files_written => {
                                if !fields.insert(__FieldTag::__total_files_written) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for total_files_written",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.total_files_written =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__file_names => {
                                if !fields.insert(__FieldTag::__file_names) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for file_names",
                                    ));
                                }
                                result.file_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for DownloadStats {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.processed_object_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "processedObjectCount",
                    &__With(&self.processed_object_count),
                )?;
            }
            if !wkt::internal::is_default(&self.successful_download_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "successfulDownloadCount",
                    &__With(&self.successful_download_count),
                )?;
            }
            if !wkt::internal::is_default(&self.total_files_written) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("totalFilesWritten", &__With(&self.total_files_written))?;
            }
            if !self.file_names.is_empty() {
                state.serialize_entry("fileNames", &self.file_names)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for DownloadStats {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("DownloadStats");
            debug_struct.field("processed_object_count", &self.processed_object_count);
            debug_struct.field("successful_download_count", &self.successful_download_count);
            debug_struct.field("total_files_written", &self.total_files_written);
            debug_struct.field("file_names", &self.file_names);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// The conversation resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Conversation {
    /// Immutable. The resource name of the conversation.
    /// Format:
    /// projects/{project}/locations/{location}/conversations/{conversation}
    pub name: std::string::String,

    /// The source of the audio and transcription for the conversation.
    pub data_source: std::option::Option<crate::model::ConversationDataSource>,

    /// Output only. The time at which the conversation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The most recent time at which the conversation was updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The time at which the conversation started.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// A user-specified language code for the conversation.
    pub language_code: std::string::String,

    /// An opaque, user-specified string representing the human agent who handled
    /// the conversation.
    pub agent_id: std::string::String,

    /// A map for the user to specify any custom fields. A maximum of 100 labels
    /// per conversation is allowed, with a maximum of 256 characters per entry.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Conversation metadata related to quality management.
    pub quality_metadata: std::option::Option<crate::model::conversation::QualityMetadata>,

    /// Input only. JSON metadata encoded as a string.
    /// This field is primarily used by Insights integrations with various telphony
    /// systems and must be in one of Insight's supported formats.
    pub metadata_json: std::string::String,

    /// Output only. The conversation transcript.
    pub transcript: std::option::Option<crate::model::conversation::Transcript>,

    /// Immutable. The conversation medium, if unspecified will default to
    /// PHONE_CALL.
    pub medium: crate::model::conversation::Medium,

    /// Output only. The duration of the conversation.
    pub duration: std::option::Option<wkt::Duration>,

    /// Output only. The number of turns in the conversation.
    pub turn_count: i32,

    /// Output only. The conversation's latest analysis, if one exists.
    pub latest_analysis: std::option::Option<crate::model::Analysis>,

    /// Output only. Latest summary of the conversation.
    pub latest_summary: std::option::Option<crate::model::ConversationSummarizationSuggestionData>,

    /// Output only. The annotations that were generated during the customer and
    /// agent interaction.
    pub runtime_annotations: std::vec::Vec<crate::model::RuntimeAnnotation>,

    /// Output only. All the matched Dialogflow intents in the call. The key
    /// corresponds to a Dialogflow intent, format:
    /// projects/{project}/agent/{agent}/intents/{intent}
    pub dialogflow_intents:
        std::collections::HashMap<std::string::String, crate::model::DialogflowIntent>,

    /// Obfuscated user ID which the customer sent to us.
    pub obfuscated_user_id: std::string::String,

    /// Metadata that applies to the conversation.
    pub metadata: std::option::Option<crate::model::conversation::Metadata>,

    /// A time to live expiration setting, can be either a specified timestamp or a
    /// duration from the time that the conversation creation request was received.
    /// Conversations with an expiration set will be removed up to 24 hours after
    /// the specified time.
    pub expiration: std::option::Option<crate::model::conversation::Expiration>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Conversation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Conversation::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [data_source][crate::model::Conversation::data_source].
    pub fn set_data_source<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ConversationDataSource>,
    {
        self.data_source = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data_source][crate::model::Conversation::data_source].
    pub fn set_or_clear_data_source<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ConversationDataSource>,
    {
        self.data_source = v.map(|x| x.into());
        self
    }

    /// Sets the value of [create_time][crate::model::Conversation::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Conversation::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Conversation::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Conversation::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time][crate::model::Conversation::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::Conversation::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [language_code][crate::model::Conversation::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [agent_id][crate::model::Conversation::agent_id].
    pub fn set_agent_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.agent_id = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Conversation::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [quality_metadata][crate::model::Conversation::quality_metadata].
    pub fn set_quality_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::conversation::QualityMetadata>,
    {
        self.quality_metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [quality_metadata][crate::model::Conversation::quality_metadata].
    pub fn set_or_clear_quality_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::conversation::QualityMetadata>,
    {
        self.quality_metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [metadata_json][crate::model::Conversation::metadata_json].
    pub fn set_metadata_json<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.metadata_json = v.into();
        self
    }

    /// Sets the value of [transcript][crate::model::Conversation::transcript].
    pub fn set_transcript<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::conversation::Transcript>,
    {
        self.transcript = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [transcript][crate::model::Conversation::transcript].
    pub fn set_or_clear_transcript<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::conversation::Transcript>,
    {
        self.transcript = v.map(|x| x.into());
        self
    }

    /// Sets the value of [medium][crate::model::Conversation::medium].
    pub fn set_medium<T: std::convert::Into<crate::model::conversation::Medium>>(
        mut self,
        v: T,
    ) -> Self {
        self.medium = v.into();
        self
    }

    /// Sets the value of [duration][crate::model::Conversation::duration].
    pub fn set_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [duration][crate::model::Conversation::duration].
    pub fn set_or_clear_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [turn_count][crate::model::Conversation::turn_count].
    pub fn set_turn_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.turn_count = v.into();
        self
    }

    /// Sets the value of [latest_analysis][crate::model::Conversation::latest_analysis].
    pub fn set_latest_analysis<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Analysis>,
    {
        self.latest_analysis = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [latest_analysis][crate::model::Conversation::latest_analysis].
    pub fn set_or_clear_latest_analysis<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Analysis>,
    {
        self.latest_analysis = v.map(|x| x.into());
        self
    }

    /// Sets the value of [latest_summary][crate::model::Conversation::latest_summary].
    pub fn set_latest_summary<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ConversationSummarizationSuggestionData>,
    {
        self.latest_summary = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [latest_summary][crate::model::Conversation::latest_summary].
    pub fn set_or_clear_latest_summary<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ConversationSummarizationSuggestionData>,
    {
        self.latest_summary = v.map(|x| x.into());
        self
    }

    /// Sets the value of [runtime_annotations][crate::model::Conversation::runtime_annotations].
    pub fn set_runtime_annotations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RuntimeAnnotation>,
    {
        use std::iter::Iterator;
        self.runtime_annotations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [dialogflow_intents][crate::model::Conversation::dialogflow_intents].
    pub fn set_dialogflow_intents<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::DialogflowIntent>,
    {
        use std::iter::Iterator;
        self.dialogflow_intents = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [obfuscated_user_id][crate::model::Conversation::obfuscated_user_id].
    pub fn set_obfuscated_user_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.obfuscated_user_id = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::Conversation::metadata].
    ///
    /// Note that all the setters affecting `metadata` are mutually
    /// exclusive.
    pub fn set_metadata<
        T: std::convert::Into<std::option::Option<crate::model::conversation::Metadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = v.into();
        self
    }

    /// The value of [metadata][crate::model::Conversation::metadata]
    /// if it holds a `CallMetadata`, `None` if the field is not set or
    /// holds a different branch.
    pub fn call_metadata(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::conversation::CallMetadata>> {
        #[allow(unreachable_patterns)]
        self.metadata.as_ref().and_then(|v| match v {
            crate::model::conversation::Metadata::CallMetadata(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [metadata][crate::model::Conversation::metadata]
    /// to hold a `CallMetadata`.
    ///
    /// Note that all the setters affecting `metadata` are
    /// mutually exclusive.
    pub fn set_call_metadata<
        T: std::convert::Into<std::boxed::Box<crate::model::conversation::CallMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metadata =
            std::option::Option::Some(crate::model::conversation::Metadata::CallMetadata(v.into()));
        self
    }

    /// Sets the value of [expiration][crate::model::Conversation::expiration].
    ///
    /// Note that all the setters affecting `expiration` are mutually
    /// exclusive.
    pub fn set_expiration<
        T: std::convert::Into<std::option::Option<crate::model::conversation::Expiration>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.expiration = v.into();
        self
    }

    /// The value of [expiration][crate::model::Conversation::expiration]
    /// if it holds a `ExpireTime`, `None` if the field is not set or
    /// holds a different branch.
    pub fn expire_time(&self) -> std::option::Option<&std::boxed::Box<wkt::Timestamp>> {
        #[allow(unreachable_patterns)]
        self.expiration.as_ref().and_then(|v| match v {
            crate::model::conversation::Expiration::ExpireTime(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [expiration][crate::model::Conversation::expiration]
    /// to hold a `ExpireTime`.
    ///
    /// Note that all the setters affecting `expiration` are
    /// mutually exclusive.
    pub fn set_expire_time<T: std::convert::Into<std::boxed::Box<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expiration =
            std::option::Option::Some(crate::model::conversation::Expiration::ExpireTime(v.into()));
        self
    }

    /// The value of [expiration][crate::model::Conversation::expiration]
    /// if it holds a `Ttl`, `None` if the field is not set or
    /// holds a different branch.
    pub fn ttl(&self) -> std::option::Option<&std::boxed::Box<wkt::Duration>> {
        #[allow(unreachable_patterns)]
        self.expiration.as_ref().and_then(|v| match v {
            crate::model::conversation::Expiration::Ttl(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [expiration][crate::model::Conversation::expiration]
    /// to hold a `Ttl`.
    ///
    /// Note that all the setters affecting `expiration` are
    /// mutually exclusive.
    pub fn set_ttl<T: std::convert::Into<std::boxed::Box<wkt::Duration>>>(mut self, v: T) -> Self {
        self.expiration =
            std::option::Option::Some(crate::model::conversation::Expiration::Ttl(v.into()));
        self
    }
}

impl wkt::message::Message for Conversation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.Conversation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Conversation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __call_metadata,
            __expire_time,
            __ttl,
            __name,
            __data_source,
            __create_time,
            __update_time,
            __start_time,
            __language_code,
            __agent_id,
            __labels,
            __quality_metadata,
            __metadata_json,
            __transcript,
            __medium,
            __duration,
            __turn_count,
            __latest_analysis,
            __latest_summary,
            __runtime_annotations,
            __dialogflow_intents,
            __obfuscated_user_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Conversation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "callMetadata" => Ok(__FieldTag::__call_metadata),
                            "call_metadata" => Ok(__FieldTag::__call_metadata),
                            "expireTime" => Ok(__FieldTag::__expire_time),
                            "expire_time" => Ok(__FieldTag::__expire_time),
                            "ttl" => Ok(__FieldTag::__ttl),
                            "name" => Ok(__FieldTag::__name),
                            "dataSource" => Ok(__FieldTag::__data_source),
                            "data_source" => Ok(__FieldTag::__data_source),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "agentId" => Ok(__FieldTag::__agent_id),
                            "agent_id" => Ok(__FieldTag::__agent_id),
                            "labels" => Ok(__FieldTag::__labels),
                            "qualityMetadata" => Ok(__FieldTag::__quality_metadata),
                            "quality_metadata" => Ok(__FieldTag::__quality_metadata),
                            "metadataJson" => Ok(__FieldTag::__metadata_json),
                            "metadata_json" => Ok(__FieldTag::__metadata_json),
                            "transcript" => Ok(__FieldTag::__transcript),
                            "medium" => Ok(__FieldTag::__medium),
                            "duration" => Ok(__FieldTag::__duration),
                            "turnCount" => Ok(__FieldTag::__turn_count),
                            "turn_count" => Ok(__FieldTag::__turn_count),
                            "latestAnalysis" => Ok(__FieldTag::__latest_analysis),
                            "latest_analysis" => Ok(__FieldTag::__latest_analysis),
                            "latestSummary" => Ok(__FieldTag::__latest_summary),
                            "latest_summary" => Ok(__FieldTag::__latest_summary),
                            "runtimeAnnotations" => Ok(__FieldTag::__runtime_annotations),
                            "runtime_annotations" => Ok(__FieldTag::__runtime_annotations),
                            "dialogflowIntents" => Ok(__FieldTag::__dialogflow_intents),
                            "dialogflow_intents" => Ok(__FieldTag::__dialogflow_intents),
                            "obfuscatedUserId" => Ok(__FieldTag::__obfuscated_user_id),
                            "obfuscated_user_id" => Ok(__FieldTag::__obfuscated_user_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Conversation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Conversation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__call_metadata => {
                            if !fields.insert(__FieldTag::__call_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for call_metadata",
                                ));
                            }
                            if result.metadata.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `metadata`, a oneof with full ID .google.cloud.contactcenterinsights.v1.Conversation.call_metadata, latest field was callMetadata",
                                ));
                            }
                            result.metadata = std::option::Option::Some(
                                crate::model::conversation::Metadata::CallMetadata(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::conversation::CallMetadata>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__expire_time => {
                            if !fields.insert(__FieldTag::__expire_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expire_time",
                                ));
                            }
                            if result.expiration.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `expiration`, a oneof with full ID .google.cloud.contactcenterinsights.v1.Conversation.expire_time, latest field was expireTime",
                                ));
                            }
                            result.expiration = std::option::Option::Some(
                                crate::model::conversation::Expiration::ExpireTime(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Timestamp>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__ttl => {
                            if !fields.insert(__FieldTag::__ttl) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ttl",
                                ));
                            }
                            if result.expiration.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `expiration`, a oneof with full ID .google.cloud.contactcenterinsights.v1.Conversation.ttl, latest field was ttl",
                                ));
                            }
                            result.expiration = std::option::Option::Some(
                                crate::model::conversation::Expiration::Ttl(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Duration>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_source => {
                            if !fields.insert(__FieldTag::__data_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_source",
                                ));
                            }
                            result.data_source = map.next_value::<std::option::Option<crate::model::ConversationDataSource>>()?
                                ;
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__agent_id => {
                            if !fields.insert(__FieldTag::__agent_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for agent_id",
                                ));
                            }
                            result.agent_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__quality_metadata => {
                            if !fields.insert(__FieldTag::__quality_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for quality_metadata",
                                ));
                            }
                            result.quality_metadata =
                                map.next_value::<std::option::Option<
                                    crate::model::conversation::QualityMetadata,
                                >>()?;
                        }
                        __FieldTag::__metadata_json => {
                            if !fields.insert(__FieldTag::__metadata_json) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata_json",
                                ));
                            }
                            result.metadata_json = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__transcript => {
                            if !fields.insert(__FieldTag::__transcript) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transcript",
                                ));
                            }
                            result.transcript = map.next_value::<std::option::Option<crate::model::conversation::Transcript>>()?
                                ;
                        }
                        __FieldTag::__medium => {
                            if !fields.insert(__FieldTag::__medium) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for medium",
                                ));
                            }
                            result.medium = map.next_value::<std::option::Option<crate::model::conversation::Medium>>()?.unwrap_or_default();
                        }
                        __FieldTag::__duration => {
                            if !fields.insert(__FieldTag::__duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for duration",
                                ));
                            }
                            result.duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__turn_count => {
                            if !fields.insert(__FieldTag::__turn_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for turn_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.turn_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__latest_analysis => {
                            if !fields.insert(__FieldTag::__latest_analysis) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for latest_analysis",
                                ));
                            }
                            result.latest_analysis =
                                map.next_value::<std::option::Option<crate::model::Analysis>>()?;
                        }
                        __FieldTag::__latest_summary => {
                            if !fields.insert(__FieldTag::__latest_summary) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for latest_summary",
                                ));
                            }
                            result.latest_summary = map.next_value::<std::option::Option<
                                crate::model::ConversationSummarizationSuggestionData,
                            >>()?;
                        }
                        __FieldTag::__runtime_annotations => {
                            if !fields.insert(__FieldTag::__runtime_annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for runtime_annotations",
                                ));
                            }
                            result.runtime_annotations =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::RuntimeAnnotation>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dialogflow_intents => {
                            if !fields.insert(__FieldTag::__dialogflow_intents) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dialogflow_intents",
                                ));
                            }
                            result.dialogflow_intents = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::DialogflowIntent,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__obfuscated_user_id => {
                            if !fields.insert(__FieldTag::__obfuscated_user_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for obfuscated_user_id",
                                ));
                            }
                            result.obfuscated_user_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Conversation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.call_metadata() {
            state.serialize_entry("callMetadata", value)?;
        }
        if let Some(value) = self.expire_time() {
            state.serialize_entry("expireTime", value)?;
        }
        if let Some(value) = self.ttl() {
            state.serialize_entry("ttl", value)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.data_source.is_some() {
            state.serialize_entry("dataSource", &self.data_source)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self.agent_id.is_empty() {
            state.serialize_entry("agentId", &self.agent_id)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.quality_metadata.is_some() {
            state.serialize_entry("qualityMetadata", &self.quality_metadata)?;
        }
        if !self.metadata_json.is_empty() {
            state.serialize_entry("metadataJson", &self.metadata_json)?;
        }
        if self.transcript.is_some() {
            state.serialize_entry("transcript", &self.transcript)?;
        }
        if !wkt::internal::is_default(&self.medium) {
            state.serialize_entry("medium", &self.medium)?;
        }
        if self.duration.is_some() {
            state.serialize_entry("duration", &self.duration)?;
        }
        if !wkt::internal::is_default(&self.turn_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("turnCount", &__With(&self.turn_count))?;
        }
        if self.latest_analysis.is_some() {
            state.serialize_entry("latestAnalysis", &self.latest_analysis)?;
        }
        if self.latest_summary.is_some() {
            state.serialize_entry("latestSummary", &self.latest_summary)?;
        }
        if !self.runtime_annotations.is_empty() {
            state.serialize_entry("runtimeAnnotations", &self.runtime_annotations)?;
        }
        if !self.dialogflow_intents.is_empty() {
            state.serialize_entry("dialogflowIntents", &self.dialogflow_intents)?;
        }
        if !self.obfuscated_user_id.is_empty() {
            state.serialize_entry("obfuscatedUserId", &self.obfuscated_user_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Conversation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Conversation");
        debug_struct.field("name", &self.name);
        debug_struct.field("data_source", &self.data_source);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("language_code", &self.language_code);
        debug_struct.field("agent_id", &self.agent_id);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("quality_metadata", &self.quality_metadata);
        debug_struct.field("metadata_json", &self.metadata_json);
        debug_struct.field("transcript", &self.transcript);
        debug_struct.field("medium", &self.medium);
        debug_struct.field("duration", &self.duration);
        debug_struct.field("turn_count", &self.turn_count);
        debug_struct.field("latest_analysis", &self.latest_analysis);
        debug_struct.field("latest_summary", &self.latest_summary);
        debug_struct.field("runtime_annotations", &self.runtime_annotations);
        debug_struct.field("dialogflow_intents", &self.dialogflow_intents);
        debug_struct.field("obfuscated_user_id", &self.obfuscated_user_id);
        debug_struct.field("metadata", &self.metadata);
        debug_struct.field("expiration", &self.expiration);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Conversation].
pub mod conversation {
    #[allow(unused_imports)]
    use super::*;

    /// Call-specific metadata.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CallMetadata {
        /// The audio channel that contains the customer.
        pub customer_channel: i32,

        /// The audio channel that contains the agent.
        pub agent_channel: i32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CallMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [customer_channel][crate::model::conversation::CallMetadata::customer_channel].
        pub fn set_customer_channel<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.customer_channel = v.into();
            self
        }

        /// Sets the value of [agent_channel][crate::model::conversation::CallMetadata::agent_channel].
        pub fn set_agent_channel<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.agent_channel = v.into();
            self
        }
    }

    impl wkt::message::Message for CallMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.Conversation.CallMetadata"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for CallMetadata {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __customer_channel,
                __agent_channel,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for CallMetadata")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "customerChannel" => Ok(__FieldTag::__customer_channel),
                                "customer_channel" => Ok(__FieldTag::__customer_channel),
                                "agentChannel" => Ok(__FieldTag::__agent_channel),
                                "agent_channel" => Ok(__FieldTag::__agent_channel),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = CallMetadata;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct CallMetadata")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__customer_channel => {
                                if !fields.insert(__FieldTag::__customer_channel) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for customer_channel",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.customer_channel =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__agent_channel => {
                                if !fields.insert(__FieldTag::__agent_channel) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for agent_channel",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.agent_channel =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for CallMetadata {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.customer_channel) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("customerChannel", &__With(&self.customer_channel))?;
            }
            if !wkt::internal::is_default(&self.agent_channel) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("agentChannel", &__With(&self.agent_channel))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for CallMetadata {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("CallMetadata");
            debug_struct.field("customer_channel", &self.customer_channel);
            debug_struct.field("agent_channel", &self.agent_channel);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Conversation metadata related to quality management.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct QualityMetadata {
        /// An arbitrary integer value indicating the customer's satisfaction rating.
        pub customer_satisfaction_rating: i32,

        /// The amount of time the customer waited to connect with an agent.
        pub wait_duration: std::option::Option<wkt::Duration>,

        /// An arbitrary string value specifying the menu path the customer took.
        pub menu_path: std::string::String,

        /// Information about agents involved in the call.
        pub agent_info: std::vec::Vec<crate::model::conversation::quality_metadata::AgentInfo>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl QualityMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [customer_satisfaction_rating][crate::model::conversation::QualityMetadata::customer_satisfaction_rating].
        pub fn set_customer_satisfaction_rating<T: std::convert::Into<i32>>(
            mut self,
            v: T,
        ) -> Self {
            self.customer_satisfaction_rating = v.into();
            self
        }

        /// Sets the value of [wait_duration][crate::model::conversation::QualityMetadata::wait_duration].
        pub fn set_wait_duration<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.wait_duration = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [wait_duration][crate::model::conversation::QualityMetadata::wait_duration].
        pub fn set_or_clear_wait_duration<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.wait_duration = v.map(|x| x.into());
            self
        }

        /// Sets the value of [menu_path][crate::model::conversation::QualityMetadata::menu_path].
        pub fn set_menu_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.menu_path = v.into();
            self
        }

        /// Sets the value of [agent_info][crate::model::conversation::QualityMetadata::agent_info].
        pub fn set_agent_info<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::conversation::quality_metadata::AgentInfo>,
        {
            use std::iter::Iterator;
            self.agent_info = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for QualityMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.Conversation.QualityMetadata"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for QualityMetadata {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __customer_satisfaction_rating,
                __wait_duration,
                __menu_path,
                __agent_info,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for QualityMetadata")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "customerSatisfactionRating" => {
                                    Ok(__FieldTag::__customer_satisfaction_rating)
                                }
                                "customer_satisfaction_rating" => {
                                    Ok(__FieldTag::__customer_satisfaction_rating)
                                }
                                "waitDuration" => Ok(__FieldTag::__wait_duration),
                                "wait_duration" => Ok(__FieldTag::__wait_duration),
                                "menuPath" => Ok(__FieldTag::__menu_path),
                                "menu_path" => Ok(__FieldTag::__menu_path),
                                "agentInfo" => Ok(__FieldTag::__agent_info),
                                "agent_info" => Ok(__FieldTag::__agent_info),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = QualityMetadata;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct QualityMetadata")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__customer_satisfaction_rating => {
                                if !fields.insert(__FieldTag::__customer_satisfaction_rating) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for customer_satisfaction_rating",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.customer_satisfaction_rating =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__wait_duration => {
                                if !fields.insert(__FieldTag::__wait_duration) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for wait_duration",
                                    ));
                                }
                                result.wait_duration =
                                    map.next_value::<std::option::Option<wkt::Duration>>()?;
                            }
                            __FieldTag::__menu_path => {
                                if !fields.insert(__FieldTag::__menu_path) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for menu_path",
                                    ));
                                }
                                result.menu_path = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__agent_info => {
                                if !fields.insert(__FieldTag::__agent_info) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for agent_info",
                                    ));
                                }
                                result.agent_info = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<
                                            crate::model::conversation::quality_metadata::AgentInfo,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for QualityMetadata {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.customer_satisfaction_rating) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "customerSatisfactionRating",
                    &__With(&self.customer_satisfaction_rating),
                )?;
            }
            if self.wait_duration.is_some() {
                state.serialize_entry("waitDuration", &self.wait_duration)?;
            }
            if !self.menu_path.is_empty() {
                state.serialize_entry("menuPath", &self.menu_path)?;
            }
            if !self.agent_info.is_empty() {
                state.serialize_entry("agentInfo", &self.agent_info)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for QualityMetadata {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("QualityMetadata");
            debug_struct.field(
                "customer_satisfaction_rating",
                &self.customer_satisfaction_rating,
            );
            debug_struct.field("wait_duration", &self.wait_duration);
            debug_struct.field("menu_path", &self.menu_path);
            debug_struct.field("agent_info", &self.agent_info);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [QualityMetadata].
    pub mod quality_metadata {
        #[allow(unused_imports)]
        use super::*;

        /// Information about an agent involved in the conversation.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct AgentInfo {
            /// A user-specified string representing the agent.
            pub agent_id: std::string::String,

            /// The agent's name.
            pub display_name: std::string::String,

            /// A user-specified string representing the agent's team.
            pub team: std::string::String,

            /// A user-provided string indicating the outcome of the agent's segment of
            /// the call.
            pub disposition_code: std::string::String,

            /// The agent type, e.g. HUMAN_AGENT.
            pub agent_type: crate::model::conversation_participant::Role,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl AgentInfo {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [agent_id][crate::model::conversation::quality_metadata::AgentInfo::agent_id].
            pub fn set_agent_id<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.agent_id = v.into();
                self
            }

            /// Sets the value of [display_name][crate::model::conversation::quality_metadata::AgentInfo::display_name].
            pub fn set_display_name<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.display_name = v.into();
                self
            }

            /// Sets the value of [team][crate::model::conversation::quality_metadata::AgentInfo::team].
            pub fn set_team<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.team = v.into();
                self
            }

            /// Sets the value of [disposition_code][crate::model::conversation::quality_metadata::AgentInfo::disposition_code].
            pub fn set_disposition_code<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.disposition_code = v.into();
                self
            }

            /// Sets the value of [agent_type][crate::model::conversation::quality_metadata::AgentInfo::agent_type].
            pub fn set_agent_type<
                T: std::convert::Into<crate::model::conversation_participant::Role>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.agent_type = v.into();
                self
            }
        }

        impl wkt::message::Message for AgentInfo {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.contactcenterinsights.v1.Conversation.QualityMetadata.AgentInfo"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for AgentInfo {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __agent_id,
                    __display_name,
                    __team,
                    __disposition_code,
                    __agent_type,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for AgentInfo")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "agentId" => Ok(__FieldTag::__agent_id),
                                    "agent_id" => Ok(__FieldTag::__agent_id),
                                    "displayName" => Ok(__FieldTag::__display_name),
                                    "display_name" => Ok(__FieldTag::__display_name),
                                    "team" => Ok(__FieldTag::__team),
                                    "dispositionCode" => Ok(__FieldTag::__disposition_code),
                                    "disposition_code" => Ok(__FieldTag::__disposition_code),
                                    "agentType" => Ok(__FieldTag::__agent_type),
                                    "agent_type" => Ok(__FieldTag::__agent_type),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = AgentInfo;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct AgentInfo")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__agent_id => {
                                    if !fields.insert(__FieldTag::__agent_id) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for agent_id",
                                            ),
                                        );
                                    }
                                    result.agent_id = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__display_name => {
                                    if !fields.insert(__FieldTag::__display_name) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for display_name",
                                            ),
                                        );
                                    }
                                    result.display_name = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__team => {
                                    if !fields.insert(__FieldTag::__team) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for team"),
                                        );
                                    }
                                    result.team = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__disposition_code => {
                                    if !fields.insert(__FieldTag::__disposition_code) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for disposition_code",
                                            ),
                                        );
                                    }
                                    result.disposition_code = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__agent_type => {
                                    if !fields.insert(__FieldTag::__agent_type) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for agent_type",
                                            ),
                                        );
                                    }
                                    result.agent_type = map
                                        .next_value::<std::option::Option<
                                            crate::model::conversation_participant::Role,
                                        >>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for AgentInfo {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.agent_id.is_empty() {
                    state.serialize_entry("agentId", &self.agent_id)?;
                }
                if !self.display_name.is_empty() {
                    state.serialize_entry("displayName", &self.display_name)?;
                }
                if !self.team.is_empty() {
                    state.serialize_entry("team", &self.team)?;
                }
                if !self.disposition_code.is_empty() {
                    state.serialize_entry("dispositionCode", &self.disposition_code)?;
                }
                if !wkt::internal::is_default(&self.agent_type) {
                    state.serialize_entry("agentType", &self.agent_type)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for AgentInfo {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("AgentInfo");
                debug_struct.field("agent_id", &self.agent_id);
                debug_struct.field("display_name", &self.display_name);
                debug_struct.field("team", &self.team);
                debug_struct.field("disposition_code", &self.disposition_code);
                debug_struct.field("agent_type", &self.agent_type);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }
    }

    /// A message representing the transcript of a conversation.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Transcript {
        /// A list of sequential transcript segments that comprise the conversation.
        pub transcript_segments:
            std::vec::Vec<crate::model::conversation::transcript::TranscriptSegment>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Transcript {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [transcript_segments][crate::model::conversation::Transcript::transcript_segments].
        pub fn set_transcript_segments<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::conversation::transcript::TranscriptSegment>,
        {
            use std::iter::Iterator;
            self.transcript_segments = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Transcript {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.Conversation.Transcript"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Transcript {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __transcript_segments,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Transcript")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "transcriptSegments" => Ok(__FieldTag::__transcript_segments),
                                "transcript_segments" => Ok(__FieldTag::__transcript_segments),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Transcript;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Transcript")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__transcript_segments => {
                                if !fields.insert(__FieldTag::__transcript_segments) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for transcript_segments",
                                    ));
                                }
                                result.transcript_segments = map.next_value::<std::option::Option<std::vec::Vec<crate::model::conversation::transcript::TranscriptSegment>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Transcript {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.transcript_segments.is_empty() {
                state.serialize_entry("transcriptSegments", &self.transcript_segments)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Transcript {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Transcript");
            debug_struct.field("transcript_segments", &self.transcript_segments);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [Transcript].
    pub mod transcript {
        #[allow(unused_imports)]
        use super::*;

        /// A segment of a full transcript.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct TranscriptSegment {

            /// The time that the message occurred, if provided.
            pub message_time: std::option::Option<wkt::Timestamp>,

            /// The text of this segment.
            pub text: std::string::String,

            /// A confidence estimate between 0.0 and 1.0 of the fidelity of this
            /// segment. A default value of 0.0 indicates that the value is unset.
            pub confidence: f32,

            /// A list of the word-specific information for each word in the segment.
            pub words: std::vec::Vec<crate::model::conversation::transcript::transcript_segment::WordInfo>,

            /// The language code of this segment as a
            /// [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt) language tag.
            /// Example: "en-US".
            pub language_code: std::string::String,

            /// For conversations derived from multi-channel audio, this is the channel
            /// number corresponding to the audio from that channel. For
            /// audioChannelCount = N, its output values can range from '1' to 'N'. A
            /// channel tag of 0 indicates that the audio is mono.
            pub channel_tag: i32,

            /// The participant of this segment.
            pub segment_participant: std::option::Option<crate::model::ConversationParticipant>,

            /// CCAI metadata relating to the current transcript segment.
            pub dialogflow_segment_metadata: std::option::Option<crate::model::conversation::transcript::transcript_segment::DialogflowSegmentMetadata>,

            /// The sentiment for this transcript segment.
            pub sentiment: std::option::Option<crate::model::SentimentData>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl TranscriptSegment {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [message_time][crate::model::conversation::transcript::TranscriptSegment::message_time].
            pub fn set_message_time<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::Timestamp>,
            {
                self.message_time = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [message_time][crate::model::conversation::transcript::TranscriptSegment::message_time].
            pub fn set_or_clear_message_time<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::Timestamp>,
            {
                self.message_time = v.map(|x| x.into());
                self
            }

            /// Sets the value of [text][crate::model::conversation::transcript::TranscriptSegment::text].
            pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.text = v.into();
                self
            }

            /// Sets the value of [confidence][crate::model::conversation::transcript::TranscriptSegment::confidence].
            pub fn set_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
                self.confidence = v.into();
                self
            }

            /// Sets the value of [words][crate::model::conversation::transcript::TranscriptSegment::words].
            pub fn set_words<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<
                        crate::model::conversation::transcript::transcript_segment::WordInfo,
                    >,
            {
                use std::iter::Iterator;
                self.words = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [language_code][crate::model::conversation::transcript::TranscriptSegment::language_code].
            pub fn set_language_code<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.language_code = v.into();
                self
            }

            /// Sets the value of [channel_tag][crate::model::conversation::transcript::TranscriptSegment::channel_tag].
            pub fn set_channel_tag<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.channel_tag = v.into();
                self
            }

            /// Sets the value of [segment_participant][crate::model::conversation::transcript::TranscriptSegment::segment_participant].
            pub fn set_segment_participant<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::ConversationParticipant>,
            {
                self.segment_participant = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [segment_participant][crate::model::conversation::transcript::TranscriptSegment::segment_participant].
            pub fn set_or_clear_segment_participant<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::ConversationParticipant>,
            {
                self.segment_participant = v.map(|x| x.into());
                self
            }

            /// Sets the value of [dialogflow_segment_metadata][crate::model::conversation::transcript::TranscriptSegment::dialogflow_segment_metadata].
            pub fn set_dialogflow_segment_metadata<T>(mut self, v: T) -> Self
            where T: std::convert::Into<crate::model::conversation::transcript::transcript_segment::DialogflowSegmentMetadata>
            {
                self.dialogflow_segment_metadata = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [dialogflow_segment_metadata][crate::model::conversation::transcript::TranscriptSegment::dialogflow_segment_metadata].
            pub fn set_or_clear_dialogflow_segment_metadata<T>(mut self, v: std::option::Option<T>) -> Self
            where T: std::convert::Into<crate::model::conversation::transcript::transcript_segment::DialogflowSegmentMetadata>
            {
                self.dialogflow_segment_metadata = v.map(|x| x.into());
                self
            }

            /// Sets the value of [sentiment][crate::model::conversation::transcript::TranscriptSegment::sentiment].
            pub fn set_sentiment<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::SentimentData>,
            {
                self.sentiment = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [sentiment][crate::model::conversation::transcript::TranscriptSegment::sentiment].
            pub fn set_or_clear_sentiment<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::SentimentData>,
            {
                self.sentiment = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for TranscriptSegment {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.contactcenterinsights.v1.Conversation.Transcript.TranscriptSegment"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for TranscriptSegment {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __message_time,
                    __text,
                    __confidence,
                    __words,
                    __language_code,
                    __channel_tag,
                    __segment_participant,
                    __dialogflow_segment_metadata,
                    __sentiment,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for TranscriptSegment")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "messageTime" => Ok(__FieldTag::__message_time),
                                    "message_time" => Ok(__FieldTag::__message_time),
                                    "text" => Ok(__FieldTag::__text),
                                    "confidence" => Ok(__FieldTag::__confidence),
                                    "words" => Ok(__FieldTag::__words),
                                    "languageCode" => Ok(__FieldTag::__language_code),
                                    "language_code" => Ok(__FieldTag::__language_code),
                                    "channelTag" => Ok(__FieldTag::__channel_tag),
                                    "channel_tag" => Ok(__FieldTag::__channel_tag),
                                    "segmentParticipant" => Ok(__FieldTag::__segment_participant),
                                    "segment_participant" => Ok(__FieldTag::__segment_participant),
                                    "dialogflowSegmentMetadata" => {
                                        Ok(__FieldTag::__dialogflow_segment_metadata)
                                    }
                                    "dialogflow_segment_metadata" => {
                                        Ok(__FieldTag::__dialogflow_segment_metadata)
                                    }
                                    "sentiment" => Ok(__FieldTag::__sentiment),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = TranscriptSegment;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct TranscriptSegment")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__message_time => {
                                    if !fields.insert(__FieldTag::__message_time) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for message_time",
                                            ),
                                        );
                                    }
                                    result.message_time =
                                        map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                                }
                                __FieldTag::__text => {
                                    if !fields.insert(__FieldTag::__text) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for text"),
                                        );
                                    }
                                    result.text = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__confidence => {
                                    if !fields.insert(__FieldTag::__confidence) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for confidence",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<f32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.confidence =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__words => {
                                    if !fields.insert(__FieldTag::__words) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for words"),
                                        );
                                    }
                                    result.words = map.next_value::<std::option::Option<std::vec::Vec<crate::model::conversation::transcript::transcript_segment::WordInfo>>>()?.unwrap_or_default();
                                }
                                __FieldTag::__language_code => {
                                    if !fields.insert(__FieldTag::__language_code) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for language_code",
                                            ),
                                        );
                                    }
                                    result.language_code = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__channel_tag => {
                                    if !fields.insert(__FieldTag::__channel_tag) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for channel_tag",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.channel_tag =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__segment_participant => {
                                    if !fields.insert(__FieldTag::__segment_participant) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for segment_participant",
                                            ),
                                        );
                                    }
                                    result.segment_participant = map
                                        .next_value::<std::option::Option<
                                            crate::model::ConversationParticipant,
                                        >>()?;
                                }
                                __FieldTag::__dialogflow_segment_metadata => {
                                    if !fields.insert(__FieldTag::__dialogflow_segment_metadata) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for dialogflow_segment_metadata",
                                            ),
                                        );
                                    }
                                    result.dialogflow_segment_metadata = map.next_value::<std::option::Option<crate::model::conversation::transcript::transcript_segment::DialogflowSegmentMetadata>>()?
                                        ;
                                }
                                __FieldTag::__sentiment => {
                                    if !fields.insert(__FieldTag::__sentiment) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for sentiment",
                                            ),
                                        );
                                    }
                                    result.sentiment = map.next_value::<std::option::Option<crate::model::SentimentData>>()?
                                        ;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for TranscriptSegment {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if self.message_time.is_some() {
                    state.serialize_entry("messageTime", &self.message_time)?;
                }
                if !self.text.is_empty() {
                    state.serialize_entry("text", &self.text)?;
                }
                if !wkt::internal::is_default(&self.confidence) {
                    struct __With<'a>(&'a f32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("confidence", &__With(&self.confidence))?;
                }
                if !self.words.is_empty() {
                    state.serialize_entry("words", &self.words)?;
                }
                if !self.language_code.is_empty() {
                    state.serialize_entry("languageCode", &self.language_code)?;
                }
                if !wkt::internal::is_default(&self.channel_tag) {
                    struct __With<'a>(&'a i32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("channelTag", &__With(&self.channel_tag))?;
                }
                if self.segment_participant.is_some() {
                    state.serialize_entry("segmentParticipant", &self.segment_participant)?;
                }
                if self.dialogflow_segment_metadata.is_some() {
                    state.serialize_entry(
                        "dialogflowSegmentMetadata",
                        &self.dialogflow_segment_metadata,
                    )?;
                }
                if self.sentiment.is_some() {
                    state.serialize_entry("sentiment", &self.sentiment)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for TranscriptSegment {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("TranscriptSegment");
                debug_struct.field("message_time", &self.message_time);
                debug_struct.field("text", &self.text);
                debug_struct.field("confidence", &self.confidence);
                debug_struct.field("words", &self.words);
                debug_struct.field("language_code", &self.language_code);
                debug_struct.field("channel_tag", &self.channel_tag);
                debug_struct.field("segment_participant", &self.segment_participant);
                debug_struct.field(
                    "dialogflow_segment_metadata",
                    &self.dialogflow_segment_metadata,
                );
                debug_struct.field("sentiment", &self.sentiment);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// Defines additional types related to [TranscriptSegment].
        pub mod transcript_segment {
            #[allow(unused_imports)]
            use super::*;

            /// Word-level info for words in a transcript.
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct WordInfo {
                /// Time offset of the start of this word relative to the beginning of
                /// the total conversation.
                pub start_offset: std::option::Option<wkt::Duration>,

                /// Time offset of the end of this word relative to the beginning of the
                /// total conversation.
                pub end_offset: std::option::Option<wkt::Duration>,

                /// The word itself. Includes punctuation marks that surround the word.
                pub word: std::string::String,

                /// A confidence estimate between 0.0 and 1.0 of the fidelity of this
                /// word. A default value of 0.0 indicates that the value is unset.
                pub confidence: f32,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl WordInfo {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [start_offset][crate::model::conversation::transcript::transcript_segment::WordInfo::start_offset].
                pub fn set_start_offset<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<wkt::Duration>,
                {
                    self.start_offset = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [start_offset][crate::model::conversation::transcript::transcript_segment::WordInfo::start_offset].
                pub fn set_or_clear_start_offset<T>(mut self, v: std::option::Option<T>) -> Self
                where
                    T: std::convert::Into<wkt::Duration>,
                {
                    self.start_offset = v.map(|x| x.into());
                    self
                }

                /// Sets the value of [end_offset][crate::model::conversation::transcript::transcript_segment::WordInfo::end_offset].
                pub fn set_end_offset<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<wkt::Duration>,
                {
                    self.end_offset = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [end_offset][crate::model::conversation::transcript::transcript_segment::WordInfo::end_offset].
                pub fn set_or_clear_end_offset<T>(mut self, v: std::option::Option<T>) -> Self
                where
                    T: std::convert::Into<wkt::Duration>,
                {
                    self.end_offset = v.map(|x| x.into());
                    self
                }

                /// Sets the value of [word][crate::model::conversation::transcript::transcript_segment::WordInfo::word].
                pub fn set_word<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.word = v.into();
                    self
                }

                /// Sets the value of [confidence][crate::model::conversation::transcript::transcript_segment::WordInfo::confidence].
                pub fn set_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
                    self.confidence = v.into();
                    self
                }
            }

            impl wkt::message::Message for WordInfo {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.contactcenterinsights.v1.Conversation.Transcript.TranscriptSegment.WordInfo"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for WordInfo {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __start_offset,
                        __end_offset,
                        __word,
                        __confidence,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for WordInfo")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "startOffset" => Ok(__FieldTag::__start_offset),
                                        "start_offset" => Ok(__FieldTag::__start_offset),
                                        "endOffset" => Ok(__FieldTag::__end_offset),
                                        "end_offset" => Ok(__FieldTag::__end_offset),
                                        "word" => Ok(__FieldTag::__word),
                                        "confidence" => Ok(__FieldTag::__confidence),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = WordInfo;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct WordInfo")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__start_offset => {
                                        if !fields.insert(__FieldTag::__start_offset) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for start_offset",
                                                ),
                                            );
                                        }
                                        result.start_offset =
                                            map.next_value::<std::option::Option<wkt::Duration>>()?;
                                    }
                                    __FieldTag::__end_offset => {
                                        if !fields.insert(__FieldTag::__end_offset) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for end_offset",
                                                ),
                                            );
                                        }
                                        result.end_offset =
                                            map.next_value::<std::option::Option<wkt::Duration>>()?;
                                    }
                                    __FieldTag::__word => {
                                        if !fields.insert(__FieldTag::__word) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for word",
                                                ),
                                            );
                                        }
                                        result.word = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__confidence => {
                                        if !fields.insert(__FieldTag::__confidence) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for confidence",
                                                ),
                                            );
                                        }
                                        struct __With(std::option::Option<f32>);
                                        impl<'de> serde::de::Deserialize<'de> for __With {
                                            fn deserialize<D>(
                                                deserializer: D,
                                            ) -> std::result::Result<Self, D::Error>
                                            where
                                                D: serde::de::Deserializer<'de>,
                                            {
                                                serde_with::As::<
                                                    std::option::Option<wkt::internal::F32>,
                                                >::deserialize(
                                                    deserializer
                                                )
                                                .map(__With)
                                            }
                                        }
                                        result.confidence =
                                            map.next_value::<__With>()?.0.unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for WordInfo {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if self.start_offset.is_some() {
                        state.serialize_entry("startOffset", &self.start_offset)?;
                    }
                    if self.end_offset.is_some() {
                        state.serialize_entry("endOffset", &self.end_offset)?;
                    }
                    if !self.word.is_empty() {
                        state.serialize_entry("word", &self.word)?;
                    }
                    if !wkt::internal::is_default(&self.confidence) {
                        struct __With<'a>(&'a f32);
                        impl<'a> serde::ser::Serialize for __With<'a> {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::ser::Serializer,
                            {
                                serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                            }
                        }
                        state.serialize_entry("confidence", &__With(&self.confidence))?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            impl std::fmt::Debug for WordInfo {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    let mut debug_struct = f.debug_struct("WordInfo");
                    debug_struct.field("start_offset", &self.start_offset);
                    debug_struct.field("end_offset", &self.end_offset);
                    debug_struct.field("word", &self.word);
                    debug_struct.field("confidence", &self.confidence);
                    if !self._unknown_fields.is_empty() {
                        debug_struct.field("_unknown_fields", &self._unknown_fields);
                    }
                    debug_struct.finish()
                }
            }

            /// Metadata from Dialogflow relating to the current transcript segment.
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct DialogflowSegmentMetadata {
                /// Whether the transcript segment was covered under the configured smart
                /// reply allowlist in Agent Assist.
                pub smart_reply_allowlist_covered: bool,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl DialogflowSegmentMetadata {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [smart_reply_allowlist_covered][crate::model::conversation::transcript::transcript_segment::DialogflowSegmentMetadata::smart_reply_allowlist_covered].
                pub fn set_smart_reply_allowlist_covered<T: std::convert::Into<bool>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.smart_reply_allowlist_covered = v.into();
                    self
                }
            }

            impl wkt::message::Message for DialogflowSegmentMetadata {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.contactcenterinsights.v1.Conversation.Transcript.TranscriptSegment.DialogflowSegmentMetadata"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for DialogflowSegmentMetadata {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __smart_reply_allowlist_covered,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter
                                        .write_str("a field name for DialogflowSegmentMetadata")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "smartReplyAllowlistCovered" => {
                                            Ok(__FieldTag::__smart_reply_allowlist_covered)
                                        }
                                        "smart_reply_allowlist_covered" => {
                                            Ok(__FieldTag::__smart_reply_allowlist_covered)
                                        }
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = DialogflowSegmentMetadata;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct DialogflowSegmentMetadata")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__smart_reply_allowlist_covered => {
                                        if !fields
                                            .insert(__FieldTag::__smart_reply_allowlist_covered)
                                        {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for smart_reply_allowlist_covered",
                                                ),
                                            );
                                        }
                                        result.smart_reply_allowlist_covered = map
                                            .next_value::<std::option::Option<bool>>()?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for DialogflowSegmentMetadata {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !wkt::internal::is_default(&self.smart_reply_allowlist_covered) {
                        state.serialize_entry(
                            "smartReplyAllowlistCovered",
                            &self.smart_reply_allowlist_covered,
                        )?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            impl std::fmt::Debug for DialogflowSegmentMetadata {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    let mut debug_struct = f.debug_struct("DialogflowSegmentMetadata");
                    debug_struct.field(
                        "smart_reply_allowlist_covered",
                        &self.smart_reply_allowlist_covered,
                    );
                    if !self._unknown_fields.is_empty() {
                        debug_struct.field("_unknown_fields", &self._unknown_fields);
                    }
                    debug_struct.finish()
                }
            }
        }
    }

    /// Possible media for the conversation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Medium {
        /// Default value, if unspecified will default to PHONE_CALL.
        Unspecified,
        /// The format for conversations that took place over the phone.
        PhoneCall,
        /// The format for conversations that took place over chat.
        Chat,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Medium::value] or
        /// [Medium::name].
        UnknownValue(medium::UnknownValue),
    }

    #[doc(hidden)]
    pub mod medium {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Medium {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::PhoneCall => std::option::Option::Some(1),
                Self::Chat => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MEDIUM_UNSPECIFIED"),
                Self::PhoneCall => std::option::Option::Some("PHONE_CALL"),
                Self::Chat => std::option::Option::Some("CHAT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Medium {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Medium {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Medium {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::PhoneCall,
                2 => Self::Chat,
                _ => Self::UnknownValue(medium::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Medium {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MEDIUM_UNSPECIFIED" => Self::Unspecified,
                "PHONE_CALL" => Self::PhoneCall,
                "CHAT" => Self::Chat,
                _ => Self::UnknownValue(medium::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Medium {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::PhoneCall => serializer.serialize_i32(1),
                Self::Chat => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Medium {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Medium>::new(
                ".google.cloud.contactcenterinsights.v1.Conversation.Medium",
            ))
        }
    }

    /// Metadata that applies to the conversation.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Metadata {
        /// Call-specific metadata.
        CallMetadata(std::boxed::Box<crate::model::conversation::CallMetadata>),
    }

    /// A time to live expiration setting, can be either a specified timestamp or a
    /// duration from the time that the conversation creation request was received.
    /// Conversations with an expiration set will be removed up to 24 hours after
    /// the specified time.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Expiration {
        /// The time at which this conversation should expire. After this time, the
        /// conversation data and any associated analyses will be deleted.
        ExpireTime(std::boxed::Box<wkt::Timestamp>),
        /// Input only. The TTL for this resource. If specified, then this TTL will
        /// be used to calculate the expire time.
        Ttl(std::boxed::Box<wkt::Duration>),
    }
}

/// The analysis resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Analysis {
    /// Immutable. The resource name of the analysis.
    /// Format:
    /// projects/{project}/locations/{location}/conversations/{conversation}/analyses/{analysis}
    pub name: std::string::String,

    /// Output only. The time at which the analysis was requested.
    pub request_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which the analysis was created, which occurs when
    /// the long-running operation completes.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The result of the analysis, which is populated when the
    /// analysis finishes.
    pub analysis_result: std::option::Option<crate::model::AnalysisResult>,

    /// To select the annotators to run and the phrase matchers to use
    /// (if any). If not specified, all annotators will be run.
    pub annotator_selector: std::option::Option<crate::model::AnnotatorSelector>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Analysis {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Analysis::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_time][crate::model::Analysis::request_time].
    pub fn set_request_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.request_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [request_time][crate::model::Analysis::request_time].
    pub fn set_or_clear_request_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.request_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [create_time][crate::model::Analysis::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Analysis::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [analysis_result][crate::model::Analysis::analysis_result].
    pub fn set_analysis_result<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AnalysisResult>,
    {
        self.analysis_result = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [analysis_result][crate::model::Analysis::analysis_result].
    pub fn set_or_clear_analysis_result<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AnalysisResult>,
    {
        self.analysis_result = v.map(|x| x.into());
        self
    }

    /// Sets the value of [annotator_selector][crate::model::Analysis::annotator_selector].
    pub fn set_annotator_selector<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AnnotatorSelector>,
    {
        self.annotator_selector = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [annotator_selector][crate::model::Analysis::annotator_selector].
    pub fn set_or_clear_annotator_selector<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AnnotatorSelector>,
    {
        self.annotator_selector = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Analysis {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.Analysis"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Analysis {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_time,
            __create_time,
            __analysis_result,
            __annotator_selector,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Analysis")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestTime" => Ok(__FieldTag::__request_time),
                            "request_time" => Ok(__FieldTag::__request_time),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "analysisResult" => Ok(__FieldTag::__analysis_result),
                            "analysis_result" => Ok(__FieldTag::__analysis_result),
                            "annotatorSelector" => Ok(__FieldTag::__annotator_selector),
                            "annotator_selector" => Ok(__FieldTag::__annotator_selector),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Analysis;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Analysis")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_time => {
                            if !fields.insert(__FieldTag::__request_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_time",
                                ));
                            }
                            result.request_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__analysis_result => {
                            if !fields.insert(__FieldTag::__analysis_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for analysis_result",
                                ));
                            }
                            result.analysis_result = map
                                .next_value::<std::option::Option<crate::model::AnalysisResult>>(
                                )?;
                        }
                        __FieldTag::__annotator_selector => {
                            if !fields.insert(__FieldTag::__annotator_selector) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotator_selector",
                                ));
                            }
                            result.annotator_selector = map
                                .next_value::<std::option::Option<crate::model::AnnotatorSelector>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Analysis {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.request_time.is_some() {
            state.serialize_entry("requestTime", &self.request_time)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.analysis_result.is_some() {
            state.serialize_entry("analysisResult", &self.analysis_result)?;
        }
        if self.annotator_selector.is_some() {
            state.serialize_entry("annotatorSelector", &self.annotator_selector)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Analysis {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Analysis");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_time", &self.request_time);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("analysis_result", &self.analysis_result);
        debug_struct.field("annotator_selector", &self.annotator_selector);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The conversation source, which is a combination of transcript and audio.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ConversationDataSource {
    /// The source of the conversation.
    pub source: std::option::Option<crate::model::conversation_data_source::Source>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConversationDataSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source][crate::model::ConversationDataSource::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::conversation_data_source::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::ConversationDataSource::source]
    /// if it holds a `GcsSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::GcsSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::conversation_data_source::Source::GcsSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ConversationDataSource::source]
    /// to hold a `GcsSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_gcs_source<T: std::convert::Into<std::boxed::Box<crate::model::GcsSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::conversation_data_source::Source::GcsSource(v.into()),
        );
        self
    }

    /// The value of [source][crate::model::ConversationDataSource::source]
    /// if it holds a `DialogflowSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn dialogflow_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DialogflowSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::conversation_data_source::Source::DialogflowSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ConversationDataSource::source]
    /// to hold a `DialogflowSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_dialogflow_source<
        T: std::convert::Into<std::boxed::Box<crate::model::DialogflowSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::conversation_data_source::Source::DialogflowSource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ConversationDataSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ConversationDataSource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ConversationDataSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcs_source,
            __dialogflow_source,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConversationDataSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcsSource" => Ok(__FieldTag::__gcs_source),
                            "gcs_source" => Ok(__FieldTag::__gcs_source),
                            "dialogflowSource" => Ok(__FieldTag::__dialogflow_source),
                            "dialogflow_source" => Ok(__FieldTag::__dialogflow_source),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ConversationDataSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConversationDataSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcs_source => {
                            if !fields.insert(__FieldTag::__gcs_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_source",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.contactcenterinsights.v1.ConversationDataSource.gcs_source, latest field was gcsSource",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::conversation_data_source::Source::GcsSource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GcsSource>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__dialogflow_source => {
                            if !fields.insert(__FieldTag::__dialogflow_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dialogflow_source",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.contactcenterinsights.v1.ConversationDataSource.dialogflow_source, latest field was dialogflowSource",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::conversation_data_source::Source::DialogflowSource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DialogflowSource>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ConversationDataSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.gcs_source() {
            state.serialize_entry("gcsSource", value)?;
        }
        if let Some(value) = self.dialogflow_source() {
            state.serialize_entry("dialogflowSource", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ConversationDataSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConversationDataSource");
        debug_struct.field("source", &self.source);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ConversationDataSource].
pub mod conversation_data_source {
    #[allow(unused_imports)]
    use super::*;

    /// The source of the conversation.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// A Cloud Storage location specification for the audio and transcript.
        GcsSource(std::boxed::Box<crate::model::GcsSource>),
        /// The source when the conversation comes from Dialogflow.
        DialogflowSource(std::boxed::Box<crate::model::DialogflowSource>),
    }
}

/// A Cloud Storage source of conversation data.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GcsSource {
    /// Cloud Storage URI that points to a file that contains the conversation
    /// audio.
    pub audio_uri: std::string::String,

    /// Immutable. Cloud Storage URI that points to a file that contains the
    /// conversation transcript.
    pub transcript_uri: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcsSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [audio_uri][crate::model::GcsSource::audio_uri].
    pub fn set_audio_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.audio_uri = v.into();
        self
    }

    /// Sets the value of [transcript_uri][crate::model::GcsSource::transcript_uri].
    pub fn set_transcript_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.transcript_uri = v.into();
        self
    }
}

impl wkt::message::Message for GcsSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.GcsSource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GcsSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __audio_uri,
            __transcript_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GcsSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "audioUri" => Ok(__FieldTag::__audio_uri),
                            "audio_uri" => Ok(__FieldTag::__audio_uri),
                            "transcriptUri" => Ok(__FieldTag::__transcript_uri),
                            "transcript_uri" => Ok(__FieldTag::__transcript_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GcsSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GcsSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__audio_uri => {
                            if !fields.insert(__FieldTag::__audio_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for audio_uri",
                                ));
                            }
                            result.audio_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__transcript_uri => {
                            if !fields.insert(__FieldTag::__transcript_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transcript_uri",
                                ));
                            }
                            result.transcript_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GcsSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.audio_uri.is_empty() {
            state.serialize_entry("audioUri", &self.audio_uri)?;
        }
        if !self.transcript_uri.is_empty() {
            state.serialize_entry("transcriptUri", &self.transcript_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GcsSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GcsSource");
        debug_struct.field("audio_uri", &self.audio_uri);
        debug_struct.field("transcript_uri", &self.transcript_uri);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A Dialogflow source of conversation data.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DialogflowSource {
    /// Output only. The name of the Dialogflow conversation that this conversation
    /// resource is derived from. Format:
    /// projects/{project}/locations/{location}/conversations/{conversation}
    pub dialogflow_conversation: std::string::String,

    /// Cloud Storage URI that points to a file that contains the conversation
    /// audio.
    pub audio_uri: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DialogflowSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dialogflow_conversation][crate::model::DialogflowSource::dialogflow_conversation].
    pub fn set_dialogflow_conversation<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.dialogflow_conversation = v.into();
        self
    }

    /// Sets the value of [audio_uri][crate::model::DialogflowSource::audio_uri].
    pub fn set_audio_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.audio_uri = v.into();
        self
    }
}

impl wkt::message::Message for DialogflowSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.DialogflowSource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DialogflowSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dialogflow_conversation,
            __audio_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DialogflowSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dialogflowConversation" => Ok(__FieldTag::__dialogflow_conversation),
                            "dialogflow_conversation" => Ok(__FieldTag::__dialogflow_conversation),
                            "audioUri" => Ok(__FieldTag::__audio_uri),
                            "audio_uri" => Ok(__FieldTag::__audio_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DialogflowSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DialogflowSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dialogflow_conversation => {
                            if !fields.insert(__FieldTag::__dialogflow_conversation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dialogflow_conversation",
                                ));
                            }
                            result.dialogflow_conversation = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__audio_uri => {
                            if !fields.insert(__FieldTag::__audio_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for audio_uri",
                                ));
                            }
                            result.audio_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DialogflowSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.dialogflow_conversation.is_empty() {
            state.serialize_entry("dialogflowConversation", &self.dialogflow_conversation)?;
        }
        if !self.audio_uri.is_empty() {
            state.serialize_entry("audioUri", &self.audio_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DialogflowSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DialogflowSource");
        debug_struct.field("dialogflow_conversation", &self.dialogflow_conversation);
        debug_struct.field("audio_uri", &self.audio_uri);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The result of an analysis.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AnalysisResult {
    /// The time at which the analysis ended.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Metadata discovered during analysis.
    pub metadata: std::option::Option<crate::model::analysis_result::Metadata>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnalysisResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [end_time][crate::model::AnalysisResult::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::AnalysisResult::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [metadata][crate::model::AnalysisResult::metadata].
    ///
    /// Note that all the setters affecting `metadata` are mutually
    /// exclusive.
    pub fn set_metadata<
        T: std::convert::Into<std::option::Option<crate::model::analysis_result::Metadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = v.into();
        self
    }

    /// The value of [metadata][crate::model::AnalysisResult::metadata]
    /// if it holds a `CallAnalysisMetadata`, `None` if the field is not set or
    /// holds a different branch.
    pub fn call_analysis_metadata(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::analysis_result::CallAnalysisMetadata>>
    {
        #[allow(unreachable_patterns)]
        self.metadata.as_ref().and_then(|v| match v {
            crate::model::analysis_result::Metadata::CallAnalysisMetadata(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [metadata][crate::model::AnalysisResult::metadata]
    /// to hold a `CallAnalysisMetadata`.
    ///
    /// Note that all the setters affecting `metadata` are
    /// mutually exclusive.
    pub fn set_call_analysis_metadata<
        T: std::convert::Into<std::boxed::Box<crate::model::analysis_result::CallAnalysisMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = std::option::Option::Some(
            crate::model::analysis_result::Metadata::CallAnalysisMetadata(v.into()),
        );
        self
    }
}

impl wkt::message::Message for AnalysisResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.AnalysisResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AnalysisResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __call_analysis_metadata,
            __end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AnalysisResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "callAnalysisMetadata" => Ok(__FieldTag::__call_analysis_metadata),
                            "call_analysis_metadata" => Ok(__FieldTag::__call_analysis_metadata),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AnalysisResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnalysisResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__call_analysis_metadata => {
                            if !fields.insert(__FieldTag::__call_analysis_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for call_analysis_metadata",
                                ));
                            }
                            if result.metadata.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `metadata`, a oneof with full ID .google.cloud.contactcenterinsights.v1.AnalysisResult.call_analysis_metadata, latest field was callAnalysisMetadata",
                                ));
                            }
                            result.metadata = std::option::Option::Some(
                                crate::model::analysis_result::Metadata::CallAnalysisMetadata(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::analysis_result::CallAnalysisMetadata,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AnalysisResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.call_analysis_metadata() {
            state.serialize_entry("callAnalysisMetadata", value)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AnalysisResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AnalysisResult");
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("metadata", &self.metadata);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AnalysisResult].
pub mod analysis_result {
    #[allow(unused_imports)]
    use super::*;

    /// Call-specific metadata created during analysis.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CallAnalysisMetadata {
        /// A list of call annotations that apply to this call.
        pub annotations: std::vec::Vec<crate::model::CallAnnotation>,

        /// All the entities in the call.
        pub entities: std::collections::HashMap<std::string::String, crate::model::Entity>,

        /// Overall conversation-level sentiment for each channel of the call.
        pub sentiments: std::vec::Vec<crate::model::ConversationLevelSentiment>,

        /// Overall conversation-level silence during the call.
        pub silence: std::option::Option<crate::model::ConversationLevelSilence>,

        /// All the matched intents in the call.
        pub intents: std::collections::HashMap<std::string::String, crate::model::Intent>,

        /// All the matched phrase matchers in the call.
        pub phrase_matchers:
            std::collections::HashMap<std::string::String, crate::model::PhraseMatchData>,

        /// Overall conversation-level issue modeling result.
        pub issue_model_result: std::option::Option<crate::model::IssueModelResult>,

        /// Results of scoring QaScorecards.
        pub qa_scorecard_results: std::vec::Vec<crate::model::QaScorecardResult>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CallAnalysisMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [annotations][crate::model::analysis_result::CallAnalysisMetadata::annotations].
        pub fn set_annotations<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::CallAnnotation>,
        {
            use std::iter::Iterator;
            self.annotations = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [entities][crate::model::analysis_result::CallAnalysisMetadata::entities].
        pub fn set_entities<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<crate::model::Entity>,
        {
            use std::iter::Iterator;
            self.entities = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [sentiments][crate::model::analysis_result::CallAnalysisMetadata::sentiments].
        pub fn set_sentiments<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::ConversationLevelSentiment>,
        {
            use std::iter::Iterator;
            self.sentiments = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [silence][crate::model::analysis_result::CallAnalysisMetadata::silence].
        pub fn set_silence<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::ConversationLevelSilence>,
        {
            self.silence = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [silence][crate::model::analysis_result::CallAnalysisMetadata::silence].
        pub fn set_or_clear_silence<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::ConversationLevelSilence>,
        {
            self.silence = v.map(|x| x.into());
            self
        }

        /// Sets the value of [intents][crate::model::analysis_result::CallAnalysisMetadata::intents].
        pub fn set_intents<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<crate::model::Intent>,
        {
            use std::iter::Iterator;
            self.intents = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [phrase_matchers][crate::model::analysis_result::CallAnalysisMetadata::phrase_matchers].
        pub fn set_phrase_matchers<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<crate::model::PhraseMatchData>,
        {
            use std::iter::Iterator;
            self.phrase_matchers = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [issue_model_result][crate::model::analysis_result::CallAnalysisMetadata::issue_model_result].
        pub fn set_issue_model_result<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::IssueModelResult>,
        {
            self.issue_model_result = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [issue_model_result][crate::model::analysis_result::CallAnalysisMetadata::issue_model_result].
        pub fn set_or_clear_issue_model_result<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::IssueModelResult>,
        {
            self.issue_model_result = v.map(|x| x.into());
            self
        }

        /// Sets the value of [qa_scorecard_results][crate::model::analysis_result::CallAnalysisMetadata::qa_scorecard_results].
        pub fn set_qa_scorecard_results<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::QaScorecardResult>,
        {
            use std::iter::Iterator;
            self.qa_scorecard_results = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for CallAnalysisMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.AnalysisResult.CallAnalysisMetadata"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for CallAnalysisMetadata {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __annotations,
                __entities,
                __sentiments,
                __silence,
                __intents,
                __phrase_matchers,
                __issue_model_result,
                __qa_scorecard_results,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for CallAnalysisMetadata")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "annotations" => Ok(__FieldTag::__annotations),
                                "entities" => Ok(__FieldTag::__entities),
                                "sentiments" => Ok(__FieldTag::__sentiments),
                                "silence" => Ok(__FieldTag::__silence),
                                "intents" => Ok(__FieldTag::__intents),
                                "phraseMatchers" => Ok(__FieldTag::__phrase_matchers),
                                "phrase_matchers" => Ok(__FieldTag::__phrase_matchers),
                                "issueModelResult" => Ok(__FieldTag::__issue_model_result),
                                "issue_model_result" => Ok(__FieldTag::__issue_model_result),
                                "qaScorecardResults" => Ok(__FieldTag::__qa_scorecard_results),
                                "qa_scorecard_results" => Ok(__FieldTag::__qa_scorecard_results),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = CallAnalysisMetadata;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct CallAnalysisMetadata")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__annotations => {
                                if !fields.insert(__FieldTag::__annotations) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for annotations",
                                    ));
                                }
                                result.annotations = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::CallAnnotation>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__entities => {
                                if !fields.insert(__FieldTag::__entities) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for entities",
                                    ));
                                }
                                result.entities = map
                                    .next_value::<std::option::Option<
                                        std::collections::HashMap<
                                            std::string::String,
                                            crate::model::Entity,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__sentiments => {
                                if !fields.insert(__FieldTag::__sentiments) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for sentiments",
                                    ));
                                }
                                result.sentiments = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::ConversationLevelSentiment>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__silence => {
                                if !fields.insert(__FieldTag::__silence) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for silence",
                                    ));
                                }
                                result.silence = map.next_value::<std::option::Option<crate::model::ConversationLevelSilence>>()?
                                    ;
                            }
                            __FieldTag::__intents => {
                                if !fields.insert(__FieldTag::__intents) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for intents",
                                    ));
                                }
                                result.intents = map
                                    .next_value::<std::option::Option<
                                        std::collections::HashMap<
                                            std::string::String,
                                            crate::model::Intent,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__phrase_matchers => {
                                if !fields.insert(__FieldTag::__phrase_matchers) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for phrase_matchers",
                                    ));
                                }
                                result.phrase_matchers = map
                                    .next_value::<std::option::Option<
                                        std::collections::HashMap<
                                            std::string::String,
                                            crate::model::PhraseMatchData,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__issue_model_result => {
                                if !fields.insert(__FieldTag::__issue_model_result) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for issue_model_result",
                                    ));
                                }
                                result.issue_model_result = map.next_value::<std::option::Option<crate::model::IssueModelResult>>()?
                                    ;
                            }
                            __FieldTag::__qa_scorecard_results => {
                                if !fields.insert(__FieldTag::__qa_scorecard_results) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for qa_scorecard_results",
                                    ));
                                }
                                result.qa_scorecard_results = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::QaScorecardResult>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for CallAnalysisMetadata {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.annotations.is_empty() {
                state.serialize_entry("annotations", &self.annotations)?;
            }
            if !self.entities.is_empty() {
                state.serialize_entry("entities", &self.entities)?;
            }
            if !self.sentiments.is_empty() {
                state.serialize_entry("sentiments", &self.sentiments)?;
            }
            if self.silence.is_some() {
                state.serialize_entry("silence", &self.silence)?;
            }
            if !self.intents.is_empty() {
                state.serialize_entry("intents", &self.intents)?;
            }
            if !self.phrase_matchers.is_empty() {
                state.serialize_entry("phraseMatchers", &self.phrase_matchers)?;
            }
            if self.issue_model_result.is_some() {
                state.serialize_entry("issueModelResult", &self.issue_model_result)?;
            }
            if !self.qa_scorecard_results.is_empty() {
                state.serialize_entry("qaScorecardResults", &self.qa_scorecard_results)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for CallAnalysisMetadata {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("CallAnalysisMetadata");
            debug_struct.field("annotations", &self.annotations);
            debug_struct.field("entities", &self.entities);
            debug_struct.field("sentiments", &self.sentiments);
            debug_struct.field("silence", &self.silence);
            debug_struct.field("intents", &self.intents);
            debug_struct.field("phrase_matchers", &self.phrase_matchers);
            debug_struct.field("issue_model_result", &self.issue_model_result);
            debug_struct.field("qa_scorecard_results", &self.qa_scorecard_results);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Metadata discovered during analysis.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Metadata {
        /// Call-specific metadata created by the analysis.
        CallAnalysisMetadata(std::boxed::Box<crate::model::analysis_result::CallAnalysisMetadata>),
    }
}

/// Issue Modeling result on a conversation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct IssueModelResult {
    /// Issue model that generates the result.
    /// Format: projects/{project}/locations/{location}/issueModels/{issue_model}
    pub issue_model: std::string::String,

    /// All the matched issues.
    pub issues: std::vec::Vec<crate::model::IssueAssignment>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IssueModelResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [issue_model][crate::model::IssueModelResult::issue_model].
    pub fn set_issue_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.issue_model = v.into();
        self
    }

    /// Sets the value of [issues][crate::model::IssueModelResult::issues].
    pub fn set_issues<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::IssueAssignment>,
    {
        use std::iter::Iterator;
        self.issues = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for IssueModelResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.IssueModelResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for IssueModelResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __issue_model,
            __issues,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IssueModelResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "issueModel" => Ok(__FieldTag::__issue_model),
                            "issue_model" => Ok(__FieldTag::__issue_model),
                            "issues" => Ok(__FieldTag::__issues),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = IssueModelResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IssueModelResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__issue_model => {
                            if !fields.insert(__FieldTag::__issue_model) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for issue_model",
                                ));
                            }
                            result.issue_model = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__issues => {
                            if !fields.insert(__FieldTag::__issues) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for issues",
                                ));
                            }
                            result.issues =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::IssueAssignment>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for IssueModelResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.issue_model.is_empty() {
            state.serialize_entry("issueModel", &self.issue_model)?;
        }
        if !self.issues.is_empty() {
            state.serialize_entry("issues", &self.issues)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for IssueModelResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IssueModelResult");
        debug_struct.field("issue_model", &self.issue_model);
        debug_struct.field("issues", &self.issues);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents a conversation, resource, and label provided by the user.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FeedbackLabel {
    /// Immutable. Resource name of the FeedbackLabel.
    /// Format:
    /// projects/{project}/locations/{location}/conversations/{conversation}/feedbackLabels/{feedback_label}
    pub name: std::string::String,

    /// Resource name of the resource to be labeled.
    pub labeled_resource: std::string::String,

    /// Output only. Create time of the label.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Update time of the label.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Label type.
    pub label_type: std::option::Option<crate::model::feedback_label::LabelType>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FeedbackLabel {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FeedbackLabel::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [labeled_resource][crate::model::FeedbackLabel::labeled_resource].
    pub fn set_labeled_resource<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.labeled_resource = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::FeedbackLabel::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::FeedbackLabel::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::FeedbackLabel::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::FeedbackLabel::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [label_type][crate::model::FeedbackLabel::label_type].
    ///
    /// Note that all the setters affecting `label_type` are mutually
    /// exclusive.
    pub fn set_label_type<
        T: std::convert::Into<std::option::Option<crate::model::feedback_label::LabelType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.label_type = v.into();
        self
    }

    /// The value of [label_type][crate::model::FeedbackLabel::label_type]
    /// if it holds a `Label`, `None` if the field is not set or
    /// holds a different branch.
    pub fn label(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.label_type.as_ref().and_then(|v| match v {
            crate::model::feedback_label::LabelType::Label(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [label_type][crate::model::FeedbackLabel::label_type]
    /// to hold a `Label`.
    ///
    /// Note that all the setters affecting `label_type` are
    /// mutually exclusive.
    pub fn set_label<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.label_type =
            std::option::Option::Some(crate::model::feedback_label::LabelType::Label(v.into()));
        self
    }

    /// The value of [label_type][crate::model::FeedbackLabel::label_type]
    /// if it holds a `QaAnswerLabel`, `None` if the field is not set or
    /// holds a different branch.
    pub fn qa_answer_label(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::qa_answer::AnswerValue>> {
        #[allow(unreachable_patterns)]
        self.label_type.as_ref().and_then(|v| match v {
            crate::model::feedback_label::LabelType::QaAnswerLabel(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [label_type][crate::model::FeedbackLabel::label_type]
    /// to hold a `QaAnswerLabel`.
    ///
    /// Note that all the setters affecting `label_type` are
    /// mutually exclusive.
    pub fn set_qa_answer_label<
        T: std::convert::Into<std::boxed::Box<crate::model::qa_answer::AnswerValue>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.label_type = std::option::Option::Some(
            crate::model::feedback_label::LabelType::QaAnswerLabel(v.into()),
        );
        self
    }
}

impl wkt::message::Message for FeedbackLabel {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.FeedbackLabel"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FeedbackLabel {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __label,
            __qa_answer_label,
            __name,
            __labeled_resource,
            __create_time,
            __update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FeedbackLabel")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "label" => Ok(__FieldTag::__label),
                            "qaAnswerLabel" => Ok(__FieldTag::__qa_answer_label),
                            "qa_answer_label" => Ok(__FieldTag::__qa_answer_label),
                            "name" => Ok(__FieldTag::__name),
                            "labeledResource" => Ok(__FieldTag::__labeled_resource),
                            "labeled_resource" => Ok(__FieldTag::__labeled_resource),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FeedbackLabel;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FeedbackLabel")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__label => {
                            if !fields.insert(__FieldTag::__label) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for label",
                                ));
                            }
                            if result.label_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `label_type`, a oneof with full ID .google.cloud.contactcenterinsights.v1.FeedbackLabel.label, latest field was label",
                                ));
                            }
                            result.label_type = std::option::Option::Some(
                                crate::model::feedback_label::LabelType::Label(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__qa_answer_label => {
                            if !fields.insert(__FieldTag::__qa_answer_label) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for qa_answer_label",
                                ));
                            }
                            if result.label_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `label_type`, a oneof with full ID .google.cloud.contactcenterinsights.v1.FeedbackLabel.qa_answer_label, latest field was qaAnswerLabel",
                                ));
                            }
                            result.label_type = std::option::Option::Some(
                                crate::model::feedback_label::LabelType::QaAnswerLabel(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::qa_answer::AnswerValue>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labeled_resource => {
                            if !fields.insert(__FieldTag::__labeled_resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labeled_resource",
                                ));
                            }
                            result.labeled_resource = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FeedbackLabel {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.label() {
            state.serialize_entry("label", value)?;
        }
        if let Some(value) = self.qa_answer_label() {
            state.serialize_entry("qaAnswerLabel", value)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.labeled_resource.is_empty() {
            state.serialize_entry("labeledResource", &self.labeled_resource)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FeedbackLabel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FeedbackLabel");
        debug_struct.field("name", &self.name);
        debug_struct.field("labeled_resource", &self.labeled_resource);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("label_type", &self.label_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [FeedbackLabel].
pub mod feedback_label {
    #[allow(unused_imports)]
    use super::*;

    /// Label type.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LabelType {
        /// String label.
        Label(std::string::String),
        /// QaAnswer label.
        QaAnswerLabel(std::boxed::Box<crate::model::qa_answer::AnswerValue>),
    }
}

/// One channel of conversation-level sentiment data.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ConversationLevelSentiment {
    /// The channel of the audio that the data applies to.
    pub channel_tag: i32,

    /// Data specifying sentiment.
    pub sentiment_data: std::option::Option<crate::model::SentimentData>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConversationLevelSentiment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [channel_tag][crate::model::ConversationLevelSentiment::channel_tag].
    pub fn set_channel_tag<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.channel_tag = v.into();
        self
    }

    /// Sets the value of [sentiment_data][crate::model::ConversationLevelSentiment::sentiment_data].
    pub fn set_sentiment_data<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SentimentData>,
    {
        self.sentiment_data = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sentiment_data][crate::model::ConversationLevelSentiment::sentiment_data].
    pub fn set_or_clear_sentiment_data<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SentimentData>,
    {
        self.sentiment_data = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ConversationLevelSentiment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ConversationLevelSentiment"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ConversationLevelSentiment {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __channel_tag,
            __sentiment_data,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConversationLevelSentiment")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "channelTag" => Ok(__FieldTag::__channel_tag),
                            "channel_tag" => Ok(__FieldTag::__channel_tag),
                            "sentimentData" => Ok(__FieldTag::__sentiment_data),
                            "sentiment_data" => Ok(__FieldTag::__sentiment_data),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ConversationLevelSentiment;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConversationLevelSentiment")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__channel_tag => {
                            if !fields.insert(__FieldTag::__channel_tag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for channel_tag",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.channel_tag = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__sentiment_data => {
                            if !fields.insert(__FieldTag::__sentiment_data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sentiment_data",
                                ));
                            }
                            result.sentiment_data = map
                                .next_value::<std::option::Option<crate::model::SentimentData>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ConversationLevelSentiment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.channel_tag) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("channelTag", &__With(&self.channel_tag))?;
        }
        if self.sentiment_data.is_some() {
            state.serialize_entry("sentimentData", &self.sentiment_data)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ConversationLevelSentiment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConversationLevelSentiment");
        debug_struct.field("channel_tag", &self.channel_tag);
        debug_struct.field("sentiment_data", &self.sentiment_data);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Conversation-level silence data.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ConversationLevelSilence {
    /// Amount of time calculated to be in silence.
    pub silence_duration: std::option::Option<wkt::Duration>,

    /// Percentage of the total conversation spent in silence.
    pub silence_percentage: f32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConversationLevelSilence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [silence_duration][crate::model::ConversationLevelSilence::silence_duration].
    pub fn set_silence_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.silence_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [silence_duration][crate::model::ConversationLevelSilence::silence_duration].
    pub fn set_or_clear_silence_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.silence_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [silence_percentage][crate::model::ConversationLevelSilence::silence_percentage].
    pub fn set_silence_percentage<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.silence_percentage = v.into();
        self
    }
}

impl wkt::message::Message for ConversationLevelSilence {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ConversationLevelSilence"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ConversationLevelSilence {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __silence_duration,
            __silence_percentage,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConversationLevelSilence")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "silenceDuration" => Ok(__FieldTag::__silence_duration),
                            "silence_duration" => Ok(__FieldTag::__silence_duration),
                            "silencePercentage" => Ok(__FieldTag::__silence_percentage),
                            "silence_percentage" => Ok(__FieldTag::__silence_percentage),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ConversationLevelSilence;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConversationLevelSilence")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__silence_duration => {
                            if !fields.insert(__FieldTag::__silence_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for silence_duration",
                                ));
                            }
                            result.silence_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__silence_percentage => {
                            if !fields.insert(__FieldTag::__silence_percentage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for silence_percentage",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.silence_percentage =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ConversationLevelSilence {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.silence_duration.is_some() {
            state.serialize_entry("silenceDuration", &self.silence_duration)?;
        }
        if !wkt::internal::is_default(&self.silence_percentage) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("silencePercentage", &__With(&self.silence_percentage))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ConversationLevelSilence {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConversationLevelSilence");
        debug_struct.field("silence_duration", &self.silence_duration);
        debug_struct.field("silence_percentage", &self.silence_percentage);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Information about the issue.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct IssueAssignment {
    /// Resource name of the assigned issue.
    pub issue: std::string::String,

    /// Score indicating the likelihood of the issue assignment.
    /// currently bounded on [0,1].
    pub score: f64,

    /// Immutable. Display name of the assigned issue. This field is set at time of
    /// analyis and immutable since then.
    pub display_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IssueAssignment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [issue][crate::model::IssueAssignment::issue].
    pub fn set_issue<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.issue = v.into();
        self
    }

    /// Sets the value of [score][crate::model::IssueAssignment::score].
    pub fn set_score<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::IssueAssignment::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }
}

impl wkt::message::Message for IssueAssignment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.IssueAssignment"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for IssueAssignment {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __issue,
            __score,
            __display_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IssueAssignment")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "issue" => Ok(__FieldTag::__issue),
                            "score" => Ok(__FieldTag::__score),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = IssueAssignment;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IssueAssignment")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__issue => {
                            if !fields.insert(__FieldTag::__issue) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for issue",
                                ));
                            }
                            result.issue = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__score => {
                            if !fields.insert(__FieldTag::__score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for score",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.score = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for IssueAssignment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.issue.is_empty() {
            state.serialize_entry("issue", &self.issue)?;
        }
        if !wkt::internal::is_default(&self.score) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("score", &__With(&self.score))?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for IssueAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IssueAssignment");
        debug_struct.field("issue", &self.issue);
        debug_struct.field("score", &self.score);
        debug_struct.field("display_name", &self.display_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A piece of metadata that applies to a window of a call.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CallAnnotation {
    /// The channel of the audio where the annotation occurs. For single-channel
    /// audio, this field is not populated.
    pub channel_tag: i32,

    /// The boundary in the conversation where the annotation starts, inclusive.
    pub annotation_start_boundary: std::option::Option<crate::model::AnnotationBoundary>,

    /// The boundary in the conversation where the annotation ends, inclusive.
    pub annotation_end_boundary: std::option::Option<crate::model::AnnotationBoundary>,

    /// The data in the annotation.
    pub data: std::option::Option<crate::model::call_annotation::Data>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CallAnnotation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [channel_tag][crate::model::CallAnnotation::channel_tag].
    pub fn set_channel_tag<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.channel_tag = v.into();
        self
    }

    /// Sets the value of [annotation_start_boundary][crate::model::CallAnnotation::annotation_start_boundary].
    pub fn set_annotation_start_boundary<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AnnotationBoundary>,
    {
        self.annotation_start_boundary = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [annotation_start_boundary][crate::model::CallAnnotation::annotation_start_boundary].
    pub fn set_or_clear_annotation_start_boundary<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AnnotationBoundary>,
    {
        self.annotation_start_boundary = v.map(|x| x.into());
        self
    }

    /// Sets the value of [annotation_end_boundary][crate::model::CallAnnotation::annotation_end_boundary].
    pub fn set_annotation_end_boundary<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AnnotationBoundary>,
    {
        self.annotation_end_boundary = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [annotation_end_boundary][crate::model::CallAnnotation::annotation_end_boundary].
    pub fn set_or_clear_annotation_end_boundary<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AnnotationBoundary>,
    {
        self.annotation_end_boundary = v.map(|x| x.into());
        self
    }

    /// Sets the value of [data][crate::model::CallAnnotation::data].
    ///
    /// Note that all the setters affecting `data` are mutually
    /// exclusive.
    pub fn set_data<
        T: std::convert::Into<std::option::Option<crate::model::call_annotation::Data>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data = v.into();
        self
    }

    /// The value of [data][crate::model::CallAnnotation::data]
    /// if it holds a `InterruptionData`, `None` if the field is not set or
    /// holds a different branch.
    pub fn interruption_data(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::InterruptionData>> {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::call_annotation::Data::InterruptionData(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data][crate::model::CallAnnotation::data]
    /// to hold a `InterruptionData`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_interruption_data<
        T: std::convert::Into<std::boxed::Box<crate::model::InterruptionData>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data = std::option::Option::Some(
            crate::model::call_annotation::Data::InterruptionData(v.into()),
        );
        self
    }

    /// The value of [data][crate::model::CallAnnotation::data]
    /// if it holds a `SentimentData`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sentiment_data(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SentimentData>> {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::call_annotation::Data::SentimentData(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data][crate::model::CallAnnotation::data]
    /// to hold a `SentimentData`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_sentiment_data<
        T: std::convert::Into<std::boxed::Box<crate::model::SentimentData>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data =
            std::option::Option::Some(crate::model::call_annotation::Data::SentimentData(v.into()));
        self
    }

    /// The value of [data][crate::model::CallAnnotation::data]
    /// if it holds a `SilenceData`, `None` if the field is not set or
    /// holds a different branch.
    pub fn silence_data(&self) -> std::option::Option<&std::boxed::Box<crate::model::SilenceData>> {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::call_annotation::Data::SilenceData(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data][crate::model::CallAnnotation::data]
    /// to hold a `SilenceData`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_silence_data<T: std::convert::Into<std::boxed::Box<crate::model::SilenceData>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data =
            std::option::Option::Some(crate::model::call_annotation::Data::SilenceData(v.into()));
        self
    }

    /// The value of [data][crate::model::CallAnnotation::data]
    /// if it holds a `HoldData`, `None` if the field is not set or
    /// holds a different branch.
    pub fn hold_data(&self) -> std::option::Option<&std::boxed::Box<crate::model::HoldData>> {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::call_annotation::Data::HoldData(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data][crate::model::CallAnnotation::data]
    /// to hold a `HoldData`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_hold_data<T: std::convert::Into<std::boxed::Box<crate::model::HoldData>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data =
            std::option::Option::Some(crate::model::call_annotation::Data::HoldData(v.into()));
        self
    }

    /// The value of [data][crate::model::CallAnnotation::data]
    /// if it holds a `EntityMentionData`, `None` if the field is not set or
    /// holds a different branch.
    pub fn entity_mention_data(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::EntityMentionData>> {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::call_annotation::Data::EntityMentionData(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data][crate::model::CallAnnotation::data]
    /// to hold a `EntityMentionData`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_entity_mention_data<
        T: std::convert::Into<std::boxed::Box<crate::model::EntityMentionData>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data = std::option::Option::Some(
            crate::model::call_annotation::Data::EntityMentionData(v.into()),
        );
        self
    }

    /// The value of [data][crate::model::CallAnnotation::data]
    /// if it holds a `IntentMatchData`, `None` if the field is not set or
    /// holds a different branch.
    pub fn intent_match_data(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::IntentMatchData>> {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::call_annotation::Data::IntentMatchData(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data][crate::model::CallAnnotation::data]
    /// to hold a `IntentMatchData`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_intent_match_data<
        T: std::convert::Into<std::boxed::Box<crate::model::IntentMatchData>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data = std::option::Option::Some(
            crate::model::call_annotation::Data::IntentMatchData(v.into()),
        );
        self
    }

    /// The value of [data][crate::model::CallAnnotation::data]
    /// if it holds a `PhraseMatchData`, `None` if the field is not set or
    /// holds a different branch.
    pub fn phrase_match_data(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PhraseMatchData>> {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::call_annotation::Data::PhraseMatchData(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data][crate::model::CallAnnotation::data]
    /// to hold a `PhraseMatchData`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_phrase_match_data<
        T: std::convert::Into<std::boxed::Box<crate::model::PhraseMatchData>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data = std::option::Option::Some(
            crate::model::call_annotation::Data::PhraseMatchData(v.into()),
        );
        self
    }

    /// The value of [data][crate::model::CallAnnotation::data]
    /// if it holds a `IssueMatchData`, `None` if the field is not set or
    /// holds a different branch.
    pub fn issue_match_data(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::IssueMatchData>> {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::call_annotation::Data::IssueMatchData(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data][crate::model::CallAnnotation::data]
    /// to hold a `IssueMatchData`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_issue_match_data<
        T: std::convert::Into<std::boxed::Box<crate::model::IssueMatchData>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data = std::option::Option::Some(crate::model::call_annotation::Data::IssueMatchData(
            v.into(),
        ));
        self
    }
}

impl wkt::message::Message for CallAnnotation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.CallAnnotation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CallAnnotation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __interruption_data,
            __sentiment_data,
            __silence_data,
            __hold_data,
            __entity_mention_data,
            __intent_match_data,
            __phrase_match_data,
            __issue_match_data,
            __channel_tag,
            __annotation_start_boundary,
            __annotation_end_boundary,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CallAnnotation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "interruptionData" => Ok(__FieldTag::__interruption_data),
                            "interruption_data" => Ok(__FieldTag::__interruption_data),
                            "sentimentData" => Ok(__FieldTag::__sentiment_data),
                            "sentiment_data" => Ok(__FieldTag::__sentiment_data),
                            "silenceData" => Ok(__FieldTag::__silence_data),
                            "silence_data" => Ok(__FieldTag::__silence_data),
                            "holdData" => Ok(__FieldTag::__hold_data),
                            "hold_data" => Ok(__FieldTag::__hold_data),
                            "entityMentionData" => Ok(__FieldTag::__entity_mention_data),
                            "entity_mention_data" => Ok(__FieldTag::__entity_mention_data),
                            "intentMatchData" => Ok(__FieldTag::__intent_match_data),
                            "intent_match_data" => Ok(__FieldTag::__intent_match_data),
                            "phraseMatchData" => Ok(__FieldTag::__phrase_match_data),
                            "phrase_match_data" => Ok(__FieldTag::__phrase_match_data),
                            "issueMatchData" => Ok(__FieldTag::__issue_match_data),
                            "issue_match_data" => Ok(__FieldTag::__issue_match_data),
                            "channelTag" => Ok(__FieldTag::__channel_tag),
                            "channel_tag" => Ok(__FieldTag::__channel_tag),
                            "annotationStartBoundary" => {
                                Ok(__FieldTag::__annotation_start_boundary)
                            }
                            "annotation_start_boundary" => {
                                Ok(__FieldTag::__annotation_start_boundary)
                            }
                            "annotationEndBoundary" => Ok(__FieldTag::__annotation_end_boundary),
                            "annotation_end_boundary" => Ok(__FieldTag::__annotation_end_boundary),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CallAnnotation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CallAnnotation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__interruption_data => {
                            if !fields.insert(__FieldTag::__interruption_data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for interruption_data",
                                ));
                            }
                            if result.data.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data`, a oneof with full ID .google.cloud.contactcenterinsights.v1.CallAnnotation.interruption_data, latest field was interruptionData",
                                ));
                            }
                            result.data = std::option::Option::Some(
                                crate::model::call_annotation::Data::InterruptionData(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::InterruptionData>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__sentiment_data => {
                            if !fields.insert(__FieldTag::__sentiment_data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sentiment_data",
                                ));
                            }
                            if result.data.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data`, a oneof with full ID .google.cloud.contactcenterinsights.v1.CallAnnotation.sentiment_data, latest field was sentimentData",
                                ));
                            }
                            result.data = std::option::Option::Some(
                                crate::model::call_annotation::Data::SentimentData(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SentimentData>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__silence_data => {
                            if !fields.insert(__FieldTag::__silence_data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for silence_data",
                                ));
                            }
                            if result.data.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data`, a oneof with full ID .google.cloud.contactcenterinsights.v1.CallAnnotation.silence_data, latest field was silenceData",
                                ));
                            }
                            result.data = std::option::Option::Some(
                                crate::model::call_annotation::Data::SilenceData(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SilenceData>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__hold_data => {
                            if !fields.insert(__FieldTag::__hold_data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hold_data",
                                ));
                            }
                            if result.data.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data`, a oneof with full ID .google.cloud.contactcenterinsights.v1.CallAnnotation.hold_data, latest field was holdData",
                                ));
                            }
                            result.data = std::option::Option::Some(
                                crate::model::call_annotation::Data::HoldData(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::HoldData>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__entity_mention_data => {
                            if !fields.insert(__FieldTag::__entity_mention_data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity_mention_data",
                                ));
                            }
                            if result.data.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data`, a oneof with full ID .google.cloud.contactcenterinsights.v1.CallAnnotation.entity_mention_data, latest field was entityMentionData",
                                ));
                            }
                            result.data = std::option::Option::Some(
                                crate::model::call_annotation::Data::EntityMentionData(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::EntityMentionData>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__intent_match_data => {
                            if !fields.insert(__FieldTag::__intent_match_data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for intent_match_data",
                                ));
                            }
                            if result.data.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data`, a oneof with full ID .google.cloud.contactcenterinsights.v1.CallAnnotation.intent_match_data, latest field was intentMatchData",
                                ));
                            }
                            result.data = std::option::Option::Some(
                                crate::model::call_annotation::Data::IntentMatchData(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::IntentMatchData>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__phrase_match_data => {
                            if !fields.insert(__FieldTag::__phrase_match_data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for phrase_match_data",
                                ));
                            }
                            if result.data.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data`, a oneof with full ID .google.cloud.contactcenterinsights.v1.CallAnnotation.phrase_match_data, latest field was phraseMatchData",
                                ));
                            }
                            result.data = std::option::Option::Some(
                                crate::model::call_annotation::Data::PhraseMatchData(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::PhraseMatchData>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__issue_match_data => {
                            if !fields.insert(__FieldTag::__issue_match_data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for issue_match_data",
                                ));
                            }
                            if result.data.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data`, a oneof with full ID .google.cloud.contactcenterinsights.v1.CallAnnotation.issue_match_data, latest field was issueMatchData",
                                ));
                            }
                            result.data = std::option::Option::Some(
                                crate::model::call_annotation::Data::IssueMatchData(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::IssueMatchData>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__channel_tag => {
                            if !fields.insert(__FieldTag::__channel_tag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for channel_tag",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.channel_tag = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__annotation_start_boundary => {
                            if !fields.insert(__FieldTag::__annotation_start_boundary) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotation_start_boundary",
                                ));
                            }
                            result.annotation_start_boundary = map.next_value::<std::option::Option<crate::model::AnnotationBoundary>>()?
                                ;
                        }
                        __FieldTag::__annotation_end_boundary => {
                            if !fields.insert(__FieldTag::__annotation_end_boundary) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotation_end_boundary",
                                ));
                            }
                            result.annotation_end_boundary = map.next_value::<std::option::Option<crate::model::AnnotationBoundary>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CallAnnotation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.interruption_data() {
            state.serialize_entry("interruptionData", value)?;
        }
        if let Some(value) = self.sentiment_data() {
            state.serialize_entry("sentimentData", value)?;
        }
        if let Some(value) = self.silence_data() {
            state.serialize_entry("silenceData", value)?;
        }
        if let Some(value) = self.hold_data() {
            state.serialize_entry("holdData", value)?;
        }
        if let Some(value) = self.entity_mention_data() {
            state.serialize_entry("entityMentionData", value)?;
        }
        if let Some(value) = self.intent_match_data() {
            state.serialize_entry("intentMatchData", value)?;
        }
        if let Some(value) = self.phrase_match_data() {
            state.serialize_entry("phraseMatchData", value)?;
        }
        if let Some(value) = self.issue_match_data() {
            state.serialize_entry("issueMatchData", value)?;
        }
        if !wkt::internal::is_default(&self.channel_tag) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("channelTag", &__With(&self.channel_tag))?;
        }
        if self.annotation_start_boundary.is_some() {
            state.serialize_entry("annotationStartBoundary", &self.annotation_start_boundary)?;
        }
        if self.annotation_end_boundary.is_some() {
            state.serialize_entry("annotationEndBoundary", &self.annotation_end_boundary)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CallAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CallAnnotation");
        debug_struct.field("channel_tag", &self.channel_tag);
        debug_struct.field("annotation_start_boundary", &self.annotation_start_boundary);
        debug_struct.field("annotation_end_boundary", &self.annotation_end_boundary);
        debug_struct.field("data", &self.data);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [CallAnnotation].
pub mod call_annotation {
    #[allow(unused_imports)]
    use super::*;

    /// The data in the annotation.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Data {
        /// Data specifying an interruption.
        InterruptionData(std::boxed::Box<crate::model::InterruptionData>),
        /// Data specifying sentiment.
        SentimentData(std::boxed::Box<crate::model::SentimentData>),
        /// Data specifying silence.
        SilenceData(std::boxed::Box<crate::model::SilenceData>),
        /// Data specifying a hold.
        HoldData(std::boxed::Box<crate::model::HoldData>),
        /// Data specifying an entity mention.
        EntityMentionData(std::boxed::Box<crate::model::EntityMentionData>),
        /// Data specifying an intent match.
        IntentMatchData(std::boxed::Box<crate::model::IntentMatchData>),
        /// Data specifying a phrase match.
        PhraseMatchData(std::boxed::Box<crate::model::PhraseMatchData>),
        /// Data specifying an issue match.
        IssueMatchData(std::boxed::Box<crate::model::IssueMatchData>),
    }
}

/// A point in a conversation that marks the start or the end of an annotation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AnnotationBoundary {
    /// The index in the sequence of transcribed pieces of the conversation where
    /// the boundary is located. This index starts at zero.
    pub transcript_index: i32,

    /// A detailed boundary, which describes a more specific point.
    pub detailed_boundary: std::option::Option<crate::model::annotation_boundary::DetailedBoundary>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnnotationBoundary {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [transcript_index][crate::model::AnnotationBoundary::transcript_index].
    pub fn set_transcript_index<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.transcript_index = v.into();
        self
    }

    /// Sets the value of [detailed_boundary][crate::model::AnnotationBoundary::detailed_boundary].
    ///
    /// Note that all the setters affecting `detailed_boundary` are mutually
    /// exclusive.
    pub fn set_detailed_boundary<
        T: std::convert::Into<
                std::option::Option<crate::model::annotation_boundary::DetailedBoundary>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.detailed_boundary = v.into();
        self
    }

    /// The value of [detailed_boundary][crate::model::AnnotationBoundary::detailed_boundary]
    /// if it holds a `WordIndex`, `None` if the field is not set or
    /// holds a different branch.
    pub fn word_index(&self) -> std::option::Option<&i32> {
        #[allow(unreachable_patterns)]
        self.detailed_boundary.as_ref().and_then(|v| match v {
            crate::model::annotation_boundary::DetailedBoundary::WordIndex(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [detailed_boundary][crate::model::AnnotationBoundary::detailed_boundary]
    /// to hold a `WordIndex`.
    ///
    /// Note that all the setters affecting `detailed_boundary` are
    /// mutually exclusive.
    pub fn set_word_index<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.detailed_boundary = std::option::Option::Some(
            crate::model::annotation_boundary::DetailedBoundary::WordIndex(v.into()),
        );
        self
    }
}

impl wkt::message::Message for AnnotationBoundary {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.AnnotationBoundary"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AnnotationBoundary {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __word_index,
            __transcript_index,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AnnotationBoundary")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "wordIndex" => Ok(__FieldTag::__word_index),
                            "word_index" => Ok(__FieldTag::__word_index),
                            "transcriptIndex" => Ok(__FieldTag::__transcript_index),
                            "transcript_index" => Ok(__FieldTag::__transcript_index),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AnnotationBoundary;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnnotationBoundary")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__word_index => {
                            if !fields.insert(__FieldTag::__word_index) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for word_index",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.detailed_boundary.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `detailed_boundary`, a oneof with full ID .google.cloud.contactcenterinsights.v1.AnnotationBoundary.word_index, latest field was wordIndex",
                                ));
                            }
                            result.detailed_boundary = std::option::Option::Some(
                                crate::model::annotation_boundary::DetailedBoundary::WordIndex(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__transcript_index => {
                            if !fields.insert(__FieldTag::__transcript_index) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transcript_index",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.transcript_index =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AnnotationBoundary {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.word_index() {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("wordIndex", &__With(value))?;
        }
        if !wkt::internal::is_default(&self.transcript_index) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("transcriptIndex", &__With(&self.transcript_index))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AnnotationBoundary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AnnotationBoundary");
        debug_struct.field("transcript_index", &self.transcript_index);
        debug_struct.field("detailed_boundary", &self.detailed_boundary);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AnnotationBoundary].
pub mod annotation_boundary {
    #[allow(unused_imports)]
    use super::*;

    /// A detailed boundary, which describes a more specific point.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DetailedBoundary {
        /// The word index of this boundary with respect to the first word in the
        /// transcript piece. This index starts at zero.
        WordIndex(i32),
    }
}

/// The data for an entity annotation.
/// Represents a phrase in the conversation that is a known entity, such
/// as a person, an organization, or location.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Entity {
    /// The representative name for the entity.
    pub display_name: std::string::String,

    /// The entity type.
    pub r#type: crate::model::entity::Type,

    /// Metadata associated with the entity.
    ///
    /// For most entity types, the metadata is a Wikipedia URL (`wikipedia_url`)
    /// and Knowledge Graph MID (`mid`), if they are available. For the metadata
    /// associated with other entity types, see the Type table below.
    pub metadata: std::collections::HashMap<std::string::String, std::string::String>,

    /// The salience score associated with the entity in the [0, 1.0] range.
    ///
    /// The salience score for an entity provides information about the
    /// importance or centrality of that entity to the entire document text.
    /// Scores closer to 0 are less salient, while scores closer to 1.0 are highly
    /// salient.
    pub salience: f32,

    /// The aggregate sentiment expressed for this entity in the conversation.
    pub sentiment: std::option::Option<crate::model::SentimentData>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Entity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_name][crate::model::Entity::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::Entity::type].
    pub fn set_type<T: std::convert::Into<crate::model::entity::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::Entity::metadata].
    pub fn set_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [salience][crate::model::Entity::salience].
    pub fn set_salience<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.salience = v.into();
        self
    }

    /// Sets the value of [sentiment][crate::model::Entity::sentiment].
    pub fn set_sentiment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SentimentData>,
    {
        self.sentiment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sentiment][crate::model::Entity::sentiment].
    pub fn set_or_clear_sentiment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SentimentData>,
    {
        self.sentiment = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Entity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.Entity"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Entity {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __type,
            __metadata,
            __salience,
            __sentiment,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Entity")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "type" => Ok(__FieldTag::__type),
                            "metadata" => Ok(__FieldTag::__metadata),
                            "salience" => Ok(__FieldTag::__salience),
                            "sentiment" => Ok(__FieldTag::__sentiment),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Entity;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Entity")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<crate::model::entity::Type>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata",
                                ));
                            }
                            result.metadata = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__salience => {
                            if !fields.insert(__FieldTag::__salience) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for salience",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.salience = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__sentiment => {
                            if !fields.insert(__FieldTag::__sentiment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sentiment",
                                ));
                            }
                            result.sentiment = map
                                .next_value::<std::option::Option<crate::model::SentimentData>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Entity {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.metadata.is_empty() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !wkt::internal::is_default(&self.salience) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("salience", &__With(&self.salience))?;
        }
        if self.sentiment.is_some() {
            state.serialize_entry("sentiment", &self.sentiment)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Entity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Entity");
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("metadata", &self.metadata);
        debug_struct.field("salience", &self.salience);
        debug_struct.field("sentiment", &self.sentiment);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Entity].
pub mod entity {
    #[allow(unused_imports)]
    use super::*;

    /// The type of the entity. For most entity types, the associated metadata is a
    /// Wikipedia URL (`wikipedia_url`) and Knowledge Graph MID (`mid`). The table
    /// below lists the associated fields for entities that have different
    /// metadata.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Unspecified.
        Unspecified,
        /// Person.
        Person,
        /// Location.
        Location,
        /// Organization.
        Organization,
        /// Event.
        Event,
        /// Artwork.
        WorkOfArt,
        /// Consumer product.
        ConsumerGood,
        /// Other types of entities.
        Other,
        /// Phone number.
        ///
        /// The metadata lists the phone number (formatted according to local
        /// convention), plus whichever additional elements appear in the text:
        ///
        /// * `number` - The actual number, broken down into sections according to
        ///   local convention.
        /// * `national_prefix` - Country code, if detected.
        /// * `area_code` - Region or area code, if detected.
        /// * `extension` - Phone extension (to be dialed after connection), if
        ///   detected.
        PhoneNumber,
        /// Address.
        ///
        /// The metadata identifies the street number and locality plus whichever
        /// additional elements appear in the text:
        ///
        /// * `street_number` - Street number.
        /// * `locality` - City or town.
        /// * `street_name` - Street/route name, if detected.
        /// * `postal_code` - Postal code, if detected.
        /// * `country` - Country, if detected.
        /// * `broad_region` - Administrative area, such as the state, if detected.
        /// * `narrow_region` - Smaller administrative area, such as county, if
        ///   detected.
        /// * `sublocality` - Used in Asian addresses to demark a district within a
        ///   city, if detected.
        Address,
        /// Date.
        ///
        /// The metadata identifies the components of the date:
        ///
        /// * `year` - Four digit year, if detected.
        /// * `month` - Two digit month number, if detected.
        /// * `day` - Two digit day number, if detected.
        Date,
        /// Number.
        ///
        /// The metadata is the number itself.
        Number,
        /// Price.
        ///
        /// The metadata identifies the `value` and `currency`.
        Price,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Person => std::option::Option::Some(1),
                Self::Location => std::option::Option::Some(2),
                Self::Organization => std::option::Option::Some(3),
                Self::Event => std::option::Option::Some(4),
                Self::WorkOfArt => std::option::Option::Some(5),
                Self::ConsumerGood => std::option::Option::Some(6),
                Self::Other => std::option::Option::Some(7),
                Self::PhoneNumber => std::option::Option::Some(9),
                Self::Address => std::option::Option::Some(10),
                Self::Date => std::option::Option::Some(11),
                Self::Number => std::option::Option::Some(12),
                Self::Price => std::option::Option::Some(13),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::Person => std::option::Option::Some("PERSON"),
                Self::Location => std::option::Option::Some("LOCATION"),
                Self::Organization => std::option::Option::Some("ORGANIZATION"),
                Self::Event => std::option::Option::Some("EVENT"),
                Self::WorkOfArt => std::option::Option::Some("WORK_OF_ART"),
                Self::ConsumerGood => std::option::Option::Some("CONSUMER_GOOD"),
                Self::Other => std::option::Option::Some("OTHER"),
                Self::PhoneNumber => std::option::Option::Some("PHONE_NUMBER"),
                Self::Address => std::option::Option::Some("ADDRESS"),
                Self::Date => std::option::Option::Some("DATE"),
                Self::Number => std::option::Option::Some("NUMBER"),
                Self::Price => std::option::Option::Some("PRICE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Person,
                2 => Self::Location,
                3 => Self::Organization,
                4 => Self::Event,
                5 => Self::WorkOfArt,
                6 => Self::ConsumerGood,
                7 => Self::Other,
                9 => Self::PhoneNumber,
                10 => Self::Address,
                11 => Self::Date,
                12 => Self::Number,
                13 => Self::Price,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "PERSON" => Self::Person,
                "LOCATION" => Self::Location,
                "ORGANIZATION" => Self::Organization,
                "EVENT" => Self::Event,
                "WORK_OF_ART" => Self::WorkOfArt,
                "CONSUMER_GOOD" => Self::ConsumerGood,
                "OTHER" => Self::Other,
                "PHONE_NUMBER" => Self::PhoneNumber,
                "ADDRESS" => Self::Address,
                "DATE" => Self::Date,
                "NUMBER" => Self::Number,
                "PRICE" => Self::Price,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Person => serializer.serialize_i32(1),
                Self::Location => serializer.serialize_i32(2),
                Self::Organization => serializer.serialize_i32(3),
                Self::Event => serializer.serialize_i32(4),
                Self::WorkOfArt => serializer.serialize_i32(5),
                Self::ConsumerGood => serializer.serialize_i32(6),
                Self::Other => serializer.serialize_i32(7),
                Self::PhoneNumber => serializer.serialize_i32(9),
                Self::Address => serializer.serialize_i32(10),
                Self::Date => serializer.serialize_i32(11),
                Self::Number => serializer.serialize_i32(12),
                Self::Price => serializer.serialize_i32(13),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.contactcenterinsights.v1.Entity.Type",
            ))
        }
    }
}

/// The data for an intent.
/// Represents a detected intent in the conversation, for example MAKES_PROMISE.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Intent {
    /// The unique identifier of the intent.
    pub id: std::string::String,

    /// The human-readable name of the intent.
    pub display_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Intent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::Intent::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Intent::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }
}

impl wkt::message::Message for Intent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.Intent"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Intent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            __display_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Intent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Intent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Intent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Intent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Intent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Intent");
        debug_struct.field("id", &self.id);
        debug_struct.field("display_name", &self.display_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The data for a matched phrase matcher.
/// Represents information identifying a phrase matcher for a given match.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PhraseMatchData {
    /// The unique identifier (the resource name) of the phrase matcher.
    pub phrase_matcher: std::string::String,

    /// The human-readable name of the phrase matcher.
    pub display_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PhraseMatchData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [phrase_matcher][crate::model::PhraseMatchData::phrase_matcher].
    pub fn set_phrase_matcher<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.phrase_matcher = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::PhraseMatchData::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }
}

impl wkt::message::Message for PhraseMatchData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.PhraseMatchData"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PhraseMatchData {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __phrase_matcher,
            __display_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PhraseMatchData")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "phraseMatcher" => Ok(__FieldTag::__phrase_matcher),
                            "phrase_matcher" => Ok(__FieldTag::__phrase_matcher),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PhraseMatchData;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PhraseMatchData")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__phrase_matcher => {
                            if !fields.insert(__FieldTag::__phrase_matcher) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for phrase_matcher",
                                ));
                            }
                            result.phrase_matcher = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PhraseMatchData {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.phrase_matcher.is_empty() {
            state.serialize_entry("phraseMatcher", &self.phrase_matcher)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PhraseMatchData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PhraseMatchData");
        debug_struct.field("phrase_matcher", &self.phrase_matcher);
        debug_struct.field("display_name", &self.display_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The data for a Dialogflow intent.
/// Represents a detected intent in the conversation, e.g. MAKES_PROMISE.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DialogflowIntent {
    /// The human-readable name of the intent.
    pub display_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DialogflowIntent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_name][crate::model::DialogflowIntent::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }
}

impl wkt::message::Message for DialogflowIntent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.DialogflowIntent"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DialogflowIntent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DialogflowIntent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DialogflowIntent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DialogflowIntent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DialogflowIntent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DialogflowIntent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DialogflowIntent");
        debug_struct.field("display_name", &self.display_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The data for an interruption annotation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InterruptionData {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InterruptionData {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for InterruptionData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.InterruptionData"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InterruptionData {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InterruptionData")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InterruptionData;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InterruptionData")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InterruptionData {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for InterruptionData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InterruptionData");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The data for a silence annotation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SilenceData {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SilenceData {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for SilenceData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.SilenceData"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SilenceData {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SilenceData")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SilenceData;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SilenceData")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SilenceData {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SilenceData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SilenceData");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The data for a hold annotation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct HoldData {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HoldData {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for HoldData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.HoldData"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for HoldData {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HoldData")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = HoldData;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HoldData")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for HoldData {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for HoldData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("HoldData");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The data for an entity mention annotation.
/// This represents a mention of an `Entity` in the conversation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EntityMentionData {
    /// The key of this entity in conversation entities.
    /// Can be used to retrieve the exact `Entity` this mention is attached to.
    pub entity_unique_id: std::string::String,

    /// The type of the entity mention.
    pub r#type: crate::model::entity_mention_data::MentionType,

    /// Sentiment expressed for this mention of the entity.
    pub sentiment: std::option::Option<crate::model::SentimentData>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EntityMentionData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entity_unique_id][crate::model::EntityMentionData::entity_unique_id].
    pub fn set_entity_unique_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.entity_unique_id = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::EntityMentionData::type].
    pub fn set_type<T: std::convert::Into<crate::model::entity_mention_data::MentionType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [sentiment][crate::model::EntityMentionData::sentiment].
    pub fn set_sentiment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SentimentData>,
    {
        self.sentiment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sentiment][crate::model::EntityMentionData::sentiment].
    pub fn set_or_clear_sentiment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SentimentData>,
    {
        self.sentiment = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for EntityMentionData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.EntityMentionData"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EntityMentionData {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entity_unique_id,
            __type,
            __sentiment,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EntityMentionData")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entityUniqueId" => Ok(__FieldTag::__entity_unique_id),
                            "entity_unique_id" => Ok(__FieldTag::__entity_unique_id),
                            "type" => Ok(__FieldTag::__type),
                            "sentiment" => Ok(__FieldTag::__sentiment),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EntityMentionData;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EntityMentionData")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entity_unique_id => {
                            if !fields.insert(__FieldTag::__entity_unique_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity_unique_id",
                                ));
                            }
                            result.entity_unique_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type =
                                map.next_value::<std::option::Option<
                                    crate::model::entity_mention_data::MentionType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sentiment => {
                            if !fields.insert(__FieldTag::__sentiment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sentiment",
                                ));
                            }
                            result.sentiment = map
                                .next_value::<std::option::Option<crate::model::SentimentData>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EntityMentionData {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.entity_unique_id.is_empty() {
            state.serialize_entry("entityUniqueId", &self.entity_unique_id)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if self.sentiment.is_some() {
            state.serialize_entry("sentiment", &self.sentiment)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for EntityMentionData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EntityMentionData");
        debug_struct.field("entity_unique_id", &self.entity_unique_id);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("sentiment", &self.sentiment);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [EntityMentionData].
pub mod entity_mention_data {
    #[allow(unused_imports)]
    use super::*;

    /// The supported types of mentions.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MentionType {
        /// Unspecified.
        Unspecified,
        /// Proper noun.
        Proper,
        /// Common noun (or noun compound).
        Common,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MentionType::value] or
        /// [MentionType::name].
        UnknownValue(mention_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod mention_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl MentionType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Proper => std::option::Option::Some(1),
                Self::Common => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MENTION_TYPE_UNSPECIFIED"),
                Self::Proper => std::option::Option::Some("PROPER"),
                Self::Common => std::option::Option::Some("COMMON"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for MentionType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for MentionType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for MentionType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Proper,
                2 => Self::Common,
                _ => Self::UnknownValue(mention_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for MentionType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MENTION_TYPE_UNSPECIFIED" => Self::Unspecified,
                "PROPER" => Self::Proper,
                "COMMON" => Self::Common,
                _ => Self::UnknownValue(mention_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for MentionType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Proper => serializer.serialize_i32(1),
                Self::Common => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for MentionType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MentionType>::new(
                ".google.cloud.contactcenterinsights.v1.EntityMentionData.MentionType",
            ))
        }
    }
}

/// The data for an intent match.
/// Represents an intent match for a text segment in the conversation. A text
/// segment can be part of a sentence, a complete sentence, or an utterance
/// with multiple sentences.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct IntentMatchData {
    /// The id of the matched intent.
    /// Can be used to retrieve the corresponding intent information.
    pub intent_unique_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IntentMatchData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [intent_unique_id][crate::model::IntentMatchData::intent_unique_id].
    pub fn set_intent_unique_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.intent_unique_id = v.into();
        self
    }
}

impl wkt::message::Message for IntentMatchData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.IntentMatchData"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for IntentMatchData {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __intent_unique_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IntentMatchData")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "intentUniqueId" => Ok(__FieldTag::__intent_unique_id),
                            "intent_unique_id" => Ok(__FieldTag::__intent_unique_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = IntentMatchData;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IntentMatchData")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__intent_unique_id => {
                            if !fields.insert(__FieldTag::__intent_unique_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for intent_unique_id",
                                ));
                            }
                            result.intent_unique_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for IntentMatchData {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.intent_unique_id.is_empty() {
            state.serialize_entry("intentUniqueId", &self.intent_unique_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for IntentMatchData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IntentMatchData");
        debug_struct.field("intent_unique_id", &self.intent_unique_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The data for a sentiment annotation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SentimentData {
    /// A non-negative number from 0 to infinity which represents the abolute
    /// magnitude of sentiment regardless of score.
    pub magnitude: f32,

    /// The sentiment score between -1.0 (negative) and 1.0 (positive).
    pub score: f32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SentimentData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [magnitude][crate::model::SentimentData::magnitude].
    pub fn set_magnitude<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.magnitude = v.into();
        self
    }

    /// Sets the value of [score][crate::model::SentimentData::score].
    pub fn set_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }
}

impl wkt::message::Message for SentimentData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.SentimentData"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SentimentData {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __magnitude,
            __score,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SentimentData")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "magnitude" => Ok(__FieldTag::__magnitude),
                            "score" => Ok(__FieldTag::__score),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SentimentData;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SentimentData")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__magnitude => {
                            if !fields.insert(__FieldTag::__magnitude) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for magnitude",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.magnitude = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__score => {
                            if !fields.insert(__FieldTag::__score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for score",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.score = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SentimentData {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.magnitude) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("magnitude", &__With(&self.magnitude))?;
        }
        if !wkt::internal::is_default(&self.score) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("score", &__With(&self.score))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SentimentData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SentimentData");
        debug_struct.field("magnitude", &self.magnitude);
        debug_struct.field("score", &self.score);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The data for an issue match annotation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct IssueMatchData {
    /// Information about the issue's assignment.
    pub issue_assignment: std::option::Option<crate::model::IssueAssignment>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IssueMatchData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [issue_assignment][crate::model::IssueMatchData::issue_assignment].
    pub fn set_issue_assignment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::IssueAssignment>,
    {
        self.issue_assignment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [issue_assignment][crate::model::IssueMatchData::issue_assignment].
    pub fn set_or_clear_issue_assignment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::IssueAssignment>,
    {
        self.issue_assignment = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for IssueMatchData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.IssueMatchData"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for IssueMatchData {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __issue_assignment,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IssueMatchData")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "issueAssignment" => Ok(__FieldTag::__issue_assignment),
                            "issue_assignment" => Ok(__FieldTag::__issue_assignment),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = IssueMatchData;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IssueMatchData")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__issue_assignment => {
                            if !fields.insert(__FieldTag::__issue_assignment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for issue_assignment",
                                ));
                            }
                            result.issue_assignment = map
                                .next_value::<std::option::Option<crate::model::IssueAssignment>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for IssueMatchData {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.issue_assignment.is_some() {
            state.serialize_entry("issueAssignment", &self.issue_assignment)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for IssueMatchData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IssueMatchData");
        debug_struct.field("issue_assignment", &self.issue_assignment);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The issue model resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct IssueModel {
    /// Immutable. The resource name of the issue model.
    /// Format:
    /// projects/{project}/locations/{location}/issueModels/{issue_model}
    pub name: std::string::String,

    /// The representative name for the issue model.
    pub display_name: std::string::String,

    /// Output only. The time at which this issue model was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The most recent time at which the issue model was updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Number of issues in this issue model.
    pub issue_count: i64,

    /// Output only. State of the model.
    pub state: crate::model::issue_model::State,

    /// Configs for the input data that used to create the issue model.
    pub input_data_config: std::option::Option<crate::model::issue_model::InputDataConfig>,

    /// Output only. Immutable. The issue model's label statistics on its training
    /// data.
    pub training_stats: std::option::Option<crate::model::IssueModelLabelStats>,

    /// Type of the model.
    pub model_type: crate::model::issue_model::ModelType,

    /// Language of the model.
    pub language_code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IssueModel {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::IssueModel::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::IssueModel::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::IssueModel::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::IssueModel::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::IssueModel::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::IssueModel::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [issue_count][crate::model::IssueModel::issue_count].
    pub fn set_issue_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.issue_count = v.into();
        self
    }

    /// Sets the value of [state][crate::model::IssueModel::state].
    pub fn set_state<T: std::convert::Into<crate::model::issue_model::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [input_data_config][crate::model::IssueModel::input_data_config].
    pub fn set_input_data_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::issue_model::InputDataConfig>,
    {
        self.input_data_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [input_data_config][crate::model::IssueModel::input_data_config].
    pub fn set_or_clear_input_data_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::issue_model::InputDataConfig>,
    {
        self.input_data_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [training_stats][crate::model::IssueModel::training_stats].
    pub fn set_training_stats<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::IssueModelLabelStats>,
    {
        self.training_stats = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [training_stats][crate::model::IssueModel::training_stats].
    pub fn set_or_clear_training_stats<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::IssueModelLabelStats>,
    {
        self.training_stats = v.map(|x| x.into());
        self
    }

    /// Sets the value of [model_type][crate::model::IssueModel::model_type].
    pub fn set_model_type<T: std::convert::Into<crate::model::issue_model::ModelType>>(
        mut self,
        v: T,
    ) -> Self {
        self.model_type = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::IssueModel::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }
}

impl wkt::message::Message for IssueModel {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.IssueModel"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for IssueModel {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __create_time,
            __update_time,
            __issue_count,
            __state,
            __input_data_config,
            __training_stats,
            __model_type,
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IssueModel")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "issueCount" => Ok(__FieldTag::__issue_count),
                            "issue_count" => Ok(__FieldTag::__issue_count),
                            "state" => Ok(__FieldTag::__state),
                            "inputDataConfig" => Ok(__FieldTag::__input_data_config),
                            "input_data_config" => Ok(__FieldTag::__input_data_config),
                            "trainingStats" => Ok(__FieldTag::__training_stats),
                            "training_stats" => Ok(__FieldTag::__training_stats),
                            "modelType" => Ok(__FieldTag::__model_type),
                            "model_type" => Ok(__FieldTag::__model_type),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = IssueModel;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IssueModel")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__issue_count => {
                            if !fields.insert(__FieldTag::__issue_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for issue_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.issue_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::issue_model::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__input_data_config => {
                            if !fields.insert(__FieldTag::__input_data_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input_data_config",
                                ));
                            }
                            result.input_data_config = map.next_value::<std::option::Option<crate::model::issue_model::InputDataConfig>>()?
                                ;
                        }
                        __FieldTag::__training_stats => {
                            if !fields.insert(__FieldTag::__training_stats) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for training_stats",
                                ));
                            }
                            result.training_stats = map.next_value::<std::option::Option<crate::model::IssueModelLabelStats>>()?
                                ;
                        }
                        __FieldTag::__model_type => {
                            if !fields.insert(__FieldTag::__model_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model_type",
                                ));
                            }
                            result.model_type = map.next_value::<std::option::Option<crate::model::issue_model::ModelType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for IssueModel {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !wkt::internal::is_default(&self.issue_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("issueCount", &__With(&self.issue_count))?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.input_data_config.is_some() {
            state.serialize_entry("inputDataConfig", &self.input_data_config)?;
        }
        if self.training_stats.is_some() {
            state.serialize_entry("trainingStats", &self.training_stats)?;
        }
        if !wkt::internal::is_default(&self.model_type) {
            state.serialize_entry("modelType", &self.model_type)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for IssueModel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IssueModel");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("issue_count", &self.issue_count);
        debug_struct.field("state", &self.state);
        debug_struct.field("input_data_config", &self.input_data_config);
        debug_struct.field("training_stats", &self.training_stats);
        debug_struct.field("model_type", &self.model_type);
        debug_struct.field("language_code", &self.language_code);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [IssueModel].
pub mod issue_model {
    #[allow(unused_imports)]
    use super::*;

    /// Configs for the input data used to create the issue model.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct InputDataConfig {
        /// Medium of conversations used in training data. This field is being
        /// deprecated. To specify the medium to be used in training a new issue
        /// model, set the `medium` field on `filter`.
        #[deprecated]
        pub medium: crate::model::conversation::Medium,

        /// Output only. Number of conversations used in training. Output only.
        pub training_conversations_count: i64,

        /// A filter to reduce the conversations used for training the model to a
        /// specific subset.
        pub filter: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl InputDataConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [medium][crate::model::issue_model::InputDataConfig::medium].
        #[deprecated]
        pub fn set_medium<T: std::convert::Into<crate::model::conversation::Medium>>(
            mut self,
            v: T,
        ) -> Self {
            self.medium = v.into();
            self
        }

        /// Sets the value of [training_conversations_count][crate::model::issue_model::InputDataConfig::training_conversations_count].
        pub fn set_training_conversations_count<T: std::convert::Into<i64>>(
            mut self,
            v: T,
        ) -> Self {
            self.training_conversations_count = v.into();
            self
        }

        /// Sets the value of [filter][crate::model::issue_model::InputDataConfig::filter].
        pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.filter = v.into();
            self
        }
    }

    impl wkt::message::Message for InputDataConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.IssueModel.InputDataConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for InputDataConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __medium,
                __training_conversations_count,
                __filter,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for InputDataConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "medium" => Ok(__FieldTag::__medium),
                                "trainingConversationsCount" => {
                                    Ok(__FieldTag::__training_conversations_count)
                                }
                                "training_conversations_count" => {
                                    Ok(__FieldTag::__training_conversations_count)
                                }
                                "filter" => Ok(__FieldTag::__filter),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = InputDataConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct InputDataConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__medium => {
                                if !fields.insert(__FieldTag::__medium) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for medium",
                                    ));
                                }
                                result.medium = map.next_value::<std::option::Option<crate::model::conversation::Medium>>()?.unwrap_or_default();
                            }
                            __FieldTag::__training_conversations_count => {
                                if !fields.insert(__FieldTag::__training_conversations_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for training_conversations_count",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.training_conversations_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__filter => {
                                if !fields.insert(__FieldTag::__filter) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for filter",
                                    ));
                                }
                                result.filter = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for InputDataConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.medium) {
                state.serialize_entry("medium", &self.medium)?;
            }
            if !wkt::internal::is_default(&self.training_conversations_count) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "trainingConversationsCount",
                    &__With(&self.training_conversations_count),
                )?;
            }
            if !self.filter.is_empty() {
                state.serialize_entry("filter", &self.filter)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for InputDataConfig {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("InputDataConfig");
            debug_struct.field("medium", &self.medium);
            debug_struct.field(
                "training_conversations_count",
                &self.training_conversations_count,
            );
            debug_struct.field("filter", &self.filter);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// State of the model.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified.
        Unspecified,
        /// Model is not deployed but is ready to deploy.
        Undeployed,
        /// Model is being deployed.
        Deploying,
        /// Model is deployed and is ready to be used. A model can only be used in
        /// analysis if it's in this state.
        Deployed,
        /// Model is being undeployed.
        Undeploying,
        /// Model is being deleted.
        Deleting,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Undeployed => std::option::Option::Some(1),
                Self::Deploying => std::option::Option::Some(2),
                Self::Deployed => std::option::Option::Some(3),
                Self::Undeploying => std::option::Option::Some(4),
                Self::Deleting => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Undeployed => std::option::Option::Some("UNDEPLOYED"),
                Self::Deploying => std::option::Option::Some("DEPLOYING"),
                Self::Deployed => std::option::Option::Some("DEPLOYED"),
                Self::Undeploying => std::option::Option::Some("UNDEPLOYING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Undeployed,
                2 => Self::Deploying,
                3 => Self::Deployed,
                4 => Self::Undeploying,
                5 => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "UNDEPLOYED" => Self::Undeployed,
                "DEPLOYING" => Self::Deploying,
                "DEPLOYED" => Self::Deployed,
                "UNDEPLOYING" => Self::Undeploying,
                "DELETING" => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Undeployed => serializer.serialize_i32(1),
                Self::Deploying => serializer.serialize_i32(2),
                Self::Deployed => serializer.serialize_i32(3),
                Self::Undeploying => serializer.serialize_i32(4),
                Self::Deleting => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.contactcenterinsights.v1.IssueModel.State",
            ))
        }
    }

    /// Type of the model.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ModelType {
        /// Unspecified model type.
        Unspecified,
        /// Type V1.
        TypeV1,
        /// Type V2.
        TypeV2,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ModelType::value] or
        /// [ModelType::name].
        UnknownValue(model_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod model_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ModelType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::TypeV1 => std::option::Option::Some(1),
                Self::TypeV2 => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MODEL_TYPE_UNSPECIFIED"),
                Self::TypeV1 => std::option::Option::Some("TYPE_V1"),
                Self::TypeV2 => std::option::Option::Some("TYPE_V2"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ModelType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ModelType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ModelType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::TypeV1,
                2 => Self::TypeV2,
                _ => Self::UnknownValue(model_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ModelType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MODEL_TYPE_UNSPECIFIED" => Self::Unspecified,
                "TYPE_V1" => Self::TypeV1,
                "TYPE_V2" => Self::TypeV2,
                _ => Self::UnknownValue(model_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ModelType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::TypeV1 => serializer.serialize_i32(1),
                Self::TypeV2 => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ModelType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ModelType>::new(
                ".google.cloud.contactcenterinsights.v1.IssueModel.ModelType",
            ))
        }
    }
}

/// The issue resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Issue {
    /// Immutable. The resource name of the issue.
    /// Format:
    /// projects/{project}/locations/{location}/issueModels/{issue_model}/issues/{issue}
    pub name: std::string::String,

    /// The representative name for the issue.
    pub display_name: std::string::String,

    /// Output only. The time at which this issue was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The most recent time that this issue was updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Resource names of the sample representative utterances that
    /// match to this issue.
    pub sample_utterances: std::vec::Vec<std::string::String>,

    /// Representative description of the issue.
    pub display_description: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Issue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Issue::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Issue::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Issue::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Issue::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Issue::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Issue::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [sample_utterances][crate::model::Issue::sample_utterances].
    pub fn set_sample_utterances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.sample_utterances = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [display_description][crate::model::Issue::display_description].
    pub fn set_display_description<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.display_description = v.into();
        self
    }
}

impl wkt::message::Message for Issue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.Issue"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Issue {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __create_time,
            __update_time,
            __sample_utterances,
            __display_description,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Issue")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "sampleUtterances" => Ok(__FieldTag::__sample_utterances),
                            "sample_utterances" => Ok(__FieldTag::__sample_utterances),
                            "displayDescription" => Ok(__FieldTag::__display_description),
                            "display_description" => Ok(__FieldTag::__display_description),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Issue;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Issue")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__sample_utterances => {
                            if !fields.insert(__FieldTag::__sample_utterances) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sample_utterances",
                                ));
                            }
                            result.sample_utterances = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__display_description => {
                            if !fields.insert(__FieldTag::__display_description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_description",
                                ));
                            }
                            result.display_description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Issue {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.sample_utterances.is_empty() {
            state.serialize_entry("sampleUtterances", &self.sample_utterances)?;
        }
        if !self.display_description.is_empty() {
            state.serialize_entry("displayDescription", &self.display_description)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Issue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Issue");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("sample_utterances", &self.sample_utterances);
        debug_struct.field("display_description", &self.display_description);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Aggregated statistics about an issue model.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct IssueModelLabelStats {
    /// Number of conversations the issue model has analyzed at this point in time.
    pub analyzed_conversations_count: i64,

    /// Number of analyzed conversations for which no issue was applicable at this
    /// point in time.
    pub unclassified_conversations_count: i64,

    /// Statistics on each issue. Key is the issue's resource name.
    pub issue_stats: std::collections::HashMap<
        std::string::String,
        crate::model::issue_model_label_stats::IssueStats,
    >,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IssueModelLabelStats {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [analyzed_conversations_count][crate::model::IssueModelLabelStats::analyzed_conversations_count].
    pub fn set_analyzed_conversations_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.analyzed_conversations_count = v.into();
        self
    }

    /// Sets the value of [unclassified_conversations_count][crate::model::IssueModelLabelStats::unclassified_conversations_count].
    pub fn set_unclassified_conversations_count<T: std::convert::Into<i64>>(
        mut self,
        v: T,
    ) -> Self {
        self.unclassified_conversations_count = v.into();
        self
    }

    /// Sets the value of [issue_stats][crate::model::IssueModelLabelStats::issue_stats].
    pub fn set_issue_stats<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::issue_model_label_stats::IssueStats>,
    {
        use std::iter::Iterator;
        self.issue_stats = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for IssueModelLabelStats {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.IssueModelLabelStats"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for IssueModelLabelStats {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __analyzed_conversations_count,
            __unclassified_conversations_count,
            __issue_stats,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IssueModelLabelStats")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "analyzedConversationsCount" => {
                                Ok(__FieldTag::__analyzed_conversations_count)
                            }
                            "analyzed_conversations_count" => {
                                Ok(__FieldTag::__analyzed_conversations_count)
                            }
                            "unclassifiedConversationsCount" => {
                                Ok(__FieldTag::__unclassified_conversations_count)
                            }
                            "unclassified_conversations_count" => {
                                Ok(__FieldTag::__unclassified_conversations_count)
                            }
                            "issueStats" => Ok(__FieldTag::__issue_stats),
                            "issue_stats" => Ok(__FieldTag::__issue_stats),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = IssueModelLabelStats;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IssueModelLabelStats")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__analyzed_conversations_count => {
                            if !fields.insert(__FieldTag::__analyzed_conversations_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for analyzed_conversations_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.analyzed_conversations_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__unclassified_conversations_count => {
                            if !fields.insert(__FieldTag::__unclassified_conversations_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unclassified_conversations_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.unclassified_conversations_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__issue_stats => {
                            if !fields.insert(__FieldTag::__issue_stats) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for issue_stats",
                                ));
                            }
                            result.issue_stats = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::issue_model_label_stats::IssueStats,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for IssueModelLabelStats {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.analyzed_conversations_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "analyzedConversationsCount",
                &__With(&self.analyzed_conversations_count),
            )?;
        }
        if !wkt::internal::is_default(&self.unclassified_conversations_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "unclassifiedConversationsCount",
                &__With(&self.unclassified_conversations_count),
            )?;
        }
        if !self.issue_stats.is_empty() {
            state.serialize_entry("issueStats", &self.issue_stats)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for IssueModelLabelStats {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IssueModelLabelStats");
        debug_struct.field(
            "analyzed_conversations_count",
            &self.analyzed_conversations_count,
        );
        debug_struct.field(
            "unclassified_conversations_count",
            &self.unclassified_conversations_count,
        );
        debug_struct.field("issue_stats", &self.issue_stats);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [IssueModelLabelStats].
pub mod issue_model_label_stats {
    #[allow(unused_imports)]
    use super::*;

    /// Aggregated statistics about an issue.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct IssueStats {
        /// Issue resource.
        /// Format:
        /// projects/{project}/locations/{location}/issueModels/{issue_model}/issues/{issue}
        pub issue: std::string::String,

        /// Number of conversations attached to the issue at this point in time.
        pub labeled_conversations_count: i64,

        /// Display name of the issue.
        pub display_name: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl IssueStats {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [issue][crate::model::issue_model_label_stats::IssueStats::issue].
        pub fn set_issue<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.issue = v.into();
            self
        }

        /// Sets the value of [labeled_conversations_count][crate::model::issue_model_label_stats::IssueStats::labeled_conversations_count].
        pub fn set_labeled_conversations_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.labeled_conversations_count = v.into();
            self
        }

        /// Sets the value of [display_name][crate::model::issue_model_label_stats::IssueStats::display_name].
        pub fn set_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.display_name = v.into();
            self
        }
    }

    impl wkt::message::Message for IssueStats {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.IssueModelLabelStats.IssueStats"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for IssueStats {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __issue,
                __labeled_conversations_count,
                __display_name,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for IssueStats")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "issue" => Ok(__FieldTag::__issue),
                                "labeledConversationsCount" => {
                                    Ok(__FieldTag::__labeled_conversations_count)
                                }
                                "labeled_conversations_count" => {
                                    Ok(__FieldTag::__labeled_conversations_count)
                                }
                                "displayName" => Ok(__FieldTag::__display_name),
                                "display_name" => Ok(__FieldTag::__display_name),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = IssueStats;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct IssueStats")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__issue => {
                                if !fields.insert(__FieldTag::__issue) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for issue",
                                    ));
                                }
                                result.issue = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__labeled_conversations_count => {
                                if !fields.insert(__FieldTag::__labeled_conversations_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for labeled_conversations_count",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.labeled_conversations_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__display_name => {
                                if !fields.insert(__FieldTag::__display_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for display_name",
                                    ));
                                }
                                result.display_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for IssueStats {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.issue.is_empty() {
                state.serialize_entry("issue", &self.issue)?;
            }
            if !wkt::internal::is_default(&self.labeled_conversations_count) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "labeledConversationsCount",
                    &__With(&self.labeled_conversations_count),
                )?;
            }
            if !self.display_name.is_empty() {
                state.serialize_entry("displayName", &self.display_name)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for IssueStats {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("IssueStats");
            debug_struct.field("issue", &self.issue);
            debug_struct.field(
                "labeled_conversations_count",
                &self.labeled_conversations_count,
            );
            debug_struct.field("display_name", &self.display_name);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// The phrase matcher resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PhraseMatcher {
    /// The resource name of the phrase matcher.
    /// Format:
    /// projects/{project}/locations/{location}/phraseMatchers/{phrase_matcher}
    pub name: std::string::String,

    /// Output only. Immutable. The revision ID of the phrase matcher.
    /// A new revision is committed whenever the matcher is changed, except when it
    /// is activated or deactivated. A server generated random ID will be used.
    /// Example: locations/global/phraseMatchers/my-first-matcher@1234567
    pub revision_id: std::string::String,

    /// The customized version tag to use for the phrase matcher. If not specified,
    /// it will default to `revision_id`.
    pub version_tag: std::string::String,

    /// Output only. The timestamp of when the revision was created. It is also the
    /// create time when a new matcher is added.
    pub revision_create_time: std::option::Option<wkt::Timestamp>,

    /// The human-readable name of the phrase matcher.
    pub display_name: std::string::String,

    /// Required. The type of this phrase matcher.
    pub r#type: crate::model::phrase_matcher::PhraseMatcherType,

    /// Applies the phrase matcher only when it is active.
    pub active: bool,

    /// A list of phase match rule groups that are included in this matcher.
    pub phrase_match_rule_groups: std::vec::Vec<crate::model::PhraseMatchRuleGroup>,

    /// Output only. The most recent time at which the activation status was
    /// updated.
    pub activation_update_time: std::option::Option<wkt::Timestamp>,

    /// The role whose utterances the phrase matcher should be matched
    /// against. If the role is ROLE_UNSPECIFIED it will be matched against any
    /// utterances in the transcript.
    pub role_match: crate::model::conversation_participant::Role,

    /// Output only. The most recent time at which the phrase matcher was updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PhraseMatcher {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PhraseMatcher::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [revision_id][crate::model::PhraseMatcher::revision_id].
    pub fn set_revision_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision_id = v.into();
        self
    }

    /// Sets the value of [version_tag][crate::model::PhraseMatcher::version_tag].
    pub fn set_version_tag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version_tag = v.into();
        self
    }

    /// Sets the value of [revision_create_time][crate::model::PhraseMatcher::revision_create_time].
    pub fn set_revision_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.revision_create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [revision_create_time][crate::model::PhraseMatcher::revision_create_time].
    pub fn set_or_clear_revision_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.revision_create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [display_name][crate::model::PhraseMatcher::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::PhraseMatcher::type].
    pub fn set_type<T: std::convert::Into<crate::model::phrase_matcher::PhraseMatcherType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [active][crate::model::PhraseMatcher::active].
    pub fn set_active<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.active = v.into();
        self
    }

    /// Sets the value of [phrase_match_rule_groups][crate::model::PhraseMatcher::phrase_match_rule_groups].
    pub fn set_phrase_match_rule_groups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PhraseMatchRuleGroup>,
    {
        use std::iter::Iterator;
        self.phrase_match_rule_groups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [activation_update_time][crate::model::PhraseMatcher::activation_update_time].
    pub fn set_activation_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.activation_update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [activation_update_time][crate::model::PhraseMatcher::activation_update_time].
    pub fn set_or_clear_activation_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.activation_update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [role_match][crate::model::PhraseMatcher::role_match].
    pub fn set_role_match<T: std::convert::Into<crate::model::conversation_participant::Role>>(
        mut self,
        v: T,
    ) -> Self {
        self.role_match = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::PhraseMatcher::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::PhraseMatcher::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PhraseMatcher {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.PhraseMatcher"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PhraseMatcher {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __revision_id,
            __version_tag,
            __revision_create_time,
            __display_name,
            __type,
            __active,
            __phrase_match_rule_groups,
            __activation_update_time,
            __role_match,
            __update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PhraseMatcher")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "revisionId" => Ok(__FieldTag::__revision_id),
                            "revision_id" => Ok(__FieldTag::__revision_id),
                            "versionTag" => Ok(__FieldTag::__version_tag),
                            "version_tag" => Ok(__FieldTag::__version_tag),
                            "revisionCreateTime" => Ok(__FieldTag::__revision_create_time),
                            "revision_create_time" => Ok(__FieldTag::__revision_create_time),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "type" => Ok(__FieldTag::__type),
                            "active" => Ok(__FieldTag::__active),
                            "phraseMatchRuleGroups" => Ok(__FieldTag::__phrase_match_rule_groups),
                            "phrase_match_rule_groups" => {
                                Ok(__FieldTag::__phrase_match_rule_groups)
                            }
                            "activationUpdateTime" => Ok(__FieldTag::__activation_update_time),
                            "activation_update_time" => Ok(__FieldTag::__activation_update_time),
                            "roleMatch" => Ok(__FieldTag::__role_match),
                            "role_match" => Ok(__FieldTag::__role_match),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PhraseMatcher;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PhraseMatcher")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__revision_id => {
                            if !fields.insert(__FieldTag::__revision_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for revision_id",
                                ));
                            }
                            result.revision_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version_tag => {
                            if !fields.insert(__FieldTag::__version_tag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version_tag",
                                ));
                            }
                            result.version_tag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__revision_create_time => {
                            if !fields.insert(__FieldTag::__revision_create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for revision_create_time",
                                ));
                            }
                            result.revision_create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<
                                    crate::model::phrase_matcher::PhraseMatcherType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__active => {
                            if !fields.insert(__FieldTag::__active) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for active",
                                ));
                            }
                            result.active = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__phrase_match_rule_groups => {
                            if !fields.insert(__FieldTag::__phrase_match_rule_groups) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for phrase_match_rule_groups",
                                ));
                            }
                            result.phrase_match_rule_groups = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::PhraseMatchRuleGroup>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__activation_update_time => {
                            if !fields.insert(__FieldTag::__activation_update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for activation_update_time",
                                ));
                            }
                            result.activation_update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__role_match => {
                            if !fields.insert(__FieldTag::__role_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for role_match",
                                ));
                            }
                            result.role_match =
                                map.next_value::<std::option::Option<
                                    crate::model::conversation_participant::Role,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PhraseMatcher {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.revision_id.is_empty() {
            state.serialize_entry("revisionId", &self.revision_id)?;
        }
        if !self.version_tag.is_empty() {
            state.serialize_entry("versionTag", &self.version_tag)?;
        }
        if self.revision_create_time.is_some() {
            state.serialize_entry("revisionCreateTime", &self.revision_create_time)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !wkt::internal::is_default(&self.active) {
            state.serialize_entry("active", &self.active)?;
        }
        if !self.phrase_match_rule_groups.is_empty() {
            state.serialize_entry("phraseMatchRuleGroups", &self.phrase_match_rule_groups)?;
        }
        if self.activation_update_time.is_some() {
            state.serialize_entry("activationUpdateTime", &self.activation_update_time)?;
        }
        if !wkt::internal::is_default(&self.role_match) {
            state.serialize_entry("roleMatch", &self.role_match)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PhraseMatcher {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PhraseMatcher");
        debug_struct.field("name", &self.name);
        debug_struct.field("revision_id", &self.revision_id);
        debug_struct.field("version_tag", &self.version_tag);
        debug_struct.field("revision_create_time", &self.revision_create_time);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("active", &self.active);
        debug_struct.field("phrase_match_rule_groups", &self.phrase_match_rule_groups);
        debug_struct.field("activation_update_time", &self.activation_update_time);
        debug_struct.field("role_match", &self.role_match);
        debug_struct.field("update_time", &self.update_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [PhraseMatcher].
pub mod phrase_matcher {
    #[allow(unused_imports)]
    use super::*;

    /// Specifies how to combine each phrase match rule group to determine whether
    /// there is a match.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PhraseMatcherType {
        /// Unspecified.
        Unspecified,
        /// Must meet all phrase match rule groups or there is no match.
        AllOf,
        /// If any of the phrase match rule groups are met, there is a match.
        AnyOf,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PhraseMatcherType::value] or
        /// [PhraseMatcherType::name].
        UnknownValue(phrase_matcher_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod phrase_matcher_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PhraseMatcherType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::AllOf => std::option::Option::Some(1),
                Self::AnyOf => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PHRASE_MATCHER_TYPE_UNSPECIFIED"),
                Self::AllOf => std::option::Option::Some("ALL_OF"),
                Self::AnyOf => std::option::Option::Some("ANY_OF"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PhraseMatcherType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PhraseMatcherType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PhraseMatcherType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::AllOf,
                2 => Self::AnyOf,
                _ => Self::UnknownValue(phrase_matcher_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PhraseMatcherType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PHRASE_MATCHER_TYPE_UNSPECIFIED" => Self::Unspecified,
                "ALL_OF" => Self::AllOf,
                "ANY_OF" => Self::AnyOf,
                _ => Self::UnknownValue(phrase_matcher_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PhraseMatcherType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::AllOf => serializer.serialize_i32(1),
                Self::AnyOf => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PhraseMatcherType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PhraseMatcherType>::new(
                ".google.cloud.contactcenterinsights.v1.PhraseMatcher.PhraseMatcherType",
            ))
        }
    }
}

/// A message representing a rule in the phrase matcher.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PhraseMatchRuleGroup {
    /// Required. The type of this phrase match rule group.
    pub r#type: crate::model::phrase_match_rule_group::PhraseMatchRuleGroupType,

    /// A list of phrase match rules that are included in this group.
    pub phrase_match_rules: std::vec::Vec<crate::model::PhraseMatchRule>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PhraseMatchRuleGroup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::PhraseMatchRuleGroup::type].
    pub fn set_type<
        T: std::convert::Into<crate::model::phrase_match_rule_group::PhraseMatchRuleGroupType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [phrase_match_rules][crate::model::PhraseMatchRuleGroup::phrase_match_rules].
    pub fn set_phrase_match_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PhraseMatchRule>,
    {
        use std::iter::Iterator;
        self.phrase_match_rules = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PhraseMatchRuleGroup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.PhraseMatchRuleGroup"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PhraseMatchRuleGroup {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __phrase_match_rules,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PhraseMatchRuleGroup")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "phraseMatchRules" => Ok(__FieldTag::__phrase_match_rules),
                            "phrase_match_rules" => Ok(__FieldTag::__phrase_match_rules),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PhraseMatchRuleGroup;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PhraseMatchRuleGroup")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<
                                    crate::model::phrase_match_rule_group::PhraseMatchRuleGroupType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__phrase_match_rules => {
                            if !fields.insert(__FieldTag::__phrase_match_rules) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for phrase_match_rules",
                                ));
                            }
                            result.phrase_match_rules =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::PhraseMatchRule>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PhraseMatchRuleGroup {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.phrase_match_rules.is_empty() {
            state.serialize_entry("phraseMatchRules", &self.phrase_match_rules)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PhraseMatchRuleGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PhraseMatchRuleGroup");
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("phrase_match_rules", &self.phrase_match_rules);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [PhraseMatchRuleGroup].
pub mod phrase_match_rule_group {
    #[allow(unused_imports)]
    use super::*;

    /// Specifies how to combine each phrase match rule for whether there is a
    /// match.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PhraseMatchRuleGroupType {
        /// Unspecified.
        Unspecified,
        /// Must meet all phrase match rules or there is no match.
        AllOf,
        /// If any of the phrase match rules are met, there is a match.
        AnyOf,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PhraseMatchRuleGroupType::value] or
        /// [PhraseMatchRuleGroupType::name].
        UnknownValue(phrase_match_rule_group_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod phrase_match_rule_group_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PhraseMatchRuleGroupType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::AllOf => std::option::Option::Some(1),
                Self::AnyOf => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("PHRASE_MATCH_RULE_GROUP_TYPE_UNSPECIFIED")
                }
                Self::AllOf => std::option::Option::Some("ALL_OF"),
                Self::AnyOf => std::option::Option::Some("ANY_OF"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PhraseMatchRuleGroupType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PhraseMatchRuleGroupType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PhraseMatchRuleGroupType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::AllOf,
                2 => Self::AnyOf,
                _ => Self::UnknownValue(phrase_match_rule_group_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PhraseMatchRuleGroupType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PHRASE_MATCH_RULE_GROUP_TYPE_UNSPECIFIED" => Self::Unspecified,
                "ALL_OF" => Self::AllOf,
                "ANY_OF" => Self::AnyOf,
                _ => Self::UnknownValue(phrase_match_rule_group_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PhraseMatchRuleGroupType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::AllOf => serializer.serialize_i32(1),
                Self::AnyOf => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PhraseMatchRuleGroupType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PhraseMatchRuleGroupType>::new(
                ".google.cloud.contactcenterinsights.v1.PhraseMatchRuleGroup.PhraseMatchRuleGroupType"))
        }
    }
}

/// The data for a phrase match rule.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PhraseMatchRule {
    /// Required. The phrase to be matched.
    pub query: std::string::String,

    /// Specifies whether the phrase must be missing from the transcript segment or
    /// present in the transcript segment.
    pub negated: bool,

    /// Provides additional information about the rule that specifies how to apply
    /// the rule.
    pub config: std::option::Option<crate::model::PhraseMatchRuleConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PhraseMatchRule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [query][crate::model::PhraseMatchRule::query].
    pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query = v.into();
        self
    }

    /// Sets the value of [negated][crate::model::PhraseMatchRule::negated].
    pub fn set_negated<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.negated = v.into();
        self
    }

    /// Sets the value of [config][crate::model::PhraseMatchRule::config].
    pub fn set_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PhraseMatchRuleConfig>,
    {
        self.config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [config][crate::model::PhraseMatchRule::config].
    pub fn set_or_clear_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PhraseMatchRuleConfig>,
    {
        self.config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PhraseMatchRule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.PhraseMatchRule"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PhraseMatchRule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __query,
            __negated,
            __config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PhraseMatchRule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "query" => Ok(__FieldTag::__query),
                            "negated" => Ok(__FieldTag::__negated),
                            "config" => Ok(__FieldTag::__config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PhraseMatchRule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PhraseMatchRule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__query => {
                            if !fields.insert(__FieldTag::__query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query",
                                ));
                            }
                            result.query = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__negated => {
                            if !fields.insert(__FieldTag::__negated) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for negated",
                                ));
                            }
                            result.negated = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__config => {
                            if !fields.insert(__FieldTag::__config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config",
                                ));
                            }
                            result.config = map.next_value::<std::option::Option<crate::model::PhraseMatchRuleConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PhraseMatchRule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.query.is_empty() {
            state.serialize_entry("query", &self.query)?;
        }
        if !wkt::internal::is_default(&self.negated) {
            state.serialize_entry("negated", &self.negated)?;
        }
        if self.config.is_some() {
            state.serialize_entry("config", &self.config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PhraseMatchRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PhraseMatchRule");
        debug_struct.field("query", &self.query);
        debug_struct.field("negated", &self.negated);
        debug_struct.field("config", &self.config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configuration information of a phrase match rule.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PhraseMatchRuleConfig {
    /// The configuration of the phrase match rule.
    pub config: std::option::Option<crate::model::phrase_match_rule_config::Config>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PhraseMatchRuleConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [config][crate::model::PhraseMatchRuleConfig::config].
    ///
    /// Note that all the setters affecting `config` are mutually
    /// exclusive.
    pub fn set_config<
        T: std::convert::Into<std::option::Option<crate::model::phrase_match_rule_config::Config>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config = v.into();
        self
    }

    /// The value of [config][crate::model::PhraseMatchRuleConfig::config]
    /// if it holds a `ExactMatchConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn exact_match_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ExactMatchConfig>> {
        #[allow(unreachable_patterns)]
        self.config.as_ref().and_then(|v| match v {
            crate::model::phrase_match_rule_config::Config::ExactMatchConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [config][crate::model::PhraseMatchRuleConfig::config]
    /// to hold a `ExactMatchConfig`.
    ///
    /// Note that all the setters affecting `config` are
    /// mutually exclusive.
    pub fn set_exact_match_config<
        T: std::convert::Into<std::boxed::Box<crate::model::ExactMatchConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config = std::option::Option::Some(
            crate::model::phrase_match_rule_config::Config::ExactMatchConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for PhraseMatchRuleConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.PhraseMatchRuleConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PhraseMatchRuleConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __exact_match_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PhraseMatchRuleConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "exactMatchConfig" => Ok(__FieldTag::__exact_match_config),
                            "exact_match_config" => Ok(__FieldTag::__exact_match_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PhraseMatchRuleConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PhraseMatchRuleConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__exact_match_config => {
                            if !fields.insert(__FieldTag::__exact_match_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exact_match_config",
                                ));
                            }
                            if result.config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `config`, a oneof with full ID .google.cloud.contactcenterinsights.v1.PhraseMatchRuleConfig.exact_match_config, latest field was exactMatchConfig",
                                ));
                            }
                            result.config = std::option::Option::Some(
                                crate::model::phrase_match_rule_config::Config::ExactMatchConfig(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ExactMatchConfig>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PhraseMatchRuleConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.exact_match_config() {
            state.serialize_entry("exactMatchConfig", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PhraseMatchRuleConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PhraseMatchRuleConfig");
        debug_struct.field("config", &self.config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [PhraseMatchRuleConfig].
pub mod phrase_match_rule_config {
    #[allow(unused_imports)]
    use super::*;

    /// The configuration of the phrase match rule.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Config {
        /// The configuration for the exact match rule.
        ExactMatchConfig(std::boxed::Box<crate::model::ExactMatchConfig>),
    }
}

/// Exact match configuration.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExactMatchConfig {
    /// Whether to consider case sensitivity when performing an exact match.
    pub case_sensitive: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExactMatchConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [case_sensitive][crate::model::ExactMatchConfig::case_sensitive].
    pub fn set_case_sensitive<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.case_sensitive = v.into();
        self
    }
}

impl wkt::message::Message for ExactMatchConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ExactMatchConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExactMatchConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __case_sensitive,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExactMatchConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "caseSensitive" => Ok(__FieldTag::__case_sensitive),
                            "case_sensitive" => Ok(__FieldTag::__case_sensitive),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExactMatchConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExactMatchConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__case_sensitive => {
                            if !fields.insert(__FieldTag::__case_sensitive) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for case_sensitive",
                                ));
                            }
                            result.case_sensitive = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExactMatchConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.case_sensitive) {
            state.serialize_entry("caseSensitive", &self.case_sensitive)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ExactMatchConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExactMatchConfig");
        debug_struct.field("case_sensitive", &self.case_sensitive);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The CCAI Insights project wide settings.
/// Use these settings to configure the behavior of Insights.
/// View these settings with
/// [`getsettings`](https://cloud.google.com/contact-center/insights/docs/reference/rest/v1/projects.locations/getSettings)
/// and change the settings with
/// [`updateSettings`](https://cloud.google.com/contact-center/insights/docs/reference/rest/v1/projects.locations/updateSettings).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Settings {
    /// Immutable. The resource name of the settings resource.
    /// Format:
    /// projects/{project}/locations/{location}/settings
    pub name: std::string::String,

    /// Output only. The time at which the settings was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which the settings were last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// A language code to be applied to each transcript segment unless the segment
    /// already specifies a language code. Language code defaults to "en-US" if it
    /// is neither specified on the segment nor here.
    pub language_code: std::string::String,

    /// The default TTL for newly-created conversations. If a conversation has a
    /// specified expiration, that value will be used instead. Changing this
    /// value will not change the expiration of existing conversations.
    /// Conversations with no expire time persist until they are deleted.
    pub conversation_ttl: std::option::Option<wkt::Duration>,

    /// A map that maps a notification trigger to a Pub/Sub topic. Each time a
    /// specified trigger occurs, Insights will notify the corresponding Pub/Sub
    /// topic.
    ///
    /// Keys are notification triggers. Supported keys are:
    ///
    /// * "all-triggers": Notify each time any of the supported triggers occurs.
    /// * "create-analysis": Notify each time an analysis is created.
    /// * "create-conversation": Notify each time a conversation is created.
    /// * "export-insights-data": Notify each time an export is complete.
    /// * "ingest-conversations": Notify each time an IngestConversations LRO is
    ///   complete.
    /// * "update-conversation": Notify each time a conversation is updated via
    ///   UpdateConversation.
    /// * "upload-conversation": Notify when an UploadConversation LRO is complete.
    ///
    /// Values are Pub/Sub topics. The format of each Pub/Sub topic is:
    /// projects/{project}/topics/{topic}
    pub pubsub_notification_settings:
        std::collections::HashMap<std::string::String, std::string::String>,

    /// Default analysis settings.
    pub analysis_config: std::option::Option<crate::model::settings::AnalysisConfig>,

    /// Default DLP redaction resources to be applied while ingesting
    /// conversations. This applies to conversations ingested from the
    /// `UploadConversation` and `IngestConversations` endpoints, including
    /// conversations coming from CCAI Platform.
    pub redaction_config: std::option::Option<crate::model::RedactionConfig>,

    /// Optional. Default Speech-to-Text resources to use while ingesting audio
    /// files. Optional, CCAI Insights will create a default if not provided. This
    /// applies to conversations ingested from the `UploadConversation` and
    /// `IngestConversations` endpoints, including conversations coming from CCAI
    /// Platform.
    pub speech_config: std::option::Option<crate::model::SpeechConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Settings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Settings::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Settings::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Settings::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Settings::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Settings::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [language_code][crate::model::Settings::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [conversation_ttl][crate::model::Settings::conversation_ttl].
    pub fn set_conversation_ttl<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.conversation_ttl = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [conversation_ttl][crate::model::Settings::conversation_ttl].
    pub fn set_or_clear_conversation_ttl<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.conversation_ttl = v.map(|x| x.into());
        self
    }

    /// Sets the value of [pubsub_notification_settings][crate::model::Settings::pubsub_notification_settings].
    pub fn set_pubsub_notification_settings<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.pubsub_notification_settings =
            v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [analysis_config][crate::model::Settings::analysis_config].
    pub fn set_analysis_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::settings::AnalysisConfig>,
    {
        self.analysis_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [analysis_config][crate::model::Settings::analysis_config].
    pub fn set_or_clear_analysis_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::settings::AnalysisConfig>,
    {
        self.analysis_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [redaction_config][crate::model::Settings::redaction_config].
    pub fn set_redaction_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RedactionConfig>,
    {
        self.redaction_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [redaction_config][crate::model::Settings::redaction_config].
    pub fn set_or_clear_redaction_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RedactionConfig>,
    {
        self.redaction_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [speech_config][crate::model::Settings::speech_config].
    pub fn set_speech_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SpeechConfig>,
    {
        self.speech_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [speech_config][crate::model::Settings::speech_config].
    pub fn set_or_clear_speech_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SpeechConfig>,
    {
        self.speech_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Settings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.Settings"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Settings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __update_time,
            __language_code,
            __conversation_ttl,
            __pubsub_notification_settings,
            __analysis_config,
            __redaction_config,
            __speech_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Settings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "conversationTtl" => Ok(__FieldTag::__conversation_ttl),
                            "conversation_ttl" => Ok(__FieldTag::__conversation_ttl),
                            "pubsubNotificationSettings" => {
                                Ok(__FieldTag::__pubsub_notification_settings)
                            }
                            "pubsub_notification_settings" => {
                                Ok(__FieldTag::__pubsub_notification_settings)
                            }
                            "analysisConfig" => Ok(__FieldTag::__analysis_config),
                            "analysis_config" => Ok(__FieldTag::__analysis_config),
                            "redactionConfig" => Ok(__FieldTag::__redaction_config),
                            "redaction_config" => Ok(__FieldTag::__redaction_config),
                            "speechConfig" => Ok(__FieldTag::__speech_config),
                            "speech_config" => Ok(__FieldTag::__speech_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Settings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Settings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__conversation_ttl => {
                            if !fields.insert(__FieldTag::__conversation_ttl) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation_ttl",
                                ));
                            }
                            result.conversation_ttl =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__pubsub_notification_settings => {
                            if !fields.insert(__FieldTag::__pubsub_notification_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pubsub_notification_settings",
                                ));
                            }
                            result.pubsub_notification_settings = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__analysis_config => {
                            if !fields.insert(__FieldTag::__analysis_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for analysis_config",
                                ));
                            }
                            result.analysis_config = map.next_value::<std::option::Option<crate::model::settings::AnalysisConfig>>()?
                                ;
                        }
                        __FieldTag::__redaction_config => {
                            if !fields.insert(__FieldTag::__redaction_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for redaction_config",
                                ));
                            }
                            result.redaction_config = map
                                .next_value::<std::option::Option<crate::model::RedactionConfig>>(
                                )?;
                        }
                        __FieldTag::__speech_config => {
                            if !fields.insert(__FieldTag::__speech_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for speech_config",
                                ));
                            }
                            result.speech_config = map
                                .next_value::<std::option::Option<crate::model::SpeechConfig>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Settings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if self.conversation_ttl.is_some() {
            state.serialize_entry("conversationTtl", &self.conversation_ttl)?;
        }
        if !self.pubsub_notification_settings.is_empty() {
            state.serialize_entry(
                "pubsubNotificationSettings",
                &self.pubsub_notification_settings,
            )?;
        }
        if self.analysis_config.is_some() {
            state.serialize_entry("analysisConfig", &self.analysis_config)?;
        }
        if self.redaction_config.is_some() {
            state.serialize_entry("redactionConfig", &self.redaction_config)?;
        }
        if self.speech_config.is_some() {
            state.serialize_entry("speechConfig", &self.speech_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Settings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Settings");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("language_code", &self.language_code);
        debug_struct.field("conversation_ttl", &self.conversation_ttl);
        debug_struct.field(
            "pubsub_notification_settings",
            &self.pubsub_notification_settings,
        );
        debug_struct.field("analysis_config", &self.analysis_config);
        debug_struct.field("redaction_config", &self.redaction_config);
        debug_struct.field("speech_config", &self.speech_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Settings].
pub mod settings {
    #[allow(unused_imports)]
    use super::*;

    /// Default configuration when creating Analyses in Insights.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AnalysisConfig {
        /// Percentage of conversations created using Dialogflow runtime integration
        /// to analyze automatically, between [0, 100].
        pub runtime_integration_analysis_percentage: f64,

        /// Percentage of conversations created using the UploadConversation endpoint
        /// to analyze automatically, between [0, 100].
        pub upload_conversation_analysis_percentage: f64,

        /// To select the annotators to run and the phrase matchers to use
        /// (if any). If not specified, all annotators will be run.
        pub annotator_selector: std::option::Option<crate::model::AnnotatorSelector>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AnalysisConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [runtime_integration_analysis_percentage][crate::model::settings::AnalysisConfig::runtime_integration_analysis_percentage].
        pub fn set_runtime_integration_analysis_percentage<T: std::convert::Into<f64>>(
            mut self,
            v: T,
        ) -> Self {
            self.runtime_integration_analysis_percentage = v.into();
            self
        }

        /// Sets the value of [upload_conversation_analysis_percentage][crate::model::settings::AnalysisConfig::upload_conversation_analysis_percentage].
        pub fn set_upload_conversation_analysis_percentage<T: std::convert::Into<f64>>(
            mut self,
            v: T,
        ) -> Self {
            self.upload_conversation_analysis_percentage = v.into();
            self
        }

        /// Sets the value of [annotator_selector][crate::model::settings::AnalysisConfig::annotator_selector].
        pub fn set_annotator_selector<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::AnnotatorSelector>,
        {
            self.annotator_selector = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [annotator_selector][crate::model::settings::AnalysisConfig::annotator_selector].
        pub fn set_or_clear_annotator_selector<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::AnnotatorSelector>,
        {
            self.annotator_selector = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for AnalysisConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.Settings.AnalysisConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AnalysisConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __runtime_integration_analysis_percentage,
                __upload_conversation_analysis_percentage,
                __annotator_selector,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AnalysisConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "runtimeIntegrationAnalysisPercentage" => {
                                    Ok(__FieldTag::__runtime_integration_analysis_percentage)
                                }
                                "runtime_integration_analysis_percentage" => {
                                    Ok(__FieldTag::__runtime_integration_analysis_percentage)
                                }
                                "uploadConversationAnalysisPercentage" => {
                                    Ok(__FieldTag::__upload_conversation_analysis_percentage)
                                }
                                "upload_conversation_analysis_percentage" => {
                                    Ok(__FieldTag::__upload_conversation_analysis_percentage)
                                }
                                "annotatorSelector" => Ok(__FieldTag::__annotator_selector),
                                "annotator_selector" => Ok(__FieldTag::__annotator_selector),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AnalysisConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AnalysisConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__runtime_integration_analysis_percentage => {
                                if !fields
                                    .insert(__FieldTag::__runtime_integration_analysis_percentage)
                                {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for runtime_integration_analysis_percentage",
                                    ));
                                }
                                struct __With(std::option::Option<f64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.runtime_integration_analysis_percentage =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__upload_conversation_analysis_percentage => {
                                if !fields
                                    .insert(__FieldTag::__upload_conversation_analysis_percentage)
                                {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for upload_conversation_analysis_percentage",
                                    ));
                                }
                                struct __With(std::option::Option<f64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.upload_conversation_analysis_percentage =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__annotator_selector => {
                                if !fields.insert(__FieldTag::__annotator_selector) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for annotator_selector",
                                    ));
                                }
                                result.annotator_selector = map.next_value::<std::option::Option<crate::model::AnnotatorSelector>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AnalysisConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.runtime_integration_analysis_percentage) {
                struct __With<'a>(&'a f64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "runtimeIntegrationAnalysisPercentage",
                    &__With(&self.runtime_integration_analysis_percentage),
                )?;
            }
            if !wkt::internal::is_default(&self.upload_conversation_analysis_percentage) {
                struct __With<'a>(&'a f64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "uploadConversationAnalysisPercentage",
                    &__With(&self.upload_conversation_analysis_percentage),
                )?;
            }
            if self.annotator_selector.is_some() {
                state.serialize_entry("annotatorSelector", &self.annotator_selector)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for AnalysisConfig {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("AnalysisConfig");
            debug_struct.field(
                "runtime_integration_analysis_percentage",
                &self.runtime_integration_analysis_percentage,
            );
            debug_struct.field(
                "upload_conversation_analysis_percentage",
                &self.upload_conversation_analysis_percentage,
            );
            debug_struct.field("annotator_selector", &self.annotator_selector);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// The CCAI Insights project wide analysis rule. This rule will be applied to
/// all conversations that match the filter defined in the rule. For a
/// conversation matches the filter, the annotators specified in the rule will be
/// run. If a conversation matches multiple rules, a union of all the annotators
/// will be run. One project can have multiple analysis rules.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AnalysisRule {
    /// Identifier. The resource name of the analysis rule.
    /// Format:
    /// projects/{project}/locations/{location}/analysisRules/{analysis_rule}
    pub name: std::string::String,

    /// Output only. The time at which this analysis rule was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The most recent time at which this analysis rule was updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Display Name of the analysis rule.
    pub display_name: std::option::Option<std::string::String>,

    /// Filter for the conversations that should apply this analysis
    /// rule. An empty filter means this analysis rule applies to all
    /// conversations.
    pub conversation_filter: std::string::String,

    /// Selector of annotators to run and the phrase matchers to use for
    /// conversations that matches the conversation_filter. If not specified, NO
    /// annotators will be run.
    pub annotator_selector: std::option::Option<crate::model::AnnotatorSelector>,

    /// Percentage of conversations that we should apply this analysis setting
    /// automatically, between [0, 1]. For example, 0.1 means 10%. Conversations
    /// are sampled in a determenestic way. The original runtime_percentage &
    /// upload percentage will be replaced by defining filters on the conversation.
    pub analysis_percentage: f64,

    /// If true, apply this rule to conversations. Otherwise, this rule is
    /// inactive and saved as a draft.
    pub active: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnalysisRule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AnalysisRule::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::AnalysisRule::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::AnalysisRule::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::AnalysisRule::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::AnalysisRule::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [display_name][crate::model::AnalysisRule::display_name].
    pub fn set_display_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.display_name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [display_name][crate::model::AnalysisRule::display_name].
    pub fn set_or_clear_display_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.display_name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [conversation_filter][crate::model::AnalysisRule::conversation_filter].
    pub fn set_conversation_filter<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.conversation_filter = v.into();
        self
    }

    /// Sets the value of [annotator_selector][crate::model::AnalysisRule::annotator_selector].
    pub fn set_annotator_selector<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AnnotatorSelector>,
    {
        self.annotator_selector = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [annotator_selector][crate::model::AnalysisRule::annotator_selector].
    pub fn set_or_clear_annotator_selector<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AnnotatorSelector>,
    {
        self.annotator_selector = v.map(|x| x.into());
        self
    }

    /// Sets the value of [analysis_percentage][crate::model::AnalysisRule::analysis_percentage].
    pub fn set_analysis_percentage<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.analysis_percentage = v.into();
        self
    }

    /// Sets the value of [active][crate::model::AnalysisRule::active].
    pub fn set_active<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.active = v.into();
        self
    }
}

impl wkt::message::Message for AnalysisRule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.AnalysisRule"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AnalysisRule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __update_time,
            __display_name,
            __conversation_filter,
            __annotator_selector,
            __analysis_percentage,
            __active,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AnalysisRule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "conversationFilter" => Ok(__FieldTag::__conversation_filter),
                            "conversation_filter" => Ok(__FieldTag::__conversation_filter),
                            "annotatorSelector" => Ok(__FieldTag::__annotator_selector),
                            "annotator_selector" => Ok(__FieldTag::__annotator_selector),
                            "analysisPercentage" => Ok(__FieldTag::__analysis_percentage),
                            "analysis_percentage" => Ok(__FieldTag::__analysis_percentage),
                            "active" => Ok(__FieldTag::__active),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AnalysisRule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnalysisRule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__conversation_filter => {
                            if !fields.insert(__FieldTag::__conversation_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation_filter",
                                ));
                            }
                            result.conversation_filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__annotator_selector => {
                            if !fields.insert(__FieldTag::__annotator_selector) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotator_selector",
                                ));
                            }
                            result.annotator_selector = map
                                .next_value::<std::option::Option<crate::model::AnnotatorSelector>>(
                                )?;
                        }
                        __FieldTag::__analysis_percentage => {
                            if !fields.insert(__FieldTag::__analysis_percentage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for analysis_percentage",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.analysis_percentage =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__active => {
                            if !fields.insert(__FieldTag::__active) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for active",
                                ));
                            }
                            result.active = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AnalysisRule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.display_name.is_some() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.conversation_filter.is_empty() {
            state.serialize_entry("conversationFilter", &self.conversation_filter)?;
        }
        if self.annotator_selector.is_some() {
            state.serialize_entry("annotatorSelector", &self.annotator_selector)?;
        }
        if !wkt::internal::is_default(&self.analysis_percentage) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("analysisPercentage", &__With(&self.analysis_percentage))?;
        }
        if !wkt::internal::is_default(&self.active) {
            state.serialize_entry("active", &self.active)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AnalysisRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AnalysisRule");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("conversation_filter", &self.conversation_filter);
        debug_struct.field("annotator_selector", &self.annotator_selector);
        debug_struct.field("analysis_percentage", &self.analysis_percentage);
        debug_struct.field("active", &self.active);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A customer-managed encryption key specification that can be applied to all
/// created resources (e.g. `Conversation`).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EncryptionSpec {
    /// Immutable. The resource name of the encryption key specification resource.
    /// Format:
    /// projects/{project}/locations/{location}/encryptionSpec
    pub name: std::string::String,

    /// Required. The name of customer-managed encryption key that is used to
    /// secure a resource and its sub-resources. If empty, the resource is secured
    /// by our default encryption key. Only the key in the same location as this
    /// resource is allowed to be used for encryption. Format:
    /// `projects/{project}/locations/{location}/keyRings/{keyRing}/cryptoKeys/{key}`
    pub kms_key: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EncryptionSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EncryptionSpec::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [kms_key][crate::model::EncryptionSpec::kms_key].
    pub fn set_kms_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key = v.into();
        self
    }
}

impl wkt::message::Message for EncryptionSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.EncryptionSpec"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EncryptionSpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __kms_key,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EncryptionSpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "kmsKey" => Ok(__FieldTag::__kms_key),
                            "kms_key" => Ok(__FieldTag::__kms_key),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EncryptionSpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EncryptionSpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kms_key => {
                            if !fields.insert(__FieldTag::__kms_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key",
                                ));
                            }
                            result.kms_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EncryptionSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.kms_key.is_empty() {
            state.serialize_entry("kmsKey", &self.kms_key)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for EncryptionSpec {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EncryptionSpec");
        debug_struct.field("name", &self.name);
        debug_struct.field("kms_key", &self.kms_key);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// DLP resources used for redaction while ingesting conversations.
/// DLP settings are applied to conversations ingested from the
/// `UploadConversation` and `IngestConversations` endpoints, including
/// conversation coming from CCAI Platform. They are not applied to conversations
/// ingested from the `CreateConversation` endpoint or the Dialogflow / Agent
/// Assist runtime integrations. When using Dialogflow / Agent Assist runtime
/// integrations, redaction should be performed in Dialogflow / Agent Assist.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RedactionConfig {
    /// The fully-qualified DLP deidentify template resource name.
    /// Format:
    /// `projects/{project}/deidentifyTemplates/{template}`
    pub deidentify_template: std::string::String,

    /// The fully-qualified DLP inspect template resource name.
    /// Format:
    /// `projects/{project}/locations/{location}/inspectTemplates/{template}`
    pub inspect_template: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RedactionConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [deidentify_template][crate::model::RedactionConfig::deidentify_template].
    pub fn set_deidentify_template<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deidentify_template = v.into();
        self
    }

    /// Sets the value of [inspect_template][crate::model::RedactionConfig::inspect_template].
    pub fn set_inspect_template<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_template = v.into();
        self
    }
}

impl wkt::message::Message for RedactionConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.RedactionConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RedactionConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __deidentify_template,
            __inspect_template,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RedactionConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "deidentifyTemplate" => Ok(__FieldTag::__deidentify_template),
                            "deidentify_template" => Ok(__FieldTag::__deidentify_template),
                            "inspectTemplate" => Ok(__FieldTag::__inspect_template),
                            "inspect_template" => Ok(__FieldTag::__inspect_template),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RedactionConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RedactionConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__deidentify_template => {
                            if !fields.insert(__FieldTag::__deidentify_template) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deidentify_template",
                                ));
                            }
                            result.deidentify_template = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__inspect_template => {
                            if !fields.insert(__FieldTag::__inspect_template) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inspect_template",
                                ));
                            }
                            result.inspect_template = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RedactionConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.deidentify_template.is_empty() {
            state.serialize_entry("deidentifyTemplate", &self.deidentify_template)?;
        }
        if !self.inspect_template.is_empty() {
            state.serialize_entry("inspectTemplate", &self.inspect_template)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RedactionConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RedactionConfig");
        debug_struct.field("deidentify_template", &self.deidentify_template);
        debug_struct.field("inspect_template", &self.inspect_template);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Speech-to-Text configuration.
/// Speech-to-Text settings are applied to conversations ingested from the
/// `UploadConversation` and `IngestConversations` endpoints, including
/// conversation coming from CCAI Platform. They are not applied to conversations
/// ingested from the `CreateConversation` endpoint.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SpeechConfig {
    /// The fully-qualified Speech Recognizer resource name.
    /// Format:
    /// `projects/{project_id}/locations/{location}/recognizer/{recognizer}`
    pub speech_recognizer: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SpeechConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [speech_recognizer][crate::model::SpeechConfig::speech_recognizer].
    pub fn set_speech_recognizer<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.speech_recognizer = v.into();
        self
    }
}

impl wkt::message::Message for SpeechConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.SpeechConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SpeechConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __speech_recognizer,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SpeechConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "speechRecognizer" => Ok(__FieldTag::__speech_recognizer),
                            "speech_recognizer" => Ok(__FieldTag::__speech_recognizer),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SpeechConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SpeechConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__speech_recognizer => {
                            if !fields.insert(__FieldTag::__speech_recognizer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for speech_recognizer",
                                ));
                            }
                            result.speech_recognizer = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SpeechConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.speech_recognizer.is_empty() {
            state.serialize_entry("speechRecognizer", &self.speech_recognizer)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SpeechConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SpeechConfig");
        debug_struct.field("speech_recognizer", &self.speech_recognizer);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// An annotation that was generated during the customer and agent interaction.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RuntimeAnnotation {
    /// The unique identifier of the annotation.
    /// Format:
    /// projects/{project}/locations/{location}/conversationDatasets/{dataset}/conversationDataItems/{data_item}/conversationAnnotations/{annotation}
    pub annotation_id: std::string::String,

    /// The time at which this annotation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The boundary in the conversation where the annotation starts, inclusive.
    pub start_boundary: std::option::Option<crate::model::AnnotationBoundary>,

    /// The boundary in the conversation where the annotation ends, inclusive.
    pub end_boundary: std::option::Option<crate::model::AnnotationBoundary>,

    /// The feedback that the customer has about the answer in `data`.
    pub answer_feedback: std::option::Option<crate::model::AnswerFeedback>,

    /// Explicit input used for generating the answer
    pub user_input: std::option::Option<crate::model::runtime_annotation::UserInput>,

    /// The data in the annotation.
    pub data: std::option::Option<crate::model::runtime_annotation::Data>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RuntimeAnnotation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [annotation_id][crate::model::RuntimeAnnotation::annotation_id].
    pub fn set_annotation_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.annotation_id = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::RuntimeAnnotation::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::RuntimeAnnotation::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_boundary][crate::model::RuntimeAnnotation::start_boundary].
    pub fn set_start_boundary<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AnnotationBoundary>,
    {
        self.start_boundary = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_boundary][crate::model::RuntimeAnnotation::start_boundary].
    pub fn set_or_clear_start_boundary<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AnnotationBoundary>,
    {
        self.start_boundary = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_boundary][crate::model::RuntimeAnnotation::end_boundary].
    pub fn set_end_boundary<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AnnotationBoundary>,
    {
        self.end_boundary = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_boundary][crate::model::RuntimeAnnotation::end_boundary].
    pub fn set_or_clear_end_boundary<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AnnotationBoundary>,
    {
        self.end_boundary = v.map(|x| x.into());
        self
    }

    /// Sets the value of [answer_feedback][crate::model::RuntimeAnnotation::answer_feedback].
    pub fn set_answer_feedback<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AnswerFeedback>,
    {
        self.answer_feedback = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [answer_feedback][crate::model::RuntimeAnnotation::answer_feedback].
    pub fn set_or_clear_answer_feedback<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AnswerFeedback>,
    {
        self.answer_feedback = v.map(|x| x.into());
        self
    }

    /// Sets the value of [user_input][crate::model::RuntimeAnnotation::user_input].
    pub fn set_user_input<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::runtime_annotation::UserInput>,
    {
        self.user_input = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [user_input][crate::model::RuntimeAnnotation::user_input].
    pub fn set_or_clear_user_input<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::runtime_annotation::UserInput>,
    {
        self.user_input = v.map(|x| x.into());
        self
    }

    /// Sets the value of [data][crate::model::RuntimeAnnotation::data].
    ///
    /// Note that all the setters affecting `data` are mutually
    /// exclusive.
    pub fn set_data<
        T: std::convert::Into<std::option::Option<crate::model::runtime_annotation::Data>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data = v.into();
        self
    }

    /// The value of [data][crate::model::RuntimeAnnotation::data]
    /// if it holds a `ArticleSuggestion`, `None` if the field is not set or
    /// holds a different branch.
    pub fn article_suggestion(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ArticleSuggestionData>> {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::runtime_annotation::Data::ArticleSuggestion(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data][crate::model::RuntimeAnnotation::data]
    /// to hold a `ArticleSuggestion`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_article_suggestion<
        T: std::convert::Into<std::boxed::Box<crate::model::ArticleSuggestionData>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data = std::option::Option::Some(
            crate::model::runtime_annotation::Data::ArticleSuggestion(v.into()),
        );
        self
    }

    /// The value of [data][crate::model::RuntimeAnnotation::data]
    /// if it holds a `FaqAnswer`, `None` if the field is not set or
    /// holds a different branch.
    pub fn faq_answer(&self) -> std::option::Option<&std::boxed::Box<crate::model::FaqAnswerData>> {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::runtime_annotation::Data::FaqAnswer(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data][crate::model::RuntimeAnnotation::data]
    /// to hold a `FaqAnswer`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_faq_answer<T: std::convert::Into<std::boxed::Box<crate::model::FaqAnswerData>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data =
            std::option::Option::Some(crate::model::runtime_annotation::Data::FaqAnswer(v.into()));
        self
    }

    /// The value of [data][crate::model::RuntimeAnnotation::data]
    /// if it holds a `SmartReply`, `None` if the field is not set or
    /// holds a different branch.
    pub fn smart_reply(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SmartReplyData>> {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::runtime_annotation::Data::SmartReply(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data][crate::model::RuntimeAnnotation::data]
    /// to hold a `SmartReply`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_smart_reply<T: std::convert::Into<std::boxed::Box<crate::model::SmartReplyData>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data =
            std::option::Option::Some(crate::model::runtime_annotation::Data::SmartReply(v.into()));
        self
    }

    /// The value of [data][crate::model::RuntimeAnnotation::data]
    /// if it holds a `SmartComposeSuggestion`, `None` if the field is not set or
    /// holds a different branch.
    pub fn smart_compose_suggestion(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SmartComposeSuggestionData>> {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::runtime_annotation::Data::SmartComposeSuggestion(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data][crate::model::RuntimeAnnotation::data]
    /// to hold a `SmartComposeSuggestion`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_smart_compose_suggestion<
        T: std::convert::Into<std::boxed::Box<crate::model::SmartComposeSuggestionData>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data = std::option::Option::Some(
            crate::model::runtime_annotation::Data::SmartComposeSuggestion(v.into()),
        );
        self
    }

    /// The value of [data][crate::model::RuntimeAnnotation::data]
    /// if it holds a `DialogflowInteraction`, `None` if the field is not set or
    /// holds a different branch.
    pub fn dialogflow_interaction(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DialogflowInteractionData>> {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::runtime_annotation::Data::DialogflowInteraction(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data][crate::model::RuntimeAnnotation::data]
    /// to hold a `DialogflowInteraction`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_dialogflow_interaction<
        T: std::convert::Into<std::boxed::Box<crate::model::DialogflowInteractionData>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data = std::option::Option::Some(
            crate::model::runtime_annotation::Data::DialogflowInteraction(v.into()),
        );
        self
    }

    /// The value of [data][crate::model::RuntimeAnnotation::data]
    /// if it holds a `ConversationSummarizationSuggestion`, `None` if the field is not set or
    /// holds a different branch.
    pub fn conversation_summarization_suggestion(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ConversationSummarizationSuggestionData>>
    {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::runtime_annotation::Data::ConversationSummarizationSuggestion(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data][crate::model::RuntimeAnnotation::data]
    /// to hold a `ConversationSummarizationSuggestion`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_conversation_summarization_suggestion<
        T: std::convert::Into<std::boxed::Box<crate::model::ConversationSummarizationSuggestionData>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data = std::option::Option::Some(
            crate::model::runtime_annotation::Data::ConversationSummarizationSuggestion(v.into()),
        );
        self
    }
}

impl wkt::message::Message for RuntimeAnnotation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.RuntimeAnnotation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RuntimeAnnotation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __article_suggestion,
            __faq_answer,
            __smart_reply,
            __smart_compose_suggestion,
            __dialogflow_interaction,
            __conversation_summarization_suggestion,
            __annotation_id,
            __create_time,
            __start_boundary,
            __end_boundary,
            __answer_feedback,
            __user_input,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RuntimeAnnotation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "articleSuggestion" => Ok(__FieldTag::__article_suggestion),
                            "article_suggestion" => Ok(__FieldTag::__article_suggestion),
                            "faqAnswer" => Ok(__FieldTag::__faq_answer),
                            "faq_answer" => Ok(__FieldTag::__faq_answer),
                            "smartReply" => Ok(__FieldTag::__smart_reply),
                            "smart_reply" => Ok(__FieldTag::__smart_reply),
                            "smartComposeSuggestion" => Ok(__FieldTag::__smart_compose_suggestion),
                            "smart_compose_suggestion" => {
                                Ok(__FieldTag::__smart_compose_suggestion)
                            }
                            "dialogflowInteraction" => Ok(__FieldTag::__dialogflow_interaction),
                            "dialogflow_interaction" => Ok(__FieldTag::__dialogflow_interaction),
                            "conversationSummarizationSuggestion" => {
                                Ok(__FieldTag::__conversation_summarization_suggestion)
                            }
                            "conversation_summarization_suggestion" => {
                                Ok(__FieldTag::__conversation_summarization_suggestion)
                            }
                            "annotationId" => Ok(__FieldTag::__annotation_id),
                            "annotation_id" => Ok(__FieldTag::__annotation_id),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "startBoundary" => Ok(__FieldTag::__start_boundary),
                            "start_boundary" => Ok(__FieldTag::__start_boundary),
                            "endBoundary" => Ok(__FieldTag::__end_boundary),
                            "end_boundary" => Ok(__FieldTag::__end_boundary),
                            "answerFeedback" => Ok(__FieldTag::__answer_feedback),
                            "answer_feedback" => Ok(__FieldTag::__answer_feedback),
                            "userInput" => Ok(__FieldTag::__user_input),
                            "user_input" => Ok(__FieldTag::__user_input),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RuntimeAnnotation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RuntimeAnnotation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__article_suggestion => {
                            if !fields.insert(__FieldTag::__article_suggestion) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for article_suggestion",
                                ));
                            }
                            if result.data.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data`, a oneof with full ID .google.cloud.contactcenterinsights.v1.RuntimeAnnotation.article_suggestion, latest field was articleSuggestion",
                                ));
                            }
                            result.data = std::option::Option::Some(
                                crate::model::runtime_annotation::Data::ArticleSuggestion(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ArticleSuggestionData>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__faq_answer => {
                            if !fields.insert(__FieldTag::__faq_answer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for faq_answer",
                                ));
                            }
                            if result.data.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data`, a oneof with full ID .google.cloud.contactcenterinsights.v1.RuntimeAnnotation.faq_answer, latest field was faqAnswer",
                                ));
                            }
                            result.data = std::option::Option::Some(
                                crate::model::runtime_annotation::Data::FaqAnswer(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::FaqAnswerData>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__smart_reply => {
                            if !fields.insert(__FieldTag::__smart_reply) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for smart_reply",
                                ));
                            }
                            if result.data.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data`, a oneof with full ID .google.cloud.contactcenterinsights.v1.RuntimeAnnotation.smart_reply, latest field was smartReply",
                                ));
                            }
                            result.data = std::option::Option::Some(
                                crate::model::runtime_annotation::Data::SmartReply(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SmartReplyData>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__smart_compose_suggestion => {
                            if !fields.insert(__FieldTag::__smart_compose_suggestion) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for smart_compose_suggestion",
                                ));
                            }
                            if result.data.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data`, a oneof with full ID .google.cloud.contactcenterinsights.v1.RuntimeAnnotation.smart_compose_suggestion, latest field was smartComposeSuggestion",
                                ));
                            }
                            result.data = std::option::Option::Some(
                                crate::model::runtime_annotation::Data::SmartComposeSuggestion(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SmartComposeSuggestionData>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__dialogflow_interaction => {
                            if !fields.insert(__FieldTag::__dialogflow_interaction) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dialogflow_interaction",
                                ));
                            }
                            if result.data.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data`, a oneof with full ID .google.cloud.contactcenterinsights.v1.RuntimeAnnotation.dialogflow_interaction, latest field was dialogflowInteraction",
                                ));
                            }
                            result.data = std::option::Option::Some(
                                crate::model::runtime_annotation::Data::DialogflowInteraction(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DialogflowInteractionData>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__conversation_summarization_suggestion => {
                            if !fields.insert(__FieldTag::__conversation_summarization_suggestion) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation_summarization_suggestion",
                                ));
                            }
                            if result.data.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data`, a oneof with full ID .google.cloud.contactcenterinsights.v1.RuntimeAnnotation.conversation_summarization_suggestion, latest field was conversationSummarizationSuggestion",
                                ));
                            }
                            result.data = std::option::Option::Some(
                                crate::model::runtime_annotation::Data::ConversationSummarizationSuggestion(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ConversationSummarizationSuggestionData>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__annotation_id => {
                            if !fields.insert(__FieldTag::__annotation_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotation_id",
                                ));
                            }
                            result.annotation_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__start_boundary => {
                            if !fields.insert(__FieldTag::__start_boundary) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_boundary",
                                ));
                            }
                            result.start_boundary = map.next_value::<std::option::Option<crate::model::AnnotationBoundary>>()?
                                ;
                        }
                        __FieldTag::__end_boundary => {
                            if !fields.insert(__FieldTag::__end_boundary) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_boundary",
                                ));
                            }
                            result.end_boundary = map.next_value::<std::option::Option<crate::model::AnnotationBoundary>>()?
                                ;
                        }
                        __FieldTag::__answer_feedback => {
                            if !fields.insert(__FieldTag::__answer_feedback) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for answer_feedback",
                                ));
                            }
                            result.answer_feedback = map
                                .next_value::<std::option::Option<crate::model::AnswerFeedback>>(
                                )?;
                        }
                        __FieldTag::__user_input => {
                            if !fields.insert(__FieldTag::__user_input) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_input",
                                ));
                            }
                            result.user_input =
                                map.next_value::<std::option::Option<
                                    crate::model::runtime_annotation::UserInput,
                                >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RuntimeAnnotation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.article_suggestion() {
            state.serialize_entry("articleSuggestion", value)?;
        }
        if let Some(value) = self.faq_answer() {
            state.serialize_entry("faqAnswer", value)?;
        }
        if let Some(value) = self.smart_reply() {
            state.serialize_entry("smartReply", value)?;
        }
        if let Some(value) = self.smart_compose_suggestion() {
            state.serialize_entry("smartComposeSuggestion", value)?;
        }
        if let Some(value) = self.dialogflow_interaction() {
            state.serialize_entry("dialogflowInteraction", value)?;
        }
        if let Some(value) = self.conversation_summarization_suggestion() {
            state.serialize_entry("conversationSummarizationSuggestion", value)?;
        }
        if !self.annotation_id.is_empty() {
            state.serialize_entry("annotationId", &self.annotation_id)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.start_boundary.is_some() {
            state.serialize_entry("startBoundary", &self.start_boundary)?;
        }
        if self.end_boundary.is_some() {
            state.serialize_entry("endBoundary", &self.end_boundary)?;
        }
        if self.answer_feedback.is_some() {
            state.serialize_entry("answerFeedback", &self.answer_feedback)?;
        }
        if self.user_input.is_some() {
            state.serialize_entry("userInput", &self.user_input)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RuntimeAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RuntimeAnnotation");
        debug_struct.field("annotation_id", &self.annotation_id);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("start_boundary", &self.start_boundary);
        debug_struct.field("end_boundary", &self.end_boundary);
        debug_struct.field("answer_feedback", &self.answer_feedback);
        debug_struct.field("user_input", &self.user_input);
        debug_struct.field("data", &self.data);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [RuntimeAnnotation].
pub mod runtime_annotation {
    #[allow(unused_imports)]
    use super::*;

    /// Explicit input used for generating the answer
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct UserInput {
        /// Query text. Article Search uses this to store the input query used
        /// to generate the search results.
        pub query: std::string::String,

        /// The resource name of associated generator. Format:
        /// `projects/<Project ID>/locations/<Location ID>/generators/<Generator ID>`
        pub generator_name: std::string::String,

        /// Query source for the answer.
        pub query_source: crate::model::runtime_annotation::user_input::QuerySource,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl UserInput {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [query][crate::model::runtime_annotation::UserInput::query].
        pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.query = v.into();
            self
        }

        /// Sets the value of [generator_name][crate::model::runtime_annotation::UserInput::generator_name].
        pub fn set_generator_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.generator_name = v.into();
            self
        }

        /// Sets the value of [query_source][crate::model::runtime_annotation::UserInput::query_source].
        pub fn set_query_source<
            T: std::convert::Into<crate::model::runtime_annotation::user_input::QuerySource>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.query_source = v.into();
            self
        }
    }

    impl wkt::message::Message for UserInput {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.RuntimeAnnotation.UserInput"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for UserInput {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __query,
                __generator_name,
                __query_source,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for UserInput")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "query" => Ok(__FieldTag::__query),
                                "generatorName" => Ok(__FieldTag::__generator_name),
                                "generator_name" => Ok(__FieldTag::__generator_name),
                                "querySource" => Ok(__FieldTag::__query_source),
                                "query_source" => Ok(__FieldTag::__query_source),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = UserInput;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct UserInput")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__query => {
                                if !fields.insert(__FieldTag::__query) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for query",
                                    ));
                                }
                                result.query = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__generator_name => {
                                if !fields.insert(__FieldTag::__generator_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for generator_name",
                                    ));
                                }
                                result.generator_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__query_source => {
                                if !fields.insert(__FieldTag::__query_source) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for query_source",
                                    ));
                                }
                                result.query_source = map
                                    .next_value::<std::option::Option<
                                        crate::model::runtime_annotation::user_input::QuerySource,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for UserInput {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.query.is_empty() {
                state.serialize_entry("query", &self.query)?;
            }
            if !self.generator_name.is_empty() {
                state.serialize_entry("generatorName", &self.generator_name)?;
            }
            if !wkt::internal::is_default(&self.query_source) {
                state.serialize_entry("querySource", &self.query_source)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for UserInput {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("UserInput");
            debug_struct.field("query", &self.query);
            debug_struct.field("generator_name", &self.generator_name);
            debug_struct.field("query_source", &self.query_source);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [UserInput].
    pub mod user_input {
        #[allow(unused_imports)]
        use super::*;

        /// The source of the query.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum QuerySource {
            /// Unknown query source.
            Unspecified,
            /// The query is from agents.
            AgentQuery,
            /// The query is a query from previous suggestions, e.g. from a preceding
            /// SuggestKnowledgeAssist response.
            SuggestedQuery,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [QuerySource::value] or
            /// [QuerySource::name].
            UnknownValue(query_source::UnknownValue),
        }

        #[doc(hidden)]
        pub mod query_source {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl QuerySource {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::AgentQuery => std::option::Option::Some(1),
                    Self::SuggestedQuery => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("QUERY_SOURCE_UNSPECIFIED"),
                    Self::AgentQuery => std::option::Option::Some("AGENT_QUERY"),
                    Self::SuggestedQuery => std::option::Option::Some("SUGGESTED_QUERY"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for QuerySource {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for QuerySource {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for QuerySource {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::AgentQuery,
                    2 => Self::SuggestedQuery,
                    _ => Self::UnknownValue(query_source::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for QuerySource {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "QUERY_SOURCE_UNSPECIFIED" => Self::Unspecified,
                    "AGENT_QUERY" => Self::AgentQuery,
                    "SUGGESTED_QUERY" => Self::SuggestedQuery,
                    _ => Self::UnknownValue(query_source::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for QuerySource {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::AgentQuery => serializer.serialize_i32(1),
                    Self::SuggestedQuery => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for QuerySource {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<QuerySource>::new(
                    ".google.cloud.contactcenterinsights.v1.RuntimeAnnotation.UserInput.QuerySource"))
            }
        }
    }

    /// The data in the annotation.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Data {
        /// Agent Assist Article Suggestion data.
        ArticleSuggestion(std::boxed::Box<crate::model::ArticleSuggestionData>),
        /// Agent Assist FAQ answer data.
        FaqAnswer(std::boxed::Box<crate::model::FaqAnswerData>),
        /// Agent Assist Smart Reply data.
        SmartReply(std::boxed::Box<crate::model::SmartReplyData>),
        /// Agent Assist Smart Compose suggestion data.
        SmartComposeSuggestion(std::boxed::Box<crate::model::SmartComposeSuggestionData>),
        /// Dialogflow interaction data.
        DialogflowInteraction(std::boxed::Box<crate::model::DialogflowInteractionData>),
        /// Conversation summarization suggestion data.
        ConversationSummarizationSuggestion(
            std::boxed::Box<crate::model::ConversationSummarizationSuggestionData>,
        ),
    }
}

/// The feedback that the customer has about a certain answer in the
/// conversation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AnswerFeedback {
    /// The correctness level of an answer.
    pub correctness_level: crate::model::answer_feedback::CorrectnessLevel,

    /// Indicates whether an answer or item was clicked by the human agent.
    pub clicked: bool,

    /// Indicates whether an answer or item was displayed to the human agent in the
    /// agent desktop UI.
    pub displayed: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnswerFeedback {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [correctness_level][crate::model::AnswerFeedback::correctness_level].
    pub fn set_correctness_level<
        T: std::convert::Into<crate::model::answer_feedback::CorrectnessLevel>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.correctness_level = v.into();
        self
    }

    /// Sets the value of [clicked][crate::model::AnswerFeedback::clicked].
    pub fn set_clicked<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.clicked = v.into();
        self
    }

    /// Sets the value of [displayed][crate::model::AnswerFeedback::displayed].
    pub fn set_displayed<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.displayed = v.into();
        self
    }
}

impl wkt::message::Message for AnswerFeedback {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.AnswerFeedback"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AnswerFeedback {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __correctness_level,
            __clicked,
            __displayed,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AnswerFeedback")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "correctnessLevel" => Ok(__FieldTag::__correctness_level),
                            "correctness_level" => Ok(__FieldTag::__correctness_level),
                            "clicked" => Ok(__FieldTag::__clicked),
                            "displayed" => Ok(__FieldTag::__displayed),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AnswerFeedback;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnswerFeedback")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__correctness_level => {
                            if !fields.insert(__FieldTag::__correctness_level) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for correctness_level",
                                ));
                            }
                            result.correctness_level = map
                                .next_value::<std::option::Option<
                                    crate::model::answer_feedback::CorrectnessLevel,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__clicked => {
                            if !fields.insert(__FieldTag::__clicked) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for clicked",
                                ));
                            }
                            result.clicked = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__displayed => {
                            if !fields.insert(__FieldTag::__displayed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for displayed",
                                ));
                            }
                            result.displayed = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AnswerFeedback {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.correctness_level) {
            state.serialize_entry("correctnessLevel", &self.correctness_level)?;
        }
        if !wkt::internal::is_default(&self.clicked) {
            state.serialize_entry("clicked", &self.clicked)?;
        }
        if !wkt::internal::is_default(&self.displayed) {
            state.serialize_entry("displayed", &self.displayed)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AnswerFeedback {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AnswerFeedback");
        debug_struct.field("correctness_level", &self.correctness_level);
        debug_struct.field("clicked", &self.clicked);
        debug_struct.field("displayed", &self.displayed);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AnswerFeedback].
pub mod answer_feedback {
    #[allow(unused_imports)]
    use super::*;

    /// The correctness level of an answer.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CorrectnessLevel {
        /// Correctness level unspecified.
        Unspecified,
        /// Answer is totally wrong.
        NotCorrect,
        /// Answer is partially correct.
        PartiallyCorrect,
        /// Answer is fully correct.
        FullyCorrect,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CorrectnessLevel::value] or
        /// [CorrectnessLevel::name].
        UnknownValue(correctness_level::UnknownValue),
    }

    #[doc(hidden)]
    pub mod correctness_level {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CorrectnessLevel {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::NotCorrect => std::option::Option::Some(1),
                Self::PartiallyCorrect => std::option::Option::Some(2),
                Self::FullyCorrect => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CORRECTNESS_LEVEL_UNSPECIFIED"),
                Self::NotCorrect => std::option::Option::Some("NOT_CORRECT"),
                Self::PartiallyCorrect => std::option::Option::Some("PARTIALLY_CORRECT"),
                Self::FullyCorrect => std::option::Option::Some("FULLY_CORRECT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CorrectnessLevel {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CorrectnessLevel {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CorrectnessLevel {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::NotCorrect,
                2 => Self::PartiallyCorrect,
                3 => Self::FullyCorrect,
                _ => Self::UnknownValue(correctness_level::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CorrectnessLevel {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CORRECTNESS_LEVEL_UNSPECIFIED" => Self::Unspecified,
                "NOT_CORRECT" => Self::NotCorrect,
                "PARTIALLY_CORRECT" => Self::PartiallyCorrect,
                "FULLY_CORRECT" => Self::FullyCorrect,
                _ => Self::UnknownValue(correctness_level::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CorrectnessLevel {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::NotCorrect => serializer.serialize_i32(1),
                Self::PartiallyCorrect => serializer.serialize_i32(2),
                Self::FullyCorrect => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CorrectnessLevel {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CorrectnessLevel>::new(
                ".google.cloud.contactcenterinsights.v1.AnswerFeedback.CorrectnessLevel",
            ))
        }
    }
}

/// Agent Assist Article Suggestion data.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ArticleSuggestionData {
    /// Article title.
    pub title: std::string::String,

    /// Article URI.
    pub uri: std::string::String,

    /// The system's confidence score that this article is a good match for this
    /// conversation, ranging from 0.0 (completely uncertain) to 1.0 (completely
    /// certain).
    pub confidence_score: f32,

    /// Map that contains metadata about the Article Suggestion and the document
    /// that it originates from.
    pub metadata: std::collections::HashMap<std::string::String, std::string::String>,

    /// The name of the answer record.
    /// Format:
    /// projects/{project}/locations/{location}/answerRecords/{answer_record}
    pub query_record: std::string::String,

    /// The knowledge document that this answer was extracted from.
    /// Format:
    /// projects/{project}/knowledgeBases/{knowledge_base}/documents/{document}
    pub source: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ArticleSuggestionData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [title][crate::model::ArticleSuggestionData::title].
    pub fn set_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.title = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::ArticleSuggestionData::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [confidence_score][crate::model::ArticleSuggestionData::confidence_score].
    pub fn set_confidence_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.confidence_score = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::ArticleSuggestionData::metadata].
    pub fn set_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [query_record][crate::model::ArticleSuggestionData::query_record].
    pub fn set_query_record<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query_record = v.into();
        self
    }

    /// Sets the value of [source][crate::model::ArticleSuggestionData::source].
    pub fn set_source<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source = v.into();
        self
    }
}

impl wkt::message::Message for ArticleSuggestionData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ArticleSuggestionData"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ArticleSuggestionData {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __title,
            __uri,
            __confidence_score,
            __metadata,
            __query_record,
            __source,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ArticleSuggestionData")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "title" => Ok(__FieldTag::__title),
                            "uri" => Ok(__FieldTag::__uri),
                            "confidenceScore" => Ok(__FieldTag::__confidence_score),
                            "confidence_score" => Ok(__FieldTag::__confidence_score),
                            "metadata" => Ok(__FieldTag::__metadata),
                            "queryRecord" => Ok(__FieldTag::__query_record),
                            "query_record" => Ok(__FieldTag::__query_record),
                            "source" => Ok(__FieldTag::__source),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ArticleSuggestionData;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ArticleSuggestionData")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__title => {
                            if !fields.insert(__FieldTag::__title) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for title",
                                ));
                            }
                            result.title = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__confidence_score => {
                            if !fields.insert(__FieldTag::__confidence_score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for confidence_score",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.confidence_score =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata",
                                ));
                            }
                            result.metadata = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__query_record => {
                            if !fields.insert(__FieldTag::__query_record) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_record",
                                ));
                            }
                            result.query_record = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source => {
                            if !fields.insert(__FieldTag::__source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source",
                                ));
                            }
                            result.source = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ArticleSuggestionData {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.title.is_empty() {
            state.serialize_entry("title", &self.title)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !wkt::internal::is_default(&self.confidence_score) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("confidenceScore", &__With(&self.confidence_score))?;
        }
        if !self.metadata.is_empty() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !self.query_record.is_empty() {
            state.serialize_entry("queryRecord", &self.query_record)?;
        }
        if !self.source.is_empty() {
            state.serialize_entry("source", &self.source)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ArticleSuggestionData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ArticleSuggestionData");
        debug_struct.field("title", &self.title);
        debug_struct.field("uri", &self.uri);
        debug_struct.field("confidence_score", &self.confidence_score);
        debug_struct.field("metadata", &self.metadata);
        debug_struct.field("query_record", &self.query_record);
        debug_struct.field("source", &self.source);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Agent Assist frequently-asked-question answer data.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FaqAnswerData {
    /// The piece of text from the `source` knowledge base document.
    pub answer: std::string::String,

    /// The system's confidence score that this answer is a good match for this
    /// conversation, ranging from 0.0 (completely uncertain) to 1.0 (completely
    /// certain).
    pub confidence_score: f32,

    /// The corresponding FAQ question.
    pub question: std::string::String,

    /// Map that contains metadata about the FAQ answer and the document that
    /// it originates from.
    pub metadata: std::collections::HashMap<std::string::String, std::string::String>,

    /// The name of the answer record.
    /// Format:
    /// projects/{project}/locations/{location}/answerRecords/{answer_record}
    pub query_record: std::string::String,

    /// The knowledge document that this answer was extracted from.
    /// Format:
    /// projects/{project}/knowledgeBases/{knowledge_base}/documents/{document}.
    pub source: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FaqAnswerData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [answer][crate::model::FaqAnswerData::answer].
    pub fn set_answer<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.answer = v.into();
        self
    }

    /// Sets the value of [confidence_score][crate::model::FaqAnswerData::confidence_score].
    pub fn set_confidence_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.confidence_score = v.into();
        self
    }

    /// Sets the value of [question][crate::model::FaqAnswerData::question].
    pub fn set_question<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.question = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::FaqAnswerData::metadata].
    pub fn set_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [query_record][crate::model::FaqAnswerData::query_record].
    pub fn set_query_record<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query_record = v.into();
        self
    }

    /// Sets the value of [source][crate::model::FaqAnswerData::source].
    pub fn set_source<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source = v.into();
        self
    }
}

impl wkt::message::Message for FaqAnswerData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.FaqAnswerData"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FaqAnswerData {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __answer,
            __confidence_score,
            __question,
            __metadata,
            __query_record,
            __source,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FaqAnswerData")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "answer" => Ok(__FieldTag::__answer),
                            "confidenceScore" => Ok(__FieldTag::__confidence_score),
                            "confidence_score" => Ok(__FieldTag::__confidence_score),
                            "question" => Ok(__FieldTag::__question),
                            "metadata" => Ok(__FieldTag::__metadata),
                            "queryRecord" => Ok(__FieldTag::__query_record),
                            "query_record" => Ok(__FieldTag::__query_record),
                            "source" => Ok(__FieldTag::__source),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FaqAnswerData;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FaqAnswerData")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__answer => {
                            if !fields.insert(__FieldTag::__answer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for answer",
                                ));
                            }
                            result.answer = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__confidence_score => {
                            if !fields.insert(__FieldTag::__confidence_score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for confidence_score",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.confidence_score =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__question => {
                            if !fields.insert(__FieldTag::__question) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for question",
                                ));
                            }
                            result.question = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata",
                                ));
                            }
                            result.metadata = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__query_record => {
                            if !fields.insert(__FieldTag::__query_record) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_record",
                                ));
                            }
                            result.query_record = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source => {
                            if !fields.insert(__FieldTag::__source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source",
                                ));
                            }
                            result.source = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FaqAnswerData {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.answer.is_empty() {
            state.serialize_entry("answer", &self.answer)?;
        }
        if !wkt::internal::is_default(&self.confidence_score) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("confidenceScore", &__With(&self.confidence_score))?;
        }
        if !self.question.is_empty() {
            state.serialize_entry("question", &self.question)?;
        }
        if !self.metadata.is_empty() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !self.query_record.is_empty() {
            state.serialize_entry("queryRecord", &self.query_record)?;
        }
        if !self.source.is_empty() {
            state.serialize_entry("source", &self.source)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FaqAnswerData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FaqAnswerData");
        debug_struct.field("answer", &self.answer);
        debug_struct.field("confidence_score", &self.confidence_score);
        debug_struct.field("question", &self.question);
        debug_struct.field("metadata", &self.metadata);
        debug_struct.field("query_record", &self.query_record);
        debug_struct.field("source", &self.source);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Agent Assist Smart Reply data.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SmartReplyData {
    /// The content of the reply.
    pub reply: std::string::String,

    /// The system's confidence score that this reply is a good match for this
    /// conversation, ranging from 0.0 (completely uncertain) to 1.0 (completely
    /// certain).
    pub confidence_score: f64,

    /// Map that contains metadata about the Smart Reply and the document from
    /// which it originates.
    pub metadata: std::collections::HashMap<std::string::String, std::string::String>,

    /// The name of the answer record.
    /// Format:
    /// projects/{project}/locations/{location}/answerRecords/{answer_record}
    pub query_record: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SmartReplyData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [reply][crate::model::SmartReplyData::reply].
    pub fn set_reply<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.reply = v.into();
        self
    }

    /// Sets the value of [confidence_score][crate::model::SmartReplyData::confidence_score].
    pub fn set_confidence_score<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.confidence_score = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::SmartReplyData::metadata].
    pub fn set_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [query_record][crate::model::SmartReplyData::query_record].
    pub fn set_query_record<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query_record = v.into();
        self
    }
}

impl wkt::message::Message for SmartReplyData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.SmartReplyData"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SmartReplyData {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __reply,
            __confidence_score,
            __metadata,
            __query_record,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SmartReplyData")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "reply" => Ok(__FieldTag::__reply),
                            "confidenceScore" => Ok(__FieldTag::__confidence_score),
                            "confidence_score" => Ok(__FieldTag::__confidence_score),
                            "metadata" => Ok(__FieldTag::__metadata),
                            "queryRecord" => Ok(__FieldTag::__query_record),
                            "query_record" => Ok(__FieldTag::__query_record),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SmartReplyData;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SmartReplyData")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__reply => {
                            if !fields.insert(__FieldTag::__reply) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reply",
                                ));
                            }
                            result.reply = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__confidence_score => {
                            if !fields.insert(__FieldTag::__confidence_score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for confidence_score",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.confidence_score =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata",
                                ));
                            }
                            result.metadata = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__query_record => {
                            if !fields.insert(__FieldTag::__query_record) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_record",
                                ));
                            }
                            result.query_record = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SmartReplyData {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.reply.is_empty() {
            state.serialize_entry("reply", &self.reply)?;
        }
        if !wkt::internal::is_default(&self.confidence_score) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("confidenceScore", &__With(&self.confidence_score))?;
        }
        if !self.metadata.is_empty() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !self.query_record.is_empty() {
            state.serialize_entry("queryRecord", &self.query_record)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SmartReplyData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SmartReplyData");
        debug_struct.field("reply", &self.reply);
        debug_struct.field("confidence_score", &self.confidence_score);
        debug_struct.field("metadata", &self.metadata);
        debug_struct.field("query_record", &self.query_record);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Agent Assist Smart Compose suggestion data.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SmartComposeSuggestionData {
    /// The content of the suggestion.
    pub suggestion: std::string::String,

    /// The system's confidence score that this suggestion is a good match for this
    /// conversation, ranging from 0.0 (completely uncertain) to 1.0 (completely
    /// certain).
    pub confidence_score: f64,

    /// Map that contains metadata about the Smart Compose suggestion and the
    /// document from which it originates.
    pub metadata: std::collections::HashMap<std::string::String, std::string::String>,

    /// The name of the answer record.
    /// Format:
    /// projects/{project}/locations/{location}/answerRecords/{answer_record}
    pub query_record: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SmartComposeSuggestionData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [suggestion][crate::model::SmartComposeSuggestionData::suggestion].
    pub fn set_suggestion<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.suggestion = v.into();
        self
    }

    /// Sets the value of [confidence_score][crate::model::SmartComposeSuggestionData::confidence_score].
    pub fn set_confidence_score<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.confidence_score = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::SmartComposeSuggestionData::metadata].
    pub fn set_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [query_record][crate::model::SmartComposeSuggestionData::query_record].
    pub fn set_query_record<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query_record = v.into();
        self
    }
}

impl wkt::message::Message for SmartComposeSuggestionData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.SmartComposeSuggestionData"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SmartComposeSuggestionData {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __suggestion,
            __confidence_score,
            __metadata,
            __query_record,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SmartComposeSuggestionData")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "suggestion" => Ok(__FieldTag::__suggestion),
                            "confidenceScore" => Ok(__FieldTag::__confidence_score),
                            "confidence_score" => Ok(__FieldTag::__confidence_score),
                            "metadata" => Ok(__FieldTag::__metadata),
                            "queryRecord" => Ok(__FieldTag::__query_record),
                            "query_record" => Ok(__FieldTag::__query_record),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SmartComposeSuggestionData;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SmartComposeSuggestionData")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__suggestion => {
                            if !fields.insert(__FieldTag::__suggestion) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for suggestion",
                                ));
                            }
                            result.suggestion = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__confidence_score => {
                            if !fields.insert(__FieldTag::__confidence_score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for confidence_score",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.confidence_score =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata",
                                ));
                            }
                            result.metadata = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__query_record => {
                            if !fields.insert(__FieldTag::__query_record) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_record",
                                ));
                            }
                            result.query_record = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SmartComposeSuggestionData {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.suggestion.is_empty() {
            state.serialize_entry("suggestion", &self.suggestion)?;
        }
        if !wkt::internal::is_default(&self.confidence_score) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("confidenceScore", &__With(&self.confidence_score))?;
        }
        if !self.metadata.is_empty() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !self.query_record.is_empty() {
            state.serialize_entry("queryRecord", &self.query_record)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SmartComposeSuggestionData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SmartComposeSuggestionData");
        debug_struct.field("suggestion", &self.suggestion);
        debug_struct.field("confidence_score", &self.confidence_score);
        debug_struct.field("metadata", &self.metadata);
        debug_struct.field("query_record", &self.query_record);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Dialogflow interaction data.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DialogflowInteractionData {
    /// The Dialogflow intent resource path. Format:
    /// projects/{project}/agent/{agent}/intents/{intent}
    pub dialogflow_intent_id: std::string::String,

    /// The confidence of the match ranging from 0.0 (completely uncertain) to 1.0
    /// (completely certain).
    pub confidence: f32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DialogflowInteractionData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dialogflow_intent_id][crate::model::DialogflowInteractionData::dialogflow_intent_id].
    pub fn set_dialogflow_intent_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.dialogflow_intent_id = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::DialogflowInteractionData::confidence].
    pub fn set_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }
}

impl wkt::message::Message for DialogflowInteractionData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.DialogflowInteractionData"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DialogflowInteractionData {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dialogflow_intent_id,
            __confidence,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DialogflowInteractionData")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dialogflowIntentId" => Ok(__FieldTag::__dialogflow_intent_id),
                            "dialogflow_intent_id" => Ok(__FieldTag::__dialogflow_intent_id),
                            "confidence" => Ok(__FieldTag::__confidence),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DialogflowInteractionData;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DialogflowInteractionData")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dialogflow_intent_id => {
                            if !fields.insert(__FieldTag::__dialogflow_intent_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dialogflow_intent_id",
                                ));
                            }
                            result.dialogflow_intent_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__confidence => {
                            if !fields.insert(__FieldTag::__confidence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for confidence",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.confidence = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DialogflowInteractionData {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.dialogflow_intent_id.is_empty() {
            state.serialize_entry("dialogflowIntentId", &self.dialogflow_intent_id)?;
        }
        if !wkt::internal::is_default(&self.confidence) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("confidence", &__With(&self.confidence))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DialogflowInteractionData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DialogflowInteractionData");
        debug_struct.field("dialogflow_intent_id", &self.dialogflow_intent_id);
        debug_struct.field("confidence", &self.confidence);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Conversation summarization suggestion data.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ConversationSummarizationSuggestionData {
    /// The summarization content that is concatenated into one string.
    pub text: std::string::String,

    /// The summarization content that is divided into sections. The key is the
    /// section's name and the value is the section's content. There is no
    /// specific format for the key or value.
    pub text_sections: std::collections::HashMap<std::string::String, std::string::String>,

    /// The confidence score of the summarization.
    pub confidence: f32,

    /// A map that contains metadata about the summarization and the document
    /// from which it originates.
    pub metadata: std::collections::HashMap<std::string::String, std::string::String>,

    /// The name of the answer record.
    /// Format:
    /// projects/{project}/locations/{location}/answerRecords/{answer_record}
    pub answer_record: std::string::String,

    /// The name of the model that generates this summary.
    /// Format:
    /// projects/{project}/locations/{location}/conversationModels/{conversation_model}
    pub conversation_model: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConversationSummarizationSuggestionData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [text][crate::model::ConversationSummarizationSuggestionData::text].
    pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.text = v.into();
        self
    }

    /// Sets the value of [text_sections][crate::model::ConversationSummarizationSuggestionData::text_sections].
    pub fn set_text_sections<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.text_sections = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [confidence][crate::model::ConversationSummarizationSuggestionData::confidence].
    pub fn set_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::ConversationSummarizationSuggestionData::metadata].
    pub fn set_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [answer_record][crate::model::ConversationSummarizationSuggestionData::answer_record].
    pub fn set_answer_record<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.answer_record = v.into();
        self
    }

    /// Sets the value of [conversation_model][crate::model::ConversationSummarizationSuggestionData::conversation_model].
    pub fn set_conversation_model<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.conversation_model = v.into();
        self
    }
}

impl wkt::message::Message for ConversationSummarizationSuggestionData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ConversationSummarizationSuggestionData"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ConversationSummarizationSuggestionData {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __text,
            __text_sections,
            __confidence,
            __metadata,
            __answer_record,
            __conversation_model,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for ConversationSummarizationSuggestionData")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "text" => Ok(__FieldTag::__text),
                            "textSections" => Ok(__FieldTag::__text_sections),
                            "text_sections" => Ok(__FieldTag::__text_sections),
                            "confidence" => Ok(__FieldTag::__confidence),
                            "metadata" => Ok(__FieldTag::__metadata),
                            "answerRecord" => Ok(__FieldTag::__answer_record),
                            "answer_record" => Ok(__FieldTag::__answer_record),
                            "conversationModel" => Ok(__FieldTag::__conversation_model),
                            "conversation_model" => Ok(__FieldTag::__conversation_model),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ConversationSummarizationSuggestionData;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConversationSummarizationSuggestionData")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__text => {
                            if !fields.insert(__FieldTag::__text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for text",
                                ));
                            }
                            result.text = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__text_sections => {
                            if !fields.insert(__FieldTag::__text_sections) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for text_sections",
                                ));
                            }
                            result.text_sections = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__confidence => {
                            if !fields.insert(__FieldTag::__confidence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for confidence",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.confidence = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata",
                                ));
                            }
                            result.metadata = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__answer_record => {
                            if !fields.insert(__FieldTag::__answer_record) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for answer_record",
                                ));
                            }
                            result.answer_record = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__conversation_model => {
                            if !fields.insert(__FieldTag::__conversation_model) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation_model",
                                ));
                            }
                            result.conversation_model = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ConversationSummarizationSuggestionData {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.text.is_empty() {
            state.serialize_entry("text", &self.text)?;
        }
        if !self.text_sections.is_empty() {
            state.serialize_entry("textSections", &self.text_sections)?;
        }
        if !wkt::internal::is_default(&self.confidence) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("confidence", &__With(&self.confidence))?;
        }
        if !self.metadata.is_empty() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !self.answer_record.is_empty() {
            state.serialize_entry("answerRecord", &self.answer_record)?;
        }
        if !self.conversation_model.is_empty() {
            state.serialize_entry("conversationModel", &self.conversation_model)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ConversationSummarizationSuggestionData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConversationSummarizationSuggestionData");
        debug_struct.field("text", &self.text);
        debug_struct.field("text_sections", &self.text_sections);
        debug_struct.field("confidence", &self.confidence);
        debug_struct.field("metadata", &self.metadata);
        debug_struct.field("answer_record", &self.answer_record);
        debug_struct.field("conversation_model", &self.conversation_model);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The call participant speaking for a given utterance.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ConversationParticipant {
    /// Deprecated. Use `dialogflow_participant_name` instead.
    /// The name of the Dialogflow participant. Format:
    /// projects/{project}/locations/{location}/conversations/{conversation}/participants/{participant}
    #[deprecated]
    pub dialogflow_participant: std::string::String,

    /// Obfuscated user ID from Dialogflow.
    pub obfuscated_external_user_id: std::string::String,

    /// The role of the participant.
    pub role: crate::model::conversation_participant::Role,

    pub participant: std::option::Option<crate::model::conversation_participant::Participant>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConversationParticipant {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dialogflow_participant][crate::model::ConversationParticipant::dialogflow_participant].
    #[deprecated]
    pub fn set_dialogflow_participant<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.dialogflow_participant = v.into();
        self
    }

    /// Sets the value of [obfuscated_external_user_id][crate::model::ConversationParticipant::obfuscated_external_user_id].
    pub fn set_obfuscated_external_user_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.obfuscated_external_user_id = v.into();
        self
    }

    /// Sets the value of [role][crate::model::ConversationParticipant::role].
    pub fn set_role<T: std::convert::Into<crate::model::conversation_participant::Role>>(
        mut self,
        v: T,
    ) -> Self {
        self.role = v.into();
        self
    }

    /// Sets the value of [participant][crate::model::ConversationParticipant::participant].
    ///
    /// Note that all the setters affecting `participant` are mutually
    /// exclusive.
    pub fn set_participant<
        T: std::convert::Into<
                std::option::Option<crate::model::conversation_participant::Participant>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.participant = v.into();
        self
    }

    /// The value of [participant][crate::model::ConversationParticipant::participant]
    /// if it holds a `DialogflowParticipantName`, `None` if the field is not set or
    /// holds a different branch.
    pub fn dialogflow_participant_name(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.participant.as_ref().and_then(|v| match v {
            crate::model::conversation_participant::Participant::DialogflowParticipantName(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [participant][crate::model::ConversationParticipant::participant]
    /// to hold a `DialogflowParticipantName`.
    ///
    /// Note that all the setters affecting `participant` are
    /// mutually exclusive.
    pub fn set_dialogflow_participant_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.participant = std::option::Option::Some(
            crate::model::conversation_participant::Participant::DialogflowParticipantName(
                v.into(),
            ),
        );
        self
    }

    /// The value of [participant][crate::model::ConversationParticipant::participant]
    /// if it holds a `UserId`, `None` if the field is not set or
    /// holds a different branch.
    pub fn user_id(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.participant.as_ref().and_then(|v| match v {
            crate::model::conversation_participant::Participant::UserId(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [participant][crate::model::ConversationParticipant::participant]
    /// to hold a `UserId`.
    ///
    /// Note that all the setters affecting `participant` are
    /// mutually exclusive.
    pub fn set_user_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.participant = std::option::Option::Some(
            crate::model::conversation_participant::Participant::UserId(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ConversationParticipant {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ConversationParticipant"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ConversationParticipant {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dialogflow_participant_name,
            __user_id,
            __dialogflow_participant,
            __obfuscated_external_user_id,
            __role,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConversationParticipant")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dialogflowParticipantName" => {
                                Ok(__FieldTag::__dialogflow_participant_name)
                            }
                            "dialogflow_participant_name" => {
                                Ok(__FieldTag::__dialogflow_participant_name)
                            }
                            "userId" => Ok(__FieldTag::__user_id),
                            "user_id" => Ok(__FieldTag::__user_id),
                            "dialogflowParticipant" => Ok(__FieldTag::__dialogflow_participant),
                            "dialogflow_participant" => Ok(__FieldTag::__dialogflow_participant),
                            "obfuscatedExternalUserId" => {
                                Ok(__FieldTag::__obfuscated_external_user_id)
                            }
                            "obfuscated_external_user_id" => {
                                Ok(__FieldTag::__obfuscated_external_user_id)
                            }
                            "role" => Ok(__FieldTag::__role),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ConversationParticipant;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConversationParticipant")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dialogflow_participant_name => {
                            if !fields.insert(__FieldTag::__dialogflow_participant_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dialogflow_participant_name",
                                ));
                            }
                            if result.participant.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `participant`, a oneof with full ID .google.cloud.contactcenterinsights.v1.ConversationParticipant.dialogflow_participant_name, latest field was dialogflowParticipantName",
                                ));
                            }
                            result.participant = std::option::Option::Some(
                                crate::model::conversation_participant::Participant::DialogflowParticipantName(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__user_id => {
                            if !fields.insert(__FieldTag::__user_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_id",
                                ));
                            }
                            if result.participant.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `participant`, a oneof with full ID .google.cloud.contactcenterinsights.v1.ConversationParticipant.user_id, latest field was userId",
                                ));
                            }
                            result.participant = std::option::Option::Some(
                                crate::model::conversation_participant::Participant::UserId(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__dialogflow_participant => {
                            if !fields.insert(__FieldTag::__dialogflow_participant) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dialogflow_participant",
                                ));
                            }
                            result.dialogflow_participant = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__obfuscated_external_user_id => {
                            if !fields.insert(__FieldTag::__obfuscated_external_user_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for obfuscated_external_user_id",
                                ));
                            }
                            result.obfuscated_external_user_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__role => {
                            if !fields.insert(__FieldTag::__role) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for role",
                                ));
                            }
                            result.role =
                                map.next_value::<std::option::Option<
                                    crate::model::conversation_participant::Role,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ConversationParticipant {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.dialogflow_participant_name() {
            state.serialize_entry("dialogflowParticipantName", value)?;
        }
        if let Some(value) = self.user_id() {
            state.serialize_entry("userId", value)?;
        }
        if !self.dialogflow_participant.is_empty() {
            state.serialize_entry("dialogflowParticipant", &self.dialogflow_participant)?;
        }
        if !self.obfuscated_external_user_id.is_empty() {
            state.serialize_entry(
                "obfuscatedExternalUserId",
                &self.obfuscated_external_user_id,
            )?;
        }
        if !wkt::internal::is_default(&self.role) {
            state.serialize_entry("role", &self.role)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ConversationParticipant {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConversationParticipant");
        debug_struct.field("dialogflow_participant", &self.dialogflow_participant);
        debug_struct.field(
            "obfuscated_external_user_id",
            &self.obfuscated_external_user_id,
        );
        debug_struct.field("role", &self.role);
        debug_struct.field("participant", &self.participant);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ConversationParticipant].
pub mod conversation_participant {
    #[allow(unused_imports)]
    use super::*;

    /// The role of the participant.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Role {
        /// Participant's role is not set.
        Unspecified,
        /// Participant is a human agent.
        HumanAgent,
        /// Participant is an automated agent.
        AutomatedAgent,
        /// Participant is an end user who conversed with the contact center.
        EndUser,
        /// Participant is either a human or automated agent.
        AnyAgent,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Role::value] or
        /// [Role::name].
        UnknownValue(role::UnknownValue),
    }

    #[doc(hidden)]
    pub mod role {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Role {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::HumanAgent => std::option::Option::Some(1),
                Self::AutomatedAgent => std::option::Option::Some(2),
                Self::EndUser => std::option::Option::Some(3),
                Self::AnyAgent => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ROLE_UNSPECIFIED"),
                Self::HumanAgent => std::option::Option::Some("HUMAN_AGENT"),
                Self::AutomatedAgent => std::option::Option::Some("AUTOMATED_AGENT"),
                Self::EndUser => std::option::Option::Some("END_USER"),
                Self::AnyAgent => std::option::Option::Some("ANY_AGENT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Role {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Role {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Role {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::HumanAgent,
                2 => Self::AutomatedAgent,
                3 => Self::EndUser,
                4 => Self::AnyAgent,
                _ => Self::UnknownValue(role::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Role {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ROLE_UNSPECIFIED" => Self::Unspecified,
                "HUMAN_AGENT" => Self::HumanAgent,
                "AUTOMATED_AGENT" => Self::AutomatedAgent,
                "END_USER" => Self::EndUser,
                "ANY_AGENT" => Self::AnyAgent,
                _ => Self::UnknownValue(role::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Role {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::HumanAgent => serializer.serialize_i32(1),
                Self::AutomatedAgent => serializer.serialize_i32(2),
                Self::EndUser => serializer.serialize_i32(3),
                Self::AnyAgent => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Role {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Role>::new(
                ".google.cloud.contactcenterinsights.v1.ConversationParticipant.Role",
            ))
        }
    }

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Participant {
        /// The name of the participant provided by Dialogflow. Format:
        /// projects/{project}/locations/{location}/conversations/{conversation}/participants/{participant}
        DialogflowParticipantName(std::string::String),
        /// A user-specified ID representing the participant.
        UserId(std::string::String),
    }
}

/// The View resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct View {
    /// Immutable. The resource name of the view.
    /// Format:
    /// projects/{project}/locations/{location}/views/{view}
    pub name: std::string::String,

    /// The human-readable display name of the view.
    pub display_name: std::string::String,

    /// Output only. The time at which this view was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The most recent time at which the view was updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// String with specific view properties, must be non-empty.
    pub value: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl View {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::View::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::View::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::View::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::View::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::View::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::View::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [value][crate::model::View::value].
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }
}

impl wkt::message::Message for View {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.View"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for View {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __create_time,
            __update_time,
            __value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for View")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "value" => Ok(__FieldTag::__value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = View;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct View")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            result.value = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for View {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.value.is_empty() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for View {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("View");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("value", &self.value);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Selector of all available annotators and phrase matchers to run.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AnnotatorSelector {
    /// Whether to run the interruption annotator.
    pub run_interruption_annotator: bool,

    /// Whether to run the silence annotator.
    pub run_silence_annotator: bool,

    /// Whether to run the active phrase matcher annotator(s).
    pub run_phrase_matcher_annotator: bool,

    /// The list of phrase matchers to run. If not provided, all active phrase
    /// matchers will be used. If inactive phrase matchers are provided, they will
    /// not be used. Phrase matchers will be run only if
    /// run_phrase_matcher_annotator is set to true. Format:
    /// projects/{project}/locations/{location}/phraseMatchers/{phrase_matcher}
    pub phrase_matchers: std::vec::Vec<std::string::String>,

    /// Whether to run the sentiment annotator.
    pub run_sentiment_annotator: bool,

    /// Whether to run the entity annotator.
    pub run_entity_annotator: bool,

    /// Whether to run the intent annotator.
    pub run_intent_annotator: bool,

    /// Whether to run the issue model annotator. A model should have already been
    /// deployed for this to take effect.
    pub run_issue_model_annotator: bool,

    /// The issue model to run. If not provided, the most recently deployed topic
    /// model will be used. The provided issue model will only be used for
    /// inference if the issue model is deployed and if run_issue_model_annotator
    /// is set to true. If more than one issue model is provided, only the first
    /// provided issue model will be used for inference.
    pub issue_models: std::vec::Vec<std::string::String>,

    /// Whether to run the summarization annotator.
    pub run_summarization_annotator: bool,

    /// Configuration for the summarization annotator.
    pub summarization_config:
        std::option::Option<crate::model::annotator_selector::SummarizationConfig>,

    /// Whether to run the QA annotator.
    pub run_qa_annotator: bool,

    /// Configuration for the QA annotator.
    pub qa_config: std::option::Option<crate::model::annotator_selector::QaConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnnotatorSelector {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [run_interruption_annotator][crate::model::AnnotatorSelector::run_interruption_annotator].
    pub fn set_run_interruption_annotator<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.run_interruption_annotator = v.into();
        self
    }

    /// Sets the value of [run_silence_annotator][crate::model::AnnotatorSelector::run_silence_annotator].
    pub fn set_run_silence_annotator<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.run_silence_annotator = v.into();
        self
    }

    /// Sets the value of [run_phrase_matcher_annotator][crate::model::AnnotatorSelector::run_phrase_matcher_annotator].
    pub fn set_run_phrase_matcher_annotator<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.run_phrase_matcher_annotator = v.into();
        self
    }

    /// Sets the value of [phrase_matchers][crate::model::AnnotatorSelector::phrase_matchers].
    pub fn set_phrase_matchers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.phrase_matchers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [run_sentiment_annotator][crate::model::AnnotatorSelector::run_sentiment_annotator].
    pub fn set_run_sentiment_annotator<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.run_sentiment_annotator = v.into();
        self
    }

    /// Sets the value of [run_entity_annotator][crate::model::AnnotatorSelector::run_entity_annotator].
    pub fn set_run_entity_annotator<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.run_entity_annotator = v.into();
        self
    }

    /// Sets the value of [run_intent_annotator][crate::model::AnnotatorSelector::run_intent_annotator].
    pub fn set_run_intent_annotator<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.run_intent_annotator = v.into();
        self
    }

    /// Sets the value of [run_issue_model_annotator][crate::model::AnnotatorSelector::run_issue_model_annotator].
    pub fn set_run_issue_model_annotator<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.run_issue_model_annotator = v.into();
        self
    }

    /// Sets the value of [issue_models][crate::model::AnnotatorSelector::issue_models].
    pub fn set_issue_models<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.issue_models = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [run_summarization_annotator][crate::model::AnnotatorSelector::run_summarization_annotator].
    pub fn set_run_summarization_annotator<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.run_summarization_annotator = v.into();
        self
    }

    /// Sets the value of [summarization_config][crate::model::AnnotatorSelector::summarization_config].
    pub fn set_summarization_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::annotator_selector::SummarizationConfig>,
    {
        self.summarization_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [summarization_config][crate::model::AnnotatorSelector::summarization_config].
    pub fn set_or_clear_summarization_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::annotator_selector::SummarizationConfig>,
    {
        self.summarization_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [run_qa_annotator][crate::model::AnnotatorSelector::run_qa_annotator].
    pub fn set_run_qa_annotator<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.run_qa_annotator = v.into();
        self
    }

    /// Sets the value of [qa_config][crate::model::AnnotatorSelector::qa_config].
    pub fn set_qa_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::annotator_selector::QaConfig>,
    {
        self.qa_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [qa_config][crate::model::AnnotatorSelector::qa_config].
    pub fn set_or_clear_qa_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::annotator_selector::QaConfig>,
    {
        self.qa_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AnnotatorSelector {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.AnnotatorSelector"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AnnotatorSelector {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __run_interruption_annotator,
            __run_silence_annotator,
            __run_phrase_matcher_annotator,
            __phrase_matchers,
            __run_sentiment_annotator,
            __run_entity_annotator,
            __run_intent_annotator,
            __run_issue_model_annotator,
            __issue_models,
            __run_summarization_annotator,
            __summarization_config,
            __run_qa_annotator,
            __qa_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AnnotatorSelector")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "runInterruptionAnnotator" => {
                                Ok(__FieldTag::__run_interruption_annotator)
                            }
                            "run_interruption_annotator" => {
                                Ok(__FieldTag::__run_interruption_annotator)
                            }
                            "runSilenceAnnotator" => Ok(__FieldTag::__run_silence_annotator),
                            "run_silence_annotator" => Ok(__FieldTag::__run_silence_annotator),
                            "runPhraseMatcherAnnotator" => {
                                Ok(__FieldTag::__run_phrase_matcher_annotator)
                            }
                            "run_phrase_matcher_annotator" => {
                                Ok(__FieldTag::__run_phrase_matcher_annotator)
                            }
                            "phraseMatchers" => Ok(__FieldTag::__phrase_matchers),
                            "phrase_matchers" => Ok(__FieldTag::__phrase_matchers),
                            "runSentimentAnnotator" => Ok(__FieldTag::__run_sentiment_annotator),
                            "run_sentiment_annotator" => Ok(__FieldTag::__run_sentiment_annotator),
                            "runEntityAnnotator" => Ok(__FieldTag::__run_entity_annotator),
                            "run_entity_annotator" => Ok(__FieldTag::__run_entity_annotator),
                            "runIntentAnnotator" => Ok(__FieldTag::__run_intent_annotator),
                            "run_intent_annotator" => Ok(__FieldTag::__run_intent_annotator),
                            "runIssueModelAnnotator" => Ok(__FieldTag::__run_issue_model_annotator),
                            "run_issue_model_annotator" => {
                                Ok(__FieldTag::__run_issue_model_annotator)
                            }
                            "issueModels" => Ok(__FieldTag::__issue_models),
                            "issue_models" => Ok(__FieldTag::__issue_models),
                            "runSummarizationAnnotator" => {
                                Ok(__FieldTag::__run_summarization_annotator)
                            }
                            "run_summarization_annotator" => {
                                Ok(__FieldTag::__run_summarization_annotator)
                            }
                            "summarizationConfig" => Ok(__FieldTag::__summarization_config),
                            "summarization_config" => Ok(__FieldTag::__summarization_config),
                            "runQaAnnotator" => Ok(__FieldTag::__run_qa_annotator),
                            "run_qa_annotator" => Ok(__FieldTag::__run_qa_annotator),
                            "qaConfig" => Ok(__FieldTag::__qa_config),
                            "qa_config" => Ok(__FieldTag::__qa_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AnnotatorSelector;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnnotatorSelector")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__run_interruption_annotator => {
                            if !fields.insert(__FieldTag::__run_interruption_annotator) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for run_interruption_annotator",
                                ));
                            }
                            result.run_interruption_annotator = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__run_silence_annotator => {
                            if !fields.insert(__FieldTag::__run_silence_annotator) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for run_silence_annotator",
                                ));
                            }
                            result.run_silence_annotator = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__run_phrase_matcher_annotator => {
                            if !fields.insert(__FieldTag::__run_phrase_matcher_annotator) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for run_phrase_matcher_annotator",
                                ));
                            }
                            result.run_phrase_matcher_annotator = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__phrase_matchers => {
                            if !fields.insert(__FieldTag::__phrase_matchers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for phrase_matchers",
                                ));
                            }
                            result.phrase_matchers = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__run_sentiment_annotator => {
                            if !fields.insert(__FieldTag::__run_sentiment_annotator) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for run_sentiment_annotator",
                                ));
                            }
                            result.run_sentiment_annotator = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__run_entity_annotator => {
                            if !fields.insert(__FieldTag::__run_entity_annotator) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for run_entity_annotator",
                                ));
                            }
                            result.run_entity_annotator = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__run_intent_annotator => {
                            if !fields.insert(__FieldTag::__run_intent_annotator) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for run_intent_annotator",
                                ));
                            }
                            result.run_intent_annotator = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__run_issue_model_annotator => {
                            if !fields.insert(__FieldTag::__run_issue_model_annotator) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for run_issue_model_annotator",
                                ));
                            }
                            result.run_issue_model_annotator = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__issue_models => {
                            if !fields.insert(__FieldTag::__issue_models) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for issue_models",
                                ));
                            }
                            result.issue_models = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__run_summarization_annotator => {
                            if !fields.insert(__FieldTag::__run_summarization_annotator) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for run_summarization_annotator",
                                ));
                            }
                            result.run_summarization_annotator = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__summarization_config => {
                            if !fields.insert(__FieldTag::__summarization_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for summarization_config",
                                ));
                            }
                            result.summarization_config = map.next_value::<std::option::Option<
                                crate::model::annotator_selector::SummarizationConfig,
                            >>()?;
                        }
                        __FieldTag::__run_qa_annotator => {
                            if !fields.insert(__FieldTag::__run_qa_annotator) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for run_qa_annotator",
                                ));
                            }
                            result.run_qa_annotator = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__qa_config => {
                            if !fields.insert(__FieldTag::__qa_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for qa_config",
                                ));
                            }
                            result.qa_config = map.next_value::<std::option::Option<crate::model::annotator_selector::QaConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AnnotatorSelector {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.run_interruption_annotator) {
            state.serialize_entry("runInterruptionAnnotator", &self.run_interruption_annotator)?;
        }
        if !wkt::internal::is_default(&self.run_silence_annotator) {
            state.serialize_entry("runSilenceAnnotator", &self.run_silence_annotator)?;
        }
        if !wkt::internal::is_default(&self.run_phrase_matcher_annotator) {
            state.serialize_entry(
                "runPhraseMatcherAnnotator",
                &self.run_phrase_matcher_annotator,
            )?;
        }
        if !self.phrase_matchers.is_empty() {
            state.serialize_entry("phraseMatchers", &self.phrase_matchers)?;
        }
        if !wkt::internal::is_default(&self.run_sentiment_annotator) {
            state.serialize_entry("runSentimentAnnotator", &self.run_sentiment_annotator)?;
        }
        if !wkt::internal::is_default(&self.run_entity_annotator) {
            state.serialize_entry("runEntityAnnotator", &self.run_entity_annotator)?;
        }
        if !wkt::internal::is_default(&self.run_intent_annotator) {
            state.serialize_entry("runIntentAnnotator", &self.run_intent_annotator)?;
        }
        if !wkt::internal::is_default(&self.run_issue_model_annotator) {
            state.serialize_entry("runIssueModelAnnotator", &self.run_issue_model_annotator)?;
        }
        if !self.issue_models.is_empty() {
            state.serialize_entry("issueModels", &self.issue_models)?;
        }
        if !wkt::internal::is_default(&self.run_summarization_annotator) {
            state.serialize_entry(
                "runSummarizationAnnotator",
                &self.run_summarization_annotator,
            )?;
        }
        if self.summarization_config.is_some() {
            state.serialize_entry("summarizationConfig", &self.summarization_config)?;
        }
        if !wkt::internal::is_default(&self.run_qa_annotator) {
            state.serialize_entry("runQaAnnotator", &self.run_qa_annotator)?;
        }
        if self.qa_config.is_some() {
            state.serialize_entry("qaConfig", &self.qa_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AnnotatorSelector {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AnnotatorSelector");
        debug_struct.field(
            "run_interruption_annotator",
            &self.run_interruption_annotator,
        );
        debug_struct.field("run_silence_annotator", &self.run_silence_annotator);
        debug_struct.field(
            "run_phrase_matcher_annotator",
            &self.run_phrase_matcher_annotator,
        );
        debug_struct.field("phrase_matchers", &self.phrase_matchers);
        debug_struct.field("run_sentiment_annotator", &self.run_sentiment_annotator);
        debug_struct.field("run_entity_annotator", &self.run_entity_annotator);
        debug_struct.field("run_intent_annotator", &self.run_intent_annotator);
        debug_struct.field("run_issue_model_annotator", &self.run_issue_model_annotator);
        debug_struct.field("issue_models", &self.issue_models);
        debug_struct.field(
            "run_summarization_annotator",
            &self.run_summarization_annotator,
        );
        debug_struct.field("summarization_config", &self.summarization_config);
        debug_struct.field("run_qa_annotator", &self.run_qa_annotator);
        debug_struct.field("qa_config", &self.qa_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AnnotatorSelector].
pub mod annotator_selector {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration for summarization.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SummarizationConfig {
        /// Summarization must use either a preexisting conversation profile or one
        /// of the supported default models.
        pub model_source: std::option::Option<
            crate::model::annotator_selector::summarization_config::ModelSource,
        >,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SummarizationConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [model_source][crate::model::annotator_selector::SummarizationConfig::model_source].
        ///
        /// Note that all the setters affecting `model_source` are mutually
        /// exclusive.
        pub fn set_model_source<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::annotator_selector::summarization_config::ModelSource,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.model_source = v.into();
            self
        }

        /// The value of [model_source][crate::model::annotator_selector::SummarizationConfig::model_source]
        /// if it holds a `ConversationProfile`, `None` if the field is not set or
        /// holds a different branch.
        pub fn conversation_profile(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.model_source.as_ref().and_then(|v| match v {
                crate::model::annotator_selector::summarization_config::ModelSource::ConversationProfile(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [model_source][crate::model::annotator_selector::SummarizationConfig::model_source]
        /// to hold a `ConversationProfile`.
        ///
        /// Note that all the setters affecting `model_source` are
        /// mutually exclusive.
        pub fn set_conversation_profile<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.model_source = std::option::Option::Some(
                crate::model::annotator_selector::summarization_config::ModelSource::ConversationProfile(
                    v.into()
                )
            );
            self
        }

        /// The value of [model_source][crate::model::annotator_selector::SummarizationConfig::model_source]
        /// if it holds a `SummarizationModel`, `None` if the field is not set or
        /// holds a different branch.
        pub fn summarization_model(
            &self,
        ) -> std::option::Option<
            &crate::model::annotator_selector::summarization_config::SummarizationModel,
        > {
            #[allow(unreachable_patterns)]
            self.model_source.as_ref().and_then(|v| match v {
                crate::model::annotator_selector::summarization_config::ModelSource::SummarizationModel(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [model_source][crate::model::annotator_selector::SummarizationConfig::model_source]
        /// to hold a `SummarizationModel`.
        ///
        /// Note that all the setters affecting `model_source` are
        /// mutually exclusive.
        pub fn set_summarization_model<
            T: std::convert::Into<
                    crate::model::annotator_selector::summarization_config::SummarizationModel,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.model_source = std::option::Option::Some(
                crate::model::annotator_selector::summarization_config::ModelSource::SummarizationModel(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for SummarizationConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.AnnotatorSelector.SummarizationConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SummarizationConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __conversation_profile,
                __summarization_model,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SummarizationConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "conversationProfile" => Ok(__FieldTag::__conversation_profile),
                                "conversation_profile" => Ok(__FieldTag::__conversation_profile),
                                "summarizationModel" => Ok(__FieldTag::__summarization_model),
                                "summarization_model" => Ok(__FieldTag::__summarization_model),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SummarizationConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SummarizationConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__conversation_profile => {
                                if !fields.insert(__FieldTag::__conversation_profile) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for conversation_profile",
                                    ));
                                }
                                if result.model_source.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `model_source`, a oneof with full ID .google.cloud.contactcenterinsights.v1.AnnotatorSelector.SummarizationConfig.conversation_profile, latest field was conversationProfile",
                                    ));
                                }
                                result.model_source = std::option::Option::Some(
                                    crate::model::annotator_selector::summarization_config::ModelSource::ConversationProfile(
                                        map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__summarization_model => {
                                if !fields.insert(__FieldTag::__summarization_model) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for summarization_model",
                                    ));
                                }
                                if result.model_source.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `model_source`, a oneof with full ID .google.cloud.contactcenterinsights.v1.AnnotatorSelector.SummarizationConfig.summarization_model, latest field was summarizationModel",
                                    ));
                                }
                                result.model_source = std::option::Option::Some(
                                    crate::model::annotator_selector::summarization_config::ModelSource::SummarizationModel(
                                        map.next_value::<std::option::Option<crate::model::annotator_selector::summarization_config::SummarizationModel>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SummarizationConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.conversation_profile() {
                state.serialize_entry("conversationProfile", value)?;
            }
            if let Some(value) = self.summarization_model() {
                state.serialize_entry("summarizationModel", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for SummarizationConfig {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("SummarizationConfig");
            debug_struct.field("model_source", &self.model_source);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [SummarizationConfig].
    pub mod summarization_config {
        #[allow(unused_imports)]
        use super::*;

        /// Summarization model to use, if `conversation_profile` is not used.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum SummarizationModel {
            /// Unspecified summarization model.
            Unspecified,
            /// The CCAI baseline model.
            BaselineModel,
            /// The CCAI baseline model, V2.0.
            BaselineModelV20,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [SummarizationModel::value] or
            /// [SummarizationModel::name].
            UnknownValue(summarization_model::UnknownValue),
        }

        #[doc(hidden)]
        pub mod summarization_model {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl SummarizationModel {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::BaselineModel => std::option::Option::Some(1),
                    Self::BaselineModelV20 => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => {
                        std::option::Option::Some("SUMMARIZATION_MODEL_UNSPECIFIED")
                    }
                    Self::BaselineModel => std::option::Option::Some("BASELINE_MODEL"),
                    Self::BaselineModelV20 => std::option::Option::Some("BASELINE_MODEL_V2_0"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for SummarizationModel {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for SummarizationModel {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for SummarizationModel {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::BaselineModel,
                    2 => Self::BaselineModelV20,
                    _ => Self::UnknownValue(summarization_model::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for SummarizationModel {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "SUMMARIZATION_MODEL_UNSPECIFIED" => Self::Unspecified,
                    "BASELINE_MODEL" => Self::BaselineModel,
                    "BASELINE_MODEL_V2_0" => Self::BaselineModelV20,
                    _ => Self::UnknownValue(summarization_model::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for SummarizationModel {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::BaselineModel => serializer.serialize_i32(1),
                    Self::BaselineModelV20 => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for SummarizationModel {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<SummarizationModel>::new(
                    ".google.cloud.contactcenterinsights.v1.AnnotatorSelector.SummarizationConfig.SummarizationModel"))
            }
        }

        /// Summarization must use either a preexisting conversation profile or one
        /// of the supported default models.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum ModelSource {
            /// Resource name of the Dialogflow conversation profile.
            /// Format:
            /// projects/{project}/locations/{location}/conversationProfiles/{conversation_profile}
            ConversationProfile(std::string::String),
            /// Default summarization model to be used.
            SummarizationModel(
                crate::model::annotator_selector::summarization_config::SummarizationModel,
            ),
        }
    }

    /// Configuration for the QA feature.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct QaConfig {
        /// Which scorecards should be scored.
        pub scorecard_source:
            std::option::Option<crate::model::annotator_selector::qa_config::ScorecardSource>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl QaConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [scorecard_source][crate::model::annotator_selector::QaConfig::scorecard_source].
        ///
        /// Note that all the setters affecting `scorecard_source` are mutually
        /// exclusive.
        pub fn set_scorecard_source<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::annotator_selector::qa_config::ScorecardSource,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.scorecard_source = v.into();
            self
        }

        /// The value of [scorecard_source][crate::model::annotator_selector::QaConfig::scorecard_source]
        /// if it holds a `ScorecardList`, `None` if the field is not set or
        /// holds a different branch.
        pub fn scorecard_list(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::annotator_selector::qa_config::ScorecardList>,
        > {
            #[allow(unreachable_patterns)]
            self.scorecard_source.as_ref().and_then(|v| match v {
                crate::model::annotator_selector::qa_config::ScorecardSource::ScorecardList(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [scorecard_source][crate::model::annotator_selector::QaConfig::scorecard_source]
        /// to hold a `ScorecardList`.
        ///
        /// Note that all the setters affecting `scorecard_source` are
        /// mutually exclusive.
        pub fn set_scorecard_list<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::annotator_selector::qa_config::ScorecardList>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.scorecard_source = std::option::Option::Some(
                crate::model::annotator_selector::qa_config::ScorecardSource::ScorecardList(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for QaConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.AnnotatorSelector.QaConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for QaConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __scorecard_list,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for QaConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "scorecardList" => Ok(__FieldTag::__scorecard_list),
                                "scorecard_list" => Ok(__FieldTag::__scorecard_list),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = QaConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct QaConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__scorecard_list => {
                                if !fields.insert(__FieldTag::__scorecard_list) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for scorecard_list",
                                    ));
                                }
                                if result.scorecard_source.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `scorecard_source`, a oneof with full ID .google.cloud.contactcenterinsights.v1.AnnotatorSelector.QaConfig.scorecard_list, latest field was scorecardList",
                                    ));
                                }
                                result.scorecard_source = std::option::Option::Some(
                                    crate::model::annotator_selector::qa_config::ScorecardSource::ScorecardList(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::annotator_selector::qa_config::ScorecardList>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for QaConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.scorecard_list() {
                state.serialize_entry("scorecardList", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for QaConfig {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("QaConfig");
            debug_struct.field("scorecard_source", &self.scorecard_source);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [QaConfig].
    pub mod qa_config {
        #[allow(unused_imports)]
        use super::*;

        /// Container for a list of scorecards.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct ScorecardList {
            /// List of QaScorecardRevisions.
            pub qa_scorecard_revisions: std::vec::Vec<std::string::String>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl ScorecardList {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [qa_scorecard_revisions][crate::model::annotator_selector::qa_config::ScorecardList::qa_scorecard_revisions].
            pub fn set_qa_scorecard_revisions<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.qa_scorecard_revisions = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for ScorecardList {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.contactcenterinsights.v1.AnnotatorSelector.QaConfig.ScorecardList"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for ScorecardList {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __qa_scorecard_revisions,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for ScorecardList")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "qaScorecardRevisions" => {
                                        Ok(__FieldTag::__qa_scorecard_revisions)
                                    }
                                    "qa_scorecard_revisions" => {
                                        Ok(__FieldTag::__qa_scorecard_revisions)
                                    }
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = ScorecardList;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct ScorecardList")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__qa_scorecard_revisions => {
                                    if !fields.insert(__FieldTag::__qa_scorecard_revisions) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for qa_scorecard_revisions",
                                            ),
                                        );
                                    }
                                    result.qa_scorecard_revisions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for ScorecardList {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.qa_scorecard_revisions.is_empty() {
                    state.serialize_entry("qaScorecardRevisions", &self.qa_scorecard_revisions)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for ScorecardList {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("ScorecardList");
                debug_struct.field("qa_scorecard_revisions", &self.qa_scorecard_revisions);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// Which scorecards should be scored.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum ScorecardSource {
            /// A manual list of scorecards to score.
            ScorecardList(
                std::boxed::Box<crate::model::annotator_selector::qa_config::ScorecardList>,
            ),
        }
    }
}

/// A single question to be scored by the Insights QA feature.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct QaQuestion {
    /// Identifier. The resource name of the question.
    /// Format:
    /// projects/{project}/locations/{location}/qaScorecards/{qa_scorecard}/revisions/{revision}/qaQuestions/{qa_question}
    pub name: std::string::String,

    /// Short, descriptive string, used in the UI where it's not practical
    /// to display the full question body. E.g., "Greeting".
    pub abbreviation: std::string::String,

    /// Output only. The time at which this question was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The most recent time at which the question was updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Question text. E.g., "Did the agent greet the customer?"
    pub question_body: std::string::String,

    /// Instructions describing how to determine the answer.
    pub answer_instructions: std::string::String,

    /// A list of valid answers to the question, which the LLM must choose from.
    pub answer_choices: std::vec::Vec<crate::model::qa_question::AnswerChoice>,

    /// User-defined list of arbitrary tags for the question. Used for
    /// grouping/organization and for weighting the score of each question.
    pub tags: std::vec::Vec<std::string::String>,

    /// Defines the order of the question within its parent scorecard revision.
    pub order: i32,

    /// Metrics of the underlying tuned LLM over a holdout/test set while fine
    /// tuning the underlying LLM for the given question. This field will only be
    /// populated if and only if the question is part of a scorecard revision that
    /// has been tuned.
    pub metrics: std::option::Option<crate::model::qa_question::Metrics>,

    /// Metadata about the tuning operation for the question.This field will only
    /// be populated if and only if the question is part of a scorecard revision
    /// that has been tuned.
    pub tuning_metadata: std::option::Option<crate::model::qa_question::TuningMetadata>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QaQuestion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::QaQuestion::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [abbreviation][crate::model::QaQuestion::abbreviation].
    pub fn set_abbreviation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.abbreviation = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::QaQuestion::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::QaQuestion::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::QaQuestion::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::QaQuestion::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [question_body][crate::model::QaQuestion::question_body].
    pub fn set_question_body<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.question_body = v.into();
        self
    }

    /// Sets the value of [answer_instructions][crate::model::QaQuestion::answer_instructions].
    pub fn set_answer_instructions<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.answer_instructions = v.into();
        self
    }

    /// Sets the value of [answer_choices][crate::model::QaQuestion::answer_choices].
    pub fn set_answer_choices<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::qa_question::AnswerChoice>,
    {
        use std::iter::Iterator;
        self.answer_choices = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [tags][crate::model::QaQuestion::tags].
    pub fn set_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [order][crate::model::QaQuestion::order].
    pub fn set_order<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.order = v.into();
        self
    }

    /// Sets the value of [metrics][crate::model::QaQuestion::metrics].
    pub fn set_metrics<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::qa_question::Metrics>,
    {
        self.metrics = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metrics][crate::model::QaQuestion::metrics].
    pub fn set_or_clear_metrics<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::qa_question::Metrics>,
    {
        self.metrics = v.map(|x| x.into());
        self
    }

    /// Sets the value of [tuning_metadata][crate::model::QaQuestion::tuning_metadata].
    pub fn set_tuning_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::qa_question::TuningMetadata>,
    {
        self.tuning_metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [tuning_metadata][crate::model::QaQuestion::tuning_metadata].
    pub fn set_or_clear_tuning_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::qa_question::TuningMetadata>,
    {
        self.tuning_metadata = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for QaQuestion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.QaQuestion"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for QaQuestion {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __abbreviation,
            __create_time,
            __update_time,
            __question_body,
            __answer_instructions,
            __answer_choices,
            __tags,
            __order,
            __metrics,
            __tuning_metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QaQuestion")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "abbreviation" => Ok(__FieldTag::__abbreviation),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "questionBody" => Ok(__FieldTag::__question_body),
                            "question_body" => Ok(__FieldTag::__question_body),
                            "answerInstructions" => Ok(__FieldTag::__answer_instructions),
                            "answer_instructions" => Ok(__FieldTag::__answer_instructions),
                            "answerChoices" => Ok(__FieldTag::__answer_choices),
                            "answer_choices" => Ok(__FieldTag::__answer_choices),
                            "tags" => Ok(__FieldTag::__tags),
                            "order" => Ok(__FieldTag::__order),
                            "metrics" => Ok(__FieldTag::__metrics),
                            "tuningMetadata" => Ok(__FieldTag::__tuning_metadata),
                            "tuning_metadata" => Ok(__FieldTag::__tuning_metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = QaQuestion;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QaQuestion")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__abbreviation => {
                            if !fields.insert(__FieldTag::__abbreviation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for abbreviation",
                                ));
                            }
                            result.abbreviation = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__question_body => {
                            if !fields.insert(__FieldTag::__question_body) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for question_body",
                                ));
                            }
                            result.question_body = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__answer_instructions => {
                            if !fields.insert(__FieldTag::__answer_instructions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for answer_instructions",
                                ));
                            }
                            result.answer_instructions = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__answer_choices => {
                            if !fields.insert(__FieldTag::__answer_choices) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for answer_choices",
                                ));
                            }
                            result.answer_choices = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::qa_question::AnswerChoice>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tags => {
                            if !fields.insert(__FieldTag::__tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tags",
                                ));
                            }
                            result.tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__order => {
                            if !fields.insert(__FieldTag::__order) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.order = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__metrics => {
                            if !fields.insert(__FieldTag::__metrics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metrics",
                                ));
                            }
                            result.metrics = map.next_value::<std::option::Option<crate::model::qa_question::Metrics>>()?
                                ;
                        }
                        __FieldTag::__tuning_metadata => {
                            if !fields.insert(__FieldTag::__tuning_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tuning_metadata",
                                ));
                            }
                            result.tuning_metadata = map.next_value::<std::option::Option<crate::model::qa_question::TuningMetadata>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for QaQuestion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.abbreviation.is_empty() {
            state.serialize_entry("abbreviation", &self.abbreviation)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.question_body.is_empty() {
            state.serialize_entry("questionBody", &self.question_body)?;
        }
        if !self.answer_instructions.is_empty() {
            state.serialize_entry("answerInstructions", &self.answer_instructions)?;
        }
        if !self.answer_choices.is_empty() {
            state.serialize_entry("answerChoices", &self.answer_choices)?;
        }
        if !self.tags.is_empty() {
            state.serialize_entry("tags", &self.tags)?;
        }
        if !wkt::internal::is_default(&self.order) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("order", &__With(&self.order))?;
        }
        if self.metrics.is_some() {
            state.serialize_entry("metrics", &self.metrics)?;
        }
        if self.tuning_metadata.is_some() {
            state.serialize_entry("tuningMetadata", &self.tuning_metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for QaQuestion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("QaQuestion");
        debug_struct.field("name", &self.name);
        debug_struct.field("abbreviation", &self.abbreviation);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("question_body", &self.question_body);
        debug_struct.field("answer_instructions", &self.answer_instructions);
        debug_struct.field("answer_choices", &self.answer_choices);
        debug_struct.field("tags", &self.tags);
        debug_struct.field("order", &self.order);
        debug_struct.field("metrics", &self.metrics);
        debug_struct.field("tuning_metadata", &self.tuning_metadata);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [QaQuestion].
pub mod qa_question {
    #[allow(unused_imports)]
    use super::*;

    /// Message representing a possible answer to the question.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AnswerChoice {
        /// A short string used as an identifier.
        pub key: std::string::String,

        /// Numerical score of the answer, used for generating the overall score of
        /// a QaScorecardResult. If the answer uses na_value, this field is unused.
        pub score: std::option::Option<f64>,

        /// The answer value may be one of a few different types.
        pub value: std::option::Option<crate::model::qa_question::answer_choice::Value>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AnswerChoice {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [key][crate::model::qa_question::AnswerChoice::key].
        pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.key = v.into();
            self
        }

        /// Sets the value of [score][crate::model::qa_question::AnswerChoice::score].
        pub fn set_score<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<f64>,
        {
            self.score = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [score][crate::model::qa_question::AnswerChoice::score].
        pub fn set_or_clear_score<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<f64>,
        {
            self.score = v.map(|x| x.into());
            self
        }

        /// Sets the value of [value][crate::model::qa_question::AnswerChoice::value].
        ///
        /// Note that all the setters affecting `value` are mutually
        /// exclusive.
        pub fn set_value<
            T: std::convert::Into<
                    std::option::Option<crate::model::qa_question::answer_choice::Value>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.value = v.into();
            self
        }

        /// The value of [value][crate::model::qa_question::AnswerChoice::value]
        /// if it holds a `StrValue`, `None` if the field is not set or
        /// holds a different branch.
        pub fn str_value(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::qa_question::answer_choice::Value::StrValue(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value][crate::model::qa_question::AnswerChoice::value]
        /// to hold a `StrValue`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_str_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.value = std::option::Option::Some(
                crate::model::qa_question::answer_choice::Value::StrValue(v.into()),
            );
            self
        }

        /// The value of [value][crate::model::qa_question::AnswerChoice::value]
        /// if it holds a `NumValue`, `None` if the field is not set or
        /// holds a different branch.
        pub fn num_value(&self) -> std::option::Option<&f64> {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::qa_question::answer_choice::Value::NumValue(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value][crate::model::qa_question::AnswerChoice::value]
        /// to hold a `NumValue`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_num_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.value = std::option::Option::Some(
                crate::model::qa_question::answer_choice::Value::NumValue(v.into()),
            );
            self
        }

        /// The value of [value][crate::model::qa_question::AnswerChoice::value]
        /// if it holds a `BoolValue`, `None` if the field is not set or
        /// holds a different branch.
        pub fn bool_value(&self) -> std::option::Option<&bool> {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::qa_question::answer_choice::Value::BoolValue(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value][crate::model::qa_question::AnswerChoice::value]
        /// to hold a `BoolValue`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_bool_value<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.value = std::option::Option::Some(
                crate::model::qa_question::answer_choice::Value::BoolValue(v.into()),
            );
            self
        }

        /// The value of [value][crate::model::qa_question::AnswerChoice::value]
        /// if it holds a `NaValue`, `None` if the field is not set or
        /// holds a different branch.
        pub fn na_value(&self) -> std::option::Option<&bool> {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::qa_question::answer_choice::Value::NaValue(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value][crate::model::qa_question::AnswerChoice::value]
        /// to hold a `NaValue`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_na_value<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.value = std::option::Option::Some(
                crate::model::qa_question::answer_choice::Value::NaValue(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for AnswerChoice {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.QaQuestion.AnswerChoice"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AnswerChoice {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __str_value,
                __num_value,
                __bool_value,
                __na_value,
                __key,
                __score,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AnswerChoice")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "strValue" => Ok(__FieldTag::__str_value),
                                "str_value" => Ok(__FieldTag::__str_value),
                                "numValue" => Ok(__FieldTag::__num_value),
                                "num_value" => Ok(__FieldTag::__num_value),
                                "boolValue" => Ok(__FieldTag::__bool_value),
                                "bool_value" => Ok(__FieldTag::__bool_value),
                                "naValue" => Ok(__FieldTag::__na_value),
                                "na_value" => Ok(__FieldTag::__na_value),
                                "key" => Ok(__FieldTag::__key),
                                "score" => Ok(__FieldTag::__score),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AnswerChoice;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AnswerChoice")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__str_value => {
                                if !fields.insert(__FieldTag::__str_value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for str_value",
                                    ));
                                }
                                if result.value.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `value`, a oneof with full ID .google.cloud.contactcenterinsights.v1.QaQuestion.AnswerChoice.str_value, latest field was strValue",
                                    ));
                                }
                                result.value = std::option::Option::Some(
                                    crate::model::qa_question::answer_choice::Value::StrValue(
                                        map.next_value::<std::option::Option<std::string::String>>(
                                        )?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__num_value => {
                                if !fields.insert(__FieldTag::__num_value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for num_value",
                                    ));
                                }
                                struct __With(std::option::Option<f64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                if result.value.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `value`, a oneof with full ID .google.cloud.contactcenterinsights.v1.QaQuestion.AnswerChoice.num_value, latest field was numValue",
                                    ));
                                }
                                result.value = std::option::Option::Some(
                                    crate::model::qa_question::answer_choice::Value::NumValue(
                                        map.next_value::<__With>()?.0.unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__bool_value => {
                                if !fields.insert(__FieldTag::__bool_value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for bool_value",
                                    ));
                                }
                                if result.value.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `value`, a oneof with full ID .google.cloud.contactcenterinsights.v1.QaQuestion.AnswerChoice.bool_value, latest field was boolValue",
                                    ));
                                }
                                result.value = std::option::Option::Some(
                                    crate::model::qa_question::answer_choice::Value::BoolValue(
                                        map.next_value::<std::option::Option<bool>>()?
                                            .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__na_value => {
                                if !fields.insert(__FieldTag::__na_value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for na_value",
                                    ));
                                }
                                if result.value.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `value`, a oneof with full ID .google.cloud.contactcenterinsights.v1.QaQuestion.AnswerChoice.na_value, latest field was naValue",
                                    ));
                                }
                                result.value = std::option::Option::Some(
                                    crate::model::qa_question::answer_choice::Value::NaValue(
                                        map.next_value::<std::option::Option<bool>>()?
                                            .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__key => {
                                if !fields.insert(__FieldTag::__key) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for key",
                                    ));
                                }
                                result.key = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__score => {
                                if !fields.insert(__FieldTag::__score) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for score",
                                    ));
                                }
                                struct __With(std::option::Option<f64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.score = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AnswerChoice {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.str_value() {
                state.serialize_entry("strValue", value)?;
            }
            if let Some(value) = self.num_value() {
                struct __With<'a>(&'a f64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("numValue", &__With(value))?;
            }
            if let Some(value) = self.bool_value() {
                state.serialize_entry("boolValue", value)?;
            }
            if let Some(value) = self.na_value() {
                state.serialize_entry("naValue", value)?;
            }
            if !self.key.is_empty() {
                state.serialize_entry("key", &self.key)?;
            }
            if self.score.is_some() {
                struct __With<'a>(&'a std::option::Option<f64>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("score", &__With(&self.score))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for AnswerChoice {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("AnswerChoice");
            debug_struct.field("key", &self.key);
            debug_struct.field("score", &self.score);
            debug_struct.field("value", &self.value);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [AnswerChoice].
    pub mod answer_choice {
        #[allow(unused_imports)]
        use super::*;

        /// The answer value may be one of a few different types.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Value {
            /// String value.
            StrValue(std::string::String),
            /// Numerical value.
            NumValue(f64),
            /// Boolean value.
            BoolValue(bool),
            /// A value of "Not Applicable (N/A)". If provided, this field may only
            /// be set to `true`. If a question receives this answer, it will be
            /// excluded from any score calculations.
            NaValue(bool),
        }
    }

    /// A wrapper representing metrics calculated against a test-set on a LLM that
    /// was fine tuned for this question.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Metrics {
        /// Output only. Accuracy of the model. Measures the percentage of correct
        /// answers the model gave on the test set.
        pub accuracy: f64,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Metrics {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [accuracy][crate::model::qa_question::Metrics::accuracy].
        pub fn set_accuracy<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.accuracy = v.into();
            self
        }
    }

    impl wkt::message::Message for Metrics {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.QaQuestion.Metrics"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Metrics {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __accuracy,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Metrics")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "accuracy" => Ok(__FieldTag::__accuracy),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Metrics;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Metrics")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__accuracy => {
                                if !fields.insert(__FieldTag::__accuracy) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for accuracy",
                                    ));
                                }
                                struct __With(std::option::Option<f64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.accuracy = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Metrics {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.accuracy) {
                struct __With<'a>(&'a f64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("accuracy", &__With(&self.accuracy))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Metrics {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Metrics");
            debug_struct.field("accuracy", &self.accuracy);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Metadata about the tuning operation for the question. Will only be set if a
    /// scorecard containing this question has been tuned.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TuningMetadata {
        /// Total number of valid labels provided for the question at the time of
        /// tuining.
        pub total_valid_label_count: i64,

        /// A list of any applicable data validation warnings about the question's
        /// feedback labels.
        pub dataset_validation_warnings: std::vec::Vec<crate::model::DatasetValidationWarning>,

        /// Error status of the tuning operation for the question. Will only be set
        /// if the tuning operation failed.
        pub tuning_error: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TuningMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [total_valid_label_count][crate::model::qa_question::TuningMetadata::total_valid_label_count].
        pub fn set_total_valid_label_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.total_valid_label_count = v.into();
            self
        }

        /// Sets the value of [dataset_validation_warnings][crate::model::qa_question::TuningMetadata::dataset_validation_warnings].
        pub fn set_dataset_validation_warnings<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::DatasetValidationWarning>,
        {
            use std::iter::Iterator;
            self.dataset_validation_warnings = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [tuning_error][crate::model::qa_question::TuningMetadata::tuning_error].
        pub fn set_tuning_error<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.tuning_error = v.into();
            self
        }
    }

    impl wkt::message::Message for TuningMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.QaQuestion.TuningMetadata"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for TuningMetadata {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __total_valid_label_count,
                __dataset_validation_warnings,
                __tuning_error,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for TuningMetadata")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "totalValidLabelCount" => Ok(__FieldTag::__total_valid_label_count),
                                "total_valid_label_count" => {
                                    Ok(__FieldTag::__total_valid_label_count)
                                }
                                "datasetValidationWarnings" => {
                                    Ok(__FieldTag::__dataset_validation_warnings)
                                }
                                "dataset_validation_warnings" => {
                                    Ok(__FieldTag::__dataset_validation_warnings)
                                }
                                "tuningError" => Ok(__FieldTag::__tuning_error),
                                "tuning_error" => Ok(__FieldTag::__tuning_error),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = TuningMetadata;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct TuningMetadata")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__total_valid_label_count => {
                                if !fields.insert(__FieldTag::__total_valid_label_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for total_valid_label_count",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.total_valid_label_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__dataset_validation_warnings => {
                                if !fields.insert(__FieldTag::__dataset_validation_warnings) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for dataset_validation_warnings",
                                    ));
                                }
                                result.dataset_validation_warnings = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::DatasetValidationWarning>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__tuning_error => {
                                if !fields.insert(__FieldTag::__tuning_error) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for tuning_error",
                                    ));
                                }
                                result.tuning_error = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for TuningMetadata {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.total_valid_label_count) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "totalValidLabelCount",
                    &__With(&self.total_valid_label_count),
                )?;
            }
            if !self.dataset_validation_warnings.is_empty() {
                state.serialize_entry(
                    "datasetValidationWarnings",
                    &self.dataset_validation_warnings,
                )?;
            }
            if !self.tuning_error.is_empty() {
                state.serialize_entry("tuningError", &self.tuning_error)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for TuningMetadata {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("TuningMetadata");
            debug_struct.field("total_valid_label_count", &self.total_valid_label_count);
            debug_struct.field(
                "dataset_validation_warnings",
                &self.dataset_validation_warnings,
            );
            debug_struct.field("tuning_error", &self.tuning_error);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// A QaScorecard represents a collection of questions to be scored during
/// analysis.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct QaScorecard {
    /// Identifier. The scorecard name.
    /// Format:
    /// projects/{project}/locations/{location}/qaScorecards/{qa_scorecard}
    pub name: std::string::String,

    /// The user-specified display name of the scorecard.
    pub display_name: std::string::String,

    /// A text description explaining the intent of the scorecard.
    pub description: std::string::String,

    /// Output only. The time at which this scorecard was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The most recent time at which the scorecard was updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QaScorecard {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::QaScorecard::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::QaScorecard::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::QaScorecard::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::QaScorecard::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::QaScorecard::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::QaScorecard::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::QaScorecard::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for QaScorecard {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.QaScorecard"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for QaScorecard {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __description,
            __create_time,
            __update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QaScorecard")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = QaScorecard;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QaScorecard")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for QaScorecard {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for QaScorecard {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("QaScorecard");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("description", &self.description);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A revision of a QaScorecard.
///
/// Modifying published scorecard fields would invalidate existing scorecard
/// results  the questions may have changed, or the score weighting will make
/// existing scores impossible to understand. So changes must create a new
/// revision, rather than modifying the existing resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct QaScorecardRevision {
    /// Identifier. The name of the scorecard revision.
    /// Format:
    /// projects/{project}/locations/{location}/qaScorecards/{qa_scorecard}/revisions/{revision}
    pub name: std::string::String,

    /// The snapshot of the scorecard at the time of this revision's creation.
    pub snapshot: std::option::Option<crate::model::QaScorecard>,

    /// Output only. The timestamp that the revision was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Alternative IDs for this revision of the scorecard, e.g.,
    /// `latest`.
    pub alternate_ids: std::vec::Vec<std::string::String>,

    /// Output only. State of the scorecard revision, indicating whether it's ready
    /// to be used in analysis.
    pub state: crate::model::qa_scorecard_revision::State,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QaScorecardRevision {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::QaScorecardRevision::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [snapshot][crate::model::QaScorecardRevision::snapshot].
    pub fn set_snapshot<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::QaScorecard>,
    {
        self.snapshot = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [snapshot][crate::model::QaScorecardRevision::snapshot].
    pub fn set_or_clear_snapshot<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::QaScorecard>,
    {
        self.snapshot = v.map(|x| x.into());
        self
    }

    /// Sets the value of [create_time][crate::model::QaScorecardRevision::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::QaScorecardRevision::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [alternate_ids][crate::model::QaScorecardRevision::alternate_ids].
    pub fn set_alternate_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.alternate_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [state][crate::model::QaScorecardRevision::state].
    pub fn set_state<T: std::convert::Into<crate::model::qa_scorecard_revision::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }
}

impl wkt::message::Message for QaScorecardRevision {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.QaScorecardRevision"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for QaScorecardRevision {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __snapshot,
            __create_time,
            __alternate_ids,
            __state,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QaScorecardRevision")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "snapshot" => Ok(__FieldTag::__snapshot),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "alternateIds" => Ok(__FieldTag::__alternate_ids),
                            "alternate_ids" => Ok(__FieldTag::__alternate_ids),
                            "state" => Ok(__FieldTag::__state),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = QaScorecardRevision;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QaScorecardRevision")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__snapshot => {
                            if !fields.insert(__FieldTag::__snapshot) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for snapshot",
                                ));
                            }
                            result.snapshot =
                                map.next_value::<std::option::Option<crate::model::QaScorecard>>()?;
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__alternate_ids => {
                            if !fields.insert(__FieldTag::__alternate_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for alternate_ids",
                                ));
                            }
                            result.alternate_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::qa_scorecard_revision::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for QaScorecardRevision {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.snapshot.is_some() {
            state.serialize_entry("snapshot", &self.snapshot)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self.alternate_ids.is_empty() {
            state.serialize_entry("alternateIds", &self.alternate_ids)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for QaScorecardRevision {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("QaScorecardRevision");
        debug_struct.field("name", &self.name);
        debug_struct.field("snapshot", &self.snapshot);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("alternate_ids", &self.alternate_ids);
        debug_struct.field("state", &self.state);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [QaScorecardRevision].
pub mod qa_scorecard_revision {
    #[allow(unused_imports)]
    use super::*;

    /// Enum representing the set of states a scorecard revision may be in.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified.
        Unspecified,
        /// The scorecard revision can be edited.
        Editable,
        /// Scorecard model training is in progress.
        Training,
        /// Scorecard revision model training failed.
        TrainingFailed,
        /// The revision can be used in analysis.
        Ready,
        /// Scorecard is being deleted.
        Deleting,
        /// Scorecard model training was explicitly cancelled by the user.
        TrainingCancelled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Editable => std::option::Option::Some(12),
                Self::Training => std::option::Option::Some(2),
                Self::TrainingFailed => std::option::Option::Some(9),
                Self::Ready => std::option::Option::Some(11),
                Self::Deleting => std::option::Option::Some(7),
                Self::TrainingCancelled => std::option::Option::Some(14),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Editable => std::option::Option::Some("EDITABLE"),
                Self::Training => std::option::Option::Some("TRAINING"),
                Self::TrainingFailed => std::option::Option::Some("TRAINING_FAILED"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::TrainingCancelled => std::option::Option::Some("TRAINING_CANCELLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                2 => Self::Training,
                7 => Self::Deleting,
                9 => Self::TrainingFailed,
                11 => Self::Ready,
                12 => Self::Editable,
                14 => Self::TrainingCancelled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "EDITABLE" => Self::Editable,
                "TRAINING" => Self::Training,
                "TRAINING_FAILED" => Self::TrainingFailed,
                "READY" => Self::Ready,
                "DELETING" => Self::Deleting,
                "TRAINING_CANCELLED" => Self::TrainingCancelled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Editable => serializer.serialize_i32(12),
                Self::Training => serializer.serialize_i32(2),
                Self::TrainingFailed => serializer.serialize_i32(9),
                Self::Ready => serializer.serialize_i32(11),
                Self::Deleting => serializer.serialize_i32(7),
                Self::TrainingCancelled => serializer.serialize_i32(14),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.contactcenterinsights.v1.QaScorecardRevision.State",
            ))
        }
    }
}

/// An answer to a QaQuestion.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct QaAnswer {
    /// The QaQuestion answered by this answer.
    pub qa_question: std::string::String,

    /// The conversation the answer applies to.
    pub conversation: std::string::String,

    /// Question text. E.g., "Did the agent greet the customer?"
    pub question_body: std::string::String,

    /// The main answer value, incorporating any manual edits if they exist.
    pub answer_value: std::option::Option<crate::model::qa_answer::AnswerValue>,

    /// User-defined list of arbitrary tags. Matches the value from
    /// QaScorecard.ScorecardQuestion.tags. Used for grouping/organization and
    /// for weighting the score of each answer.
    pub tags: std::vec::Vec<std::string::String>,

    /// List of all individual answers given to the question.
    pub answer_sources: std::vec::Vec<crate::model::qa_answer::AnswerSource>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QaAnswer {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [qa_question][crate::model::QaAnswer::qa_question].
    pub fn set_qa_question<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.qa_question = v.into();
        self
    }

    /// Sets the value of [conversation][crate::model::QaAnswer::conversation].
    pub fn set_conversation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.conversation = v.into();
        self
    }

    /// Sets the value of [question_body][crate::model::QaAnswer::question_body].
    pub fn set_question_body<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.question_body = v.into();
        self
    }

    /// Sets the value of [answer_value][crate::model::QaAnswer::answer_value].
    pub fn set_answer_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::qa_answer::AnswerValue>,
    {
        self.answer_value = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [answer_value][crate::model::QaAnswer::answer_value].
    pub fn set_or_clear_answer_value<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::qa_answer::AnswerValue>,
    {
        self.answer_value = v.map(|x| x.into());
        self
    }

    /// Sets the value of [tags][crate::model::QaAnswer::tags].
    pub fn set_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [answer_sources][crate::model::QaAnswer::answer_sources].
    pub fn set_answer_sources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::qa_answer::AnswerSource>,
    {
        use std::iter::Iterator;
        self.answer_sources = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for QaAnswer {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.QaAnswer"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for QaAnswer {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __qa_question,
            __conversation,
            __question_body,
            __answer_value,
            __tags,
            __answer_sources,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QaAnswer")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "qaQuestion" => Ok(__FieldTag::__qa_question),
                            "qa_question" => Ok(__FieldTag::__qa_question),
                            "conversation" => Ok(__FieldTag::__conversation),
                            "questionBody" => Ok(__FieldTag::__question_body),
                            "question_body" => Ok(__FieldTag::__question_body),
                            "answerValue" => Ok(__FieldTag::__answer_value),
                            "answer_value" => Ok(__FieldTag::__answer_value),
                            "tags" => Ok(__FieldTag::__tags),
                            "answerSources" => Ok(__FieldTag::__answer_sources),
                            "answer_sources" => Ok(__FieldTag::__answer_sources),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = QaAnswer;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QaAnswer")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__qa_question => {
                            if !fields.insert(__FieldTag::__qa_question) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for qa_question",
                                ));
                            }
                            result.qa_question = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__conversation => {
                            if !fields.insert(__FieldTag::__conversation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation",
                                ));
                            }
                            result.conversation = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__question_body => {
                            if !fields.insert(__FieldTag::__question_body) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for question_body",
                                ));
                            }
                            result.question_body = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__answer_value => {
                            if !fields.insert(__FieldTag::__answer_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for answer_value",
                                ));
                            }
                            result.answer_value = map.next_value::<std::option::Option<crate::model::qa_answer::AnswerValue>>()?
                                ;
                        }
                        __FieldTag::__tags => {
                            if !fields.insert(__FieldTag::__tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tags",
                                ));
                            }
                            result.tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__answer_sources => {
                            if !fields.insert(__FieldTag::__answer_sources) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for answer_sources",
                                ));
                            }
                            result.answer_sources = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::qa_answer::AnswerSource>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for QaAnswer {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.qa_question.is_empty() {
            state.serialize_entry("qaQuestion", &self.qa_question)?;
        }
        if !self.conversation.is_empty() {
            state.serialize_entry("conversation", &self.conversation)?;
        }
        if !self.question_body.is_empty() {
            state.serialize_entry("questionBody", &self.question_body)?;
        }
        if self.answer_value.is_some() {
            state.serialize_entry("answerValue", &self.answer_value)?;
        }
        if !self.tags.is_empty() {
            state.serialize_entry("tags", &self.tags)?;
        }
        if !self.answer_sources.is_empty() {
            state.serialize_entry("answerSources", &self.answer_sources)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for QaAnswer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("QaAnswer");
        debug_struct.field("qa_question", &self.qa_question);
        debug_struct.field("conversation", &self.conversation);
        debug_struct.field("question_body", &self.question_body);
        debug_struct.field("answer_value", &self.answer_value);
        debug_struct.field("tags", &self.tags);
        debug_struct.field("answer_sources", &self.answer_sources);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [QaAnswer].
pub mod qa_answer {
    #[allow(unused_imports)]
    use super::*;

    /// Message for holding the value of a
    /// [QaAnswer][google.cloud.contactcenterinsights.v1.QaAnswer].
    /// [QaQuestion.AnswerChoice][google.cloud.contactcenterinsights.v1.QaQuestion.AnswerChoice]
    /// defines the possible answer values for a question.
    ///
    /// [google.cloud.contactcenterinsights.v1.QaAnswer]: crate::model::QaAnswer
    /// [google.cloud.contactcenterinsights.v1.QaQuestion.AnswerChoice]: crate::model::qa_question::AnswerChoice
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AnswerValue {
        /// A short string used as an identifier. Matches the value used in
        /// QaQuestion.AnswerChoice.key.
        pub key: std::string::String,

        /// Output only. Numerical score of the answer.
        pub score: std::option::Option<f64>,

        /// Output only. The maximum potential score of the question.
        pub potential_score: std::option::Option<f64>,

        /// Output only. Normalized score of the questions. Calculated as score /
        /// potential_score.
        pub normalized_score: std::option::Option<f64>,

        /// The answer value may be one of a few different types.
        pub value: std::option::Option<crate::model::qa_answer::answer_value::Value>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AnswerValue {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [key][crate::model::qa_answer::AnswerValue::key].
        pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.key = v.into();
            self
        }

        /// Sets the value of [score][crate::model::qa_answer::AnswerValue::score].
        pub fn set_score<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<f64>,
        {
            self.score = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [score][crate::model::qa_answer::AnswerValue::score].
        pub fn set_or_clear_score<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<f64>,
        {
            self.score = v.map(|x| x.into());
            self
        }

        /// Sets the value of [potential_score][crate::model::qa_answer::AnswerValue::potential_score].
        pub fn set_potential_score<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<f64>,
        {
            self.potential_score = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [potential_score][crate::model::qa_answer::AnswerValue::potential_score].
        pub fn set_or_clear_potential_score<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<f64>,
        {
            self.potential_score = v.map(|x| x.into());
            self
        }

        /// Sets the value of [normalized_score][crate::model::qa_answer::AnswerValue::normalized_score].
        pub fn set_normalized_score<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<f64>,
        {
            self.normalized_score = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [normalized_score][crate::model::qa_answer::AnswerValue::normalized_score].
        pub fn set_or_clear_normalized_score<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<f64>,
        {
            self.normalized_score = v.map(|x| x.into());
            self
        }

        /// Sets the value of [value][crate::model::qa_answer::AnswerValue::value].
        ///
        /// Note that all the setters affecting `value` are mutually
        /// exclusive.
        pub fn set_value<
            T: std::convert::Into<std::option::Option<crate::model::qa_answer::answer_value::Value>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.value = v.into();
            self
        }

        /// The value of [value][crate::model::qa_answer::AnswerValue::value]
        /// if it holds a `StrValue`, `None` if the field is not set or
        /// holds a different branch.
        pub fn str_value(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::qa_answer::answer_value::Value::StrValue(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value][crate::model::qa_answer::AnswerValue::value]
        /// to hold a `StrValue`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_str_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.value = std::option::Option::Some(
                crate::model::qa_answer::answer_value::Value::StrValue(v.into()),
            );
            self
        }

        /// The value of [value][crate::model::qa_answer::AnswerValue::value]
        /// if it holds a `NumValue`, `None` if the field is not set or
        /// holds a different branch.
        pub fn num_value(&self) -> std::option::Option<&f64> {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::qa_answer::answer_value::Value::NumValue(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value][crate::model::qa_answer::AnswerValue::value]
        /// to hold a `NumValue`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_num_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.value = std::option::Option::Some(
                crate::model::qa_answer::answer_value::Value::NumValue(v.into()),
            );
            self
        }

        /// The value of [value][crate::model::qa_answer::AnswerValue::value]
        /// if it holds a `BoolValue`, `None` if the field is not set or
        /// holds a different branch.
        pub fn bool_value(&self) -> std::option::Option<&bool> {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::qa_answer::answer_value::Value::BoolValue(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value][crate::model::qa_answer::AnswerValue::value]
        /// to hold a `BoolValue`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_bool_value<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.value = std::option::Option::Some(
                crate::model::qa_answer::answer_value::Value::BoolValue(v.into()),
            );
            self
        }

        /// The value of [value][crate::model::qa_answer::AnswerValue::value]
        /// if it holds a `NaValue`, `None` if the field is not set or
        /// holds a different branch.
        pub fn na_value(&self) -> std::option::Option<&bool> {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::qa_answer::answer_value::Value::NaValue(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value][crate::model::qa_answer::AnswerValue::value]
        /// to hold a `NaValue`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_na_value<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.value = std::option::Option::Some(
                crate::model::qa_answer::answer_value::Value::NaValue(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for AnswerValue {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.QaAnswer.AnswerValue"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AnswerValue {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __str_value,
                __num_value,
                __bool_value,
                __na_value,
                __key,
                __score,
                __potential_score,
                __normalized_score,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AnswerValue")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "strValue" => Ok(__FieldTag::__str_value),
                                "str_value" => Ok(__FieldTag::__str_value),
                                "numValue" => Ok(__FieldTag::__num_value),
                                "num_value" => Ok(__FieldTag::__num_value),
                                "boolValue" => Ok(__FieldTag::__bool_value),
                                "bool_value" => Ok(__FieldTag::__bool_value),
                                "naValue" => Ok(__FieldTag::__na_value),
                                "na_value" => Ok(__FieldTag::__na_value),
                                "key" => Ok(__FieldTag::__key),
                                "score" => Ok(__FieldTag::__score),
                                "potentialScore" => Ok(__FieldTag::__potential_score),
                                "potential_score" => Ok(__FieldTag::__potential_score),
                                "normalizedScore" => Ok(__FieldTag::__normalized_score),
                                "normalized_score" => Ok(__FieldTag::__normalized_score),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AnswerValue;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AnswerValue")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__str_value => {
                                if !fields.insert(__FieldTag::__str_value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for str_value",
                                    ));
                                }
                                if result.value.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `value`, a oneof with full ID .google.cloud.contactcenterinsights.v1.QaAnswer.AnswerValue.str_value, latest field was strValue",
                                    ));
                                }
                                result.value = std::option::Option::Some(
                                    crate::model::qa_answer::answer_value::Value::StrValue(
                                        map.next_value::<std::option::Option<std::string::String>>(
                                        )?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__num_value => {
                                if !fields.insert(__FieldTag::__num_value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for num_value",
                                    ));
                                }
                                struct __With(std::option::Option<f64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                if result.value.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `value`, a oneof with full ID .google.cloud.contactcenterinsights.v1.QaAnswer.AnswerValue.num_value, latest field was numValue",
                                    ));
                                }
                                result.value = std::option::Option::Some(
                                    crate::model::qa_answer::answer_value::Value::NumValue(
                                        map.next_value::<__With>()?.0.unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__bool_value => {
                                if !fields.insert(__FieldTag::__bool_value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for bool_value",
                                    ));
                                }
                                if result.value.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `value`, a oneof with full ID .google.cloud.contactcenterinsights.v1.QaAnswer.AnswerValue.bool_value, latest field was boolValue",
                                    ));
                                }
                                result.value = std::option::Option::Some(
                                    crate::model::qa_answer::answer_value::Value::BoolValue(
                                        map.next_value::<std::option::Option<bool>>()?
                                            .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__na_value => {
                                if !fields.insert(__FieldTag::__na_value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for na_value",
                                    ));
                                }
                                if result.value.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `value`, a oneof with full ID .google.cloud.contactcenterinsights.v1.QaAnswer.AnswerValue.na_value, latest field was naValue",
                                    ));
                                }
                                result.value = std::option::Option::Some(
                                    crate::model::qa_answer::answer_value::Value::NaValue(
                                        map.next_value::<std::option::Option<bool>>()?
                                            .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__key => {
                                if !fields.insert(__FieldTag::__key) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for key",
                                    ));
                                }
                                result.key = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__score => {
                                if !fields.insert(__FieldTag::__score) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for score",
                                    ));
                                }
                                struct __With(std::option::Option<f64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.score = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::__potential_score => {
                                if !fields.insert(__FieldTag::__potential_score) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for potential_score",
                                    ));
                                }
                                struct __With(std::option::Option<f64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.potential_score = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::__normalized_score => {
                                if !fields.insert(__FieldTag::__normalized_score) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for normalized_score",
                                    ));
                                }
                                struct __With(std::option::Option<f64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.normalized_score = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AnswerValue {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.str_value() {
                state.serialize_entry("strValue", value)?;
            }
            if let Some(value) = self.num_value() {
                struct __With<'a>(&'a f64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("numValue", &__With(value))?;
            }
            if let Some(value) = self.bool_value() {
                state.serialize_entry("boolValue", value)?;
            }
            if let Some(value) = self.na_value() {
                state.serialize_entry("naValue", value)?;
            }
            if !self.key.is_empty() {
                state.serialize_entry("key", &self.key)?;
            }
            if self.score.is_some() {
                struct __With<'a>(&'a std::option::Option<f64>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("score", &__With(&self.score))?;
            }
            if self.potential_score.is_some() {
                struct __With<'a>(&'a std::option::Option<f64>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("potentialScore", &__With(&self.potential_score))?;
            }
            if self.normalized_score.is_some() {
                struct __With<'a>(&'a std::option::Option<f64>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("normalizedScore", &__With(&self.normalized_score))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for AnswerValue {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("AnswerValue");
            debug_struct.field("key", &self.key);
            debug_struct.field("score", &self.score);
            debug_struct.field("potential_score", &self.potential_score);
            debug_struct.field("normalized_score", &self.normalized_score);
            debug_struct.field("value", &self.value);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [AnswerValue].
    pub mod answer_value {
        #[allow(unused_imports)]
        use super::*;

        /// The answer value may be one of a few different types.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Value {
            /// String value.
            StrValue(std::string::String),
            /// Numerical value.
            NumValue(f64),
            /// Boolean value.
            BoolValue(bool),
            /// A value of "Not Applicable (N/A)". Should only ever be `true`.
            NaValue(bool),
        }
    }

    /// A question may have multiple answers from varying sources, one of which
    /// becomes the "main" answer above. AnswerSource represents each individual
    /// answer.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AnswerSource {
        /// What created the answer.
        pub source_type: crate::model::qa_answer::answer_source::SourceType,

        /// The answer value from this source.
        pub answer_value: std::option::Option<crate::model::qa_answer::AnswerValue>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AnswerSource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [source_type][crate::model::qa_answer::AnswerSource::source_type].
        pub fn set_source_type<
            T: std::convert::Into<crate::model::qa_answer::answer_source::SourceType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.source_type = v.into();
            self
        }

        /// Sets the value of [answer_value][crate::model::qa_answer::AnswerSource::answer_value].
        pub fn set_answer_value<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::qa_answer::AnswerValue>,
        {
            self.answer_value = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [answer_value][crate::model::qa_answer::AnswerSource::answer_value].
        pub fn set_or_clear_answer_value<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::qa_answer::AnswerValue>,
        {
            self.answer_value = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for AnswerSource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.QaAnswer.AnswerSource"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AnswerSource {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __source_type,
                __answer_value,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AnswerSource")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "sourceType" => Ok(__FieldTag::__source_type),
                                "source_type" => Ok(__FieldTag::__source_type),
                                "answerValue" => Ok(__FieldTag::__answer_value),
                                "answer_value" => Ok(__FieldTag::__answer_value),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AnswerSource;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AnswerSource")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__source_type => {
                                if !fields.insert(__FieldTag::__source_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for source_type",
                                    ));
                                }
                                result.source_type = map
                                    .next_value::<std::option::Option<
                                        crate::model::qa_answer::answer_source::SourceType,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__answer_value => {
                                if !fields.insert(__FieldTag::__answer_value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for answer_value",
                                    ));
                                }
                                result.answer_value = map.next_value::<std::option::Option<crate::model::qa_answer::AnswerValue>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AnswerSource {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.source_type) {
                state.serialize_entry("sourceType", &self.source_type)?;
            }
            if self.answer_value.is_some() {
                state.serialize_entry("answerValue", &self.answer_value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for AnswerSource {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("AnswerSource");
            debug_struct.field("source_type", &self.source_type);
            debug_struct.field("answer_value", &self.answer_value);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [AnswerSource].
    pub mod answer_source {
        #[allow(unused_imports)]
        use super::*;

        /// What created the answer.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum SourceType {
            /// Source type is unspecified.
            Unspecified,
            /// Answer was system-generated; created during an Insights analysis.
            SystemGenerated,
            /// Answer was created by a human via manual edit.
            ManualEdit,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [SourceType::value] or
            /// [SourceType::name].
            UnknownValue(source_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod source_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl SourceType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::SystemGenerated => std::option::Option::Some(1),
                    Self::ManualEdit => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("SOURCE_TYPE_UNSPECIFIED"),
                    Self::SystemGenerated => std::option::Option::Some("SYSTEM_GENERATED"),
                    Self::ManualEdit => std::option::Option::Some("MANUAL_EDIT"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for SourceType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for SourceType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for SourceType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::SystemGenerated,
                    2 => Self::ManualEdit,
                    _ => Self::UnknownValue(source_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for SourceType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "SOURCE_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "SYSTEM_GENERATED" => Self::SystemGenerated,
                    "MANUAL_EDIT" => Self::ManualEdit,
                    _ => Self::UnknownValue(source_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for SourceType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::SystemGenerated => serializer.serialize_i32(1),
                    Self::ManualEdit => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for SourceType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<SourceType>::new(
                    ".google.cloud.contactcenterinsights.v1.QaAnswer.AnswerSource.SourceType",
                ))
            }
        }
    }
}

/// The results of scoring a single conversation against a QaScorecard. Contains
/// a collection of QaAnswers and aggregate score.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct QaScorecardResult {
    /// Identifier. The name of the scorecard result.
    /// Format:
    /// projects/{project}/locations/{location}/qaScorecardResults/{qa_scorecard_result}
    pub name: std::string::String,

    /// The QaScorecardRevision scored by this result.
    pub qa_scorecard_revision: std::string::String,

    /// The conversation scored by this result.
    pub conversation: std::string::String,

    /// Output only. The timestamp that the revision was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// ID of the agent that handled the conversation.
    pub agent_id: std::string::String,

    /// Set of QaAnswers represented in the result.
    pub qa_answers: std::vec::Vec<crate::model::QaAnswer>,

    /// The overall numerical score of the result, incorporating any manual edits
    /// if they exist.
    pub score: std::option::Option<f64>,

    /// The maximum potential overall score of the scorecard. Any questions
    /// answered using `na_value` are excluded from this calculation.
    pub potential_score: std::option::Option<f64>,

    /// The normalized score, which is the score divided by the potential score.
    /// Any manual edits are included if they exist.
    pub normalized_score: std::option::Option<f64>,

    /// Collection of tags and their scores.
    pub qa_tag_results: std::vec::Vec<crate::model::qa_scorecard_result::QaTagResult>,

    /// List of all individual score sets.
    pub score_sources: std::vec::Vec<crate::model::qa_scorecard_result::ScoreSource>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QaScorecardResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::QaScorecardResult::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [qa_scorecard_revision][crate::model::QaScorecardResult::qa_scorecard_revision].
    pub fn set_qa_scorecard_revision<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.qa_scorecard_revision = v.into();
        self
    }

    /// Sets the value of [conversation][crate::model::QaScorecardResult::conversation].
    pub fn set_conversation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.conversation = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::QaScorecardResult::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::QaScorecardResult::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [agent_id][crate::model::QaScorecardResult::agent_id].
    pub fn set_agent_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.agent_id = v.into();
        self
    }

    /// Sets the value of [qa_answers][crate::model::QaScorecardResult::qa_answers].
    pub fn set_qa_answers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::QaAnswer>,
    {
        use std::iter::Iterator;
        self.qa_answers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [score][crate::model::QaScorecardResult::score].
    pub fn set_score<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.score = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [score][crate::model::QaScorecardResult::score].
    pub fn set_or_clear_score<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.score = v.map(|x| x.into());
        self
    }

    /// Sets the value of [potential_score][crate::model::QaScorecardResult::potential_score].
    pub fn set_potential_score<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.potential_score = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [potential_score][crate::model::QaScorecardResult::potential_score].
    pub fn set_or_clear_potential_score<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.potential_score = v.map(|x| x.into());
        self
    }

    /// Sets the value of [normalized_score][crate::model::QaScorecardResult::normalized_score].
    pub fn set_normalized_score<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.normalized_score = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [normalized_score][crate::model::QaScorecardResult::normalized_score].
    pub fn set_or_clear_normalized_score<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.normalized_score = v.map(|x| x.into());
        self
    }

    /// Sets the value of [qa_tag_results][crate::model::QaScorecardResult::qa_tag_results].
    pub fn set_qa_tag_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::qa_scorecard_result::QaTagResult>,
    {
        use std::iter::Iterator;
        self.qa_tag_results = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [score_sources][crate::model::QaScorecardResult::score_sources].
    pub fn set_score_sources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::qa_scorecard_result::ScoreSource>,
    {
        use std::iter::Iterator;
        self.score_sources = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for QaScorecardResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.QaScorecardResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for QaScorecardResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __qa_scorecard_revision,
            __conversation,
            __create_time,
            __agent_id,
            __qa_answers,
            __score,
            __potential_score,
            __normalized_score,
            __qa_tag_results,
            __score_sources,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QaScorecardResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "qaScorecardRevision" => Ok(__FieldTag::__qa_scorecard_revision),
                            "qa_scorecard_revision" => Ok(__FieldTag::__qa_scorecard_revision),
                            "conversation" => Ok(__FieldTag::__conversation),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "agentId" => Ok(__FieldTag::__agent_id),
                            "agent_id" => Ok(__FieldTag::__agent_id),
                            "qaAnswers" => Ok(__FieldTag::__qa_answers),
                            "qa_answers" => Ok(__FieldTag::__qa_answers),
                            "score" => Ok(__FieldTag::__score),
                            "potentialScore" => Ok(__FieldTag::__potential_score),
                            "potential_score" => Ok(__FieldTag::__potential_score),
                            "normalizedScore" => Ok(__FieldTag::__normalized_score),
                            "normalized_score" => Ok(__FieldTag::__normalized_score),
                            "qaTagResults" => Ok(__FieldTag::__qa_tag_results),
                            "qa_tag_results" => Ok(__FieldTag::__qa_tag_results),
                            "scoreSources" => Ok(__FieldTag::__score_sources),
                            "score_sources" => Ok(__FieldTag::__score_sources),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = QaScorecardResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QaScorecardResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__qa_scorecard_revision => {
                            if !fields.insert(__FieldTag::__qa_scorecard_revision) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for qa_scorecard_revision",
                                ));
                            }
                            result.qa_scorecard_revision = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__conversation => {
                            if !fields.insert(__FieldTag::__conversation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation",
                                ));
                            }
                            result.conversation = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__agent_id => {
                            if !fields.insert(__FieldTag::__agent_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for agent_id",
                                ));
                            }
                            result.agent_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__qa_answers => {
                            if !fields.insert(__FieldTag::__qa_answers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for qa_answers",
                                ));
                            }
                            result.qa_answers = map.next_value::<std::option::Option<std::vec::Vec<crate::model::QaAnswer>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__score => {
                            if !fields.insert(__FieldTag::__score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for score",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.score = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__potential_score => {
                            if !fields.insert(__FieldTag::__potential_score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for potential_score",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.potential_score = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__normalized_score => {
                            if !fields.insert(__FieldTag::__normalized_score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for normalized_score",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.normalized_score = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__qa_tag_results => {
                            if !fields.insert(__FieldTag::__qa_tag_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for qa_tag_results",
                                ));
                            }
                            result.qa_tag_results = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::qa_scorecard_result::QaTagResult>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__score_sources => {
                            if !fields.insert(__FieldTag::__score_sources) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for score_sources",
                                ));
                            }
                            result.score_sources = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::qa_scorecard_result::ScoreSource>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for QaScorecardResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.qa_scorecard_revision.is_empty() {
            state.serialize_entry("qaScorecardRevision", &self.qa_scorecard_revision)?;
        }
        if !self.conversation.is_empty() {
            state.serialize_entry("conversation", &self.conversation)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self.agent_id.is_empty() {
            state.serialize_entry("agentId", &self.agent_id)?;
        }
        if !self.qa_answers.is_empty() {
            state.serialize_entry("qaAnswers", &self.qa_answers)?;
        }
        if self.score.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("score", &__With(&self.score))?;
        }
        if self.potential_score.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("potentialScore", &__With(&self.potential_score))?;
        }
        if self.normalized_score.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("normalizedScore", &__With(&self.normalized_score))?;
        }
        if !self.qa_tag_results.is_empty() {
            state.serialize_entry("qaTagResults", &self.qa_tag_results)?;
        }
        if !self.score_sources.is_empty() {
            state.serialize_entry("scoreSources", &self.score_sources)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for QaScorecardResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("QaScorecardResult");
        debug_struct.field("name", &self.name);
        debug_struct.field("qa_scorecard_revision", &self.qa_scorecard_revision);
        debug_struct.field("conversation", &self.conversation);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("agent_id", &self.agent_id);
        debug_struct.field("qa_answers", &self.qa_answers);
        debug_struct.field("score", &self.score);
        debug_struct.field("potential_score", &self.potential_score);
        debug_struct.field("normalized_score", &self.normalized_score);
        debug_struct.field("qa_tag_results", &self.qa_tag_results);
        debug_struct.field("score_sources", &self.score_sources);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [QaScorecardResult].
pub mod qa_scorecard_result {
    #[allow(unused_imports)]
    use super::*;

    /// Tags and their corresponding results.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct QaTagResult {
        /// The tag the score applies to.
        pub tag: std::string::String,

        /// The score the tag applies to.
        pub score: std::option::Option<f64>,

        /// The potential score the tag applies to.
        pub potential_score: std::option::Option<f64>,

        /// The normalized score the tag applies to.
        pub normalized_score: std::option::Option<f64>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl QaTagResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [tag][crate::model::qa_scorecard_result::QaTagResult::tag].
        pub fn set_tag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.tag = v.into();
            self
        }

        /// Sets the value of [score][crate::model::qa_scorecard_result::QaTagResult::score].
        pub fn set_score<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<f64>,
        {
            self.score = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [score][crate::model::qa_scorecard_result::QaTagResult::score].
        pub fn set_or_clear_score<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<f64>,
        {
            self.score = v.map(|x| x.into());
            self
        }

        /// Sets the value of [potential_score][crate::model::qa_scorecard_result::QaTagResult::potential_score].
        pub fn set_potential_score<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<f64>,
        {
            self.potential_score = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [potential_score][crate::model::qa_scorecard_result::QaTagResult::potential_score].
        pub fn set_or_clear_potential_score<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<f64>,
        {
            self.potential_score = v.map(|x| x.into());
            self
        }

        /// Sets the value of [normalized_score][crate::model::qa_scorecard_result::QaTagResult::normalized_score].
        pub fn set_normalized_score<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<f64>,
        {
            self.normalized_score = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [normalized_score][crate::model::qa_scorecard_result::QaTagResult::normalized_score].
        pub fn set_or_clear_normalized_score<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<f64>,
        {
            self.normalized_score = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for QaTagResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.QaScorecardResult.QaTagResult"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for QaTagResult {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __tag,
                __score,
                __potential_score,
                __normalized_score,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for QaTagResult")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "tag" => Ok(__FieldTag::__tag),
                                "score" => Ok(__FieldTag::__score),
                                "potentialScore" => Ok(__FieldTag::__potential_score),
                                "potential_score" => Ok(__FieldTag::__potential_score),
                                "normalizedScore" => Ok(__FieldTag::__normalized_score),
                                "normalized_score" => Ok(__FieldTag::__normalized_score),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = QaTagResult;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct QaTagResult")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__tag => {
                                if !fields.insert(__FieldTag::__tag) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for tag",
                                    ));
                                }
                                result.tag = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__score => {
                                if !fields.insert(__FieldTag::__score) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for score",
                                    ));
                                }
                                struct __With(std::option::Option<f64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.score = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::__potential_score => {
                                if !fields.insert(__FieldTag::__potential_score) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for potential_score",
                                    ));
                                }
                                struct __With(std::option::Option<f64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.potential_score = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::__normalized_score => {
                                if !fields.insert(__FieldTag::__normalized_score) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for normalized_score",
                                    ));
                                }
                                struct __With(std::option::Option<f64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.normalized_score = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for QaTagResult {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.tag.is_empty() {
                state.serialize_entry("tag", &self.tag)?;
            }
            if self.score.is_some() {
                struct __With<'a>(&'a std::option::Option<f64>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("score", &__With(&self.score))?;
            }
            if self.potential_score.is_some() {
                struct __With<'a>(&'a std::option::Option<f64>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("potentialScore", &__With(&self.potential_score))?;
            }
            if self.normalized_score.is_some() {
                struct __With<'a>(&'a std::option::Option<f64>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("normalizedScore", &__With(&self.normalized_score))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for QaTagResult {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("QaTagResult");
            debug_struct.field("tag", &self.tag);
            debug_struct.field("score", &self.score);
            debug_struct.field("potential_score", &self.potential_score);
            debug_struct.field("normalized_score", &self.normalized_score);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// A scorecard result may have multiple sets of scores from varying sources,
    /// one of which becomes the "main" answer above. A ScoreSource represents
    /// each individual set of scores.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ScoreSource {
        /// What created the score.
        pub source_type: crate::model::qa_scorecard_result::score_source::SourceType,

        /// The overall numerical score of the result.
        pub score: std::option::Option<f64>,

        /// The maximum potential overall score of the scorecard. Any questions
        /// answered using `na_value` are excluded from this calculation.
        pub potential_score: std::option::Option<f64>,

        /// The normalized score, which is the score divided by the potential score.
        pub normalized_score: std::option::Option<f64>,

        /// Collection of tags and their scores.
        pub qa_tag_results: std::vec::Vec<crate::model::qa_scorecard_result::QaTagResult>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ScoreSource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [source_type][crate::model::qa_scorecard_result::ScoreSource::source_type].
        pub fn set_source_type<
            T: std::convert::Into<crate::model::qa_scorecard_result::score_source::SourceType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.source_type = v.into();
            self
        }

        /// Sets the value of [score][crate::model::qa_scorecard_result::ScoreSource::score].
        pub fn set_score<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<f64>,
        {
            self.score = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [score][crate::model::qa_scorecard_result::ScoreSource::score].
        pub fn set_or_clear_score<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<f64>,
        {
            self.score = v.map(|x| x.into());
            self
        }

        /// Sets the value of [potential_score][crate::model::qa_scorecard_result::ScoreSource::potential_score].
        pub fn set_potential_score<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<f64>,
        {
            self.potential_score = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [potential_score][crate::model::qa_scorecard_result::ScoreSource::potential_score].
        pub fn set_or_clear_potential_score<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<f64>,
        {
            self.potential_score = v.map(|x| x.into());
            self
        }

        /// Sets the value of [normalized_score][crate::model::qa_scorecard_result::ScoreSource::normalized_score].
        pub fn set_normalized_score<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<f64>,
        {
            self.normalized_score = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [normalized_score][crate::model::qa_scorecard_result::ScoreSource::normalized_score].
        pub fn set_or_clear_normalized_score<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<f64>,
        {
            self.normalized_score = v.map(|x| x.into());
            self
        }

        /// Sets the value of [qa_tag_results][crate::model::qa_scorecard_result::ScoreSource::qa_tag_results].
        pub fn set_qa_tag_results<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::qa_scorecard_result::QaTagResult>,
        {
            use std::iter::Iterator;
            self.qa_tag_results = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ScoreSource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.QaScorecardResult.ScoreSource"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ScoreSource {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __source_type,
                __score,
                __potential_score,
                __normalized_score,
                __qa_tag_results,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ScoreSource")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "sourceType" => Ok(__FieldTag::__source_type),
                                "source_type" => Ok(__FieldTag::__source_type),
                                "score" => Ok(__FieldTag::__score),
                                "potentialScore" => Ok(__FieldTag::__potential_score),
                                "potential_score" => Ok(__FieldTag::__potential_score),
                                "normalizedScore" => Ok(__FieldTag::__normalized_score),
                                "normalized_score" => Ok(__FieldTag::__normalized_score),
                                "qaTagResults" => Ok(__FieldTag::__qa_tag_results),
                                "qa_tag_results" => Ok(__FieldTag::__qa_tag_results),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ScoreSource;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ScoreSource")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__source_type => {
                                if !fields.insert(__FieldTag::__source_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for source_type",
                                    ));
                                }
                                result.source_type = map
                                    .next_value::<std::option::Option<
                                        crate::model::qa_scorecard_result::score_source::SourceType,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__score => {
                                if !fields.insert(__FieldTag::__score) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for score",
                                    ));
                                }
                                struct __With(std::option::Option<f64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.score = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::__potential_score => {
                                if !fields.insert(__FieldTag::__potential_score) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for potential_score",
                                    ));
                                }
                                struct __With(std::option::Option<f64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.potential_score = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::__normalized_score => {
                                if !fields.insert(__FieldTag::__normalized_score) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for normalized_score",
                                    ));
                                }
                                struct __With(std::option::Option<f64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.normalized_score = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::__qa_tag_results => {
                                if !fields.insert(__FieldTag::__qa_tag_results) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for qa_tag_results",
                                    ));
                                }
                                result.qa_tag_results = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<
                                            crate::model::qa_scorecard_result::QaTagResult,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ScoreSource {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.source_type) {
                state.serialize_entry("sourceType", &self.source_type)?;
            }
            if self.score.is_some() {
                struct __With<'a>(&'a std::option::Option<f64>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("score", &__With(&self.score))?;
            }
            if self.potential_score.is_some() {
                struct __With<'a>(&'a std::option::Option<f64>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("potentialScore", &__With(&self.potential_score))?;
            }
            if self.normalized_score.is_some() {
                struct __With<'a>(&'a std::option::Option<f64>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("normalizedScore", &__With(&self.normalized_score))?;
            }
            if !self.qa_tag_results.is_empty() {
                state.serialize_entry("qaTagResults", &self.qa_tag_results)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ScoreSource {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ScoreSource");
            debug_struct.field("source_type", &self.source_type);
            debug_struct.field("score", &self.score);
            debug_struct.field("potential_score", &self.potential_score);
            debug_struct.field("normalized_score", &self.normalized_score);
            debug_struct.field("qa_tag_results", &self.qa_tag_results);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [ScoreSource].
    pub mod score_source {
        #[allow(unused_imports)]
        use super::*;

        /// What created the score.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum SourceType {
            /// Source type is unspecified.
            Unspecified,
            /// Score is derived only from system-generated answers.
            SystemGeneratedOnly,
            /// Score is derived from both system-generated answers, and includes
            /// any manual edits if they exist.
            IncludesManualEdits,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [SourceType::value] or
            /// [SourceType::name].
            UnknownValue(source_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod source_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl SourceType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::SystemGeneratedOnly => std::option::Option::Some(1),
                    Self::IncludesManualEdits => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("SOURCE_TYPE_UNSPECIFIED"),
                    Self::SystemGeneratedOnly => std::option::Option::Some("SYSTEM_GENERATED_ONLY"),
                    Self::IncludesManualEdits => std::option::Option::Some("INCLUDES_MANUAL_EDITS"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for SourceType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for SourceType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for SourceType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::SystemGeneratedOnly,
                    2 => Self::IncludesManualEdits,
                    _ => Self::UnknownValue(source_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for SourceType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "SOURCE_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "SYSTEM_GENERATED_ONLY" => Self::SystemGeneratedOnly,
                    "INCLUDES_MANUAL_EDITS" => Self::IncludesManualEdits,
                    _ => Self::UnknownValue(source_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for SourceType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::SystemGeneratedOnly => serializer.serialize_i32(1),
                    Self::IncludesManualEdits => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for SourceType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<SourceType>::new(
                    ".google.cloud.contactcenterinsights.v1.QaScorecardResult.ScoreSource.SourceType"))
            }
        }
    }
}

/// Represents the options for viewing a conversation.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ConversationView {
    /// The conversation view is not specified.
    ///
    /// * Defaults to `FULL` in `GetConversationRequest`.
    /// * Defaults to `BASIC` in `ListConversationsRequest`.
    Unspecified,
    /// Populates all fields in the conversation.
    Full,
    /// Populates all fields in the conversation except the transcript.
    Basic,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ConversationView::value] or
    /// [ConversationView::name].
    UnknownValue(conversation_view::UnknownValue),
}

#[doc(hidden)]
pub mod conversation_view {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ConversationView {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Full => std::option::Option::Some(2),
            Self::Basic => std::option::Option::Some(1),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("CONVERSATION_VIEW_UNSPECIFIED"),
            Self::Full => std::option::Option::Some("FULL"),
            Self::Basic => std::option::Option::Some("BASIC"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ConversationView {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ConversationView {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ConversationView {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Basic,
            2 => Self::Full,
            _ => Self::UnknownValue(conversation_view::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ConversationView {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "CONVERSATION_VIEW_UNSPECIFIED" => Self::Unspecified,
            "FULL" => Self::Full,
            "BASIC" => Self::Basic,
            _ => Self::UnknownValue(conversation_view::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ConversationView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Full => serializer.serialize_i32(2),
            Self::Basic => serializer.serialize_i32(1),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ConversationView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ConversationView>::new(
            ".google.cloud.contactcenterinsights.v1.ConversationView",
        ))
    }
}

/// Enum for the different types of issues a tuning dataset can have.
/// These warnings are currentlyraised when trying to validate a dataset for
/// tuning a scorecard.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum DatasetValidationWarning {
    /// Unspecified data validation warning.
    Unspecified,
    /// A non-trivial percentage of the feedback labels are invalid.
    TooManyInvalidFeedbackLabels,
    /// The quantity of valid feedback labels provided is less than the
    /// recommended minimum.
    InsufficientFeedbackLabels,
    /// One or more of the answers have less than the recommended minimum of
    /// feedback labels.
    InsufficientFeedbackLabelsPerAnswer,
    /// All the labels in the dataset come from a single answer choice.
    AllFeedbackLabelsHaveTheSameAnswer,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [DatasetValidationWarning::value] or
    /// [DatasetValidationWarning::name].
    UnknownValue(dataset_validation_warning::UnknownValue),
}

#[doc(hidden)]
pub mod dataset_validation_warning {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl DatasetValidationWarning {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::TooManyInvalidFeedbackLabels => std::option::Option::Some(1),
            Self::InsufficientFeedbackLabels => std::option::Option::Some(2),
            Self::InsufficientFeedbackLabelsPerAnswer => std::option::Option::Some(3),
            Self::AllFeedbackLabelsHaveTheSameAnswer => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => {
                std::option::Option::Some("DATASET_VALIDATION_WARNING_UNSPECIFIED")
            }
            Self::TooManyInvalidFeedbackLabels => {
                std::option::Option::Some("TOO_MANY_INVALID_FEEDBACK_LABELS")
            }
            Self::InsufficientFeedbackLabels => {
                std::option::Option::Some("INSUFFICIENT_FEEDBACK_LABELS")
            }
            Self::InsufficientFeedbackLabelsPerAnswer => {
                std::option::Option::Some("INSUFFICIENT_FEEDBACK_LABELS_PER_ANSWER")
            }
            Self::AllFeedbackLabelsHaveTheSameAnswer => {
                std::option::Option::Some("ALL_FEEDBACK_LABELS_HAVE_THE_SAME_ANSWER")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for DatasetValidationWarning {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for DatasetValidationWarning {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for DatasetValidationWarning {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::TooManyInvalidFeedbackLabels,
            2 => Self::InsufficientFeedbackLabels,
            3 => Self::InsufficientFeedbackLabelsPerAnswer,
            4 => Self::AllFeedbackLabelsHaveTheSameAnswer,
            _ => Self::UnknownValue(dataset_validation_warning::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for DatasetValidationWarning {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "DATASET_VALIDATION_WARNING_UNSPECIFIED" => Self::Unspecified,
            "TOO_MANY_INVALID_FEEDBACK_LABELS" => Self::TooManyInvalidFeedbackLabels,
            "INSUFFICIENT_FEEDBACK_LABELS" => Self::InsufficientFeedbackLabels,
            "INSUFFICIENT_FEEDBACK_LABELS_PER_ANSWER" => Self::InsufficientFeedbackLabelsPerAnswer,
            "ALL_FEEDBACK_LABELS_HAVE_THE_SAME_ANSWER" => Self::AllFeedbackLabelsHaveTheSameAnswer,
            _ => Self::UnknownValue(dataset_validation_warning::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for DatasetValidationWarning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::TooManyInvalidFeedbackLabels => serializer.serialize_i32(1),
            Self::InsufficientFeedbackLabels => serializer.serialize_i32(2),
            Self::InsufficientFeedbackLabelsPerAnswer => serializer.serialize_i32(3),
            Self::AllFeedbackLabelsHaveTheSameAnswer => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for DatasetValidationWarning {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<DatasetValidationWarning>::new(
            ".google.cloud.contactcenterinsights.v1.DatasetValidationWarning",
        ))
    }
}
