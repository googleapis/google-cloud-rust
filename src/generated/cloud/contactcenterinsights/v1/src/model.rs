// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// The request for calculating conversation statistics.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CalculateStatsRequest {
    /// Required. The location of the conversations.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,

    /// A filter to reduce results to a specific subset. This field is useful for
    /// getting statistics about conversations with specific properties.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CalculateStatsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::CalculateStatsRequest::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::CalculateStatsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for CalculateStatsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.CalculateStatsRequest"
    }
}

/// The response for calculating conversation statistics.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CalculateStatsResponse {
    /// The average duration of all conversations. The average is calculated using
    /// only conversations that have a time duration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub average_duration: std::option::Option<wkt::Duration>,

    /// The average number of turns per conversation.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub average_turn_count: i32,

    /// The total number of conversations.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub conversation_count: i32,

    /// A map associating each smart highlighter display name with its respective
    /// number of matches in the set of conversations.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub smart_highlighter_matches: std::collections::HashMap<std::string::String, i32>,

    /// A map associating each custom highlighter resource name with its respective
    /// number of matches in the set of conversations.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub custom_highlighter_matches: std::collections::HashMap<std::string::String, i32>,

    /// A map associating each issue resource name with its respective number of
    /// matches in the set of conversations. Key has the format:
    /// `projects/<Project-ID>/locations/<Location-ID>/issueModels/<Issue-Model-ID>/issues/<Issue-ID>`
    /// Deprecated, use `issue_matches_stats` field instead.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[deprecated]
    pub issue_matches: std::collections::HashMap<std::string::String, i32>,

    /// A map associating each issue resource name with its respective number of
    /// matches in the set of conversations. Key has the format:
    /// `projects/<Project-ID>/locations/<Location-ID>/issueModels/<Issue-Model-ID>/issues/<Issue-ID>`
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub issue_matches_stats: std::collections::HashMap<
        std::string::String,
        crate::model::issue_model_label_stats::IssueStats,
    >,

    /// A time series representing the count of conversations created over time
    /// that match that requested filter criteria.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub conversation_count_time_series:
        std::option::Option<crate::model::calculate_stats_response::TimeSeries>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CalculateStatsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [average_duration][crate::model::CalculateStatsResponse::average_duration].
    pub fn set_average_duration<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.average_duration = v.into();
        self
    }

    /// Sets the value of [average_turn_count][crate::model::CalculateStatsResponse::average_turn_count].
    pub fn set_average_turn_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.average_turn_count = v.into();
        self
    }

    /// Sets the value of [conversation_count][crate::model::CalculateStatsResponse::conversation_count].
    pub fn set_conversation_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.conversation_count = v.into();
        self
    }

    /// Sets the value of [smart_highlighter_matches][crate::model::CalculateStatsResponse::smart_highlighter_matches].
    pub fn set_smart_highlighter_matches<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.smart_highlighter_matches = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [custom_highlighter_matches][crate::model::CalculateStatsResponse::custom_highlighter_matches].
    pub fn set_custom_highlighter_matches<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.custom_highlighter_matches =
            v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [issue_matches][crate::model::CalculateStatsResponse::issue_matches].
    #[deprecated]
    pub fn set_issue_matches<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.issue_matches = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [issue_matches_stats][crate::model::CalculateStatsResponse::issue_matches_stats].
    pub fn set_issue_matches_stats<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::issue_model_label_stats::IssueStats>,
    {
        use std::iter::Iterator;
        self.issue_matches_stats = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [conversation_count_time_series][crate::model::CalculateStatsResponse::conversation_count_time_series].
    pub fn set_conversation_count_time_series<
        T: std::convert::Into<std::option::Option<crate::model::calculate_stats_response::TimeSeries>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.conversation_count_time_series = v.into();
        self
    }
}

impl wkt::message::Message for CalculateStatsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.CalculateStatsResponse"
    }
}

/// Defines additional types related to [CalculateStatsResponse].
pub mod calculate_stats_response {
    #[allow(unused_imports)]
    use super::*;

    /// A time series representing conversations over time.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct TimeSeries {
        /// The duration of each interval.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub interval_duration: std::option::Option<wkt::Duration>,

        /// An ordered list of intervals from earliest to latest, where each interval
        /// represents the number of conversations that transpired during the time
        /// window.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub points: std::vec::Vec<crate::model::calculate_stats_response::time_series::Interval>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TimeSeries {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [interval_duration][crate::model::calculate_stats_response::TimeSeries::interval_duration].
        pub fn set_interval_duration<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
            mut self,
            v: T,
        ) -> Self {
            self.interval_duration = v.into();
            self
        }

        /// Sets the value of [points][crate::model::calculate_stats_response::TimeSeries::points].
        pub fn set_points<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::calculate_stats_response::time_series::Interval>,
        {
            use std::iter::Iterator;
            self.points = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for TimeSeries {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.CalculateStatsResponse.TimeSeries"
        }
    }

    /// Defines additional types related to [TimeSeries].
    pub mod time_series {
        #[allow(unused_imports)]
        use super::*;

        /// A single interval in a time series.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Interval {
            /// The start time of this interval.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub start_time: std::option::Option<wkt::Timestamp>,

            /// The number of conversations created in this interval.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub conversation_count: i32,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Interval {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [start_time][crate::model::calculate_stats_response::time_series::Interval::start_time].
            pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
                mut self,
                v: T,
            ) -> Self {
                self.start_time = v.into();
                self
            }

            /// Sets the value of [conversation_count][crate::model::calculate_stats_response::time_series::Interval::conversation_count].
            pub fn set_conversation_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.conversation_count = v.into();
                self
            }
        }

        impl wkt::message::Message for Interval {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.contactcenterinsights.v1.CalculateStatsResponse.TimeSeries.Interval"
            }
        }
    }
}

/// Metadata for a create analysis operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateAnalysisOperationMetadata {
    /// Output only. The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The Conversation that this Analysis Operation belongs to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub conversation: std::string::String,

    /// Output only. The annotator selector used for the analysis (if any).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub annotator_selector: std::option::Option<crate::model::AnnotatorSelector>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateAnalysisOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::CreateAnalysisOperationMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::CreateAnalysisOperationMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [conversation][crate::model::CreateAnalysisOperationMetadata::conversation].
    pub fn set_conversation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.conversation = v.into();
        self
    }

    /// Sets the value of [annotator_selector][crate::model::CreateAnalysisOperationMetadata::annotator_selector].
    pub fn set_annotator_selector<
        T: std::convert::Into<std::option::Option<crate::model::AnnotatorSelector>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.annotator_selector = v.into();
        self
    }
}

impl wkt::message::Message for CreateAnalysisOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.CreateAnalysisOperationMetadata"
    }
}

/// Request to create a conversation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateConversationRequest {
    /// Required. The parent resource of the conversation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The conversation resource to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub conversation: std::option::Option<crate::model::Conversation>,

    /// A unique ID for the new conversation. This ID will become the final
    /// component of the conversation's resource name. If no ID is specified, a
    /// server-generated ID will be used.
    ///
    /// This value should be 4-64 characters and must match the regular
    /// expression `^[a-z0-9-]{4,64}$`. Valid characters are `[a-z][0-9]-`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub conversation_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateConversationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateConversationRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [conversation][crate::model::CreateConversationRequest::conversation].
    pub fn set_conversation<
        T: std::convert::Into<std::option::Option<crate::model::Conversation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.conversation = v.into();
        self
    }

    /// Sets the value of [conversation_id][crate::model::CreateConversationRequest::conversation_id].
    pub fn set_conversation_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.conversation_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateConversationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.CreateConversationRequest"
    }
}

/// Request to upload a conversation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UploadConversationRequest {
    /// Required. The parent resource of the conversation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The conversation resource to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub conversation: std::option::Option<crate::model::Conversation>,

    /// Optional. A unique ID for the new conversation. This ID will become the
    /// final component of the conversation's resource name. If no ID is specified,
    /// a server-generated ID will be used.
    ///
    /// This value should be 4-64 characters and must match the regular
    /// expression `^[a-z0-9-]{4,64}$`. Valid characters are `[a-z][0-9]-`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub conversation_id: std::string::String,

    /// Optional. DLP settings for transcript redaction. Will default to the config
    /// specified in Settings.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub redaction_config: std::option::Option<crate::model::RedactionConfig>,

    /// Optional. Speech-to-Text configuration. Will default to the config
    /// specified in Settings.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub speech_config: std::option::Option<crate::model::SpeechConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UploadConversationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::UploadConversationRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [conversation][crate::model::UploadConversationRequest::conversation].
    pub fn set_conversation<
        T: std::convert::Into<std::option::Option<crate::model::Conversation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.conversation = v.into();
        self
    }

    /// Sets the value of [conversation_id][crate::model::UploadConversationRequest::conversation_id].
    pub fn set_conversation_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.conversation_id = v.into();
        self
    }

    /// Sets the value of [redaction_config][crate::model::UploadConversationRequest::redaction_config].
    pub fn set_redaction_config<
        T: std::convert::Into<std::option::Option<crate::model::RedactionConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.redaction_config = v.into();
        self
    }

    /// Sets the value of [speech_config][crate::model::UploadConversationRequest::speech_config].
    pub fn set_speech_config<
        T: std::convert::Into<std::option::Option<crate::model::SpeechConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.speech_config = v.into();
        self
    }
}

impl wkt::message::Message for UploadConversationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.UploadConversationRequest"
    }
}

/// The metadata for an `UploadConversation` operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UploadConversationMetadata {
    /// Output only. The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The original request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub request: std::option::Option<crate::model::UploadConversationRequest>,

    /// Output only. The operation name for a successfully created analysis
    /// operation, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub analysis_operation: std::string::String,

    /// Output only. The redaction config applied to the uploaded conversation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub applied_redaction_config: std::option::Option<crate::model::RedactionConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UploadConversationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::UploadConversationMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::UploadConversationMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [request][crate::model::UploadConversationMetadata::request].
    pub fn set_request<
        T: std::convert::Into<std::option::Option<crate::model::UploadConversationRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = v.into();
        self
    }

    /// Sets the value of [analysis_operation][crate::model::UploadConversationMetadata::analysis_operation].
    pub fn set_analysis_operation<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.analysis_operation = v.into();
        self
    }

    /// Sets the value of [applied_redaction_config][crate::model::UploadConversationMetadata::applied_redaction_config].
    pub fn set_applied_redaction_config<
        T: std::convert::Into<std::option::Option<crate::model::RedactionConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.applied_redaction_config = v.into();
        self
    }
}

impl wkt::message::Message for UploadConversationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.UploadConversationMetadata"
    }
}

/// Request to list conversations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListConversationsRequest {
    /// Required. The parent resource of the conversation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of conversations to return in the response. A valid page
    /// size ranges from 0 to 100,000 inclusive. If the page size is zero or
    /// unspecified, a default page size of 100 will be chosen. Note that a call
    /// might return fewer results than the requested page size.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The value returned by the last `ListConversationsResponse`. This value
    /// indicates that this is a continuation of a prior `ListConversations` call
    /// and that the system should return the next page of data.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// A filter to reduce results to a specific subset. Useful for querying
    /// conversations with specific properties.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. The attribute by which to order conversations in the response.
    /// If empty, conversations will be ordered by descending creation time.
    /// Supported values are one of the following:
    ///
    /// * create_time
    /// * customer_satisfaction_rating
    /// * duration
    /// * latest_analysis
    /// * start_time
    /// * turn_count
    ///
    /// The default sort order is ascending. To specify order, append `asc` or
    /// `desc` (`create_time desc`).
    /// For more details, see [Google AIPs
    /// Ordering](https://google.aip.dev/132#ordering).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// The level of details of the conversation. Default is `BASIC`.
    pub view: crate::model::ConversationView,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConversationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListConversationsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListConversationsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListConversationsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListConversationsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListConversationsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListConversationsRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::ConversationView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for ListConversationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ListConversationsRequest"
    }
}

/// The response of listing conversations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListConversationsResponse {
    /// The conversations that match the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub conversations: std::vec::Vec<crate::model::Conversation>,

    /// A token which can be sent as `page_token` to retrieve the next page. If
    /// this field is set, it means there is another page available. If it is not
    /// set, it means no other pages are available.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConversationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [conversations][crate::model::ListConversationsResponse::conversations].
    pub fn set_conversations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Conversation>,
    {
        use std::iter::Iterator;
        self.conversations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListConversationsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListConversationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ListConversationsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListConversationsResponse {
    type PageItem = crate::model::Conversation;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.conversations
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request to get a conversation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetConversationRequest {
    /// Required. The name of the conversation to get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The level of details of the conversation. Default is `FULL`.
    pub view: crate::model::ConversationView,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetConversationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetConversationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetConversationRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::ConversationView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetConversationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.GetConversationRequest"
    }
}

/// The request to update a conversation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateConversationRequest {
    /// Required. The new values for the conversation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub conversation: std::option::Option<crate::model::Conversation>,

    /// The list of fields to be updated. All possible fields can be updated by
    /// passing `*`, or a subset of the following updateable fields can be
    /// provided:
    ///
    /// * `agent_id`
    /// * `language_code`
    /// * `labels`
    /// * `metadata`
    /// * `quality_metadata`
    /// * `call_metadata`
    /// * `start_time`
    /// * `expire_time` or `ttl`
    /// * `data_source.gcs_source.audio_uri` or
    ///   `data_source.dialogflow_source.audio_uri`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateConversationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [conversation][crate::model::UpdateConversationRequest::conversation].
    pub fn set_conversation<
        T: std::convert::Into<std::option::Option<crate::model::Conversation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.conversation = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateConversationRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateConversationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.UpdateConversationRequest"
    }
}

/// The request to delete a conversation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteConversationRequest {
    /// Required. The name of the conversation to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// If set to true, all of this conversation's analyses will also be deleted.
    /// Otherwise, the request will only succeed if the conversation has no
    /// analyses.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub force: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteConversationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteConversationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteConversationRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteConversationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.DeleteConversationRequest"
    }
}

/// The request to ingest conversations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct IngestConversationsRequest {
    /// Required. The parent resource for new conversations.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Configuration that applies to all conversations.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub conversation_config:
        std::option::Option<crate::model::ingest_conversations_request::ConversationConfig>,

    /// Optional. DLP settings for transcript redaction. Optional, will default to
    /// the config specified in Settings.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub redaction_config: std::option::Option<crate::model::RedactionConfig>,

    /// Optional. Default Speech-to-Text configuration. Optional, will default to
    /// the config specified in Settings.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub speech_config: std::option::Option<crate::model::SpeechConfig>,

    /// Optional. If set, this fields indicates the number of objects to ingest
    /// from the Cloud Storage bucket. If empty, the entire bucket will be
    /// ingested. Unless they are first deleted, conversations produced through
    /// sampling won't be ingested by subsequent ingest requests.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sample_size: std::option::Option<i32>,

    /// Configuration for an external data store containing objects that will
    /// be converted to conversations.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::ingest_conversations_request::Source>,

    /// Configuration for converting individual `source` objects to conversations.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub object_config:
        std::option::Option<crate::model::ingest_conversations_request::ObjectConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IngestConversationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::IngestConversationsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [conversation_config][crate::model::IngestConversationsRequest::conversation_config].
    pub fn set_conversation_config<
        T: std::convert::Into<
                std::option::Option<crate::model::ingest_conversations_request::ConversationConfig>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.conversation_config = v.into();
        self
    }

    /// Sets the value of [redaction_config][crate::model::IngestConversationsRequest::redaction_config].
    pub fn set_redaction_config<
        T: std::convert::Into<std::option::Option<crate::model::RedactionConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.redaction_config = v.into();
        self
    }

    /// Sets the value of [speech_config][crate::model::IngestConversationsRequest::speech_config].
    pub fn set_speech_config<
        T: std::convert::Into<std::option::Option<crate::model::SpeechConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.speech_config = v.into();
        self
    }

    /// Sets the value of [sample_size][crate::model::IngestConversationsRequest::sample_size].
    pub fn set_sample_size<T: std::convert::Into<std::option::Option<i32>>>(
        mut self,
        v: T,
    ) -> Self {
        self.sample_size = v.into();
        self
    }

    /// Sets the value of [source][crate::model::IngestConversationsRequest::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::ingest_conversations_request::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::IngestConversationsRequest::source]
    /// if it holds a `GcsSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ingest_conversations_request::GcsSource>>
    {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::ingest_conversations_request::Source::GcsSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::IngestConversationsRequest::source]
    /// to hold a `GcsSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_gcs_source<
        T: std::convert::Into<std::boxed::Box<crate::model::ingest_conversations_request::GcsSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::ingest_conversations_request::Source::GcsSource(v.into()),
        );
        self
    }

    /// Sets the value of [object_config][crate::model::IngestConversationsRequest::object_config].
    ///
    /// Note that all the setters affecting `object_config` are mutually
    /// exclusive.
    pub fn set_object_config<
        T: std::convert::Into<
                std::option::Option<crate::model::ingest_conversations_request::ObjectConfig>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.object_config = v.into();
        self
    }

    /// The value of [object_config][crate::model::IngestConversationsRequest::object_config]
    /// if it holds a `TranscriptObjectConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn transcript_object_config(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::ingest_conversations_request::TranscriptObjectConfig>,
    > {
        #[allow(unreachable_patterns)]
        self.object_config.as_ref().and_then(|v| match v {
            crate::model::ingest_conversations_request::ObjectConfig::TranscriptObjectConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [object_config][crate::model::IngestConversationsRequest::object_config]
    /// to hold a `TranscriptObjectConfig`.
    ///
    /// Note that all the setters affecting `object_config` are
    /// mutually exclusive.
    pub fn set_transcript_object_config<
        T: std::convert::Into<
                std::boxed::Box<crate::model::ingest_conversations_request::TranscriptObjectConfig>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.object_config = std::option::Option::Some(
            crate::model::ingest_conversations_request::ObjectConfig::TranscriptObjectConfig(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for IngestConversationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.IngestConversationsRequest"
    }
}

/// Defines additional types related to [IngestConversationsRequest].
pub mod ingest_conversations_request {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration for Cloud Storage bucket sources.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GcsSource {
        /// Required. The Cloud Storage bucket containing source objects.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub bucket_uri: std::string::String,

        /// Optional. Specifies the type of the objects in `bucket_uri`.
        pub bucket_object_type:
            crate::model::ingest_conversations_request::gcs_source::BucketObjectType,

        /// Optional. The Cloud Storage path to the conversation metadata. Note that:
        /// [1] Metadata files are expected to be in JSON format.
        /// [2] Metadata and source files (transcripts or audio) must be in
        /// separate buckets.
        /// [3] A source file and its corresponding metadata file must share the same
        /// name to
        /// be properly ingested, E.g. `gs://bucket/audio/conversation1.mp3` and
        /// `gs://bucket/metadata/conversation1.json`.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub metadata_bucket_uri: std::option::Option<std::string::String>,

        /// Optional. Custom keys to extract as conversation labels from metadata
        /// files in `metadata_bucket_uri`. Keys not included in this field will be
        /// ignored. Note that there is a limit of 100 labels per conversation.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub custom_metadata_keys: std::vec::Vec<std::string::String>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GcsSource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [bucket_uri][crate::model::ingest_conversations_request::GcsSource::bucket_uri].
        pub fn set_bucket_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.bucket_uri = v.into();
            self
        }

        /// Sets the value of [bucket_object_type][crate::model::ingest_conversations_request::GcsSource::bucket_object_type].
        pub fn set_bucket_object_type<
            T: std::convert::Into<
                    crate::model::ingest_conversations_request::gcs_source::BucketObjectType,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.bucket_object_type = v.into();
            self
        }

        /// Sets the value of [metadata_bucket_uri][crate::model::ingest_conversations_request::GcsSource::metadata_bucket_uri].
        pub fn set_metadata_bucket_uri<
            T: std::convert::Into<std::option::Option<std::string::String>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.metadata_bucket_uri = v.into();
            self
        }

        /// Sets the value of [custom_metadata_keys][crate::model::ingest_conversations_request::GcsSource::custom_metadata_keys].
        pub fn set_custom_metadata_keys<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.custom_metadata_keys = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for GcsSource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.IngestConversationsRequest.GcsSource"
        }
    }

    /// Defines additional types related to [GcsSource].
    pub mod gcs_source {
        #[allow(unused_imports)]
        use super::*;

        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum BucketObjectType {
            /// The object type is unspecified and will default to `TRANSCRIPT`.
            Unspecified,
            /// The object is a transcript.
            Transcript,
            /// The object is an audio file.
            Audio,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [BucketObjectType::value] or
            /// [BucketObjectType::name].
            UnknownValue(bucket_object_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod bucket_object_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl BucketObjectType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Transcript => std::option::Option::Some(1),
                    Self::Audio => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => {
                        std::option::Option::Some("BUCKET_OBJECT_TYPE_UNSPECIFIED")
                    }
                    Self::Transcript => std::option::Option::Some("TRANSCRIPT"),
                    Self::Audio => std::option::Option::Some("AUDIO"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for BucketObjectType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for BucketObjectType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for BucketObjectType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Transcript,
                    2 => Self::Audio,
                    _ => Self::UnknownValue(bucket_object_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for BucketObjectType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "BUCKET_OBJECT_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "TRANSCRIPT" => Self::Transcript,
                    "AUDIO" => Self::Audio,
                    _ => Self::UnknownValue(bucket_object_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for BucketObjectType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Transcript => serializer.serialize_i32(1),
                    Self::Audio => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for BucketObjectType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<BucketObjectType>::new(
                    ".google.cloud.contactcenterinsights.v1.IngestConversationsRequest.GcsSource.BucketObjectType"))
            }
        }
    }

    /// Configuration for processing transcript objects.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct TranscriptObjectConfig {
        /// Required. The medium transcript objects represent.
        pub medium: crate::model::conversation::Medium,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TranscriptObjectConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [medium][crate::model::ingest_conversations_request::TranscriptObjectConfig::medium].
        pub fn set_medium<T: std::convert::Into<crate::model::conversation::Medium>>(
            mut self,
            v: T,
        ) -> Self {
            self.medium = v.into();
            self
        }
    }

    impl wkt::message::Message for TranscriptObjectConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.IngestConversationsRequest.TranscriptObjectConfig"
        }
    }

    /// Configuration that applies to all conversations.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ConversationConfig {
        /// Optional. An opaque, user-specified string representing a human agent who
        /// handled all conversations in the import. Note that this will be
        /// overridden if per-conversation metadata is provided through the
        /// `metadata_bucket_uri`.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub agent_id: std::string::String,

        /// Optional. Indicates which of the channels, 1 or 2, contains the agent.
        /// Note that this must be set for conversations to be properly displayed and
        /// analyzed.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub agent_channel: i32,

        /// Optional. Indicates which of the channels, 1 or 2, contains the agent.
        /// Note that this must be set for conversations to be properly displayed and
        /// analyzed.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub customer_channel: i32,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ConversationConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [agent_id][crate::model::ingest_conversations_request::ConversationConfig::agent_id].
        pub fn set_agent_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.agent_id = v.into();
            self
        }

        /// Sets the value of [agent_channel][crate::model::ingest_conversations_request::ConversationConfig::agent_channel].
        pub fn set_agent_channel<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.agent_channel = v.into();
            self
        }

        /// Sets the value of [customer_channel][crate::model::ingest_conversations_request::ConversationConfig::customer_channel].
        pub fn set_customer_channel<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.customer_channel = v.into();
            self
        }
    }

    impl wkt::message::Message for ConversationConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.IngestConversationsRequest.ConversationConfig"
        }
    }

    /// Configuration for an external data store containing objects that will
    /// be converted to conversations.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// A cloud storage bucket source. Note that any previously ingested objects
        /// from the source will be skipped to avoid duplication.
        GcsSource(std::boxed::Box<crate::model::ingest_conversations_request::GcsSource>),
    }

    /// Configuration for converting individual `source` objects to conversations.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ObjectConfig {
        /// Configuration for when `source` contains conversation transcripts.
        TranscriptObjectConfig(
            std::boxed::Box<crate::model::ingest_conversations_request::TranscriptObjectConfig>,
        ),
    }
}

/// The metadata for an IngestConversations operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct IngestConversationsMetadata {
    /// Output only. The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The original request for ingest.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub request: std::option::Option<crate::model::IngestConversationsRequest>,

    /// Output only. Partial errors during ingest operation that might cause the
    /// operation output to be incomplete.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub partial_errors: std::vec::Vec<rpc::model::Status>,

    /// Output only. Statistics for IngestConversations operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ingest_conversations_stats:
        std::option::Option<crate::model::ingest_conversations_metadata::IngestConversationsStats>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IngestConversationsMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::IngestConversationsMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::IngestConversationsMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [request][crate::model::IngestConversationsMetadata::request].
    pub fn set_request<
        T: std::convert::Into<std::option::Option<crate::model::IngestConversationsRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = v.into();
        self
    }

    /// Sets the value of [partial_errors][crate::model::IngestConversationsMetadata::partial_errors].
    pub fn set_partial_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.partial_errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [ingest_conversations_stats][crate::model::IngestConversationsMetadata::ingest_conversations_stats].
    pub fn set_ingest_conversations_stats<
        T: std::convert::Into<
                std::option::Option<
                    crate::model::ingest_conversations_metadata::IngestConversationsStats,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ingest_conversations_stats = v.into();
        self
    }
}

impl wkt::message::Message for IngestConversationsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.IngestConversationsMetadata"
    }
}

/// Defines additional types related to [IngestConversationsMetadata].
pub mod ingest_conversations_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Statistics for IngestConversations operation.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct IngestConversationsStats {
        /// Output only. The number of objects processed during the ingest operation.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub processed_object_count: i32,

        /// Output only. The number of objects skipped because another conversation
        /// with the same transcript uri had already been ingested.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub duplicates_skipped_count: i32,

        /// Output only. The number of new conversations added during this ingest
        /// operation.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub successful_ingest_count: i32,

        /// Output only. The number of objects which were unable to be ingested due
        /// to errors. The errors are populated in the partial_errors field.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub failed_ingest_count: i32,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl IngestConversationsStats {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [processed_object_count][crate::model::ingest_conversations_metadata::IngestConversationsStats::processed_object_count].
        pub fn set_processed_object_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.processed_object_count = v.into();
            self
        }

        /// Sets the value of [duplicates_skipped_count][crate::model::ingest_conversations_metadata::IngestConversationsStats::duplicates_skipped_count].
        pub fn set_duplicates_skipped_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.duplicates_skipped_count = v.into();
            self
        }

        /// Sets the value of [successful_ingest_count][crate::model::ingest_conversations_metadata::IngestConversationsStats::successful_ingest_count].
        pub fn set_successful_ingest_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.successful_ingest_count = v.into();
            self
        }

        /// Sets the value of [failed_ingest_count][crate::model::ingest_conversations_metadata::IngestConversationsStats::failed_ingest_count].
        pub fn set_failed_ingest_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.failed_ingest_count = v.into();
            self
        }
    }

    impl wkt::message::Message for IngestConversationsStats {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.IngestConversationsMetadata.IngestConversationsStats"
        }
    }
}

/// The response to an IngestConversations operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct IngestConversationsResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IngestConversationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for IngestConversationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.IngestConversationsResponse"
    }
}

/// The request to create an analysis.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateAnalysisRequest {
    /// Required. The parent resource of the analysis.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The analysis to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub analysis: std::option::Option<crate::model::Analysis>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateAnalysisRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateAnalysisRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [analysis][crate::model::CreateAnalysisRequest::analysis].
    pub fn set_analysis<T: std::convert::Into<std::option::Option<crate::model::Analysis>>>(
        mut self,
        v: T,
    ) -> Self {
        self.analysis = v.into();
        self
    }
}

impl wkt::message::Message for CreateAnalysisRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.CreateAnalysisRequest"
    }
}

/// The request to list analyses.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAnalysesRequest {
    /// Required. The parent resource of the analyses.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of analyses to return in the response. If this
    /// value is zero, the service will select a default size. A call might return
    /// fewer objects than requested. A non-empty `next_page_token` in the response
    /// indicates that more data is available.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The value returned by the last `ListAnalysesResponse`; indicates
    /// that this is a continuation of a prior `ListAnalyses` call and
    /// the system should return the next page of data.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// A filter to reduce results to a specific subset. Useful for querying
    /// conversations with specific properties.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAnalysesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAnalysesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAnalysesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAnalysesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListAnalysesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListAnalysesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ListAnalysesRequest"
    }
}

/// The response to list analyses.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAnalysesResponse {
    /// The analyses that match the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub analyses: std::vec::Vec<crate::model::Analysis>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAnalysesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [analyses][crate::model::ListAnalysesResponse::analyses].
    pub fn set_analyses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Analysis>,
    {
        use std::iter::Iterator;
        self.analyses = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAnalysesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAnalysesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ListAnalysesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAnalysesResponse {
    type PageItem = crate::model::Analysis;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.analyses
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request to get an analysis.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetAnalysisRequest {
    /// Required. The name of the analysis to get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetAnalysisRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAnalysisRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAnalysisRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.GetAnalysisRequest"
    }
}

/// The request to delete an analysis.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteAnalysisRequest {
    /// Required. The name of the analysis to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteAnalysisRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteAnalysisRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAnalysisRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.DeleteAnalysisRequest"
    }
}

/// The request to analyze conversations in bulk.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BulkAnalyzeConversationsRequest {
    /// Required. The parent resource to create analyses in.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Filter used to select the subset of conversations to analyze.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Required. Percentage of selected conversation to analyze, between
    /// [0, 100].
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F32")]
    pub analysis_percentage: f32,

    /// To select the annotators to run and the phrase matchers to use
    /// (if any). If not specified, all annotators will be run.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub annotator_selector: std::option::Option<crate::model::AnnotatorSelector>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BulkAnalyzeConversationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BulkAnalyzeConversationsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::BulkAnalyzeConversationsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [analysis_percentage][crate::model::BulkAnalyzeConversationsRequest::analysis_percentage].
    pub fn set_analysis_percentage<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.analysis_percentage = v.into();
        self
    }

    /// Sets the value of [annotator_selector][crate::model::BulkAnalyzeConversationsRequest::annotator_selector].
    pub fn set_annotator_selector<
        T: std::convert::Into<std::option::Option<crate::model::AnnotatorSelector>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.annotator_selector = v.into();
        self
    }
}

impl wkt::message::Message for BulkAnalyzeConversationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.BulkAnalyzeConversationsRequest"
    }
}

/// The metadata for a bulk analyze conversations operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BulkAnalyzeConversationsMetadata {
    /// The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The original request for bulk analyze.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub request: std::option::Option<crate::model::BulkAnalyzeConversationsRequest>,

    /// The number of requested analyses that have completed successfully so far.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub completed_analyses_count: i32,

    /// The number of requested analyses that have failed so far.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub failed_analyses_count: i32,

    /// Total number of analyses requested. Computed by the number of conversations
    /// returned by `filter` multiplied by `analysis_percentage` in the request.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub total_requested_analyses_count: i32,

    /// Output only. Partial errors during bulk analyze operation that might cause
    /// the operation output to be incomplete.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub partial_errors: std::vec::Vec<rpc::model::Status>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BulkAnalyzeConversationsMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::BulkAnalyzeConversationsMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::BulkAnalyzeConversationsMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [request][crate::model::BulkAnalyzeConversationsMetadata::request].
    pub fn set_request<
        T: std::convert::Into<std::option::Option<crate::model::BulkAnalyzeConversationsRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = v.into();
        self
    }

    /// Sets the value of [completed_analyses_count][crate::model::BulkAnalyzeConversationsMetadata::completed_analyses_count].
    pub fn set_completed_analyses_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.completed_analyses_count = v.into();
        self
    }

    /// Sets the value of [failed_analyses_count][crate::model::BulkAnalyzeConversationsMetadata::failed_analyses_count].
    pub fn set_failed_analyses_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.failed_analyses_count = v.into();
        self
    }

    /// Sets the value of [total_requested_analyses_count][crate::model::BulkAnalyzeConversationsMetadata::total_requested_analyses_count].
    pub fn set_total_requested_analyses_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_requested_analyses_count = v.into();
        self
    }

    /// Sets the value of [partial_errors][crate::model::BulkAnalyzeConversationsMetadata::partial_errors].
    pub fn set_partial_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.partial_errors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BulkAnalyzeConversationsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.BulkAnalyzeConversationsMetadata"
    }
}

/// The response for a bulk analyze conversations operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BulkAnalyzeConversationsResponse {
    /// Count of successful analyses.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub successful_analysis_count: i32,

    /// Count of failed analyses.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub failed_analysis_count: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BulkAnalyzeConversationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [successful_analysis_count][crate::model::BulkAnalyzeConversationsResponse::successful_analysis_count].
    pub fn set_successful_analysis_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.successful_analysis_count = v.into();
        self
    }

    /// Sets the value of [failed_analysis_count][crate::model::BulkAnalyzeConversationsResponse::failed_analysis_count].
    pub fn set_failed_analysis_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.failed_analysis_count = v.into();
        self
    }
}

impl wkt::message::Message for BulkAnalyzeConversationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.BulkAnalyzeConversationsResponse"
    }
}

/// The request to delete conversations in bulk.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BulkDeleteConversationsRequest {
    /// Required. The parent resource to delete conversations from.
    /// Format:
    /// projects/{project}/locations/{location}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Filter used to select the subset of conversations to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Maximum number of conversations to delete.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub max_delete_count: i32,

    /// If set to true, all of this conversation's analyses will also be deleted.
    /// Otherwise, the request will only succeed if the conversation has no
    /// analyses.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub force: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BulkDeleteConversationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BulkDeleteConversationsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::BulkDeleteConversationsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [max_delete_count][crate::model::BulkDeleteConversationsRequest::max_delete_count].
    pub fn set_max_delete_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_delete_count = v.into();
        self
    }

    /// Sets the value of [force][crate::model::BulkDeleteConversationsRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for BulkDeleteConversationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.BulkDeleteConversationsRequest"
    }
}

/// The metadata for a bulk delete conversations operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BulkDeleteConversationsMetadata {
    /// The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The original request for bulk delete.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub request: std::option::Option<crate::model::BulkDeleteConversationsRequest>,

    /// Partial errors during bulk delete conversations operation that might cause
    /// the operation output to be incomplete.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub partial_errors: std::vec::Vec<rpc::model::Status>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BulkDeleteConversationsMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::BulkDeleteConversationsMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::BulkDeleteConversationsMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [request][crate::model::BulkDeleteConversationsMetadata::request].
    pub fn set_request<
        T: std::convert::Into<std::option::Option<crate::model::BulkDeleteConversationsRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = v.into();
        self
    }

    /// Sets the value of [partial_errors][crate::model::BulkDeleteConversationsMetadata::partial_errors].
    pub fn set_partial_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.partial_errors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BulkDeleteConversationsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.BulkDeleteConversationsMetadata"
    }
}

/// The response for a bulk delete conversations operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BulkDeleteConversationsResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BulkDeleteConversationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for BulkDeleteConversationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.BulkDeleteConversationsResponse"
    }
}

/// The request to export insights.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportInsightsDataRequest {
    /// Required. The parent resource to export data from.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// A filter to reduce results to a specific subset. Useful for exporting
    /// conversations with specific properties.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// A fully qualified KMS key name for BigQuery tables protected by CMEK.
    /// Format:
    /// projects/{project}/locations/{location}/keyRings/{keyring}/cryptoKeys/{key}/cryptoKeyVersions/{version}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key: std::string::String,

    /// Options for what to do if the destination table already exists.
    pub write_disposition: crate::model::export_insights_data_request::WriteDisposition,

    /// Exporter destination.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub destination: std::option::Option<crate::model::export_insights_data_request::Destination>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExportInsightsDataRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ExportInsightsDataRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ExportInsightsDataRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [kms_key][crate::model::ExportInsightsDataRequest::kms_key].
    pub fn set_kms_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key = v.into();
        self
    }

    /// Sets the value of [write_disposition][crate::model::ExportInsightsDataRequest::write_disposition].
    pub fn set_write_disposition<
        T: std::convert::Into<crate::model::export_insights_data_request::WriteDisposition>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.write_disposition = v.into();
        self
    }

    /// Sets the value of [destination][crate::model::ExportInsightsDataRequest::destination].
    ///
    /// Note that all the setters affecting `destination` are mutually
    /// exclusive.
    pub fn set_destination<
        T: std::convert::Into<
                std::option::Option<crate::model::export_insights_data_request::Destination>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::ExportInsightsDataRequest::destination]
    /// if it holds a `BigQueryDestination`, `None` if the field is not set or
    /// holds a different branch.
    pub fn big_query_destination(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::export_insights_data_request::BigQueryDestination>,
    > {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::export_insights_data_request::Destination::BigQueryDestination(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::ExportInsightsDataRequest::destination]
    /// to hold a `BigQueryDestination`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_big_query_destination<
        T: std::convert::Into<
                std::boxed::Box<crate::model::export_insights_data_request::BigQueryDestination>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::export_insights_data_request::Destination::BigQueryDestination(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ExportInsightsDataRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ExportInsightsDataRequest"
    }
}

/// Defines additional types related to [ExportInsightsDataRequest].
pub mod export_insights_data_request {
    #[allow(unused_imports)]
    use super::*;

    /// A BigQuery Table Reference.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct BigQueryDestination {
        /// A project ID or number. If specified, then export will attempt to
        /// write data to this project instead of the resource project. Otherwise,
        /// the resource project will be used.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub project_id: std::string::String,

        /// Required. The name of the BigQuery dataset that the snapshot result
        /// should be exported to. If this dataset does not exist, the export call
        /// returns an INVALID_ARGUMENT error.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub dataset: std::string::String,

        /// The BigQuery table name to which the insights data should be written.
        /// If this table does not exist, the export call returns an INVALID_ARGUMENT
        /// error.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub table: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BigQueryDestination {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [project_id][crate::model::export_insights_data_request::BigQueryDestination::project_id].
        pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project_id = v.into();
            self
        }

        /// Sets the value of [dataset][crate::model::export_insights_data_request::BigQueryDestination::dataset].
        pub fn set_dataset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.dataset = v.into();
            self
        }

        /// Sets the value of [table][crate::model::export_insights_data_request::BigQueryDestination::table].
        pub fn set_table<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.table = v.into();
            self
        }
    }

    impl wkt::message::Message for BigQueryDestination {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.ExportInsightsDataRequest.BigQueryDestination"
        }
    }

    /// Specifies the action that occurs if the destination table already exists.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum WriteDisposition {
        /// Write disposition is not specified. Defaults to WRITE_TRUNCATE.
        Unspecified,
        /// If the table already exists, BigQuery will overwrite the table data and
        /// use the schema from the load.
        WriteTruncate,
        /// If the table already exists, BigQuery will append data to the table.
        WriteAppend,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [WriteDisposition::value] or
        /// [WriteDisposition::name].
        UnknownValue(write_disposition::UnknownValue),
    }

    #[doc(hidden)]
    pub mod write_disposition {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl WriteDisposition {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::WriteTruncate => std::option::Option::Some(1),
                Self::WriteAppend => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("WRITE_DISPOSITION_UNSPECIFIED"),
                Self::WriteTruncate => std::option::Option::Some("WRITE_TRUNCATE"),
                Self::WriteAppend => std::option::Option::Some("WRITE_APPEND"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for WriteDisposition {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for WriteDisposition {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for WriteDisposition {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::WriteTruncate,
                2 => Self::WriteAppend,
                _ => Self::UnknownValue(write_disposition::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for WriteDisposition {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "WRITE_DISPOSITION_UNSPECIFIED" => Self::Unspecified,
                "WRITE_TRUNCATE" => Self::WriteTruncate,
                "WRITE_APPEND" => Self::WriteAppend,
                _ => Self::UnknownValue(write_disposition::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for WriteDisposition {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::WriteTruncate => serializer.serialize_i32(1),
                Self::WriteAppend => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for WriteDisposition {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<WriteDisposition>::new(
                ".google.cloud.contactcenterinsights.v1.ExportInsightsDataRequest.WriteDisposition",
            ))
        }
    }

    /// Exporter destination.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Destination {
        /// Specified if sink is a BigQuery table.
        BigQueryDestination(
            std::boxed::Box<crate::model::export_insights_data_request::BigQueryDestination>,
        ),
    }
}

/// Metadata for an export insights operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportInsightsDataMetadata {
    /// Output only. The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The original request for export.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub request: std::option::Option<crate::model::ExportInsightsDataRequest>,

    /// Partial errors during export operation that might cause the operation
    /// output to be incomplete.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub partial_errors: std::vec::Vec<rpc::model::Status>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExportInsightsDataMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::ExportInsightsDataMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::ExportInsightsDataMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [request][crate::model::ExportInsightsDataMetadata::request].
    pub fn set_request<
        T: std::convert::Into<std::option::Option<crate::model::ExportInsightsDataRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = v.into();
        self
    }

    /// Sets the value of [partial_errors][crate::model::ExportInsightsDataMetadata::partial_errors].
    pub fn set_partial_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.partial_errors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ExportInsightsDataMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ExportInsightsDataMetadata"
    }
}

/// Response for an export insights operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportInsightsDataResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExportInsightsDataResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ExportInsightsDataResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ExportInsightsDataResponse"
    }
}

/// The request to create an issue model.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateIssueModelRequest {
    /// Required. The parent resource of the issue model.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The issue model to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub issue_model: std::option::Option<crate::model::IssueModel>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateIssueModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateIssueModelRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [issue_model][crate::model::CreateIssueModelRequest::issue_model].
    pub fn set_issue_model<T: std::convert::Into<std::option::Option<crate::model::IssueModel>>>(
        mut self,
        v: T,
    ) -> Self {
        self.issue_model = v.into();
        self
    }
}

impl wkt::message::Message for CreateIssueModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.CreateIssueModelRequest"
    }
}

/// Metadata for creating an issue model.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateIssueModelMetadata {
    /// Output only. The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The original request for creation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub request: std::option::Option<crate::model::CreateIssueModelRequest>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateIssueModelMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::CreateIssueModelMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::CreateIssueModelMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [request][crate::model::CreateIssueModelMetadata::request].
    pub fn set_request<
        T: std::convert::Into<std::option::Option<crate::model::CreateIssueModelRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = v.into();
        self
    }
}

impl wkt::message::Message for CreateIssueModelMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.CreateIssueModelMetadata"
    }
}

/// The request to update an issue model.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateIssueModelRequest {
    /// Required. The new values for the issue model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub issue_model: std::option::Option<crate::model::IssueModel>,

    /// The list of fields to be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateIssueModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [issue_model][crate::model::UpdateIssueModelRequest::issue_model].
    pub fn set_issue_model<T: std::convert::Into<std::option::Option<crate::model::IssueModel>>>(
        mut self,
        v: T,
    ) -> Self {
        self.issue_model = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateIssueModelRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateIssueModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.UpdateIssueModelRequest"
    }
}

/// Request to list issue models.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListIssueModelsRequest {
    /// Required. The parent resource of the issue model.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListIssueModelsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListIssueModelsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for ListIssueModelsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ListIssueModelsRequest"
    }
}

/// The response of listing issue models.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListIssueModelsResponse {
    /// The issue models that match the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub issue_models: std::vec::Vec<crate::model::IssueModel>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListIssueModelsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [issue_models][crate::model::ListIssueModelsResponse::issue_models].
    pub fn set_issue_models<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::IssueModel>,
    {
        use std::iter::Iterator;
        self.issue_models = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListIssueModelsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ListIssueModelsResponse"
    }
}

/// The request to get an issue model.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetIssueModelRequest {
    /// Required. The name of the issue model to get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetIssueModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetIssueModelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetIssueModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.GetIssueModelRequest"
    }
}

/// The request to delete an issue model.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteIssueModelRequest {
    /// Required. The name of the issue model to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteIssueModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteIssueModelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteIssueModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.DeleteIssueModelRequest"
    }
}

/// Metadata for deleting an issue model.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteIssueModelMetadata {
    /// Output only. The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The original request for deletion.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub request: std::option::Option<crate::model::DeleteIssueModelRequest>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteIssueModelMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::DeleteIssueModelMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::DeleteIssueModelMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [request][crate::model::DeleteIssueModelMetadata::request].
    pub fn set_request<
        T: std::convert::Into<std::option::Option<crate::model::DeleteIssueModelRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = v.into();
        self
    }
}

impl wkt::message::Message for DeleteIssueModelMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.DeleteIssueModelMetadata"
    }
}

/// The request to deploy an issue model.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeployIssueModelRequest {
    /// Required. The issue model to deploy.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeployIssueModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeployIssueModelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeployIssueModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.DeployIssueModelRequest"
    }
}

/// The response to deploy an issue model.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeployIssueModelResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeployIssueModelResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for DeployIssueModelResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.DeployIssueModelResponse"
    }
}

/// Metadata for deploying an issue model.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeployIssueModelMetadata {
    /// Output only. The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The original request for deployment.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub request: std::option::Option<crate::model::DeployIssueModelRequest>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeployIssueModelMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::DeployIssueModelMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::DeployIssueModelMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [request][crate::model::DeployIssueModelMetadata::request].
    pub fn set_request<
        T: std::convert::Into<std::option::Option<crate::model::DeployIssueModelRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = v.into();
        self
    }
}

impl wkt::message::Message for DeployIssueModelMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.DeployIssueModelMetadata"
    }
}

/// The request to undeploy an issue model.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UndeployIssueModelRequest {
    /// Required. The issue model to undeploy.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UndeployIssueModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UndeployIssueModelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for UndeployIssueModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.UndeployIssueModelRequest"
    }
}

/// The response to undeploy an issue model.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UndeployIssueModelResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UndeployIssueModelResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for UndeployIssueModelResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.UndeployIssueModelResponse"
    }
}

/// Metadata for undeploying an issue model.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UndeployIssueModelMetadata {
    /// Output only. The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The original request for undeployment.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub request: std::option::Option<crate::model::UndeployIssueModelRequest>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UndeployIssueModelMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::UndeployIssueModelMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::UndeployIssueModelMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [request][crate::model::UndeployIssueModelMetadata::request].
    pub fn set_request<
        T: std::convert::Into<std::option::Option<crate::model::UndeployIssueModelRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = v.into();
        self
    }
}

impl wkt::message::Message for UndeployIssueModelMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.UndeployIssueModelMetadata"
    }
}

/// Request to export an issue model.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportIssueModelRequest {
    /// Required. The issue model to export.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub destination: std::option::Option<crate::model::export_issue_model_request::Destination>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExportIssueModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ExportIssueModelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [destination][crate::model::ExportIssueModelRequest::destination].
    ///
    /// Note that all the setters affecting `destination` are mutually
    /// exclusive.
    pub fn set_destination<
        T: std::convert::Into<
                std::option::Option<crate::model::export_issue_model_request::Destination>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::ExportIssueModelRequest::destination]
    /// if it holds a `GcsDestination`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_destination(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::export_issue_model_request::GcsDestination>,
    > {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::export_issue_model_request::Destination::GcsDestination(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::ExportIssueModelRequest::destination]
    /// to hold a `GcsDestination`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_gcs_destination<
        T: std::convert::Into<
                std::boxed::Box<crate::model::export_issue_model_request::GcsDestination>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::export_issue_model_request::Destination::GcsDestination(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ExportIssueModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ExportIssueModelRequest"
    }
}

/// Defines additional types related to [ExportIssueModelRequest].
pub mod export_issue_model_request {
    #[allow(unused_imports)]
    use super::*;

    /// Google Cloud Storage Object URI to save the issue model to.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GcsDestination {
        /// Required. Format: `gs://<bucket-name>/<object-name>`
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub object_uri: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GcsDestination {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [object_uri][crate::model::export_issue_model_request::GcsDestination::object_uri].
        pub fn set_object_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.object_uri = v.into();
            self
        }
    }

    impl wkt::message::Message for GcsDestination {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.ExportIssueModelRequest.GcsDestination"
        }
    }

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Destination {
        /// Google Cloud Storage URI to export the issue model to.
        GcsDestination(std::boxed::Box<crate::model::export_issue_model_request::GcsDestination>),
    }
}

/// Response from export issue model
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportIssueModelResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExportIssueModelResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ExportIssueModelResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ExportIssueModelResponse"
    }
}

/// Metadata used for export issue model.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportIssueModelMetadata {
    /// The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The original export request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub request: std::option::Option<crate::model::ExportIssueModelRequest>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExportIssueModelMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::ExportIssueModelMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::ExportIssueModelMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [request][crate::model::ExportIssueModelMetadata::request].
    pub fn set_request<
        T: std::convert::Into<std::option::Option<crate::model::ExportIssueModelRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = v.into();
        self
    }
}

impl wkt::message::Message for ExportIssueModelMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ExportIssueModelMetadata"
    }
}

/// Request to import an issue model.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportIssueModelRequest {
    /// Required. The parent resource of the issue model.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. If set to true, will create an issue model from the imported file
    /// with randomly generated IDs for the issue model and corresponding issues.
    /// Otherwise, replaces an existing model with the same ID as the file.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub create_new_model: bool,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::import_issue_model_request::Source>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportIssueModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ImportIssueModelRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [create_new_model][crate::model::ImportIssueModelRequest::create_new_model].
    pub fn set_create_new_model<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.create_new_model = v.into();
        self
    }

    /// Sets the value of [source][crate::model::ImportIssueModelRequest::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::import_issue_model_request::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::ImportIssueModelRequest::source]
    /// if it holds a `GcsSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::import_issue_model_request::GcsSource>>
    {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_issue_model_request::Source::GcsSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ImportIssueModelRequest::source]
    /// to hold a `GcsSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_gcs_source<
        T: std::convert::Into<std::boxed::Box<crate::model::import_issue_model_request::GcsSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_issue_model_request::Source::GcsSource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ImportIssueModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ImportIssueModelRequest"
    }
}

/// Defines additional types related to [ImportIssueModelRequest].
pub mod import_issue_model_request {
    #[allow(unused_imports)]
    use super::*;

    /// Google Cloud Storage Object URI to get the issue model file from.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GcsSource {
        /// Required. Format: `gs://<bucket-name>/<object-name>`
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub object_uri: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GcsSource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [object_uri][crate::model::import_issue_model_request::GcsSource::object_uri].
        pub fn set_object_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.object_uri = v.into();
            self
        }
    }

    impl wkt::message::Message for GcsSource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.ImportIssueModelRequest.GcsSource"
        }
    }

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// Google Cloud Storage source message.
        GcsSource(std::boxed::Box<crate::model::import_issue_model_request::GcsSource>),
    }
}

/// Response from import issue model
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportIssueModelResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportIssueModelResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ImportIssueModelResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ImportIssueModelResponse"
    }
}

/// Metadata used for import issue model.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportIssueModelMetadata {
    /// The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The original import request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub request: std::option::Option<crate::model::ImportIssueModelRequest>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportIssueModelMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::ImportIssueModelMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::ImportIssueModelMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [request][crate::model::ImportIssueModelMetadata::request].
    pub fn set_request<
        T: std::convert::Into<std::option::Option<crate::model::ImportIssueModelRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = v.into();
        self
    }
}

impl wkt::message::Message for ImportIssueModelMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ImportIssueModelMetadata"
    }
}

/// The request to get an issue.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetIssueRequest {
    /// Required. The name of the issue to get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetIssueRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetIssueRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetIssueRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.GetIssueRequest"
    }
}

/// Request to list issues.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListIssuesRequest {
    /// Required. The parent resource of the issue.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListIssuesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListIssuesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for ListIssuesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ListIssuesRequest"
    }
}

/// The response of listing issues.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListIssuesResponse {
    /// The issues that match the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub issues: std::vec::Vec<crate::model::Issue>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListIssuesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [issues][crate::model::ListIssuesResponse::issues].
    pub fn set_issues<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Issue>,
    {
        use std::iter::Iterator;
        self.issues = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListIssuesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ListIssuesResponse"
    }
}

/// The request to update an issue.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateIssueRequest {
    /// Required. The new values for the issue.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub issue: std::option::Option<crate::model::Issue>,

    /// The list of fields to be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateIssueRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [issue][crate::model::UpdateIssueRequest::issue].
    pub fn set_issue<T: std::convert::Into<std::option::Option<crate::model::Issue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.issue = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateIssueRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateIssueRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.UpdateIssueRequest"
    }
}

/// The request to delete an issue.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteIssueRequest {
    /// Required. The name of the issue to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteIssueRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteIssueRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteIssueRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.DeleteIssueRequest"
    }
}

/// Request to get statistics of an issue model.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CalculateIssueModelStatsRequest {
    /// Required. The resource name of the issue model to query against.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub issue_model: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CalculateIssueModelStatsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [issue_model][crate::model::CalculateIssueModelStatsRequest::issue_model].
    pub fn set_issue_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.issue_model = v.into();
        self
    }
}

impl wkt::message::Message for CalculateIssueModelStatsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.CalculateIssueModelStatsRequest"
    }
}

/// Response of querying an issue model's statistics.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CalculateIssueModelStatsResponse {
    /// The latest label statistics for the queried issue model. Includes results
    /// on both training data and data labeled after deployment.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub current_stats: std::option::Option<crate::model::IssueModelLabelStats>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CalculateIssueModelStatsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [current_stats][crate::model::CalculateIssueModelStatsResponse::current_stats].
    pub fn set_current_stats<
        T: std::convert::Into<std::option::Option<crate::model::IssueModelLabelStats>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.current_stats = v.into();
        self
    }
}

impl wkt::message::Message for CalculateIssueModelStatsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.CalculateIssueModelStatsResponse"
    }
}

/// Request to create a phrase matcher.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreatePhraseMatcherRequest {
    /// Required. The parent resource of the phrase matcher. Required. The location
    /// to create a phrase matcher for. Format: `projects/<Project
    /// ID>/locations/<Location ID>` or `projects/<Project
    /// Number>/locations/<Location ID>`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The phrase matcher resource to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub phrase_matcher: std::option::Option<crate::model::PhraseMatcher>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreatePhraseMatcherRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreatePhraseMatcherRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [phrase_matcher][crate::model::CreatePhraseMatcherRequest::phrase_matcher].
    pub fn set_phrase_matcher<
        T: std::convert::Into<std::option::Option<crate::model::PhraseMatcher>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.phrase_matcher = v.into();
        self
    }
}

impl wkt::message::Message for CreatePhraseMatcherRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.CreatePhraseMatcherRequest"
    }
}

/// Request to list phrase matchers.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPhraseMatchersRequest {
    /// Required. The parent resource of the phrase matcher.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of phrase matchers to return in the response. If this
    /// value is zero, the service will select a default size. A call might return
    /// fewer objects than requested. A non-empty `next_page_token` in the response
    /// indicates that more data is available.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The value returned by the last `ListPhraseMatchersResponse`. This value
    /// indicates that this is a continuation of a prior `ListPhraseMatchers` call
    /// and that the system should return the next page of data.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// A filter to reduce results to a specific subset. Useful for querying
    /// phrase matchers with specific properties.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPhraseMatchersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListPhraseMatchersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListPhraseMatchersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListPhraseMatchersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListPhraseMatchersRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListPhraseMatchersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ListPhraseMatchersRequest"
    }
}

/// The response of listing phrase matchers.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPhraseMatchersResponse {
    /// The phrase matchers that match the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub phrase_matchers: std::vec::Vec<crate::model::PhraseMatcher>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPhraseMatchersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [phrase_matchers][crate::model::ListPhraseMatchersResponse::phrase_matchers].
    pub fn set_phrase_matchers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PhraseMatcher>,
    {
        use std::iter::Iterator;
        self.phrase_matchers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListPhraseMatchersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListPhraseMatchersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ListPhraseMatchersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListPhraseMatchersResponse {
    type PageItem = crate::model::PhraseMatcher;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.phrase_matchers
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request to get a a phrase matcher.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetPhraseMatcherRequest {
    /// Required. The name of the phrase matcher to get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetPhraseMatcherRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPhraseMatcherRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetPhraseMatcherRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.GetPhraseMatcherRequest"
    }
}

/// The request to delete a phrase matcher.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeletePhraseMatcherRequest {
    /// Required. The name of the phrase matcher to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeletePhraseMatcherRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeletePhraseMatcherRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeletePhraseMatcherRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.DeletePhraseMatcherRequest"
    }
}

/// The request to update a phrase matcher.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdatePhraseMatcherRequest {
    /// Required. The new values for the phrase matcher.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub phrase_matcher: std::option::Option<crate::model::PhraseMatcher>,

    /// The list of fields to be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdatePhraseMatcherRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [phrase_matcher][crate::model::UpdatePhraseMatcherRequest::phrase_matcher].
    pub fn set_phrase_matcher<
        T: std::convert::Into<std::option::Option<crate::model::PhraseMatcher>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.phrase_matcher = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdatePhraseMatcherRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdatePhraseMatcherRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.UpdatePhraseMatcherRequest"
    }
}

/// The request to get project-level settings.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetSettingsRequest {
    /// Required. The name of the settings resource to get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSettingsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSettingsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetSettingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.GetSettingsRequest"
    }
}

/// The request to update project-level settings.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateSettingsRequest {
    /// Required. The new settings values.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub settings: std::option::Option<crate::model::Settings>,

    /// Required. The list of fields to be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateSettingsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [settings][crate::model::UpdateSettingsRequest::settings].
    pub fn set_settings<T: std::convert::Into<std::option::Option<crate::model::Settings>>>(
        mut self,
        v: T,
    ) -> Self {
        self.settings = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateSettingsRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateSettingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.UpdateSettingsRequest"
    }
}

/// The request to create a analysis rule.
/// analysis_rule_id will be generated by the server.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateAnalysisRuleRequest {
    /// Required. The parent resource of the analysis rule. Required. The location
    /// to create a analysis rule for. Format: `projects/<Project
    /// ID>/locations/<Location ID>` or `projects/<Project
    /// Number>/locations/<Location ID>`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The analysis rule resource to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub analysis_rule: std::option::Option<crate::model::AnalysisRule>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateAnalysisRuleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateAnalysisRuleRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [analysis_rule][crate::model::CreateAnalysisRuleRequest::analysis_rule].
    pub fn set_analysis_rule<
        T: std::convert::Into<std::option::Option<crate::model::AnalysisRule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.analysis_rule = v.into();
        self
    }
}

impl wkt::message::Message for CreateAnalysisRuleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.CreateAnalysisRuleRequest"
    }
}

/// The request for getting a analysis rule.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetAnalysisRuleRequest {
    /// Required. The name of the AnalysisRule to get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetAnalysisRuleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAnalysisRuleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAnalysisRuleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.GetAnalysisRuleRequest"
    }
}

/// The request to update a analysis rule.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateAnalysisRuleRequest {
    /// Required. The new analysis rule.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub analysis_rule: std::option::Option<crate::model::AnalysisRule>,

    /// Optional. The list of fields to be updated.
    /// If the update_mask is not provided, the update will be applied to all
    /// fields.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateAnalysisRuleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [analysis_rule][crate::model::UpdateAnalysisRuleRequest::analysis_rule].
    pub fn set_analysis_rule<
        T: std::convert::Into<std::option::Option<crate::model::AnalysisRule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.analysis_rule = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateAnalysisRuleRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateAnalysisRuleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.UpdateAnalysisRuleRequest"
    }
}

/// The request to delete a analysis rule.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteAnalysisRuleRequest {
    /// Required. The name of the analysis rule to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteAnalysisRuleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteAnalysisRuleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAnalysisRuleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.DeleteAnalysisRuleRequest"
    }
}

/// The request to list analysis rules.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAnalysisRulesRequest {
    /// Required. The parent resource of the analysis rules.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of analysis rule to return in the response. If
    /// this value is zero, the service will select a default size. A call may
    /// return fewer objects than requested. A non-empty `next_page_token` in the
    /// response indicates that more data is available.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. The value returned by the last `ListAnalysisRulesResponse`;
    /// indicates that this is a continuation of a prior `ListAnalysisRules` call
    /// and the system should return the next page of data.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAnalysisRulesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAnalysisRulesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAnalysisRulesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAnalysisRulesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAnalysisRulesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ListAnalysisRulesRequest"
    }
}

/// The response of listing views.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAnalysisRulesResponse {
    /// The analysis_rule that match the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub analysis_rules: std::vec::Vec<crate::model::AnalysisRule>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAnalysisRulesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [analysis_rules][crate::model::ListAnalysisRulesResponse::analysis_rules].
    pub fn set_analysis_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AnalysisRule>,
    {
        use std::iter::Iterator;
        self.analysis_rules = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAnalysisRulesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAnalysisRulesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ListAnalysisRulesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAnalysisRulesResponse {
    type PageItem = crate::model::AnalysisRule;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.analysis_rules
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request to get location-level encryption specification.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetEncryptionSpecRequest {
    /// Required. The name of the encryption spec resource to get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetEncryptionSpecRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEncryptionSpecRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetEncryptionSpecRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.GetEncryptionSpecRequest"
    }
}

/// The request to initialize a location-level encryption specification.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InitializeEncryptionSpecRequest {
    /// Required. The encryption spec used for CMEK encryption. It is required that
    /// the kms key is in the same region as the endpoint. The same key will be
    /// used for all provisioned resources, if encryption is available. If the
    /// `kms_key_name` field is left empty, no encryption will be enforced.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_spec: std::option::Option<crate::model::EncryptionSpec>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InitializeEncryptionSpecRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [encryption_spec][crate::model::InitializeEncryptionSpecRequest::encryption_spec].
    pub fn set_encryption_spec<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_spec = v.into();
        self
    }
}

impl wkt::message::Message for InitializeEncryptionSpecRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.InitializeEncryptionSpecRequest"
    }
}

/// The response to initialize a location-level encryption specification.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InitializeEncryptionSpecResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InitializeEncryptionSpecResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for InitializeEncryptionSpecResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.InitializeEncryptionSpecResponse"
    }
}

/// Metadata for initializing a location-level encryption specification.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InitializeEncryptionSpecMetadata {
    /// Output only. The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The original request for initialization.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub request: std::option::Option<crate::model::InitializeEncryptionSpecRequest>,

    /// Partial errors during initializing operation that might cause the operation
    /// output to be incomplete.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub partial_errors: std::vec::Vec<rpc::model::Status>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InitializeEncryptionSpecMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::InitializeEncryptionSpecMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::InitializeEncryptionSpecMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [request][crate::model::InitializeEncryptionSpecMetadata::request].
    pub fn set_request<
        T: std::convert::Into<std::option::Option<crate::model::InitializeEncryptionSpecRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = v.into();
        self
    }

    /// Sets the value of [partial_errors][crate::model::InitializeEncryptionSpecMetadata::partial_errors].
    pub fn set_partial_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.partial_errors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for InitializeEncryptionSpecMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.InitializeEncryptionSpecMetadata"
    }
}

/// The request to create a view.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateViewRequest {
    /// Required. The parent resource of the view. Required. The location to create
    /// a view for.
    /// Format: `projects/<Project ID>/locations/<Location ID>` or
    /// `projects/<Project Number>/locations/<Location ID>`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The view resource to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub view: std::option::Option<crate::model::View>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateViewRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateViewRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [view][crate::model::CreateViewRequest::view].
    pub fn set_view<T: std::convert::Into<std::option::Option<crate::model::View>>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for CreateViewRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.CreateViewRequest"
    }
}

/// The request to get a view.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetViewRequest {
    /// Required. The name of the view to get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetViewRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetViewRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetViewRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.GetViewRequest"
    }
}

/// The request to list views.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListViewsRequest {
    /// Required. The parent resource of the views.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of views to return in the response. If this
    /// value is zero, the service will select a default size. A call may return
    /// fewer objects than requested. A non-empty `next_page_token` in the response
    /// indicates that more data is available.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The value returned by the last `ListViewsResponse`; indicates
    /// that this is a continuation of a prior `ListViews` call and
    /// the system should return the next page of data.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListViewsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListViewsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListViewsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListViewsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListViewsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ListViewsRequest"
    }
}

/// The response of listing views.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListViewsResponse {
    /// The views that match the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub views: std::vec::Vec<crate::model::View>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListViewsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [views][crate::model::ListViewsResponse::views].
    pub fn set_views<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::View>,
    {
        use std::iter::Iterator;
        self.views = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListViewsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListViewsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ListViewsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListViewsResponse {
    type PageItem = crate::model::View;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.views
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request to update a view.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateViewRequest {
    /// Required. The new view.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub view: std::option::Option<crate::model::View>,

    /// The list of fields to be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateViewRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [view][crate::model::UpdateViewRequest::view].
    pub fn set_view<T: std::convert::Into<std::option::Option<crate::model::View>>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateViewRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateViewRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.UpdateViewRequest"
    }
}

/// The request to delete a view.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteViewRequest {
    /// Required. The name of the view to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteViewRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteViewRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteViewRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.DeleteViewRequest"
    }
}

/// A dimension determines the grouping key for the query. In SQL terms, these
/// would be part of both the "SELECT" and "GROUP BY" clauses.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Dimension {
    /// The key of the dimension.
    pub dimension_key: crate::model::dimension::DimensionKey,

    /// Output-only metadata about the dimension.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub dimension_metadata: std::option::Option<crate::model::dimension::DimensionMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Dimension {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dimension_key][crate::model::Dimension::dimension_key].
    pub fn set_dimension_key<T: std::convert::Into<crate::model::dimension::DimensionKey>>(
        mut self,
        v: T,
    ) -> Self {
        self.dimension_key = v.into();
        self
    }

    /// Sets the value of [dimension_metadata][crate::model::Dimension::dimension_metadata].
    ///
    /// Note that all the setters affecting `dimension_metadata` are mutually
    /// exclusive.
    pub fn set_dimension_metadata<
        T: std::convert::Into<std::option::Option<crate::model::dimension::DimensionMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dimension_metadata = v.into();
        self
    }

    /// The value of [dimension_metadata][crate::model::Dimension::dimension_metadata]
    /// if it holds a `IssueDimensionMetadata`, `None` if the field is not set or
    /// holds a different branch.
    pub fn issue_dimension_metadata(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::dimension::IssueDimensionMetadata>>
    {
        #[allow(unreachable_patterns)]
        self.dimension_metadata.as_ref().and_then(|v| match v {
            crate::model::dimension::DimensionMetadata::IssueDimensionMetadata(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [dimension_metadata][crate::model::Dimension::dimension_metadata]
    /// to hold a `IssueDimensionMetadata`.
    ///
    /// Note that all the setters affecting `dimension_metadata` are
    /// mutually exclusive.
    pub fn set_issue_dimension_metadata<
        T: std::convert::Into<std::boxed::Box<crate::model::dimension::IssueDimensionMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dimension_metadata = std::option::Option::Some(
            crate::model::dimension::DimensionMetadata::IssueDimensionMetadata(v.into()),
        );
        self
    }

    /// The value of [dimension_metadata][crate::model::Dimension::dimension_metadata]
    /// if it holds a `AgentDimensionMetadata`, `None` if the field is not set or
    /// holds a different branch.
    pub fn agent_dimension_metadata(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::dimension::AgentDimensionMetadata>>
    {
        #[allow(unreachable_patterns)]
        self.dimension_metadata.as_ref().and_then(|v| match v {
            crate::model::dimension::DimensionMetadata::AgentDimensionMetadata(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [dimension_metadata][crate::model::Dimension::dimension_metadata]
    /// to hold a `AgentDimensionMetadata`.
    ///
    /// Note that all the setters affecting `dimension_metadata` are
    /// mutually exclusive.
    pub fn set_agent_dimension_metadata<
        T: std::convert::Into<std::boxed::Box<crate::model::dimension::AgentDimensionMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dimension_metadata = std::option::Option::Some(
            crate::model::dimension::DimensionMetadata::AgentDimensionMetadata(v.into()),
        );
        self
    }

    /// The value of [dimension_metadata][crate::model::Dimension::dimension_metadata]
    /// if it holds a `QaQuestionDimensionMetadata`, `None` if the field is not set or
    /// holds a different branch.
    pub fn qa_question_dimension_metadata(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::dimension::QaQuestionDimensionMetadata>>
    {
        #[allow(unreachable_patterns)]
        self.dimension_metadata.as_ref().and_then(|v| match v {
            crate::model::dimension::DimensionMetadata::QaQuestionDimensionMetadata(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [dimension_metadata][crate::model::Dimension::dimension_metadata]
    /// to hold a `QaQuestionDimensionMetadata`.
    ///
    /// Note that all the setters affecting `dimension_metadata` are
    /// mutually exclusive.
    pub fn set_qa_question_dimension_metadata<
        T: std::convert::Into<std::boxed::Box<crate::model::dimension::QaQuestionDimensionMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dimension_metadata = std::option::Option::Some(
            crate::model::dimension::DimensionMetadata::QaQuestionDimensionMetadata(v.into()),
        );
        self
    }

    /// The value of [dimension_metadata][crate::model::Dimension::dimension_metadata]
    /// if it holds a `QaQuestionAnswerDimensionMetadata`, `None` if the field is not set or
    /// holds a different branch.
    pub fn qa_question_answer_dimension_metadata(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::dimension::QaQuestionAnswerDimensionMetadata>,
    > {
        #[allow(unreachable_patterns)]
        self.dimension_metadata.as_ref().and_then(|v| match v {
            crate::model::dimension::DimensionMetadata::QaQuestionAnswerDimensionMetadata(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [dimension_metadata][crate::model::Dimension::dimension_metadata]
    /// to hold a `QaQuestionAnswerDimensionMetadata`.
    ///
    /// Note that all the setters affecting `dimension_metadata` are
    /// mutually exclusive.
    pub fn set_qa_question_answer_dimension_metadata<
        T: std::convert::Into<
                std::boxed::Box<crate::model::dimension::QaQuestionAnswerDimensionMetadata>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dimension_metadata = std::option::Option::Some(
            crate::model::dimension::DimensionMetadata::QaQuestionAnswerDimensionMetadata(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Dimension {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.Dimension"
    }
}

/// Defines additional types related to [Dimension].
pub mod dimension {
    #[allow(unused_imports)]
    use super::*;

    /// Metadata about the issue dimension.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct IssueDimensionMetadata {
        /// The issue ID.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub issue_id: std::string::String,

        /// The issue display name.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub issue_display_name: std::string::String,

        /// The parent issue model ID.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub issue_model_id: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl IssueDimensionMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [issue_id][crate::model::dimension::IssueDimensionMetadata::issue_id].
        pub fn set_issue_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.issue_id = v.into();
            self
        }

        /// Sets the value of [issue_display_name][crate::model::dimension::IssueDimensionMetadata::issue_display_name].
        pub fn set_issue_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.issue_display_name = v.into();
            self
        }

        /// Sets the value of [issue_model_id][crate::model::dimension::IssueDimensionMetadata::issue_model_id].
        pub fn set_issue_model_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.issue_model_id = v.into();
            self
        }
    }

    impl wkt::message::Message for IssueDimensionMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.Dimension.IssueDimensionMetadata"
        }
    }

    /// Metadata about the agent dimension.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct AgentDimensionMetadata {
        /// Optional. A user-specified string representing the agent.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub agent_id: std::string::String,

        /// Optional. The agent's name
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub agent_display_name: std::string::String,

        /// Optional. A user-specified string representing the agent's team.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub agent_team: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AgentDimensionMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [agent_id][crate::model::dimension::AgentDimensionMetadata::agent_id].
        pub fn set_agent_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.agent_id = v.into();
            self
        }

        /// Sets the value of [agent_display_name][crate::model::dimension::AgentDimensionMetadata::agent_display_name].
        pub fn set_agent_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.agent_display_name = v.into();
            self
        }

        /// Sets the value of [agent_team][crate::model::dimension::AgentDimensionMetadata::agent_team].
        pub fn set_agent_team<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.agent_team = v.into();
            self
        }
    }

    impl wkt::message::Message for AgentDimensionMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.Dimension.AgentDimensionMetadata"
        }
    }

    /// Metadata about the QA question dimension.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct QaQuestionDimensionMetadata {
        /// Optional. The QA scorecard ID.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub qa_scorecard_id: std::string::String,

        /// Optional. The QA question ID.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub qa_question_id: std::string::String,

        /// Optional. The full body of the question.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub question_body: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl QaQuestionDimensionMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [qa_scorecard_id][crate::model::dimension::QaQuestionDimensionMetadata::qa_scorecard_id].
        pub fn set_qa_scorecard_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.qa_scorecard_id = v.into();
            self
        }

        /// Sets the value of [qa_question_id][crate::model::dimension::QaQuestionDimensionMetadata::qa_question_id].
        pub fn set_qa_question_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.qa_question_id = v.into();
            self
        }

        /// Sets the value of [question_body][crate::model::dimension::QaQuestionDimensionMetadata::question_body].
        pub fn set_question_body<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.question_body = v.into();
            self
        }
    }

    impl wkt::message::Message for QaQuestionDimensionMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.Dimension.QaQuestionDimensionMetadata"
        }
    }

    /// Metadata about the QA question-answer dimension.
    /// This is useful for showing the answer distribution for questions for a
    /// given scorecard.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct QaQuestionAnswerDimensionMetadata {
        /// Optional. The QA scorecard ID.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub qa_scorecard_id: std::string::String,

        /// Optional. The QA question ID.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub qa_question_id: std::string::String,

        /// Optional. The full body of the question.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub question_body: std::string::String,

        /// Optional. The full body of the question.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub answer_value: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl QaQuestionAnswerDimensionMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [qa_scorecard_id][crate::model::dimension::QaQuestionAnswerDimensionMetadata::qa_scorecard_id].
        pub fn set_qa_scorecard_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.qa_scorecard_id = v.into();
            self
        }

        /// Sets the value of [qa_question_id][crate::model::dimension::QaQuestionAnswerDimensionMetadata::qa_question_id].
        pub fn set_qa_question_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.qa_question_id = v.into();
            self
        }

        /// Sets the value of [question_body][crate::model::dimension::QaQuestionAnswerDimensionMetadata::question_body].
        pub fn set_question_body<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.question_body = v.into();
            self
        }

        /// Sets the value of [answer_value][crate::model::dimension::QaQuestionAnswerDimensionMetadata::answer_value].
        pub fn set_answer_value<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.answer_value = v.into();
            self
        }
    }

    impl wkt::message::Message for QaQuestionAnswerDimensionMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.Dimension.QaQuestionAnswerDimensionMetadata"
        }
    }

    /// The key of the dimension.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DimensionKey {
        /// The key of the dimension is unspecified.
        Unspecified,
        /// The dimension is keyed by issues.
        Issue,
        /// The dimension is keyed by agents.
        Agent,
        /// The dimension is keyed by agent teams.
        AgentTeam,
        /// The dimension is keyed by QaQuestionIds.
        /// Note that: We only group by the QuestionId and not the revision-id of the
        /// scorecard this question is a part of. This allows for showing stats for
        /// the same question across different scorecard revisions.
        QaQuestionId,
        /// The dimension is keyed by QaQuestionIds-Answer value pairs.
        /// Note that: We only group by the QuestionId and not the revision-id of the
        /// scorecard this question is a part of. This allows for showing
        /// distribution of answers per question across different scorecard
        /// revisions.
        QaQuestionAnswerValue,
        /// The dimension is keyed by the conversation profile ID.
        ConversationProfileId,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DimensionKey::value] or
        /// [DimensionKey::name].
        UnknownValue(dimension_key::UnknownValue),
    }

    #[doc(hidden)]
    pub mod dimension_key {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DimensionKey {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Issue => std::option::Option::Some(1),
                Self::Agent => std::option::Option::Some(2),
                Self::AgentTeam => std::option::Option::Some(3),
                Self::QaQuestionId => std::option::Option::Some(4),
                Self::QaQuestionAnswerValue => std::option::Option::Some(5),
                Self::ConversationProfileId => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DIMENSION_KEY_UNSPECIFIED"),
                Self::Issue => std::option::Option::Some("ISSUE"),
                Self::Agent => std::option::Option::Some("AGENT"),
                Self::AgentTeam => std::option::Option::Some("AGENT_TEAM"),
                Self::QaQuestionId => std::option::Option::Some("QA_QUESTION_ID"),
                Self::QaQuestionAnswerValue => {
                    std::option::Option::Some("QA_QUESTION_ANSWER_VALUE")
                }
                Self::ConversationProfileId => std::option::Option::Some("CONVERSATION_PROFILE_ID"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DimensionKey {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DimensionKey {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DimensionKey {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Issue,
                2 => Self::Agent,
                3 => Self::AgentTeam,
                4 => Self::QaQuestionId,
                5 => Self::QaQuestionAnswerValue,
                6 => Self::ConversationProfileId,
                _ => Self::UnknownValue(dimension_key::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DimensionKey {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DIMENSION_KEY_UNSPECIFIED" => Self::Unspecified,
                "ISSUE" => Self::Issue,
                "AGENT" => Self::Agent,
                "AGENT_TEAM" => Self::AgentTeam,
                "QA_QUESTION_ID" => Self::QaQuestionId,
                "QA_QUESTION_ANSWER_VALUE" => Self::QaQuestionAnswerValue,
                "CONVERSATION_PROFILE_ID" => Self::ConversationProfileId,
                _ => Self::UnknownValue(dimension_key::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DimensionKey {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Issue => serializer.serialize_i32(1),
                Self::Agent => serializer.serialize_i32(2),
                Self::AgentTeam => serializer.serialize_i32(3),
                Self::QaQuestionId => serializer.serialize_i32(4),
                Self::QaQuestionAnswerValue => serializer.serialize_i32(5),
                Self::ConversationProfileId => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DimensionKey {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DimensionKey>::new(
                ".google.cloud.contactcenterinsights.v1.Dimension.DimensionKey",
            ))
        }
    }

    /// Output-only metadata about the dimension.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum DimensionMetadata {
        /// Output only. Metadata about the issue dimension.
        IssueDimensionMetadata(std::boxed::Box<crate::model::dimension::IssueDimensionMetadata>),
        /// Output only. Metadata about the agent dimension.
        AgentDimensionMetadata(std::boxed::Box<crate::model::dimension::AgentDimensionMetadata>),
        /// Output only. Metadata about the QA question dimension.
        QaQuestionDimensionMetadata(
            std::boxed::Box<crate::model::dimension::QaQuestionDimensionMetadata>,
        ),
        /// Output only. Metadata about the QA question-answer dimension.
        QaQuestionAnswerDimensionMetadata(
            std::boxed::Box<crate::model::dimension::QaQuestionAnswerDimensionMetadata>,
        ),
    }
}

/// The request for querying metrics.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QueryMetricsRequest {
    /// Required. The location of the data.
    /// "projects/{project}/locations/{location}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,

    /// Required. Filter to select a subset of conversations to compute the
    /// metrics. Must specify a window of the conversation create time to compute
    /// the metrics. The returned metrics will be from the range [DATE(starting
    /// create time), DATE(ending create time)).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The time granularity of each data point in the time series.
    /// Defaults to NONE if this field is unspecified.
    pub time_granularity: crate::model::query_metrics_request::TimeGranularity,

    /// The dimensions that determine the grouping key for the query. Defaults to
    /// no dimension if this field is unspecified. If a dimension is specified,
    /// its key must also be specified. Each dimension's key must be unique.
    ///
    /// If a time granularity is also specified, metric values in the dimension
    /// will be bucketed by this granularity.
    ///
    /// Up to one dimension is supported for now.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub dimensions: std::vec::Vec<crate::model::Dimension>,

    /// Measures to return. Defaults to all measures if this field is unspecified.
    /// A valid mask should traverse from the `measure` field from the response.
    /// For example, a path from a measure mask to get the conversation count is
    /// "conversation_measure.count".
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub measure_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QueryMetricsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::QueryMetricsRequest::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::QueryMetricsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [time_granularity][crate::model::QueryMetricsRequest::time_granularity].
    pub fn set_time_granularity<
        T: std::convert::Into<crate::model::query_metrics_request::TimeGranularity>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.time_granularity = v.into();
        self
    }

    /// Sets the value of [dimensions][crate::model::QueryMetricsRequest::dimensions].
    pub fn set_dimensions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Dimension>,
    {
        use std::iter::Iterator;
        self.dimensions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [measure_mask][crate::model::QueryMetricsRequest::measure_mask].
    pub fn set_measure_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.measure_mask = v.into();
        self
    }
}

impl wkt::message::Message for QueryMetricsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.QueryMetricsRequest"
    }
}

/// Defines additional types related to [QueryMetricsRequest].
pub mod query_metrics_request {
    #[allow(unused_imports)]
    use super::*;

    /// A time granularity divides the time line into discrete time periods.
    /// This is useful for defining buckets over which filtering and aggregation
    /// should be performed.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TimeGranularity {
        /// The time granularity is unspecified and will default to NONE.
        Unspecified,
        /// No time granularity. The response won't contain a time series.
        /// This is the default value if no time granularity is specified.
        None,
        /// Data points in the time series will aggregate at a daily granularity.
        /// 1 day means [midnight to midnight).
        Daily,
        /// Data points in the time series will aggregate at a daily granularity.
        /// 1 HOUR means [01:00 to 02:00).
        Hourly,
        /// Data points in the time series will aggregate at a daily granularity.
        /// PER_MINUTE means [01:00 to 01:01).
        PerMinute,
        /// Data points in the time series will aggregate at a 1 minute  granularity.
        /// PER_5_MINUTES means [01:00 to 01:05).
        Per5Minutes,
        /// Data points in the time series will aggregate at a monthly granularity.
        /// 1 MONTH means [01st of the month to 1st of the next month).
        Monthly,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TimeGranularity::value] or
        /// [TimeGranularity::name].
        UnknownValue(time_granularity::UnknownValue),
    }

    #[doc(hidden)]
    pub mod time_granularity {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TimeGranularity {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::None => std::option::Option::Some(1),
                Self::Daily => std::option::Option::Some(2),
                Self::Hourly => std::option::Option::Some(3),
                Self::PerMinute => std::option::Option::Some(4),
                Self::Per5Minutes => std::option::Option::Some(5),
                Self::Monthly => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TIME_GRANULARITY_UNSPECIFIED"),
                Self::None => std::option::Option::Some("NONE"),
                Self::Daily => std::option::Option::Some("DAILY"),
                Self::Hourly => std::option::Option::Some("HOURLY"),
                Self::PerMinute => std::option::Option::Some("PER_MINUTE"),
                Self::Per5Minutes => std::option::Option::Some("PER_5_MINUTES"),
                Self::Monthly => std::option::Option::Some("MONTHLY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TimeGranularity {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TimeGranularity {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TimeGranularity {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::None,
                2 => Self::Daily,
                3 => Self::Hourly,
                4 => Self::PerMinute,
                5 => Self::Per5Minutes,
                6 => Self::Monthly,
                _ => Self::UnknownValue(time_granularity::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TimeGranularity {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TIME_GRANULARITY_UNSPECIFIED" => Self::Unspecified,
                "NONE" => Self::None,
                "DAILY" => Self::Daily,
                "HOURLY" => Self::Hourly,
                "PER_MINUTE" => Self::PerMinute,
                "PER_5_MINUTES" => Self::Per5Minutes,
                "MONTHLY" => Self::Monthly,
                _ => Self::UnknownValue(time_granularity::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TimeGranularity {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::None => serializer.serialize_i32(1),
                Self::Daily => serializer.serialize_i32(2),
                Self::Hourly => serializer.serialize_i32(3),
                Self::PerMinute => serializer.serialize_i32(4),
                Self::Per5Minutes => serializer.serialize_i32(5),
                Self::Monthly => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TimeGranularity {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TimeGranularity>::new(
                ".google.cloud.contactcenterinsights.v1.QueryMetricsRequest.TimeGranularity",
            ))
        }
    }
}

/// The response for querying metrics.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QueryMetricsResponse {
    /// Required. The location of the data.
    /// "projects/{project}/locations/{location}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,

    /// The metrics last update time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// A slice contains a total and (if the request specified a time granularity)
    /// a time series of metric values. Each slice contains a unique combination of
    /// the cardinality of dimensions from the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub slices: std::vec::Vec<crate::model::query_metrics_response::Slice>,

    /// The macro average slice contains aggregated averages across the selected
    /// dimension. i.e. if group_by agent is specified this field will contain the
    /// average across all agents.
    /// This field is only populated if the request specifies a Dimension.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub macro_average_slice: std::option::Option<crate::model::query_metrics_response::Slice>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QueryMetricsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::QueryMetricsResponse::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::QueryMetricsResponse::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [slices][crate::model::QueryMetricsResponse::slices].
    pub fn set_slices<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::query_metrics_response::Slice>,
    {
        use std::iter::Iterator;
        self.slices = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [macro_average_slice][crate::model::QueryMetricsResponse::macro_average_slice].
    pub fn set_macro_average_slice<
        T: std::convert::Into<std::option::Option<crate::model::query_metrics_response::Slice>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.macro_average_slice = v.into();
        self
    }
}

impl wkt::message::Message for QueryMetricsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.QueryMetricsResponse"
    }
}

/// Defines additional types related to [QueryMetricsResponse].
pub mod query_metrics_response {
    #[allow(unused_imports)]
    use super::*;

    /// A slice contains a total and (if the request specified a time granularity)
    /// a time series of metric values. Each slice contains a unique combination of
    /// the cardinality of dimensions from the request.
    ///
    /// For example, if the request specifies a single ISSUE dimension and it has a
    /// cardinality of 2 (i.e. the data used to compute the metrics has 2 issues in
    /// total), the response will have 2 slices:
    ///
    /// * Slice 1 -> dimensions=[Issue 1]
    /// * Slice 2 -> dimensions=[Issue 2]
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Slice {
        /// A unique combination of dimensions that this slice represents.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub dimensions: std::vec::Vec<crate::model::Dimension>,

        /// The total metric value. The interval of this data point is
        /// [starting create time, ending create time) from the request.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub total: std::option::Option<crate::model::query_metrics_response::slice::DataPoint>,

        /// A time series of metric values. This is only populated if the request
        /// specifies a time granularity other than NONE.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub time_series:
            std::option::Option<crate::model::query_metrics_response::slice::TimeSeries>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Slice {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [dimensions][crate::model::query_metrics_response::Slice::dimensions].
        pub fn set_dimensions<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::Dimension>,
        {
            use std::iter::Iterator;
            self.dimensions = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [total][crate::model::query_metrics_response::Slice::total].
        pub fn set_total<
            T: std::convert::Into<
                    std::option::Option<crate::model::query_metrics_response::slice::DataPoint>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.total = v.into();
            self
        }

        /// Sets the value of [time_series][crate::model::query_metrics_response::Slice::time_series].
        pub fn set_time_series<
            T: std::convert::Into<
                    std::option::Option<crate::model::query_metrics_response::slice::TimeSeries>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.time_series = v.into();
            self
        }
    }

    impl wkt::message::Message for Slice {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.QueryMetricsResponse.Slice"
        }
    }

    /// Defines additional types related to [Slice].
    pub mod slice {
        #[allow(unused_imports)]
        use super::*;

        /// A data point contains the metric values mapped to an interval.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct DataPoint {
            /// The interval that this data point represents.
            ///
            /// * If this is the total data point, the interval is
            ///   [starting create time, ending create time) from the request.
            /// * If this a data point from the time series, the interval is
            ///   [time, time + time granularity from the request).
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub interval: std::option::Option<gtype::model::Interval>,

            /// The measure included in this data point.
            #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
            pub measure: std::option::Option<
                crate::model::query_metrics_response::slice::data_point::Measure,
            >,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl DataPoint {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [interval][crate::model::query_metrics_response::slice::DataPoint::interval].
            pub fn set_interval<
                T: std::convert::Into<std::option::Option<gtype::model::Interval>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.interval = v.into();
                self
            }

            /// Sets the value of [measure][crate::model::query_metrics_response::slice::DataPoint::measure].
            ///
            /// Note that all the setters affecting `measure` are mutually
            /// exclusive.
            pub fn set_measure<
                T: std::convert::Into<
                        std::option::Option<
                            crate::model::query_metrics_response::slice::data_point::Measure,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.measure = v.into();
                self
            }

            /// The value of [measure][crate::model::query_metrics_response::slice::DataPoint::measure]
            /// if it holds a `ConversationMeasure`, `None` if the field is not set or
            /// holds a different branch.
            pub fn conversation_measure(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<
                    crate::model::query_metrics_response::slice::data_point::ConversationMeasure,
                >,
            > {
                #[allow(unreachable_patterns)]
                self.measure.as_ref().and_then(|v| match v {
                    crate::model::query_metrics_response::slice::data_point::Measure::ConversationMeasure(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [measure][crate::model::query_metrics_response::slice::DataPoint::measure]
            /// to hold a `ConversationMeasure`.
            ///
            /// Note that all the setters affecting `measure` are
            /// mutually exclusive.
            pub fn set_conversation_measure<T: std::convert::Into<std::boxed::Box<crate::model::query_metrics_response::slice::data_point::ConversationMeasure>>>(mut self, v: T) -> Self{
                self.measure = std::option::Option::Some(
                    crate::model::query_metrics_response::slice::data_point::Measure::ConversationMeasure(
                        v.into()
                    )
                );
                self
            }
        }

        impl wkt::message::Message for DataPoint {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.contactcenterinsights.v1.QueryMetricsResponse.Slice.DataPoint"
            }
        }

        /// Defines additional types related to [DataPoint].
        pub mod data_point {
            #[allow(unused_imports)]
            use super::*;

            /// The measure related to conversations.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct ConversationMeasure {

                /// The conversation count.
                #[serde(skip_serializing_if = "std::option::Option::is_none")]
                pub conversation_count: std::option::Option<i32>,

                /// The average silence percentage.
                #[serde(skip_serializing_if = "std::option::Option::is_none")]
                #[serde_as(as = "std::option::Option<wkt::internal::F32>")]
                pub average_silence_percentage: std::option::Option<f32>,

                /// The average duration.
                #[serde(skip_serializing_if = "std::option::Option::is_none")]
                pub average_duration: std::option::Option<wkt::Duration>,

                /// The average turn count.
                #[serde(skip_serializing_if = "std::option::Option::is_none")]
                #[serde_as(as = "std::option::Option<wkt::internal::F32>")]
                pub average_turn_count: std::option::Option<f32>,

                /// The average agent's sentiment score.
                #[serde(skip_serializing_if = "std::option::Option::is_none")]
                #[serde_as(as = "std::option::Option<wkt::internal::F32>")]
                pub average_agent_sentiment_score: std::option::Option<f32>,

                /// The average client's sentiment score.
                #[serde(skip_serializing_if = "std::option::Option::is_none")]
                #[serde_as(as = "std::option::Option<wkt::internal::F32>")]
                pub average_client_sentiment_score: std::option::Option<f32>,

                /// The average customer satisfaction rating.
                #[serde(skip_serializing_if = "std::option::Option::is_none")]
                #[serde_as(as = "std::option::Option<wkt::internal::F64>")]
                pub average_customer_satisfaction_rating: std::option::Option<f64>,

                /// Average QA normalized score.
                /// Will exclude 0's in average calculation.
                #[serde(skip_serializing_if = "std::option::Option::is_none")]
                #[serde_as(as = "std::option::Option<wkt::internal::F64>")]
                pub average_qa_normalized_score: std::option::Option<f64>,

                /// Average QA normalized score for all the tags.
                #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                pub qa_tag_scores: std::vec::Vec<crate::model::query_metrics_response::slice::data_point::conversation_measure::QaTagScore>,

                /// Average QA normalized score averaged for questions averaged across
                /// all revisions of the parent scorecard.
                /// Will be only populated if the request specifies a dimension of
                /// QA_QUESTION_ID.
                #[serde(skip_serializing_if = "std::option::Option::is_none")]
                #[serde_as(as = "std::option::Option<wkt::internal::F64>")]
                pub average_qa_question_normalized_score: std::option::Option<f64>,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl ConversationMeasure {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [conversation_count][crate::model::query_metrics_response::slice::data_point::ConversationMeasure::conversation_count].
                pub fn set_conversation_count<T: std::convert::Into<std::option::Option<i32>>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.conversation_count = v.into();
                    self
                }

                /// Sets the value of [average_silence_percentage][crate::model::query_metrics_response::slice::data_point::ConversationMeasure::average_silence_percentage].
                pub fn set_average_silence_percentage<
                    T: std::convert::Into<std::option::Option<f32>>,
                >(
                    mut self,
                    v: T,
                ) -> Self {
                    self.average_silence_percentage = v.into();
                    self
                }

                /// Sets the value of [average_duration][crate::model::query_metrics_response::slice::data_point::ConversationMeasure::average_duration].
                pub fn set_average_duration<
                    T: std::convert::Into<std::option::Option<wkt::Duration>>,
                >(
                    mut self,
                    v: T,
                ) -> Self {
                    self.average_duration = v.into();
                    self
                }

                /// Sets the value of [average_turn_count][crate::model::query_metrics_response::slice::data_point::ConversationMeasure::average_turn_count].
                pub fn set_average_turn_count<T: std::convert::Into<std::option::Option<f32>>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.average_turn_count = v.into();
                    self
                }

                /// Sets the value of [average_agent_sentiment_score][crate::model::query_metrics_response::slice::data_point::ConversationMeasure::average_agent_sentiment_score].
                pub fn set_average_agent_sentiment_score<
                    T: std::convert::Into<std::option::Option<f32>>,
                >(
                    mut self,
                    v: T,
                ) -> Self {
                    self.average_agent_sentiment_score = v.into();
                    self
                }

                /// Sets the value of [average_client_sentiment_score][crate::model::query_metrics_response::slice::data_point::ConversationMeasure::average_client_sentiment_score].
                pub fn set_average_client_sentiment_score<
                    T: std::convert::Into<std::option::Option<f32>>,
                >(
                    mut self,
                    v: T,
                ) -> Self {
                    self.average_client_sentiment_score = v.into();
                    self
                }

                /// Sets the value of [average_customer_satisfaction_rating][crate::model::query_metrics_response::slice::data_point::ConversationMeasure::average_customer_satisfaction_rating].
                pub fn set_average_customer_satisfaction_rating<
                    T: std::convert::Into<std::option::Option<f64>>,
                >(
                    mut self,
                    v: T,
                ) -> Self {
                    self.average_customer_satisfaction_rating = v.into();
                    self
                }

                /// Sets the value of [average_qa_normalized_score][crate::model::query_metrics_response::slice::data_point::ConversationMeasure::average_qa_normalized_score].
                pub fn set_average_qa_normalized_score<
                    T: std::convert::Into<std::option::Option<f64>>,
                >(
                    mut self,
                    v: T,
                ) -> Self {
                    self.average_qa_normalized_score = v.into();
                    self
                }

                /// Sets the value of [qa_tag_scores][crate::model::query_metrics_response::slice::data_point::ConversationMeasure::qa_tag_scores].
                pub fn set_qa_tag_scores<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<crate::model::query_metrics_response::slice::data_point::conversation_measure::QaTagScore>
                {
                    use std::iter::Iterator;
                    self.qa_tag_scores = v.into_iter().map(|i| i.into()).collect();
                    self
                }

                /// Sets the value of [average_qa_question_normalized_score][crate::model::query_metrics_response::slice::data_point::ConversationMeasure::average_qa_question_normalized_score].
                pub fn set_average_qa_question_normalized_score<
                    T: std::convert::Into<std::option::Option<f64>>,
                >(
                    mut self,
                    v: T,
                ) -> Self {
                    self.average_qa_question_normalized_score = v.into();
                    self
                }
            }

            impl wkt::message::Message for ConversationMeasure {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.contactcenterinsights.v1.QueryMetricsResponse.Slice.DataPoint.ConversationMeasure"
                }
            }

            /// Defines additional types related to [ConversationMeasure].
            pub mod conversation_measure {
                #[allow(unused_imports)]
                use super::*;

                /// Average QA normalized score for the tag.
                #[serde_with::serde_as]
                #[derive(
                    Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize,
                )]
                #[serde(default, rename_all = "camelCase")]
                #[non_exhaustive]
                pub struct QaTagScore {
                    /// Tag name.
                    #[serde(skip_serializing_if = "std::string::String::is_empty")]
                    pub tag: std::string::String,

                    /// Average tag normalized score per tag.
                    #[serde(skip_serializing_if = "wkt::internal::is_default")]
                    #[serde_as(as = "wkt::internal::F64")]
                    pub average_tag_normalized_score: f64,

                    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
                }

                impl QaTagScore {
                    pub fn new() -> Self {
                        std::default::Default::default()
                    }

                    /// Sets the value of [tag][crate::model::query_metrics_response::slice::data_point::conversation_measure::QaTagScore::tag].
                    pub fn set_tag<T: std::convert::Into<std::string::String>>(
                        mut self,
                        v: T,
                    ) -> Self {
                        self.tag = v.into();
                        self
                    }

                    /// Sets the value of [average_tag_normalized_score][crate::model::query_metrics_response::slice::data_point::conversation_measure::QaTagScore::average_tag_normalized_score].
                    pub fn set_average_tag_normalized_score<T: std::convert::Into<f64>>(
                        mut self,
                        v: T,
                    ) -> Self {
                        self.average_tag_normalized_score = v.into();
                        self
                    }
                }

                impl wkt::message::Message for QaTagScore {
                    fn typename() -> &'static str {
                        "type.googleapis.com/google.cloud.contactcenterinsights.v1.QueryMetricsResponse.Slice.DataPoint.ConversationMeasure.QaTagScore"
                    }
                }
            }

            /// The measure included in this data point.
            #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(rename_all = "camelCase")]
            #[non_exhaustive]
            pub enum Measure {
                /// The measure related to conversations.
                ConversationMeasure(std::boxed::Box<crate::model::query_metrics_response::slice::data_point::ConversationMeasure>),
            }
        }

        /// A time series of metric values.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct TimeSeries {
            /// The data points that make up the time series .
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub data_points: std::vec::Vec<crate::model::query_metrics_response::slice::DataPoint>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl TimeSeries {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [data_points][crate::model::query_metrics_response::slice::TimeSeries::data_points].
            pub fn set_data_points<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::query_metrics_response::slice::DataPoint>,
            {
                use std::iter::Iterator;
                self.data_points = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for TimeSeries {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.contactcenterinsights.v1.QueryMetricsResponse.Slice.TimeSeries"
            }
        }
    }
}

/// The metadata from querying metrics.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QueryMetricsMetadata {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QueryMetricsMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for QueryMetricsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.QueryMetricsMetadata"
    }
}

/// The request for creating a QaQuestion.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateQaQuestionRequest {
    /// Required. The parent resource of the QaQuestion.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The QaQuestion to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub qa_question: std::option::Option<crate::model::QaQuestion>,

    /// Optional. A unique ID for the new question. This ID will become the final
    /// component of the question's resource name. If no ID is specified, a
    /// server-generated ID will be used.
    ///
    /// This value should be 4-64 characters and must match the regular
    /// expression `^[a-z0-9-]{4,64}$`. Valid characters are `[a-z][0-9]-`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub qa_question_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateQaQuestionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateQaQuestionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [qa_question][crate::model::CreateQaQuestionRequest::qa_question].
    pub fn set_qa_question<T: std::convert::Into<std::option::Option<crate::model::QaQuestion>>>(
        mut self,
        v: T,
    ) -> Self {
        self.qa_question = v.into();
        self
    }

    /// Sets the value of [qa_question_id][crate::model::CreateQaQuestionRequest::qa_question_id].
    pub fn set_qa_question_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.qa_question_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateQaQuestionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.CreateQaQuestionRequest"
    }
}

/// The request for a QaQuestion.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetQaQuestionRequest {
    /// Required. The name of the QaQuestion to get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetQaQuestionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetQaQuestionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetQaQuestionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.GetQaQuestionRequest"
    }
}

/// Request to list QaQuestions.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListQaQuestionsRequest {
    /// Required. The parent resource of the questions.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of questions to return in the response. If the
    /// value is zero, the service will select a default size. A call might return
    /// fewer objects than requested. A non-empty `next_page_token` in the response
    /// indicates that more data is available.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. The value returned by the last `ListQaQuestionsResponse`. This
    /// value indicates that this is a continuation of a prior `ListQaQuestions`
    /// call and that the system should return the next page of data.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListQaQuestionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListQaQuestionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListQaQuestionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListQaQuestionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListQaQuestionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ListQaQuestionsRequest"
    }
}

/// The response from a ListQaQuestions request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListQaQuestionsResponse {
    /// The QaQuestions under the parent.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub qa_questions: std::vec::Vec<crate::model::QaQuestion>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListQaQuestionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [qa_questions][crate::model::ListQaQuestionsResponse::qa_questions].
    pub fn set_qa_questions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::QaQuestion>,
    {
        use std::iter::Iterator;
        self.qa_questions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListQaQuestionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListQaQuestionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ListQaQuestionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListQaQuestionsResponse {
    type PageItem = crate::model::QaQuestion;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.qa_questions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request for updating a QaQuestion.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateQaQuestionRequest {
    /// Required. The QaQuestion to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub qa_question: std::option::Option<crate::model::QaQuestion>,

    /// Required. The list of fields to be updated. All possible fields can be
    /// updated by passing `*`, or a subset of the following updateable fields can
    /// be provided:
    ///
    /// * `abbreviation`
    /// * `answer_choices`
    /// * `answer_instructions`
    /// * `order`
    /// * `question_body`
    /// * `tags`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateQaQuestionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [qa_question][crate::model::UpdateQaQuestionRequest::qa_question].
    pub fn set_qa_question<T: std::convert::Into<std::option::Option<crate::model::QaQuestion>>>(
        mut self,
        v: T,
    ) -> Self {
        self.qa_question = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateQaQuestionRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateQaQuestionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.UpdateQaQuestionRequest"
    }
}

/// The request for deleting a QaQuestion.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteQaQuestionRequest {
    /// Required. The name of the QaQuestion to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteQaQuestionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteQaQuestionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteQaQuestionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.DeleteQaQuestionRequest"
    }
}

/// The request for creating a QaScorecard.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateQaScorecardRequest {
    /// Required. The parent resource of the QaScorecard.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The QaScorecard to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub qa_scorecard: std::option::Option<crate::model::QaScorecard>,

    /// Optional. A unique ID for the new QaScorecard. This ID will become the
    /// final component of the QaScorecard's resource name. If no ID is specified,
    /// a server-generated ID will be used.
    ///
    /// This value should be 4-64 characters and must match the regular
    /// expression `^[a-z0-9-]{4,64}$`. Valid characters are `[a-z][0-9]-`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub qa_scorecard_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateQaScorecardRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateQaScorecardRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [qa_scorecard][crate::model::CreateQaScorecardRequest::qa_scorecard].
    pub fn set_qa_scorecard<
        T: std::convert::Into<std::option::Option<crate::model::QaScorecard>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.qa_scorecard = v.into();
        self
    }

    /// Sets the value of [qa_scorecard_id][crate::model::CreateQaScorecardRequest::qa_scorecard_id].
    pub fn set_qa_scorecard_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.qa_scorecard_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateQaScorecardRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.CreateQaScorecardRequest"
    }
}

/// The request for a QaScorecard. By default, returns the latest revision.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetQaScorecardRequest {
    /// Required. The name of the QaScorecard to get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetQaScorecardRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetQaScorecardRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetQaScorecardRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.GetQaScorecardRequest"
    }
}

/// The request for updating a QaScorecard.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateQaScorecardRequest {
    /// Required. The QaScorecard to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub qa_scorecard: std::option::Option<crate::model::QaScorecard>,

    /// Required. The list of fields to be updated. All possible fields can be
    /// updated by passing `*`, or a subset of the following updateable fields can
    /// be provided:
    ///
    /// * `description`
    /// * `display_name`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateQaScorecardRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [qa_scorecard][crate::model::UpdateQaScorecardRequest::qa_scorecard].
    pub fn set_qa_scorecard<
        T: std::convert::Into<std::option::Option<crate::model::QaScorecard>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.qa_scorecard = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateQaScorecardRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateQaScorecardRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.UpdateQaScorecardRequest"
    }
}

/// The request for deleting a QaScorecard.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteQaScorecardRequest {
    /// Required. The name of the QaScorecard to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. If set to true, all of this QaScorecard's child resources will
    /// also be deleted. Otherwise, the request will only succeed if it has none.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub force: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteQaScorecardRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteQaScorecardRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteQaScorecardRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteQaScorecardRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.DeleteQaScorecardRequest"
    }
}

/// The request for creating a QaScorecardRevision.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateQaScorecardRevisionRequest {
    /// Required. The parent resource of the QaScorecardRevision.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The QaScorecardRevision to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub qa_scorecard_revision: std::option::Option<crate::model::QaScorecardRevision>,

    /// Optional. A unique ID for the new QaScorecardRevision. This ID will become
    /// the final component of the QaScorecardRevision's resource name. If no ID is
    /// specified, a server-generated ID will be used.
    ///
    /// This value should be 4-64 characters and must match the regular
    /// expression `^[a-z0-9-]{4,64}$`. Valid characters are `[a-z][0-9]-`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub qa_scorecard_revision_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateQaScorecardRevisionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateQaScorecardRevisionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [qa_scorecard_revision][crate::model::CreateQaScorecardRevisionRequest::qa_scorecard_revision].
    pub fn set_qa_scorecard_revision<
        T: std::convert::Into<std::option::Option<crate::model::QaScorecardRevision>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.qa_scorecard_revision = v.into();
        self
    }

    /// Sets the value of [qa_scorecard_revision_id][crate::model::CreateQaScorecardRevisionRequest::qa_scorecard_revision_id].
    pub fn set_qa_scorecard_revision_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.qa_scorecard_revision_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateQaScorecardRevisionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.CreateQaScorecardRevisionRequest"
    }
}

/// The request for a QaScorecardRevision.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetQaScorecardRevisionRequest {
    /// Required. The name of the QaScorecardRevision to get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetQaScorecardRevisionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetQaScorecardRevisionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetQaScorecardRevisionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.GetQaScorecardRevisionRequest"
    }
}

/// Request for TuneQaScorecardRevision endpoint.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TuneQaScorecardRevisionRequest {
    /// Required. The parent resource for new fine tuning job instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Filter for selecting the feedback labels that needs to be
    /// used for training.
    /// This filter can be used to limit the feedback labels used for tuning to a
    /// feedback labels created or updated for a specific time-window etc.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Run in validate only mode, no fine tuning will actually run.
    /// Data quality validations like training data distributions will run.
    /// Even when set to false, the data quality validations will still run but
    /// once the validations complete we will proceed with the fine tune, if
    /// applicable.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TuneQaScorecardRevisionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::TuneQaScorecardRevisionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::TuneQaScorecardRevisionRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::TuneQaScorecardRevisionRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for TuneQaScorecardRevisionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.TuneQaScorecardRevisionRequest"
    }
}

/// Response for TuneQaScorecardRevision endpoint.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TuneQaScorecardRevisionResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TuneQaScorecardRevisionResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for TuneQaScorecardRevisionResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.TuneQaScorecardRevisionResponse"
    }
}

/// Metadata for TuneQaScorecardRevision endpoint.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TuneQaScorecardRevisionMetadata {
    /// Output only. The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The original request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub request: std::option::Option<crate::model::TuneQaScorecardRevisionRequest>,

    /// Output only. The results of data validation per question in the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub qa_question_dataset_validation_results: std::vec::Vec<
        crate::model::tune_qa_scorecard_revision_metadata::QaQuestionDatasetValidationResult,
    >,

    /// Output only. The metrics for each QaQuestion in the TuneScorecardRevision
    /// request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub qa_question_dataset_tuning_metrics: std::vec::Vec<
        crate::model::tune_qa_scorecard_revision_metadata::QaQuestionDatasetTuningMetrics,
    >,

    /// Output only. The percentage of the tuning job that has completed. Always
    /// between 0 and 1 where 0 indicates the job has not started i.e. 0% and 1
    /// indicates the job has completed i.e. 100%.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F64")]
    pub tuning_completion_ratio: f64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TuneQaScorecardRevisionMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::TuneQaScorecardRevisionMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::TuneQaScorecardRevisionMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [request][crate::model::TuneQaScorecardRevisionMetadata::request].
    pub fn set_request<
        T: std::convert::Into<std::option::Option<crate::model::TuneQaScorecardRevisionRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = v.into();
        self
    }

    /// Sets the value of [qa_question_dataset_validation_results][crate::model::TuneQaScorecardRevisionMetadata::qa_question_dataset_validation_results].
    pub fn set_qa_question_dataset_validation_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::tune_qa_scorecard_revision_metadata::QaQuestionDatasetValidationResult>
    {
        use std::iter::Iterator;
        self.qa_question_dataset_validation_results = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [qa_question_dataset_tuning_metrics][crate::model::TuneQaScorecardRevisionMetadata::qa_question_dataset_tuning_metrics].
    pub fn set_qa_question_dataset_tuning_metrics<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<
                crate::model::tune_qa_scorecard_revision_metadata::QaQuestionDatasetTuningMetrics,
            >,
    {
        use std::iter::Iterator;
        self.qa_question_dataset_tuning_metrics = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [tuning_completion_ratio][crate::model::TuneQaScorecardRevisionMetadata::tuning_completion_ratio].
    pub fn set_tuning_completion_ratio<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.tuning_completion_ratio = v.into();
        self
    }
}

impl wkt::message::Message for TuneQaScorecardRevisionMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.TuneQaScorecardRevisionMetadata"
    }
}

/// Defines additional types related to [TuneQaScorecardRevisionMetadata].
pub mod tune_qa_scorecard_revision_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Contains validation results for a question in the tuning request.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct QaQuestionDatasetValidationResult {
        /// Output only. The resource path of the question whose dataset was
        /// evaluated for tuning.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub question: std::string::String,

        /// A list of any applicable data validation warnings about the question's
        /// feedback labels.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub dataset_validation_warnings: std::vec::Vec<crate::model::DatasetValidationWarning>,

        /// The number of valid feedback labels in the question's dataset.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub valid_feedback_labels_count: i32,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl QaQuestionDatasetValidationResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [question][crate::model::tune_qa_scorecard_revision_metadata::QaQuestionDatasetValidationResult::question].
        pub fn set_question<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.question = v.into();
            self
        }

        /// Sets the value of [dataset_validation_warnings][crate::model::tune_qa_scorecard_revision_metadata::QaQuestionDatasetValidationResult::dataset_validation_warnings].
        pub fn set_dataset_validation_warnings<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::DatasetValidationWarning>,
        {
            use std::iter::Iterator;
            self.dataset_validation_warnings = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [valid_feedback_labels_count][crate::model::tune_qa_scorecard_revision_metadata::QaQuestionDatasetValidationResult::valid_feedback_labels_count].
        pub fn set_valid_feedback_labels_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.valid_feedback_labels_count = v.into();
            self
        }
    }

    impl wkt::message::Message for QaQuestionDatasetValidationResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.TuneQaScorecardRevisionMetadata.QaQuestionDatasetValidationResult"
        }
    }

    /// Contains performance metrics for each QaQuestion in the
    /// TuneScorecardRevision request.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct QaQuestionDatasetTuningMetrics {

        /// Output only. The resource path of the question whose dataset was
        /// evaluated for tuning.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub question: std::string::String,

        /// Output only. The metrics for the question's dataset.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub metrics: std::option::Option<crate::model::tune_qa_scorecard_revision_metadata::qa_question_dataset_tuning_metrics::Metrics>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl QaQuestionDatasetTuningMetrics {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [question][crate::model::tune_qa_scorecard_revision_metadata::QaQuestionDatasetTuningMetrics::question].
        pub fn set_question<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.question = v.into();
            self
        }

        /// Sets the value of [metrics][crate::model::tune_qa_scorecard_revision_metadata::QaQuestionDatasetTuningMetrics::metrics].
        pub fn set_metrics<T: std::convert::Into<std::option::Option<crate::model::tune_qa_scorecard_revision_metadata::qa_question_dataset_tuning_metrics::Metrics>>>(mut self, v: T) -> Self{
            self.metrics = v.into();
            self
        }
    }

    impl wkt::message::Message for QaQuestionDatasetTuningMetrics {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.TuneQaScorecardRevisionMetadata.QaQuestionDatasetTuningMetrics"
        }
    }

    /// Defines additional types related to [QaQuestionDatasetTuningMetrics].
    pub mod qa_question_dataset_tuning_metrics {
        #[allow(unused_imports)]
        use super::*;

        /// Performance metrics for the question's dataset calculated over the tuned
        /// model.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Metrics {
            /// Accuracy of the question's dataset.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "wkt::internal::F64")]
            pub accuracy: f64,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Metrics {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [accuracy][crate::model::tune_qa_scorecard_revision_metadata::qa_question_dataset_tuning_metrics::Metrics::accuracy].
            pub fn set_accuracy<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                self.accuracy = v.into();
                self
            }
        }

        impl wkt::message::Message for Metrics {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.contactcenterinsights.v1.TuneQaScorecardRevisionMetadata.QaQuestionDatasetTuningMetrics.Metrics"
            }
        }
    }
}

/// The request to deploy a QaScorecardRevision
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeployQaScorecardRevisionRequest {
    /// Required. The name of the QaScorecardRevision to deploy.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeployQaScorecardRevisionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeployQaScorecardRevisionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeployQaScorecardRevisionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.DeployQaScorecardRevisionRequest"
    }
}

/// The request to undeploy a QaScorecardRevision
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UndeployQaScorecardRevisionRequest {
    /// Required. The name of the QaScorecardRevision to undeploy.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UndeployQaScorecardRevisionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UndeployQaScorecardRevisionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for UndeployQaScorecardRevisionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.UndeployQaScorecardRevisionRequest"
    }
}

/// The request to delete a QaScorecardRevision.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteQaScorecardRevisionRequest {
    /// Required. The name of the QaScorecardRevision to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. If set to true, all of this QaScorecardRevision's child resources
    /// will also be deleted. Otherwise, the request will only succeed if it has
    /// none.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub force: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteQaScorecardRevisionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteQaScorecardRevisionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteQaScorecardRevisionRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteQaScorecardRevisionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.DeleteQaScorecardRevisionRequest"
    }
}

/// Request to list QaScorecards.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListQaScorecardsRequest {
    /// Required. The parent resource of the scorecards.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of scorecards to return in the response. If
    /// the value is zero, the service will select a default size. A call might
    /// return fewer objects than requested. A non-empty `next_page_token` in the
    /// response indicates that more data is available.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. The value returned by the last `ListQaScorecardsResponse`. This
    /// value indicates that this is a continuation of a prior `ListQaScorecards`
    /// call and that the system should return the next page of data.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListQaScorecardsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListQaScorecardsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListQaScorecardsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListQaScorecardsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListQaScorecardsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ListQaScorecardsRequest"
    }
}

/// The response from a ListQaScorecards request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListQaScorecardsResponse {
    /// The QaScorecards under the parent.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub qa_scorecards: std::vec::Vec<crate::model::QaScorecard>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListQaScorecardsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [qa_scorecards][crate::model::ListQaScorecardsResponse::qa_scorecards].
    pub fn set_qa_scorecards<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::QaScorecard>,
    {
        use std::iter::Iterator;
        self.qa_scorecards = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListQaScorecardsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListQaScorecardsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ListQaScorecardsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListQaScorecardsResponse {
    type PageItem = crate::model::QaScorecard;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.qa_scorecards
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request to list QaScorecardRevisions
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListQaScorecardRevisionsRequest {
    /// Required. The parent resource of the scorecard revisions. To list all
    /// revisions of all scorecards, substitute the QaScorecard ID with a '-'
    /// character.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of scorecard revisions to return in the
    /// response. If the value is zero, the service will select a default size. A
    /// call might return fewer objects than requested. A non-empty
    /// `next_page_token` in the response indicates that more data is available.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. The value returned by the last
    /// `ListQaScorecardRevisionsResponse`. This value indicates that this is a
    /// continuation of a prior `ListQaScorecardRevisions` call and that the system
    /// should return the next page of data.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. A filter to reduce results to a specific subset. Useful for
    /// querying scorecard revisions with specific properties.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListQaScorecardRevisionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListQaScorecardRevisionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListQaScorecardRevisionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListQaScorecardRevisionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListQaScorecardRevisionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListQaScorecardRevisionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ListQaScorecardRevisionsRequest"
    }
}

/// The response from a ListQaScorecardRevisions request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListQaScorecardRevisionsResponse {
    /// The QaScorecards under the parent.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub qa_scorecard_revisions: std::vec::Vec<crate::model::QaScorecardRevision>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListQaScorecardRevisionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [qa_scorecard_revisions][crate::model::ListQaScorecardRevisionsResponse::qa_scorecard_revisions].
    pub fn set_qa_scorecard_revisions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::QaScorecardRevision>,
    {
        use std::iter::Iterator;
        self.qa_scorecard_revisions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListQaScorecardRevisionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListQaScorecardRevisionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ListQaScorecardRevisionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListQaScorecardRevisionsResponse {
    type PageItem = crate::model::QaScorecardRevision;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.qa_scorecard_revisions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request for creating a feedback label.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateFeedbackLabelRequest {
    /// Required. The parent resource of the feedback label.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The ID of the feedback label to create.
    /// If one is not specified it will be generated by the server.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub feedback_label_id: std::string::String,

    /// Required. The feedback label to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub feedback_label: std::option::Option<crate::model::FeedbackLabel>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateFeedbackLabelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateFeedbackLabelRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [feedback_label_id][crate::model::CreateFeedbackLabelRequest::feedback_label_id].
    pub fn set_feedback_label_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.feedback_label_id = v.into();
        self
    }

    /// Sets the value of [feedback_label][crate::model::CreateFeedbackLabelRequest::feedback_label].
    pub fn set_feedback_label<
        T: std::convert::Into<std::option::Option<crate::model::FeedbackLabel>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.feedback_label = v.into();
        self
    }
}

impl wkt::message::Message for CreateFeedbackLabelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.CreateFeedbackLabelRequest"
    }
}

/// The request for listing feedback labels.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFeedbackLabelsRequest {
    /// Required. The parent resource of the feedback labels.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. A filter to reduce results to a specific subset. Supports
    /// disjunctions (OR) and conjunctions (AND). Automatically sorts by
    /// conversation ID. To sort by all feedback labels in a project see
    /// ListAllFeedbackLabels.
    ///
    /// Supported fields:
    ///
    /// * `issue_model_id`
    /// * `qa_question_id`
    /// * `qa_scorecard_id`
    /// * `min_create_time`
    /// * `max_create_time`
    /// * `min_update_time`
    /// * `max_update_time`
    /// * `feedback_label_type`: QUALITY_AI, TOPIC_MODELING
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. The maximum number of feedback labels to return in the response.
    /// A valid page size ranges from 0 to 100,000 inclusive. If the page size is
    /// zero or unspecified, a default page size of 100 will be chosen. Note that a
    /// call might return fewer results than the requested page size.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. The value returned by the last `ListFeedbackLabelsResponse`. This
    /// value indicates that this is a continuation of a prior `ListFeedbackLabels`
    /// call and that the system should return the next page of data.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListFeedbackLabelsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListFeedbackLabelsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListFeedbackLabelsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListFeedbackLabelsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListFeedbackLabelsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListFeedbackLabelsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ListFeedbackLabelsRequest"
    }
}

/// The response for listing feedback labels.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListFeedbackLabelsResponse {
    /// The feedback labels that match the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub feedback_labels: std::vec::Vec<crate::model::FeedbackLabel>,

    /// The next page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListFeedbackLabelsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [feedback_labels][crate::model::ListFeedbackLabelsResponse::feedback_labels].
    pub fn set_feedback_labels<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FeedbackLabel>,
    {
        use std::iter::Iterator;
        self.feedback_labels = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListFeedbackLabelsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListFeedbackLabelsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ListFeedbackLabelsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListFeedbackLabelsResponse {
    type PageItem = crate::model::FeedbackLabel;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.feedback_labels
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request for getting a feedback label.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetFeedbackLabelRequest {
    /// Required. The name of the feedback label to get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetFeedbackLabelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetFeedbackLabelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetFeedbackLabelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.GetFeedbackLabelRequest"
    }
}

/// The request for updating a feedback label.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateFeedbackLabelRequest {
    /// Required. The feedback label to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub feedback_label: std::option::Option<crate::model::FeedbackLabel>,

    /// Required. The list of fields to be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateFeedbackLabelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [feedback_label][crate::model::UpdateFeedbackLabelRequest::feedback_label].
    pub fn set_feedback_label<
        T: std::convert::Into<std::option::Option<crate::model::FeedbackLabel>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.feedback_label = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateFeedbackLabelRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateFeedbackLabelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.UpdateFeedbackLabelRequest"
    }
}

/// The request for deleting a feedback label.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteFeedbackLabelRequest {
    /// Required. The name of the feedback label to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteFeedbackLabelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteFeedbackLabelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteFeedbackLabelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.DeleteFeedbackLabelRequest"
    }
}

/// The request for listing all feedback labels.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAllFeedbackLabelsRequest {
    /// Required. The parent resource of all feedback labels per project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of feedback labels to return in the response.
    /// A valid page size ranges from 0 to 100,000 inclusive. If the page size is
    /// zero or unspecified, a default page size of 100 will be chosen. Note that a
    /// call might return fewer results than the requested page size.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. The value returned by the last `ListAllFeedbackLabelsResponse`.
    /// This value indicates that this is a continuation of a prior
    /// `ListAllFeedbackLabels` call and that the system should return the next
    /// page of data.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. A filter to reduce results to a specific subset in the entire
    /// project. Supports disjunctions (OR) and conjunctions (AND).
    ///
    /// Supported fields:
    ///
    /// * `issue_model_id`
    /// * `qa_question_id`
    /// * `min_create_time`
    /// * `max_create_time`
    /// * `min_update_time`
    /// * `max_update_time`
    /// * `feedback_label_type`: QUALITY_AI, TOPIC_MODELING
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAllFeedbackLabelsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAllFeedbackLabelsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAllFeedbackLabelsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAllFeedbackLabelsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListAllFeedbackLabelsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListAllFeedbackLabelsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ListAllFeedbackLabelsRequest"
    }
}

/// The response for listing all feedback labels.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAllFeedbackLabelsResponse {
    /// The feedback labels that match the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub feedback_labels: std::vec::Vec<crate::model::FeedbackLabel>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAllFeedbackLabelsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [feedback_labels][crate::model::ListAllFeedbackLabelsResponse::feedback_labels].
    pub fn set_feedback_labels<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FeedbackLabel>,
    {
        use std::iter::Iterator;
        self.feedback_labels = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAllFeedbackLabelsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAllFeedbackLabelsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ListAllFeedbackLabelsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAllFeedbackLabelsResponse {
    type PageItem = crate::model::FeedbackLabel;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.feedback_labels
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request for bulk uploading feedback labels.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BulkUploadFeedbackLabelsRequest {
    /// Required. The parent resource for new feedback labels.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. If set, upload will not happen and the labels will be validated.
    /// If not set, then default behavior will be to upload the labels after
    /// validation is complete.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    /// Configuration for an external data store containing objects that will
    /// be converted to FeedbackLabels.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::bulk_upload_feedback_labels_request::Source>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BulkUploadFeedbackLabelsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BulkUploadFeedbackLabelsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::BulkUploadFeedbackLabelsRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [source][crate::model::BulkUploadFeedbackLabelsRequest::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<
                std::option::Option<crate::model::bulk_upload_feedback_labels_request::Source>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::BulkUploadFeedbackLabelsRequest::source]
    /// if it holds a `GcsSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_source(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::bulk_upload_feedback_labels_request::GcsSource>,
    > {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::bulk_upload_feedback_labels_request::Source::GcsSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::BulkUploadFeedbackLabelsRequest::source]
    /// to hold a `GcsSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_gcs_source<
        T: std::convert::Into<
                std::boxed::Box<crate::model::bulk_upload_feedback_labels_request::GcsSource>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::bulk_upload_feedback_labels_request::Source::GcsSource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BulkUploadFeedbackLabelsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.BulkUploadFeedbackLabelsRequest"
    }
}

/// Defines additional types related to [BulkUploadFeedbackLabelsRequest].
pub mod bulk_upload_feedback_labels_request {
    #[allow(unused_imports)]
    use super::*;

    /// Google Cloud Storage Object details to get the feedback label file from.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GcsSource {
        /// Required. File format which will be ingested.
        pub format: crate::model::bulk_upload_feedback_labels_request::gcs_source::Format,

        /// Required. The Google Cloud Storage URI of the file to import.
        /// Format: `gs://bucket_name/object_name`
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub object_uri: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GcsSource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [format][crate::model::bulk_upload_feedback_labels_request::GcsSource::format].
        pub fn set_format<
            T: std::convert::Into<
                    crate::model::bulk_upload_feedback_labels_request::gcs_source::Format,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.format = v.into();
            self
        }

        /// Sets the value of [object_uri][crate::model::bulk_upload_feedback_labels_request::GcsSource::object_uri].
        pub fn set_object_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.object_uri = v.into();
            self
        }
    }

    impl wkt::message::Message for GcsSource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.BulkUploadFeedbackLabelsRequest.GcsSource"
        }
    }

    /// Defines additional types related to [GcsSource].
    pub mod gcs_source {
        #[allow(unused_imports)]
        use super::*;

        /// All permissible file formats.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Format {
            /// Unspecified format.
            Unspecified,
            /// CSV format.
            Csv,
            /// JSON format.
            Json,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Format::value] or
            /// [Format::name].
            UnknownValue(format::UnknownValue),
        }

        #[doc(hidden)]
        pub mod format {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Format {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Csv => std::option::Option::Some(1),
                    Self::Json => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("FORMAT_UNSPECIFIED"),
                    Self::Csv => std::option::Option::Some("CSV"),
                    Self::Json => std::option::Option::Some("JSON"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Format {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Format {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Format {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Csv,
                    2 => Self::Json,
                    _ => Self::UnknownValue(format::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Format {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "FORMAT_UNSPECIFIED" => Self::Unspecified,
                    "CSV" => Self::Csv,
                    "JSON" => Self::Json,
                    _ => Self::UnknownValue(format::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Format {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Csv => serializer.serialize_i32(1),
                    Self::Json => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Format {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Format>::new(
                    ".google.cloud.contactcenterinsights.v1.BulkUploadFeedbackLabelsRequest.GcsSource.Format"))
            }
        }
    }

    /// Configuration for an external data store containing objects that will
    /// be converted to FeedbackLabels.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// A cloud storage bucket source.
        GcsSource(std::boxed::Box<crate::model::bulk_upload_feedback_labels_request::GcsSource>),
    }
}

/// Response for the Bulk Upload Feedback Labels API.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BulkUploadFeedbackLabelsResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BulkUploadFeedbackLabelsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for BulkUploadFeedbackLabelsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.BulkUploadFeedbackLabelsResponse"
    }
}

/// Metadata for the Bulk Upload Feedback Labels API.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BulkUploadFeedbackLabelsMetadata {
    /// Output only. The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The original request for ingest.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub request: std::option::Option<crate::model::BulkUploadFeedbackLabelsRequest>,

    /// Partial errors during ingest operation that might cause the operation
    /// output to be incomplete.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub partial_errors: std::vec::Vec<rpc::model::Status>,

    /// Output only. Statistics for BulkUploadFeedbackLabels operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub upload_stats:
        std::option::Option<crate::model::bulk_upload_feedback_labels_metadata::UploadStats>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BulkUploadFeedbackLabelsMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::BulkUploadFeedbackLabelsMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::BulkUploadFeedbackLabelsMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [request][crate::model::BulkUploadFeedbackLabelsMetadata::request].
    pub fn set_request<
        T: std::convert::Into<std::option::Option<crate::model::BulkUploadFeedbackLabelsRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = v.into();
        self
    }

    /// Sets the value of [partial_errors][crate::model::BulkUploadFeedbackLabelsMetadata::partial_errors].
    pub fn set_partial_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.partial_errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [upload_stats][crate::model::BulkUploadFeedbackLabelsMetadata::upload_stats].
    pub fn set_upload_stats<
        T: std::convert::Into<
                std::option::Option<
                    crate::model::bulk_upload_feedback_labels_metadata::UploadStats,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.upload_stats = v.into();
        self
    }
}

impl wkt::message::Message for BulkUploadFeedbackLabelsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.BulkUploadFeedbackLabelsMetadata"
    }
}

/// Defines additional types related to [BulkUploadFeedbackLabelsMetadata].
pub mod bulk_upload_feedback_labels_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Statistics for BulkUploadFeedbackLabels operation.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct UploadStats {
        /// The number of objects processed during the upload operation.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub processed_object_count: i32,

        /// The number of objects skipped because of failed validation
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub failed_validation_count: i32,

        /// The number of new feedback labels added during this ingest operation.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub successful_upload_count: i32,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl UploadStats {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [processed_object_count][crate::model::bulk_upload_feedback_labels_metadata::UploadStats::processed_object_count].
        pub fn set_processed_object_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.processed_object_count = v.into();
            self
        }

        /// Sets the value of [failed_validation_count][crate::model::bulk_upload_feedback_labels_metadata::UploadStats::failed_validation_count].
        pub fn set_failed_validation_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.failed_validation_count = v.into();
            self
        }

        /// Sets the value of [successful_upload_count][crate::model::bulk_upload_feedback_labels_metadata::UploadStats::successful_upload_count].
        pub fn set_successful_upload_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.successful_upload_count = v.into();
            self
        }
    }

    impl wkt::message::Message for UploadStats {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.BulkUploadFeedbackLabelsMetadata.UploadStats"
        }
    }
}

/// Request for the BulkDownloadFeedbackLabel endpoint.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BulkDownloadFeedbackLabelsRequest {
    /// Required. The parent resource for new feedback labels.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. A filter to reduce results to a specific subset. Supports
    /// disjunctions (OR) and conjunctions (AND).
    ///
    /// Supported fields:
    ///
    /// * `issue_model_id`
    /// * `qa_question_id`
    /// * `qa_scorecard_id`
    /// * `min_create_time`
    /// * `max_create_time`
    /// * `min_update_time`
    /// * `max_update_time`
    /// * `feedback_label_type`: QUALITY_AI, TOPIC_MODELING
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Limits the maximum number of feedback labels that will be
    /// downloaded. The first `N` feedback labels will be downloaded.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub max_download_count: i32,

    /// Optional. The type of feedback labels that will be downloaded.
    pub feedback_label_type: crate::model::bulk_download_feedback_labels_request::FeedbackLabelType,

    /// Optional. Filter parent conversations to download feedback labels for.
    /// When specified, the feedback labels will be downloaded for the
    /// conversations that match the filter.
    /// If `template_qa_scorecard_id` is set, all the conversations that match the
    /// filter will be paired with the questions under the scorecard for labeling.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub conversation_filter: std::string::String,

    /// Optional. If set, a template for labeling conversations and scorecard
    /// questions will be created from the conversation_filter and the questions
    /// under the scorecard(s). The feedback label `filter` will be ignored.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub template_qa_scorecard_id: std::vec::Vec<std::string::String>,

    /// Configuration for an external data store to which the feedback labels
    /// will be written to.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub destination:
        std::option::Option<crate::model::bulk_download_feedback_labels_request::Destination>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BulkDownloadFeedbackLabelsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BulkDownloadFeedbackLabelsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::BulkDownloadFeedbackLabelsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [max_download_count][crate::model::BulkDownloadFeedbackLabelsRequest::max_download_count].
    pub fn set_max_download_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_download_count = v.into();
        self
    }

    /// Sets the value of [feedback_label_type][crate::model::BulkDownloadFeedbackLabelsRequest::feedback_label_type].
    pub fn set_feedback_label_type<
        T: std::convert::Into<crate::model::bulk_download_feedback_labels_request::FeedbackLabelType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.feedback_label_type = v.into();
        self
    }

    /// Sets the value of [conversation_filter][crate::model::BulkDownloadFeedbackLabelsRequest::conversation_filter].
    pub fn set_conversation_filter<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.conversation_filter = v.into();
        self
    }

    /// Sets the value of [template_qa_scorecard_id][crate::model::BulkDownloadFeedbackLabelsRequest::template_qa_scorecard_id].
    pub fn set_template_qa_scorecard_id<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.template_qa_scorecard_id = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [destination][crate::model::BulkDownloadFeedbackLabelsRequest::destination].
    ///
    /// Note that all the setters affecting `destination` are mutually
    /// exclusive.
    pub fn set_destination<
        T: std::convert::Into<
                std::option::Option<
                    crate::model::bulk_download_feedback_labels_request::Destination,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::BulkDownloadFeedbackLabelsRequest::destination]
    /// if it holds a `GcsDestination`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_destination(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::bulk_download_feedback_labels_request::GcsDestination>,
    > {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::bulk_download_feedback_labels_request::Destination::GcsDestination(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::BulkDownloadFeedbackLabelsRequest::destination]
    /// to hold a `GcsDestination`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_gcs_destination<
        T: std::convert::Into<
                std::boxed::Box<
                    crate::model::bulk_download_feedback_labels_request::GcsDestination,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::bulk_download_feedback_labels_request::Destination::GcsDestination(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for BulkDownloadFeedbackLabelsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.BulkDownloadFeedbackLabelsRequest"
    }
}

/// Defines additional types related to [BulkDownloadFeedbackLabelsRequest].
pub mod bulk_download_feedback_labels_request {
    #[allow(unused_imports)]
    use super::*;

    /// Google Cloud Storage Object details to write the feedback labels to.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GcsDestination {
        /// Required. File format in which the labels will be exported.
        pub format: crate::model::bulk_download_feedback_labels_request::gcs_destination::Format,

        /// Required. The Google Cloud Storage URI to write the feedback labels to.
        /// The file name will be used as a prefix for the files written to the
        /// bucket if the output needs to be split across multiple files, otherwise
        /// it will be used as is. The file extension will be appended to the file
        /// name based on the format selected.
        /// E.g. `gs://bucket_name/object_uri_prefix`
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub object_uri: std::string::String,

        /// Optional. Add whitespace to the JSON file. Makes easier to read, but
        /// increases file size. Only applicable for JSON format.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub add_whitespace: bool,

        /// Optional. Always print fields with no presence.
        /// This is useful for printing fields that are not set, like implicit 0
        /// value or empty lists/maps. Only applicable for JSON format.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub always_print_empty_fields: bool,

        /// Optional. The number of records per file. Applicable for either format.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub records_per_file_count: i64,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GcsDestination {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [format][crate::model::bulk_download_feedback_labels_request::GcsDestination::format].
        pub fn set_format<
            T: std::convert::Into<
                    crate::model::bulk_download_feedback_labels_request::gcs_destination::Format,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.format = v.into();
            self
        }

        /// Sets the value of [object_uri][crate::model::bulk_download_feedback_labels_request::GcsDestination::object_uri].
        pub fn set_object_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.object_uri = v.into();
            self
        }

        /// Sets the value of [add_whitespace][crate::model::bulk_download_feedback_labels_request::GcsDestination::add_whitespace].
        pub fn set_add_whitespace<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.add_whitespace = v.into();
            self
        }

        /// Sets the value of [always_print_empty_fields][crate::model::bulk_download_feedback_labels_request::GcsDestination::always_print_empty_fields].
        pub fn set_always_print_empty_fields<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.always_print_empty_fields = v.into();
            self
        }

        /// Sets the value of [records_per_file_count][crate::model::bulk_download_feedback_labels_request::GcsDestination::records_per_file_count].
        pub fn set_records_per_file_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.records_per_file_count = v.into();
            self
        }
    }

    impl wkt::message::Message for GcsDestination {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.BulkDownloadFeedbackLabelsRequest.GcsDestination"
        }
    }

    /// Defines additional types related to [GcsDestination].
    pub mod gcs_destination {
        #[allow(unused_imports)]
        use super::*;

        /// All permissible file formats.
        /// See `records_per_file_count` to override the default number of records
        /// per file.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Format {
            /// Unspecified format.
            Unspecified,
            /// CSV format.
            /// 1,000 labels are stored per CSV file by default.
            Csv,
            /// JSON format.
            /// 1 label stored per JSON file by default.
            Json,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Format::value] or
            /// [Format::name].
            UnknownValue(format::UnknownValue),
        }

        #[doc(hidden)]
        pub mod format {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Format {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Csv => std::option::Option::Some(1),
                    Self::Json => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("FORMAT_UNSPECIFIED"),
                    Self::Csv => std::option::Option::Some("CSV"),
                    Self::Json => std::option::Option::Some("JSON"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Format {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Format {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Format {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Csv,
                    2 => Self::Json,
                    _ => Self::UnknownValue(format::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Format {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "FORMAT_UNSPECIFIED" => Self::Unspecified,
                    "CSV" => Self::Csv,
                    "JSON" => Self::Json,
                    _ => Self::UnknownValue(format::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Format {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Csv => serializer.serialize_i32(1),
                    Self::Json => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Format {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Format>::new(
                    ".google.cloud.contactcenterinsights.v1.BulkDownloadFeedbackLabelsRequest.GcsDestination.Format"))
            }
        }
    }

    /// Possible feedback label types that will be downloaded.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum FeedbackLabelType {
        /// Unspecified format
        Unspecified,
        /// Downloaded file will contain all Quality AI labels from the latest
        /// scorecard revision.
        QualityAi,
        /// Downloaded file will contain only Topic Modeling labels.
        TopicModeling,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [FeedbackLabelType::value] or
        /// [FeedbackLabelType::name].
        UnknownValue(feedback_label_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod feedback_label_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl FeedbackLabelType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::QualityAi => std::option::Option::Some(1),
                Self::TopicModeling => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("FEEDBACK_LABEL_TYPE_UNSPECIFIED"),
                Self::QualityAi => std::option::Option::Some("QUALITY_AI"),
                Self::TopicModeling => std::option::Option::Some("TOPIC_MODELING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for FeedbackLabelType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for FeedbackLabelType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for FeedbackLabelType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::QualityAi,
                2 => Self::TopicModeling,
                _ => Self::UnknownValue(feedback_label_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for FeedbackLabelType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FEEDBACK_LABEL_TYPE_UNSPECIFIED" => Self::Unspecified,
                "QUALITY_AI" => Self::QualityAi,
                "TOPIC_MODELING" => Self::TopicModeling,
                _ => Self::UnknownValue(feedback_label_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for FeedbackLabelType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::QualityAi => serializer.serialize_i32(1),
                Self::TopicModeling => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for FeedbackLabelType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<FeedbackLabelType>::new(
                ".google.cloud.contactcenterinsights.v1.BulkDownloadFeedbackLabelsRequest.FeedbackLabelType"))
        }
    }

    /// Configuration for an external data store to which the feedback labels
    /// will be written to.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Destination {
        /// A cloud storage bucket destination.
        GcsDestination(
            std::boxed::Box<crate::model::bulk_download_feedback_labels_request::GcsDestination>,
        ),
    }
}

/// Response for the BulkDownloadFeedbackLabel endpoint.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BulkDownloadFeedbackLabelsResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BulkDownloadFeedbackLabelsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for BulkDownloadFeedbackLabelsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.BulkDownloadFeedbackLabelsResponse"
    }
}

/// Metadata for the BulkDownloadFeedbackLabel endpoint.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BulkDownloadFeedbackLabelsMetadata {
    /// Output only. The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The original request for download.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub request: std::option::Option<crate::model::BulkDownloadFeedbackLabelsRequest>,

    /// Partial errors during ingest operation that might cause the operation
    /// output to be incomplete.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub partial_errors: std::vec::Vec<rpc::model::Status>,

    /// Output only. Statistics for BulkDownloadFeedbackLabels operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub download_stats:
        std::option::Option<crate::model::bulk_download_feedback_labels_metadata::DownloadStats>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BulkDownloadFeedbackLabelsMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::BulkDownloadFeedbackLabelsMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::BulkDownloadFeedbackLabelsMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [request][crate::model::BulkDownloadFeedbackLabelsMetadata::request].
    pub fn set_request<
        T: std::convert::Into<std::option::Option<crate::model::BulkDownloadFeedbackLabelsRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = v.into();
        self
    }

    /// Sets the value of [partial_errors][crate::model::BulkDownloadFeedbackLabelsMetadata::partial_errors].
    pub fn set_partial_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.partial_errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [download_stats][crate::model::BulkDownloadFeedbackLabelsMetadata::download_stats].
    pub fn set_download_stats<
        T: std::convert::Into<
                std::option::Option<
                    crate::model::bulk_download_feedback_labels_metadata::DownloadStats,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.download_stats = v.into();
        self
    }
}

impl wkt::message::Message for BulkDownloadFeedbackLabelsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.BulkDownloadFeedbackLabelsMetadata"
    }
}

/// Defines additional types related to [BulkDownloadFeedbackLabelsMetadata].
pub mod bulk_download_feedback_labels_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Statistics for BulkDownloadFeedbackLabels operation.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DownloadStats {
        /// The number of objects processed during the download operation.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub processed_object_count: i32,

        /// The number of new feedback labels downloaded during this operation.
        /// Different from "processed" because some labels might not be downloaded
        /// because an error.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub successful_download_count: i32,

        /// Total number of files written to the provided Cloud Storage bucket.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub total_files_written: i32,

        /// Output only. Full name of the files written to Cloud storage.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub file_names: std::vec::Vec<std::string::String>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DownloadStats {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [processed_object_count][crate::model::bulk_download_feedback_labels_metadata::DownloadStats::processed_object_count].
        pub fn set_processed_object_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.processed_object_count = v.into();
            self
        }

        /// Sets the value of [successful_download_count][crate::model::bulk_download_feedback_labels_metadata::DownloadStats::successful_download_count].
        pub fn set_successful_download_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.successful_download_count = v.into();
            self
        }

        /// Sets the value of [total_files_written][crate::model::bulk_download_feedback_labels_metadata::DownloadStats::total_files_written].
        pub fn set_total_files_written<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.total_files_written = v.into();
            self
        }

        /// Sets the value of [file_names][crate::model::bulk_download_feedback_labels_metadata::DownloadStats::file_names].
        pub fn set_file_names<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.file_names = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for DownloadStats {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.BulkDownloadFeedbackLabelsMetadata.DownloadStats"
        }
    }
}

/// The conversation resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Conversation {
    /// Immutable. The resource name of the conversation.
    /// Format:
    /// projects/{project}/locations/{location}/conversations/{conversation}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The source of the audio and transcription for the conversation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_source: std::option::Option<crate::model::ConversationDataSource>,

    /// Output only. The time at which the conversation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The most recent time at which the conversation was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The time at which the conversation started.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// A user-specified language code for the conversation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub language_code: std::string::String,

    /// An opaque, user-specified string representing the human agent who handled
    /// the conversation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub agent_id: std::string::String,

    /// A map for the user to specify any custom fields. A maximum of 100 labels
    /// per conversation is allowed, with a maximum of 256 characters per entry.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Conversation metadata related to quality management.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub quality_metadata: std::option::Option<crate::model::conversation::QualityMetadata>,

    /// Input only. JSON metadata encoded as a string.
    /// This field is primarily used by Insights integrations with various telphony
    /// systems and must be in one of Insight's supported formats.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub metadata_json: std::string::String,

    /// Output only. The conversation transcript.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub transcript: std::option::Option<crate::model::conversation::Transcript>,

    /// Immutable. The conversation medium, if unspecified will default to
    /// PHONE_CALL.
    pub medium: crate::model::conversation::Medium,

    /// Output only. The duration of the conversation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub duration: std::option::Option<wkt::Duration>,

    /// Output only. The number of turns in the conversation.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub turn_count: i32,

    /// Output only. The conversation's latest analysis, if one exists.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub latest_analysis: std::option::Option<crate::model::Analysis>,

    /// Output only. Latest summary of the conversation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub latest_summary: std::option::Option<crate::model::ConversationSummarizationSuggestionData>,

    /// Output only. The annotations that were generated during the customer and
    /// agent interaction.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub runtime_annotations: std::vec::Vec<crate::model::RuntimeAnnotation>,

    /// Output only. All the matched Dialogflow intents in the call. The key
    /// corresponds to a Dialogflow intent, format:
    /// projects/{project}/agent/{agent}/intents/{intent}
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub dialogflow_intents:
        std::collections::HashMap<std::string::String, crate::model::DialogflowIntent>,

    /// Obfuscated user ID which the customer sent to us.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub obfuscated_user_id: std::string::String,

    /// Metadata that applies to the conversation.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub metadata: std::option::Option<crate::model::conversation::Metadata>,

    /// A time to live expiration setting, can be either a specified timestamp or a
    /// duration from the time that the conversation creation request was received.
    /// Conversations with an expiration set will be removed up to 24 hours after
    /// the specified time.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub expiration: std::option::Option<crate::model::conversation::Expiration>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Conversation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Conversation::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [data_source][crate::model::Conversation::data_source].
    pub fn set_data_source<
        T: std::convert::Into<std::option::Option<crate::model::ConversationDataSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_source = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Conversation::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Conversation::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::Conversation::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::Conversation::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [agent_id][crate::model::Conversation::agent_id].
    pub fn set_agent_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.agent_id = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Conversation::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [quality_metadata][crate::model::Conversation::quality_metadata].
    pub fn set_quality_metadata<
        T: std::convert::Into<std::option::Option<crate::model::conversation::QualityMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.quality_metadata = v.into();
        self
    }

    /// Sets the value of [metadata_json][crate::model::Conversation::metadata_json].
    pub fn set_metadata_json<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.metadata_json = v.into();
        self
    }

    /// Sets the value of [transcript][crate::model::Conversation::transcript].
    pub fn set_transcript<
        T: std::convert::Into<std::option::Option<crate::model::conversation::Transcript>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transcript = v.into();
        self
    }

    /// Sets the value of [medium][crate::model::Conversation::medium].
    pub fn set_medium<T: std::convert::Into<crate::model::conversation::Medium>>(
        mut self,
        v: T,
    ) -> Self {
        self.medium = v.into();
        self
    }

    /// Sets the value of [duration][crate::model::Conversation::duration].
    pub fn set_duration<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.duration = v.into();
        self
    }

    /// Sets the value of [turn_count][crate::model::Conversation::turn_count].
    pub fn set_turn_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.turn_count = v.into();
        self
    }

    /// Sets the value of [latest_analysis][crate::model::Conversation::latest_analysis].
    pub fn set_latest_analysis<
        T: std::convert::Into<std::option::Option<crate::model::Analysis>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.latest_analysis = v.into();
        self
    }

    /// Sets the value of [latest_summary][crate::model::Conversation::latest_summary].
    pub fn set_latest_summary<
        T: std::convert::Into<
                std::option::Option<crate::model::ConversationSummarizationSuggestionData>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.latest_summary = v.into();
        self
    }

    /// Sets the value of [runtime_annotations][crate::model::Conversation::runtime_annotations].
    pub fn set_runtime_annotations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RuntimeAnnotation>,
    {
        use std::iter::Iterator;
        self.runtime_annotations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [dialogflow_intents][crate::model::Conversation::dialogflow_intents].
    pub fn set_dialogflow_intents<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::DialogflowIntent>,
    {
        use std::iter::Iterator;
        self.dialogflow_intents = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [obfuscated_user_id][crate::model::Conversation::obfuscated_user_id].
    pub fn set_obfuscated_user_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.obfuscated_user_id = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::Conversation::metadata].
    ///
    /// Note that all the setters affecting `metadata` are mutually
    /// exclusive.
    pub fn set_metadata<
        T: std::convert::Into<std::option::Option<crate::model::conversation::Metadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = v.into();
        self
    }

    /// The value of [metadata][crate::model::Conversation::metadata]
    /// if it holds a `CallMetadata`, `None` if the field is not set or
    /// holds a different branch.
    pub fn call_metadata(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::conversation::CallMetadata>> {
        #[allow(unreachable_patterns)]
        self.metadata.as_ref().and_then(|v| match v {
            crate::model::conversation::Metadata::CallMetadata(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [metadata][crate::model::Conversation::metadata]
    /// to hold a `CallMetadata`.
    ///
    /// Note that all the setters affecting `metadata` are
    /// mutually exclusive.
    pub fn set_call_metadata<
        T: std::convert::Into<std::boxed::Box<crate::model::conversation::CallMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metadata =
            std::option::Option::Some(crate::model::conversation::Metadata::CallMetadata(v.into()));
        self
    }

    /// Sets the value of [expiration][crate::model::Conversation::expiration].
    ///
    /// Note that all the setters affecting `expiration` are mutually
    /// exclusive.
    pub fn set_expiration<
        T: std::convert::Into<std::option::Option<crate::model::conversation::Expiration>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.expiration = v.into();
        self
    }

    /// The value of [expiration][crate::model::Conversation::expiration]
    /// if it holds a `ExpireTime`, `None` if the field is not set or
    /// holds a different branch.
    pub fn expire_time(&self) -> std::option::Option<&std::boxed::Box<wkt::Timestamp>> {
        #[allow(unreachable_patterns)]
        self.expiration.as_ref().and_then(|v| match v {
            crate::model::conversation::Expiration::ExpireTime(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [expiration][crate::model::Conversation::expiration]
    /// to hold a `ExpireTime`.
    ///
    /// Note that all the setters affecting `expiration` are
    /// mutually exclusive.
    pub fn set_expire_time<T: std::convert::Into<std::boxed::Box<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expiration =
            std::option::Option::Some(crate::model::conversation::Expiration::ExpireTime(v.into()));
        self
    }

    /// The value of [expiration][crate::model::Conversation::expiration]
    /// if it holds a `Ttl`, `None` if the field is not set or
    /// holds a different branch.
    pub fn ttl(&self) -> std::option::Option<&std::boxed::Box<wkt::Duration>> {
        #[allow(unreachable_patterns)]
        self.expiration.as_ref().and_then(|v| match v {
            crate::model::conversation::Expiration::Ttl(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [expiration][crate::model::Conversation::expiration]
    /// to hold a `Ttl`.
    ///
    /// Note that all the setters affecting `expiration` are
    /// mutually exclusive.
    pub fn set_ttl<T: std::convert::Into<std::boxed::Box<wkt::Duration>>>(mut self, v: T) -> Self {
        self.expiration =
            std::option::Option::Some(crate::model::conversation::Expiration::Ttl(v.into()));
        self
    }
}

impl wkt::message::Message for Conversation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.Conversation"
    }
}

/// Defines additional types related to [Conversation].
pub mod conversation {
    #[allow(unused_imports)]
    use super::*;

    /// Call-specific metadata.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct CallMetadata {
        /// The audio channel that contains the customer.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub customer_channel: i32,

        /// The audio channel that contains the agent.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub agent_channel: i32,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CallMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [customer_channel][crate::model::conversation::CallMetadata::customer_channel].
        pub fn set_customer_channel<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.customer_channel = v.into();
            self
        }

        /// Sets the value of [agent_channel][crate::model::conversation::CallMetadata::agent_channel].
        pub fn set_agent_channel<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.agent_channel = v.into();
            self
        }
    }

    impl wkt::message::Message for CallMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.Conversation.CallMetadata"
        }
    }

    /// Conversation metadata related to quality management.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct QualityMetadata {
        /// An arbitrary integer value indicating the customer's satisfaction rating.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub customer_satisfaction_rating: i32,

        /// The amount of time the customer waited to connect with an agent.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub wait_duration: std::option::Option<wkt::Duration>,

        /// An arbitrary string value specifying the menu path the customer took.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub menu_path: std::string::String,

        /// Information about agents involved in the call.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub agent_info: std::vec::Vec<crate::model::conversation::quality_metadata::AgentInfo>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl QualityMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [customer_satisfaction_rating][crate::model::conversation::QualityMetadata::customer_satisfaction_rating].
        pub fn set_customer_satisfaction_rating<T: std::convert::Into<i32>>(
            mut self,
            v: T,
        ) -> Self {
            self.customer_satisfaction_rating = v.into();
            self
        }

        /// Sets the value of [wait_duration][crate::model::conversation::QualityMetadata::wait_duration].
        pub fn set_wait_duration<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
            mut self,
            v: T,
        ) -> Self {
            self.wait_duration = v.into();
            self
        }

        /// Sets the value of [menu_path][crate::model::conversation::QualityMetadata::menu_path].
        pub fn set_menu_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.menu_path = v.into();
            self
        }

        /// Sets the value of [agent_info][crate::model::conversation::QualityMetadata::agent_info].
        pub fn set_agent_info<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::conversation::quality_metadata::AgentInfo>,
        {
            use std::iter::Iterator;
            self.agent_info = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for QualityMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.Conversation.QualityMetadata"
        }
    }

    /// Defines additional types related to [QualityMetadata].
    pub mod quality_metadata {
        #[allow(unused_imports)]
        use super::*;

        /// Information about an agent involved in the conversation.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct AgentInfo {
            /// A user-specified string representing the agent.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub agent_id: std::string::String,

            /// The agent's name.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub display_name: std::string::String,

            /// A user-specified string representing the agent's team.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub team: std::string::String,

            /// A user-provided string indicating the outcome of the agent's segment of
            /// the call.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub disposition_code: std::string::String,

            /// The agent type, e.g. HUMAN_AGENT.
            pub agent_type: crate::model::conversation_participant::Role,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl AgentInfo {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [agent_id][crate::model::conversation::quality_metadata::AgentInfo::agent_id].
            pub fn set_agent_id<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.agent_id = v.into();
                self
            }

            /// Sets the value of [display_name][crate::model::conversation::quality_metadata::AgentInfo::display_name].
            pub fn set_display_name<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.display_name = v.into();
                self
            }

            /// Sets the value of [team][crate::model::conversation::quality_metadata::AgentInfo::team].
            pub fn set_team<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.team = v.into();
                self
            }

            /// Sets the value of [disposition_code][crate::model::conversation::quality_metadata::AgentInfo::disposition_code].
            pub fn set_disposition_code<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.disposition_code = v.into();
                self
            }

            /// Sets the value of [agent_type][crate::model::conversation::quality_metadata::AgentInfo::agent_type].
            pub fn set_agent_type<
                T: std::convert::Into<crate::model::conversation_participant::Role>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.agent_type = v.into();
                self
            }
        }

        impl wkt::message::Message for AgentInfo {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.contactcenterinsights.v1.Conversation.QualityMetadata.AgentInfo"
            }
        }
    }

    /// A message representing the transcript of a conversation.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Transcript {
        /// A list of sequential transcript segments that comprise the conversation.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub transcript_segments:
            std::vec::Vec<crate::model::conversation::transcript::TranscriptSegment>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Transcript {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [transcript_segments][crate::model::conversation::Transcript::transcript_segments].
        pub fn set_transcript_segments<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::conversation::transcript::TranscriptSegment>,
        {
            use std::iter::Iterator;
            self.transcript_segments = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Transcript {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.Conversation.Transcript"
        }
    }

    /// Defines additional types related to [Transcript].
    pub mod transcript {
        #[allow(unused_imports)]
        use super::*;

        /// A segment of a full transcript.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct TranscriptSegment {

            /// The time that the message occurred, if provided.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub message_time: std::option::Option<wkt::Timestamp>,

            /// The text of this segment.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub text: std::string::String,

            /// A confidence estimate between 0.0 and 1.0 of the fidelity of this
            /// segment. A default value of 0.0 indicates that the value is unset.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "wkt::internal::F32")]
            pub confidence: f32,

            /// A list of the word-specific information for each word in the segment.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub words: std::vec::Vec<crate::model::conversation::transcript::transcript_segment::WordInfo>,

            /// The language code of this segment as a
            /// [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt) language tag.
            /// Example: "en-US".
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub language_code: std::string::String,

            /// For conversations derived from multi-channel audio, this is the channel
            /// number corresponding to the audio from that channel. For
            /// audioChannelCount = N, its output values can range from '1' to 'N'. A
            /// channel tag of 0 indicates that the audio is mono.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub channel_tag: i32,

            /// The participant of this segment.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub segment_participant: std::option::Option<crate::model::ConversationParticipant>,

            /// CCAI metadata relating to the current transcript segment.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub dialogflow_segment_metadata: std::option::Option<crate::model::conversation::transcript::transcript_segment::DialogflowSegmentMetadata>,

            /// The sentiment for this transcript segment.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub sentiment: std::option::Option<crate::model::SentimentData>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl TranscriptSegment {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [message_time][crate::model::conversation::transcript::TranscriptSegment::message_time].
            pub fn set_message_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
                mut self,
                v: T,
            ) -> Self {
                self.message_time = v.into();
                self
            }

            /// Sets the value of [text][crate::model::conversation::transcript::TranscriptSegment::text].
            pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.text = v.into();
                self
            }

            /// Sets the value of [confidence][crate::model::conversation::transcript::TranscriptSegment::confidence].
            pub fn set_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
                self.confidence = v.into();
                self
            }

            /// Sets the value of [words][crate::model::conversation::transcript::TranscriptSegment::words].
            pub fn set_words<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<
                        crate::model::conversation::transcript::transcript_segment::WordInfo,
                    >,
            {
                use std::iter::Iterator;
                self.words = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [language_code][crate::model::conversation::transcript::TranscriptSegment::language_code].
            pub fn set_language_code<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.language_code = v.into();
                self
            }

            /// Sets the value of [channel_tag][crate::model::conversation::transcript::TranscriptSegment::channel_tag].
            pub fn set_channel_tag<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.channel_tag = v.into();
                self
            }

            /// Sets the value of [segment_participant][crate::model::conversation::transcript::TranscriptSegment::segment_participant].
            pub fn set_segment_participant<
                T: std::convert::Into<std::option::Option<crate::model::ConversationParticipant>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.segment_participant = v.into();
                self
            }

            /// Sets the value of [dialogflow_segment_metadata][crate::model::conversation::transcript::TranscriptSegment::dialogflow_segment_metadata].
            pub fn set_dialogflow_segment_metadata<T: std::convert::Into<std::option::Option<crate::model::conversation::transcript::transcript_segment::DialogflowSegmentMetadata>>>(mut self, v: T) -> Self{
                self.dialogflow_segment_metadata = v.into();
                self
            }

            /// Sets the value of [sentiment][crate::model::conversation::transcript::TranscriptSegment::sentiment].
            pub fn set_sentiment<
                T: std::convert::Into<std::option::Option<crate::model::SentimentData>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.sentiment = v.into();
                self
            }
        }

        impl wkt::message::Message for TranscriptSegment {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.contactcenterinsights.v1.Conversation.Transcript.TranscriptSegment"
            }
        }

        /// Defines additional types related to [TranscriptSegment].
        pub mod transcript_segment {
            #[allow(unused_imports)]
            use super::*;

            /// Word-level info for words in a transcript.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct WordInfo {
                /// Time offset of the start of this word relative to the beginning of
                /// the total conversation.
                #[serde(skip_serializing_if = "std::option::Option::is_none")]
                pub start_offset: std::option::Option<wkt::Duration>,

                /// Time offset of the end of this word relative to the beginning of the
                /// total conversation.
                #[serde(skip_serializing_if = "std::option::Option::is_none")]
                pub end_offset: std::option::Option<wkt::Duration>,

                /// The word itself. Includes punctuation marks that surround the word.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub word: std::string::String,

                /// A confidence estimate between 0.0 and 1.0 of the fidelity of this
                /// word. A default value of 0.0 indicates that the value is unset.
                #[serde(skip_serializing_if = "wkt::internal::is_default")]
                #[serde_as(as = "wkt::internal::F32")]
                pub confidence: f32,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl WordInfo {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [start_offset][crate::model::conversation::transcript::transcript_segment::WordInfo::start_offset].
                pub fn set_start_offset<
                    T: std::convert::Into<std::option::Option<wkt::Duration>>,
                >(
                    mut self,
                    v: T,
                ) -> Self {
                    self.start_offset = v.into();
                    self
                }

                /// Sets the value of [end_offset][crate::model::conversation::transcript::transcript_segment::WordInfo::end_offset].
                pub fn set_end_offset<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.end_offset = v.into();
                    self
                }

                /// Sets the value of [word][crate::model::conversation::transcript::transcript_segment::WordInfo::word].
                pub fn set_word<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.word = v.into();
                    self
                }

                /// Sets the value of [confidence][crate::model::conversation::transcript::transcript_segment::WordInfo::confidence].
                pub fn set_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
                    self.confidence = v.into();
                    self
                }
            }

            impl wkt::message::Message for WordInfo {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.contactcenterinsights.v1.Conversation.Transcript.TranscriptSegment.WordInfo"
                }
            }

            /// Metadata from Dialogflow relating to the current transcript segment.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct DialogflowSegmentMetadata {
                /// Whether the transcript segment was covered under the configured smart
                /// reply allowlist in Agent Assist.
                #[serde(skip_serializing_if = "wkt::internal::is_default")]
                pub smart_reply_allowlist_covered: bool,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl DialogflowSegmentMetadata {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [smart_reply_allowlist_covered][crate::model::conversation::transcript::transcript_segment::DialogflowSegmentMetadata::smart_reply_allowlist_covered].
                pub fn set_smart_reply_allowlist_covered<T: std::convert::Into<bool>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.smart_reply_allowlist_covered = v.into();
                    self
                }
            }

            impl wkt::message::Message for DialogflowSegmentMetadata {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.contactcenterinsights.v1.Conversation.Transcript.TranscriptSegment.DialogflowSegmentMetadata"
                }
            }
        }
    }

    /// Possible media for the conversation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Medium {
        /// Default value, if unspecified will default to PHONE_CALL.
        Unspecified,
        /// The format for conversations that took place over the phone.
        PhoneCall,
        /// The format for conversations that took place over chat.
        Chat,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Medium::value] or
        /// [Medium::name].
        UnknownValue(medium::UnknownValue),
    }

    #[doc(hidden)]
    pub mod medium {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Medium {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::PhoneCall => std::option::Option::Some(1),
                Self::Chat => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MEDIUM_UNSPECIFIED"),
                Self::PhoneCall => std::option::Option::Some("PHONE_CALL"),
                Self::Chat => std::option::Option::Some("CHAT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Medium {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Medium {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Medium {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::PhoneCall,
                2 => Self::Chat,
                _ => Self::UnknownValue(medium::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Medium {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MEDIUM_UNSPECIFIED" => Self::Unspecified,
                "PHONE_CALL" => Self::PhoneCall,
                "CHAT" => Self::Chat,
                _ => Self::UnknownValue(medium::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Medium {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::PhoneCall => serializer.serialize_i32(1),
                Self::Chat => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Medium {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Medium>::new(
                ".google.cloud.contactcenterinsights.v1.Conversation.Medium",
            ))
        }
    }

    /// Metadata that applies to the conversation.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Metadata {
        /// Call-specific metadata.
        CallMetadata(std::boxed::Box<crate::model::conversation::CallMetadata>),
    }

    /// A time to live expiration setting, can be either a specified timestamp or a
    /// duration from the time that the conversation creation request was received.
    /// Conversations with an expiration set will be removed up to 24 hours after
    /// the specified time.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Expiration {
        /// The time at which this conversation should expire. After this time, the
        /// conversation data and any associated analyses will be deleted.
        ExpireTime(std::boxed::Box<wkt::Timestamp>),
        /// Input only. The TTL for this resource. If specified, then this TTL will
        /// be used to calculate the expire time.
        Ttl(std::boxed::Box<wkt::Duration>),
    }
}

/// The analysis resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Analysis {
    /// Immutable. The resource name of the analysis.
    /// Format:
    /// projects/{project}/locations/{location}/conversations/{conversation}/analyses/{analysis}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The time at which the analysis was requested.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub request_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which the analysis was created, which occurs when
    /// the long-running operation completes.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The result of the analysis, which is populated when the
    /// analysis finishes.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub analysis_result: std::option::Option<crate::model::AnalysisResult>,

    /// To select the annotators to run and the phrase matchers to use
    /// (if any). If not specified, all annotators will be run.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub annotator_selector: std::option::Option<crate::model::AnnotatorSelector>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Analysis {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Analysis::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_time][crate::model::Analysis::request_time].
    pub fn set_request_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.request_time = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Analysis::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [analysis_result][crate::model::Analysis::analysis_result].
    pub fn set_analysis_result<
        T: std::convert::Into<std::option::Option<crate::model::AnalysisResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.analysis_result = v.into();
        self
    }

    /// Sets the value of [annotator_selector][crate::model::Analysis::annotator_selector].
    pub fn set_annotator_selector<
        T: std::convert::Into<std::option::Option<crate::model::AnnotatorSelector>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.annotator_selector = v.into();
        self
    }
}

impl wkt::message::Message for Analysis {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.Analysis"
    }
}

/// The conversation source, which is a combination of transcript and audio.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConversationDataSource {
    /// The source of the conversation.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::conversation_data_source::Source>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConversationDataSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source][crate::model::ConversationDataSource::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::conversation_data_source::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::ConversationDataSource::source]
    /// if it holds a `GcsSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::GcsSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::conversation_data_source::Source::GcsSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ConversationDataSource::source]
    /// to hold a `GcsSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_gcs_source<T: std::convert::Into<std::boxed::Box<crate::model::GcsSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::conversation_data_source::Source::GcsSource(v.into()),
        );
        self
    }

    /// The value of [source][crate::model::ConversationDataSource::source]
    /// if it holds a `DialogflowSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn dialogflow_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DialogflowSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::conversation_data_source::Source::DialogflowSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ConversationDataSource::source]
    /// to hold a `DialogflowSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_dialogflow_source<
        T: std::convert::Into<std::boxed::Box<crate::model::DialogflowSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::conversation_data_source::Source::DialogflowSource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ConversationDataSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ConversationDataSource"
    }
}

/// Defines additional types related to [ConversationDataSource].
pub mod conversation_data_source {
    #[allow(unused_imports)]
    use super::*;

    /// The source of the conversation.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// A Cloud Storage location specification for the audio and transcript.
        GcsSource(std::boxed::Box<crate::model::GcsSource>),
        /// The source when the conversation comes from Dialogflow.
        DialogflowSource(std::boxed::Box<crate::model::DialogflowSource>),
    }
}

/// A Cloud Storage source of conversation data.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GcsSource {
    /// Cloud Storage URI that points to a file that contains the conversation
    /// audio.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub audio_uri: std::string::String,

    /// Immutable. Cloud Storage URI that points to a file that contains the
    /// conversation transcript.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub transcript_uri: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcsSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [audio_uri][crate::model::GcsSource::audio_uri].
    pub fn set_audio_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.audio_uri = v.into();
        self
    }

    /// Sets the value of [transcript_uri][crate::model::GcsSource::transcript_uri].
    pub fn set_transcript_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.transcript_uri = v.into();
        self
    }
}

impl wkt::message::Message for GcsSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.GcsSource"
    }
}

/// A Dialogflow source of conversation data.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DialogflowSource {
    /// Output only. The name of the Dialogflow conversation that this conversation
    /// resource is derived from. Format:
    /// projects/{project}/locations/{location}/conversations/{conversation}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dialogflow_conversation: std::string::String,

    /// Cloud Storage URI that points to a file that contains the conversation
    /// audio.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub audio_uri: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DialogflowSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dialogflow_conversation][crate::model::DialogflowSource::dialogflow_conversation].
    pub fn set_dialogflow_conversation<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.dialogflow_conversation = v.into();
        self
    }

    /// Sets the value of [audio_uri][crate::model::DialogflowSource::audio_uri].
    pub fn set_audio_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.audio_uri = v.into();
        self
    }
}

impl wkt::message::Message for DialogflowSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.DialogflowSource"
    }
}

/// The result of an analysis.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AnalysisResult {
    /// The time at which the analysis ended.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Metadata discovered during analysis.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub metadata: std::option::Option<crate::model::analysis_result::Metadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnalysisResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [end_time][crate::model::AnalysisResult::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::AnalysisResult::metadata].
    ///
    /// Note that all the setters affecting `metadata` are mutually
    /// exclusive.
    pub fn set_metadata<
        T: std::convert::Into<std::option::Option<crate::model::analysis_result::Metadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = v.into();
        self
    }

    /// The value of [metadata][crate::model::AnalysisResult::metadata]
    /// if it holds a `CallAnalysisMetadata`, `None` if the field is not set or
    /// holds a different branch.
    pub fn call_analysis_metadata(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::analysis_result::CallAnalysisMetadata>>
    {
        #[allow(unreachable_patterns)]
        self.metadata.as_ref().and_then(|v| match v {
            crate::model::analysis_result::Metadata::CallAnalysisMetadata(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [metadata][crate::model::AnalysisResult::metadata]
    /// to hold a `CallAnalysisMetadata`.
    ///
    /// Note that all the setters affecting `metadata` are
    /// mutually exclusive.
    pub fn set_call_analysis_metadata<
        T: std::convert::Into<std::boxed::Box<crate::model::analysis_result::CallAnalysisMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = std::option::Option::Some(
            crate::model::analysis_result::Metadata::CallAnalysisMetadata(v.into()),
        );
        self
    }
}

impl wkt::message::Message for AnalysisResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.AnalysisResult"
    }
}

/// Defines additional types related to [AnalysisResult].
pub mod analysis_result {
    #[allow(unused_imports)]
    use super::*;

    /// Call-specific metadata created during analysis.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct CallAnalysisMetadata {
        /// A list of call annotations that apply to this call.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub annotations: std::vec::Vec<crate::model::CallAnnotation>,

        /// All the entities in the call.
        #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
        pub entities: std::collections::HashMap<std::string::String, crate::model::Entity>,

        /// Overall conversation-level sentiment for each channel of the call.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub sentiments: std::vec::Vec<crate::model::ConversationLevelSentiment>,

        /// Overall conversation-level silence during the call.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub silence: std::option::Option<crate::model::ConversationLevelSilence>,

        /// All the matched intents in the call.
        #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
        pub intents: std::collections::HashMap<std::string::String, crate::model::Intent>,

        /// All the matched phrase matchers in the call.
        #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
        pub phrase_matchers:
            std::collections::HashMap<std::string::String, crate::model::PhraseMatchData>,

        /// Overall conversation-level issue modeling result.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub issue_model_result: std::option::Option<crate::model::IssueModelResult>,

        /// Results of scoring QaScorecards.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub qa_scorecard_results: std::vec::Vec<crate::model::QaScorecardResult>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CallAnalysisMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [annotations][crate::model::analysis_result::CallAnalysisMetadata::annotations].
        pub fn set_annotations<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::CallAnnotation>,
        {
            use std::iter::Iterator;
            self.annotations = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [entities][crate::model::analysis_result::CallAnalysisMetadata::entities].
        pub fn set_entities<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<crate::model::Entity>,
        {
            use std::iter::Iterator;
            self.entities = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [sentiments][crate::model::analysis_result::CallAnalysisMetadata::sentiments].
        pub fn set_sentiments<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::ConversationLevelSentiment>,
        {
            use std::iter::Iterator;
            self.sentiments = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [silence][crate::model::analysis_result::CallAnalysisMetadata::silence].
        pub fn set_silence<
            T: std::convert::Into<std::option::Option<crate::model::ConversationLevelSilence>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.silence = v.into();
            self
        }

        /// Sets the value of [intents][crate::model::analysis_result::CallAnalysisMetadata::intents].
        pub fn set_intents<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<crate::model::Intent>,
        {
            use std::iter::Iterator;
            self.intents = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [phrase_matchers][crate::model::analysis_result::CallAnalysisMetadata::phrase_matchers].
        pub fn set_phrase_matchers<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<crate::model::PhraseMatchData>,
        {
            use std::iter::Iterator;
            self.phrase_matchers = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [issue_model_result][crate::model::analysis_result::CallAnalysisMetadata::issue_model_result].
        pub fn set_issue_model_result<
            T: std::convert::Into<std::option::Option<crate::model::IssueModelResult>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.issue_model_result = v.into();
            self
        }

        /// Sets the value of [qa_scorecard_results][crate::model::analysis_result::CallAnalysisMetadata::qa_scorecard_results].
        pub fn set_qa_scorecard_results<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::QaScorecardResult>,
        {
            use std::iter::Iterator;
            self.qa_scorecard_results = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for CallAnalysisMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.AnalysisResult.CallAnalysisMetadata"
        }
    }

    /// Metadata discovered during analysis.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Metadata {
        /// Call-specific metadata created by the analysis.
        CallAnalysisMetadata(std::boxed::Box<crate::model::analysis_result::CallAnalysisMetadata>),
    }
}

/// Issue Modeling result on a conversation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct IssueModelResult {
    /// Issue model that generates the result.
    /// Format: projects/{project}/locations/{location}/issueModels/{issue_model}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub issue_model: std::string::String,

    /// All the matched issues.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub issues: std::vec::Vec<crate::model::IssueAssignment>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IssueModelResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [issue_model][crate::model::IssueModelResult::issue_model].
    pub fn set_issue_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.issue_model = v.into();
        self
    }

    /// Sets the value of [issues][crate::model::IssueModelResult::issues].
    pub fn set_issues<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::IssueAssignment>,
    {
        use std::iter::Iterator;
        self.issues = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for IssueModelResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.IssueModelResult"
    }
}

/// Represents a conversation, resource, and label provided by the user.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FeedbackLabel {
    /// Immutable. Resource name of the FeedbackLabel.
    /// Format:
    /// projects/{project}/locations/{location}/conversations/{conversation}/feedbackLabels/{feedback_label}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Resource name of the resource to be labeled.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub labeled_resource: std::string::String,

    /// Output only. Create time of the label.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Update time of the label.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Label type.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub label_type: std::option::Option<crate::model::feedback_label::LabelType>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FeedbackLabel {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FeedbackLabel::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [labeled_resource][crate::model::FeedbackLabel::labeled_resource].
    pub fn set_labeled_resource<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.labeled_resource = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::FeedbackLabel::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::FeedbackLabel::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [label_type][crate::model::FeedbackLabel::label_type].
    ///
    /// Note that all the setters affecting `label_type` are mutually
    /// exclusive.
    pub fn set_label_type<
        T: std::convert::Into<std::option::Option<crate::model::feedback_label::LabelType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.label_type = v.into();
        self
    }

    /// The value of [label_type][crate::model::FeedbackLabel::label_type]
    /// if it holds a `Label`, `None` if the field is not set or
    /// holds a different branch.
    pub fn label(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.label_type.as_ref().and_then(|v| match v {
            crate::model::feedback_label::LabelType::Label(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [label_type][crate::model::FeedbackLabel::label_type]
    /// to hold a `Label`.
    ///
    /// Note that all the setters affecting `label_type` are
    /// mutually exclusive.
    pub fn set_label<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.label_type =
            std::option::Option::Some(crate::model::feedback_label::LabelType::Label(v.into()));
        self
    }

    /// The value of [label_type][crate::model::FeedbackLabel::label_type]
    /// if it holds a `QaAnswerLabel`, `None` if the field is not set or
    /// holds a different branch.
    pub fn qa_answer_label(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::qa_answer::AnswerValue>> {
        #[allow(unreachable_patterns)]
        self.label_type.as_ref().and_then(|v| match v {
            crate::model::feedback_label::LabelType::QaAnswerLabel(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [label_type][crate::model::FeedbackLabel::label_type]
    /// to hold a `QaAnswerLabel`.
    ///
    /// Note that all the setters affecting `label_type` are
    /// mutually exclusive.
    pub fn set_qa_answer_label<
        T: std::convert::Into<std::boxed::Box<crate::model::qa_answer::AnswerValue>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.label_type = std::option::Option::Some(
            crate::model::feedback_label::LabelType::QaAnswerLabel(v.into()),
        );
        self
    }
}

impl wkt::message::Message for FeedbackLabel {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.FeedbackLabel"
    }
}

/// Defines additional types related to [FeedbackLabel].
pub mod feedback_label {
    #[allow(unused_imports)]
    use super::*;

    /// Label type.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum LabelType {
        /// String label.
        Label(std::string::String),
        /// QaAnswer label.
        QaAnswerLabel(std::boxed::Box<crate::model::qa_answer::AnswerValue>),
    }
}

/// One channel of conversation-level sentiment data.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConversationLevelSentiment {
    /// The channel of the audio that the data applies to.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub channel_tag: i32,

    /// Data specifying sentiment.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sentiment_data: std::option::Option<crate::model::SentimentData>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConversationLevelSentiment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [channel_tag][crate::model::ConversationLevelSentiment::channel_tag].
    pub fn set_channel_tag<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.channel_tag = v.into();
        self
    }

    /// Sets the value of [sentiment_data][crate::model::ConversationLevelSentiment::sentiment_data].
    pub fn set_sentiment_data<
        T: std::convert::Into<std::option::Option<crate::model::SentimentData>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sentiment_data = v.into();
        self
    }
}

impl wkt::message::Message for ConversationLevelSentiment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ConversationLevelSentiment"
    }
}

/// Conversation-level silence data.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConversationLevelSilence {
    /// Amount of time calculated to be in silence.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub silence_duration: std::option::Option<wkt::Duration>,

    /// Percentage of the total conversation spent in silence.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F32")]
    pub silence_percentage: f32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConversationLevelSilence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [silence_duration][crate::model::ConversationLevelSilence::silence_duration].
    pub fn set_silence_duration<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.silence_duration = v.into();
        self
    }

    /// Sets the value of [silence_percentage][crate::model::ConversationLevelSilence::silence_percentage].
    pub fn set_silence_percentage<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.silence_percentage = v.into();
        self
    }
}

impl wkt::message::Message for ConversationLevelSilence {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ConversationLevelSilence"
    }
}

/// Information about the issue.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct IssueAssignment {
    /// Resource name of the assigned issue.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub issue: std::string::String,

    /// Score indicating the likelihood of the issue assignment.
    /// currently bounded on [0,1].
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F64")]
    pub score: f64,

    /// Immutable. Display name of the assigned issue. This field is set at time of
    /// analyis and immutable since then.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IssueAssignment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [issue][crate::model::IssueAssignment::issue].
    pub fn set_issue<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.issue = v.into();
        self
    }

    /// Sets the value of [score][crate::model::IssueAssignment::score].
    pub fn set_score<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::IssueAssignment::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }
}

impl wkt::message::Message for IssueAssignment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.IssueAssignment"
    }
}

/// A piece of metadata that applies to a window of a call.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CallAnnotation {
    /// The channel of the audio where the annotation occurs. For single-channel
    /// audio, this field is not populated.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub channel_tag: i32,

    /// The boundary in the conversation where the annotation starts, inclusive.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub annotation_start_boundary: std::option::Option<crate::model::AnnotationBoundary>,

    /// The boundary in the conversation where the annotation ends, inclusive.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub annotation_end_boundary: std::option::Option<crate::model::AnnotationBoundary>,

    /// The data in the annotation.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub data: std::option::Option<crate::model::call_annotation::Data>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CallAnnotation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [channel_tag][crate::model::CallAnnotation::channel_tag].
    pub fn set_channel_tag<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.channel_tag = v.into();
        self
    }

    /// Sets the value of [annotation_start_boundary][crate::model::CallAnnotation::annotation_start_boundary].
    pub fn set_annotation_start_boundary<
        T: std::convert::Into<std::option::Option<crate::model::AnnotationBoundary>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.annotation_start_boundary = v.into();
        self
    }

    /// Sets the value of [annotation_end_boundary][crate::model::CallAnnotation::annotation_end_boundary].
    pub fn set_annotation_end_boundary<
        T: std::convert::Into<std::option::Option<crate::model::AnnotationBoundary>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.annotation_end_boundary = v.into();
        self
    }

    /// Sets the value of [data][crate::model::CallAnnotation::data].
    ///
    /// Note that all the setters affecting `data` are mutually
    /// exclusive.
    pub fn set_data<
        T: std::convert::Into<std::option::Option<crate::model::call_annotation::Data>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data = v.into();
        self
    }

    /// The value of [data][crate::model::CallAnnotation::data]
    /// if it holds a `InterruptionData`, `None` if the field is not set or
    /// holds a different branch.
    pub fn interruption_data(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::InterruptionData>> {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::call_annotation::Data::InterruptionData(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data][crate::model::CallAnnotation::data]
    /// to hold a `InterruptionData`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_interruption_data<
        T: std::convert::Into<std::boxed::Box<crate::model::InterruptionData>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data = std::option::Option::Some(
            crate::model::call_annotation::Data::InterruptionData(v.into()),
        );
        self
    }

    /// The value of [data][crate::model::CallAnnotation::data]
    /// if it holds a `SentimentData`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sentiment_data(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SentimentData>> {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::call_annotation::Data::SentimentData(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data][crate::model::CallAnnotation::data]
    /// to hold a `SentimentData`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_sentiment_data<
        T: std::convert::Into<std::boxed::Box<crate::model::SentimentData>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data =
            std::option::Option::Some(crate::model::call_annotation::Data::SentimentData(v.into()));
        self
    }

    /// The value of [data][crate::model::CallAnnotation::data]
    /// if it holds a `SilenceData`, `None` if the field is not set or
    /// holds a different branch.
    pub fn silence_data(&self) -> std::option::Option<&std::boxed::Box<crate::model::SilenceData>> {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::call_annotation::Data::SilenceData(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data][crate::model::CallAnnotation::data]
    /// to hold a `SilenceData`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_silence_data<T: std::convert::Into<std::boxed::Box<crate::model::SilenceData>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data =
            std::option::Option::Some(crate::model::call_annotation::Data::SilenceData(v.into()));
        self
    }

    /// The value of [data][crate::model::CallAnnotation::data]
    /// if it holds a `HoldData`, `None` if the field is not set or
    /// holds a different branch.
    pub fn hold_data(&self) -> std::option::Option<&std::boxed::Box<crate::model::HoldData>> {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::call_annotation::Data::HoldData(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data][crate::model::CallAnnotation::data]
    /// to hold a `HoldData`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_hold_data<T: std::convert::Into<std::boxed::Box<crate::model::HoldData>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data =
            std::option::Option::Some(crate::model::call_annotation::Data::HoldData(v.into()));
        self
    }

    /// The value of [data][crate::model::CallAnnotation::data]
    /// if it holds a `EntityMentionData`, `None` if the field is not set or
    /// holds a different branch.
    pub fn entity_mention_data(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::EntityMentionData>> {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::call_annotation::Data::EntityMentionData(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data][crate::model::CallAnnotation::data]
    /// to hold a `EntityMentionData`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_entity_mention_data<
        T: std::convert::Into<std::boxed::Box<crate::model::EntityMentionData>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data = std::option::Option::Some(
            crate::model::call_annotation::Data::EntityMentionData(v.into()),
        );
        self
    }

    /// The value of [data][crate::model::CallAnnotation::data]
    /// if it holds a `IntentMatchData`, `None` if the field is not set or
    /// holds a different branch.
    pub fn intent_match_data(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::IntentMatchData>> {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::call_annotation::Data::IntentMatchData(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data][crate::model::CallAnnotation::data]
    /// to hold a `IntentMatchData`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_intent_match_data<
        T: std::convert::Into<std::boxed::Box<crate::model::IntentMatchData>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data = std::option::Option::Some(
            crate::model::call_annotation::Data::IntentMatchData(v.into()),
        );
        self
    }

    /// The value of [data][crate::model::CallAnnotation::data]
    /// if it holds a `PhraseMatchData`, `None` if the field is not set or
    /// holds a different branch.
    pub fn phrase_match_data(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PhraseMatchData>> {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::call_annotation::Data::PhraseMatchData(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data][crate::model::CallAnnotation::data]
    /// to hold a `PhraseMatchData`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_phrase_match_data<
        T: std::convert::Into<std::boxed::Box<crate::model::PhraseMatchData>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data = std::option::Option::Some(
            crate::model::call_annotation::Data::PhraseMatchData(v.into()),
        );
        self
    }

    /// The value of [data][crate::model::CallAnnotation::data]
    /// if it holds a `IssueMatchData`, `None` if the field is not set or
    /// holds a different branch.
    pub fn issue_match_data(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::IssueMatchData>> {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::call_annotation::Data::IssueMatchData(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data][crate::model::CallAnnotation::data]
    /// to hold a `IssueMatchData`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_issue_match_data<
        T: std::convert::Into<std::boxed::Box<crate::model::IssueMatchData>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data = std::option::Option::Some(crate::model::call_annotation::Data::IssueMatchData(
            v.into(),
        ));
        self
    }
}

impl wkt::message::Message for CallAnnotation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.CallAnnotation"
    }
}

/// Defines additional types related to [CallAnnotation].
pub mod call_annotation {
    #[allow(unused_imports)]
    use super::*;

    /// The data in the annotation.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Data {
        /// Data specifying an interruption.
        InterruptionData(std::boxed::Box<crate::model::InterruptionData>),
        /// Data specifying sentiment.
        SentimentData(std::boxed::Box<crate::model::SentimentData>),
        /// Data specifying silence.
        SilenceData(std::boxed::Box<crate::model::SilenceData>),
        /// Data specifying a hold.
        HoldData(std::boxed::Box<crate::model::HoldData>),
        /// Data specifying an entity mention.
        EntityMentionData(std::boxed::Box<crate::model::EntityMentionData>),
        /// Data specifying an intent match.
        IntentMatchData(std::boxed::Box<crate::model::IntentMatchData>),
        /// Data specifying a phrase match.
        PhraseMatchData(std::boxed::Box<crate::model::PhraseMatchData>),
        /// Data specifying an issue match.
        IssueMatchData(std::boxed::Box<crate::model::IssueMatchData>),
    }
}

/// A point in a conversation that marks the start or the end of an annotation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AnnotationBoundary {
    /// The index in the sequence of transcribed pieces of the conversation where
    /// the boundary is located. This index starts at zero.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub transcript_index: i32,

    /// A detailed boundary, which describes a more specific point.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub detailed_boundary: std::option::Option<crate::model::annotation_boundary::DetailedBoundary>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnnotationBoundary {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [transcript_index][crate::model::AnnotationBoundary::transcript_index].
    pub fn set_transcript_index<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.transcript_index = v.into();
        self
    }

    /// Sets the value of [detailed_boundary][crate::model::AnnotationBoundary::detailed_boundary].
    ///
    /// Note that all the setters affecting `detailed_boundary` are mutually
    /// exclusive.
    pub fn set_detailed_boundary<
        T: std::convert::Into<
                std::option::Option<crate::model::annotation_boundary::DetailedBoundary>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.detailed_boundary = v.into();
        self
    }

    /// The value of [detailed_boundary][crate::model::AnnotationBoundary::detailed_boundary]
    /// if it holds a `WordIndex`, `None` if the field is not set or
    /// holds a different branch.
    pub fn word_index(&self) -> std::option::Option<&i32> {
        #[allow(unreachable_patterns)]
        self.detailed_boundary.as_ref().and_then(|v| match v {
            crate::model::annotation_boundary::DetailedBoundary::WordIndex(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [detailed_boundary][crate::model::AnnotationBoundary::detailed_boundary]
    /// to hold a `WordIndex`.
    ///
    /// Note that all the setters affecting `detailed_boundary` are
    /// mutually exclusive.
    pub fn set_word_index<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.detailed_boundary = std::option::Option::Some(
            crate::model::annotation_boundary::DetailedBoundary::WordIndex(v.into()),
        );
        self
    }
}

impl wkt::message::Message for AnnotationBoundary {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.AnnotationBoundary"
    }
}

/// Defines additional types related to [AnnotationBoundary].
pub mod annotation_boundary {
    #[allow(unused_imports)]
    use super::*;

    /// A detailed boundary, which describes a more specific point.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum DetailedBoundary {
        /// The word index of this boundary with respect to the first word in the
        /// transcript piece. This index starts at zero.
        WordIndex(i32),
    }
}

/// The data for an entity annotation.
/// Represents a phrase in the conversation that is a known entity, such
/// as a person, an organization, or location.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Entity {
    /// The representative name for the entity.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// The entity type.
    #[serde(rename = "type")]
    pub r#type: crate::model::entity::Type,

    /// Metadata associated with the entity.
    ///
    /// For most entity types, the metadata is a Wikipedia URL (`wikipedia_url`)
    /// and Knowledge Graph MID (`mid`), if they are available. For the metadata
    /// associated with other entity types, see the Type table below.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub metadata: std::collections::HashMap<std::string::String, std::string::String>,

    /// The salience score associated with the entity in the [0, 1.0] range.
    ///
    /// The salience score for an entity provides information about the
    /// importance or centrality of that entity to the entire document text.
    /// Scores closer to 0 are less salient, while scores closer to 1.0 are highly
    /// salient.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F32")]
    pub salience: f32,

    /// The aggregate sentiment expressed for this entity in the conversation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sentiment: std::option::Option<crate::model::SentimentData>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Entity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_name][crate::model::Entity::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::Entity::type].
    pub fn set_type<T: std::convert::Into<crate::model::entity::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::Entity::metadata].
    pub fn set_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [salience][crate::model::Entity::salience].
    pub fn set_salience<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.salience = v.into();
        self
    }

    /// Sets the value of [sentiment][crate::model::Entity::sentiment].
    pub fn set_sentiment<
        T: std::convert::Into<std::option::Option<crate::model::SentimentData>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sentiment = v.into();
        self
    }
}

impl wkt::message::Message for Entity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.Entity"
    }
}

/// Defines additional types related to [Entity].
pub mod entity {
    #[allow(unused_imports)]
    use super::*;

    /// The type of the entity. For most entity types, the associated metadata is a
    /// Wikipedia URL (`wikipedia_url`) and Knowledge Graph MID (`mid`). The table
    /// below lists the associated fields for entities that have different
    /// metadata.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Unspecified.
        Unspecified,
        /// Person.
        Person,
        /// Location.
        Location,
        /// Organization.
        Organization,
        /// Event.
        Event,
        /// Artwork.
        WorkOfArt,
        /// Consumer product.
        ConsumerGood,
        /// Other types of entities.
        Other,
        /// Phone number.
        ///
        /// The metadata lists the phone number (formatted according to local
        /// convention), plus whichever additional elements appear in the text:
        ///
        /// * `number` - The actual number, broken down into sections according to
        ///   local convention.
        /// * `national_prefix` - Country code, if detected.
        /// * `area_code` - Region or area code, if detected.
        /// * `extension` - Phone extension (to be dialed after connection), if
        ///   detected.
        PhoneNumber,
        /// Address.
        ///
        /// The metadata identifies the street number and locality plus whichever
        /// additional elements appear in the text:
        ///
        /// * `street_number` - Street number.
        /// * `locality` - City or town.
        /// * `street_name` - Street/route name, if detected.
        /// * `postal_code` - Postal code, if detected.
        /// * `country` - Country, if detected.
        /// * `broad_region` - Administrative area, such as the state, if detected.
        /// * `narrow_region` - Smaller administrative area, such as county, if
        ///   detected.
        /// * `sublocality` - Used in Asian addresses to demark a district within a
        ///   city, if detected.
        Address,
        /// Date.
        ///
        /// The metadata identifies the components of the date:
        ///
        /// * `year` - Four digit year, if detected.
        /// * `month` - Two digit month number, if detected.
        /// * `day` - Two digit day number, if detected.
        Date,
        /// Number.
        ///
        /// The metadata is the number itself.
        Number,
        /// Price.
        ///
        /// The metadata identifies the `value` and `currency`.
        Price,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Person => std::option::Option::Some(1),
                Self::Location => std::option::Option::Some(2),
                Self::Organization => std::option::Option::Some(3),
                Self::Event => std::option::Option::Some(4),
                Self::WorkOfArt => std::option::Option::Some(5),
                Self::ConsumerGood => std::option::Option::Some(6),
                Self::Other => std::option::Option::Some(7),
                Self::PhoneNumber => std::option::Option::Some(9),
                Self::Address => std::option::Option::Some(10),
                Self::Date => std::option::Option::Some(11),
                Self::Number => std::option::Option::Some(12),
                Self::Price => std::option::Option::Some(13),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::Person => std::option::Option::Some("PERSON"),
                Self::Location => std::option::Option::Some("LOCATION"),
                Self::Organization => std::option::Option::Some("ORGANIZATION"),
                Self::Event => std::option::Option::Some("EVENT"),
                Self::WorkOfArt => std::option::Option::Some("WORK_OF_ART"),
                Self::ConsumerGood => std::option::Option::Some("CONSUMER_GOOD"),
                Self::Other => std::option::Option::Some("OTHER"),
                Self::PhoneNumber => std::option::Option::Some("PHONE_NUMBER"),
                Self::Address => std::option::Option::Some("ADDRESS"),
                Self::Date => std::option::Option::Some("DATE"),
                Self::Number => std::option::Option::Some("NUMBER"),
                Self::Price => std::option::Option::Some("PRICE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Person,
                2 => Self::Location,
                3 => Self::Organization,
                4 => Self::Event,
                5 => Self::WorkOfArt,
                6 => Self::ConsumerGood,
                7 => Self::Other,
                9 => Self::PhoneNumber,
                10 => Self::Address,
                11 => Self::Date,
                12 => Self::Number,
                13 => Self::Price,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "PERSON" => Self::Person,
                "LOCATION" => Self::Location,
                "ORGANIZATION" => Self::Organization,
                "EVENT" => Self::Event,
                "WORK_OF_ART" => Self::WorkOfArt,
                "CONSUMER_GOOD" => Self::ConsumerGood,
                "OTHER" => Self::Other,
                "PHONE_NUMBER" => Self::PhoneNumber,
                "ADDRESS" => Self::Address,
                "DATE" => Self::Date,
                "NUMBER" => Self::Number,
                "PRICE" => Self::Price,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Person => serializer.serialize_i32(1),
                Self::Location => serializer.serialize_i32(2),
                Self::Organization => serializer.serialize_i32(3),
                Self::Event => serializer.serialize_i32(4),
                Self::WorkOfArt => serializer.serialize_i32(5),
                Self::ConsumerGood => serializer.serialize_i32(6),
                Self::Other => serializer.serialize_i32(7),
                Self::PhoneNumber => serializer.serialize_i32(9),
                Self::Address => serializer.serialize_i32(10),
                Self::Date => serializer.serialize_i32(11),
                Self::Number => serializer.serialize_i32(12),
                Self::Price => serializer.serialize_i32(13),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.contactcenterinsights.v1.Entity.Type",
            ))
        }
    }
}

/// The data for an intent.
/// Represents a detected intent in the conversation, for example MAKES_PROMISE.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Intent {
    /// The unique identifier of the intent.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// The human-readable name of the intent.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Intent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::Intent::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Intent::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }
}

impl wkt::message::Message for Intent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.Intent"
    }
}

/// The data for a matched phrase matcher.
/// Represents information identifying a phrase matcher for a given match.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PhraseMatchData {
    /// The unique identifier (the resource name) of the phrase matcher.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub phrase_matcher: std::string::String,

    /// The human-readable name of the phrase matcher.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PhraseMatchData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [phrase_matcher][crate::model::PhraseMatchData::phrase_matcher].
    pub fn set_phrase_matcher<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.phrase_matcher = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::PhraseMatchData::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }
}

impl wkt::message::Message for PhraseMatchData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.PhraseMatchData"
    }
}

/// The data for a Dialogflow intent.
/// Represents a detected intent in the conversation, e.g. MAKES_PROMISE.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DialogflowIntent {
    /// The human-readable name of the intent.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DialogflowIntent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_name][crate::model::DialogflowIntent::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }
}

impl wkt::message::Message for DialogflowIntent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.DialogflowIntent"
    }
}

/// The data for an interruption annotation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InterruptionData {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InterruptionData {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for InterruptionData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.InterruptionData"
    }
}

/// The data for a silence annotation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SilenceData {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SilenceData {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for SilenceData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.SilenceData"
    }
}

/// The data for a hold annotation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HoldData {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HoldData {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for HoldData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.HoldData"
    }
}

/// The data for an entity mention annotation.
/// This represents a mention of an `Entity` in the conversation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EntityMentionData {
    /// The key of this entity in conversation entities.
    /// Can be used to retrieve the exact `Entity` this mention is attached to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entity_unique_id: std::string::String,

    /// The type of the entity mention.
    #[serde(rename = "type")]
    pub r#type: crate::model::entity_mention_data::MentionType,

    /// Sentiment expressed for this mention of the entity.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sentiment: std::option::Option<crate::model::SentimentData>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EntityMentionData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entity_unique_id][crate::model::EntityMentionData::entity_unique_id].
    pub fn set_entity_unique_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.entity_unique_id = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::EntityMentionData::type].
    pub fn set_type<T: std::convert::Into<crate::model::entity_mention_data::MentionType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [sentiment][crate::model::EntityMentionData::sentiment].
    pub fn set_sentiment<
        T: std::convert::Into<std::option::Option<crate::model::SentimentData>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sentiment = v.into();
        self
    }
}

impl wkt::message::Message for EntityMentionData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.EntityMentionData"
    }
}

/// Defines additional types related to [EntityMentionData].
pub mod entity_mention_data {
    #[allow(unused_imports)]
    use super::*;

    /// The supported types of mentions.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MentionType {
        /// Unspecified.
        Unspecified,
        /// Proper noun.
        Proper,
        /// Common noun (or noun compound).
        Common,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MentionType::value] or
        /// [MentionType::name].
        UnknownValue(mention_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod mention_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl MentionType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Proper => std::option::Option::Some(1),
                Self::Common => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MENTION_TYPE_UNSPECIFIED"),
                Self::Proper => std::option::Option::Some("PROPER"),
                Self::Common => std::option::Option::Some("COMMON"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for MentionType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for MentionType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for MentionType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Proper,
                2 => Self::Common,
                _ => Self::UnknownValue(mention_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for MentionType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MENTION_TYPE_UNSPECIFIED" => Self::Unspecified,
                "PROPER" => Self::Proper,
                "COMMON" => Self::Common,
                _ => Self::UnknownValue(mention_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for MentionType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Proper => serializer.serialize_i32(1),
                Self::Common => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for MentionType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MentionType>::new(
                ".google.cloud.contactcenterinsights.v1.EntityMentionData.MentionType",
            ))
        }
    }
}

/// The data for an intent match.
/// Represents an intent match for a text segment in the conversation. A text
/// segment can be part of a sentence, a complete sentence, or an utterance
/// with multiple sentences.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct IntentMatchData {
    /// The id of the matched intent.
    /// Can be used to retrieve the corresponding intent information.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub intent_unique_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IntentMatchData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [intent_unique_id][crate::model::IntentMatchData::intent_unique_id].
    pub fn set_intent_unique_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.intent_unique_id = v.into();
        self
    }
}

impl wkt::message::Message for IntentMatchData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.IntentMatchData"
    }
}

/// The data for a sentiment annotation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SentimentData {
    /// A non-negative number from 0 to infinity which represents the abolute
    /// magnitude of sentiment regardless of score.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F32")]
    pub magnitude: f32,

    /// The sentiment score between -1.0 (negative) and 1.0 (positive).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F32")]
    pub score: f32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SentimentData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [magnitude][crate::model::SentimentData::magnitude].
    pub fn set_magnitude<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.magnitude = v.into();
        self
    }

    /// Sets the value of [score][crate::model::SentimentData::score].
    pub fn set_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }
}

impl wkt::message::Message for SentimentData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.SentimentData"
    }
}

/// The data for an issue match annotation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct IssueMatchData {
    /// Information about the issue's assignment.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub issue_assignment: std::option::Option<crate::model::IssueAssignment>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IssueMatchData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [issue_assignment][crate::model::IssueMatchData::issue_assignment].
    pub fn set_issue_assignment<
        T: std::convert::Into<std::option::Option<crate::model::IssueAssignment>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.issue_assignment = v.into();
        self
    }
}

impl wkt::message::Message for IssueMatchData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.IssueMatchData"
    }
}

/// The issue model resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct IssueModel {
    /// Immutable. The resource name of the issue model.
    /// Format:
    /// projects/{project}/locations/{location}/issueModels/{issue_model}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The representative name for the issue model.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. The time at which this issue model was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The most recent time at which the issue model was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Number of issues in this issue model.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub issue_count: i64,

    /// Output only. State of the model.
    pub state: crate::model::issue_model::State,

    /// Configs for the input data that used to create the issue model.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub input_data_config: std::option::Option<crate::model::issue_model::InputDataConfig>,

    /// Output only. Immutable. The issue model's label statistics on its training
    /// data.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub training_stats: std::option::Option<crate::model::IssueModelLabelStats>,

    /// Type of the model.
    pub model_type: crate::model::issue_model::ModelType,

    /// Language of the model.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub language_code: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IssueModel {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::IssueModel::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::IssueModel::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::IssueModel::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::IssueModel::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [issue_count][crate::model::IssueModel::issue_count].
    pub fn set_issue_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.issue_count = v.into();
        self
    }

    /// Sets the value of [state][crate::model::IssueModel::state].
    pub fn set_state<T: std::convert::Into<crate::model::issue_model::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [input_data_config][crate::model::IssueModel::input_data_config].
    pub fn set_input_data_config<
        T: std::convert::Into<std::option::Option<crate::model::issue_model::InputDataConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.input_data_config = v.into();
        self
    }

    /// Sets the value of [training_stats][crate::model::IssueModel::training_stats].
    pub fn set_training_stats<
        T: std::convert::Into<std::option::Option<crate::model::IssueModelLabelStats>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.training_stats = v.into();
        self
    }

    /// Sets the value of [model_type][crate::model::IssueModel::model_type].
    pub fn set_model_type<T: std::convert::Into<crate::model::issue_model::ModelType>>(
        mut self,
        v: T,
    ) -> Self {
        self.model_type = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::IssueModel::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }
}

impl wkt::message::Message for IssueModel {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.IssueModel"
    }
}

/// Defines additional types related to [IssueModel].
pub mod issue_model {
    #[allow(unused_imports)]
    use super::*;

    /// Configs for the input data used to create the issue model.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct InputDataConfig {
        /// Medium of conversations used in training data. This field is being
        /// deprecated. To specify the medium to be used in training a new issue
        /// model, set the `medium` field on `filter`.
        #[deprecated]
        pub medium: crate::model::conversation::Medium,

        /// Output only. Number of conversations used in training. Output only.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub training_conversations_count: i64,

        /// A filter to reduce the conversations used for training the model to a
        /// specific subset.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub filter: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl InputDataConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [medium][crate::model::issue_model::InputDataConfig::medium].
        #[deprecated]
        pub fn set_medium<T: std::convert::Into<crate::model::conversation::Medium>>(
            mut self,
            v: T,
        ) -> Self {
            self.medium = v.into();
            self
        }

        /// Sets the value of [training_conversations_count][crate::model::issue_model::InputDataConfig::training_conversations_count].
        pub fn set_training_conversations_count<T: std::convert::Into<i64>>(
            mut self,
            v: T,
        ) -> Self {
            self.training_conversations_count = v.into();
            self
        }

        /// Sets the value of [filter][crate::model::issue_model::InputDataConfig::filter].
        pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.filter = v.into();
            self
        }
    }

    impl wkt::message::Message for InputDataConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.IssueModel.InputDataConfig"
        }
    }

    /// State of the model.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified.
        Unspecified,
        /// Model is not deployed but is ready to deploy.
        Undeployed,
        /// Model is being deployed.
        Deploying,
        /// Model is deployed and is ready to be used. A model can only be used in
        /// analysis if it's in this state.
        Deployed,
        /// Model is being undeployed.
        Undeploying,
        /// Model is being deleted.
        Deleting,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Undeployed => std::option::Option::Some(1),
                Self::Deploying => std::option::Option::Some(2),
                Self::Deployed => std::option::Option::Some(3),
                Self::Undeploying => std::option::Option::Some(4),
                Self::Deleting => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Undeployed => std::option::Option::Some("UNDEPLOYED"),
                Self::Deploying => std::option::Option::Some("DEPLOYING"),
                Self::Deployed => std::option::Option::Some("DEPLOYED"),
                Self::Undeploying => std::option::Option::Some("UNDEPLOYING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Undeployed,
                2 => Self::Deploying,
                3 => Self::Deployed,
                4 => Self::Undeploying,
                5 => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "UNDEPLOYED" => Self::Undeployed,
                "DEPLOYING" => Self::Deploying,
                "DEPLOYED" => Self::Deployed,
                "UNDEPLOYING" => Self::Undeploying,
                "DELETING" => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Undeployed => serializer.serialize_i32(1),
                Self::Deploying => serializer.serialize_i32(2),
                Self::Deployed => serializer.serialize_i32(3),
                Self::Undeploying => serializer.serialize_i32(4),
                Self::Deleting => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.contactcenterinsights.v1.IssueModel.State",
            ))
        }
    }

    /// Type of the model.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ModelType {
        /// Unspecified model type.
        Unspecified,
        /// Type V1.
        TypeV1,
        /// Type V2.
        TypeV2,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ModelType::value] or
        /// [ModelType::name].
        UnknownValue(model_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod model_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ModelType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::TypeV1 => std::option::Option::Some(1),
                Self::TypeV2 => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MODEL_TYPE_UNSPECIFIED"),
                Self::TypeV1 => std::option::Option::Some("TYPE_V1"),
                Self::TypeV2 => std::option::Option::Some("TYPE_V2"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ModelType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ModelType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ModelType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::TypeV1,
                2 => Self::TypeV2,
                _ => Self::UnknownValue(model_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ModelType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MODEL_TYPE_UNSPECIFIED" => Self::Unspecified,
                "TYPE_V1" => Self::TypeV1,
                "TYPE_V2" => Self::TypeV2,
                _ => Self::UnknownValue(model_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ModelType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::TypeV1 => serializer.serialize_i32(1),
                Self::TypeV2 => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ModelType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ModelType>::new(
                ".google.cloud.contactcenterinsights.v1.IssueModel.ModelType",
            ))
        }
    }
}

/// The issue resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Issue {
    /// Immutable. The resource name of the issue.
    /// Format:
    /// projects/{project}/locations/{location}/issueModels/{issue_model}/issues/{issue}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The representative name for the issue.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. The time at which this issue was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The most recent time that this issue was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Resource names of the sample representative utterances that
    /// match to this issue.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub sample_utterances: std::vec::Vec<std::string::String>,

    /// Representative description of the issue.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_description: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Issue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Issue::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Issue::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Issue::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Issue::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [sample_utterances][crate::model::Issue::sample_utterances].
    pub fn set_sample_utterances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.sample_utterances = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [display_description][crate::model::Issue::display_description].
    pub fn set_display_description<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.display_description = v.into();
        self
    }
}

impl wkt::message::Message for Issue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.Issue"
    }
}

/// Aggregated statistics about an issue model.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct IssueModelLabelStats {
    /// Number of conversations the issue model has analyzed at this point in time.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub analyzed_conversations_count: i64,

    /// Number of analyzed conversations for which no issue was applicable at this
    /// point in time.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub unclassified_conversations_count: i64,

    /// Statistics on each issue. Key is the issue's resource name.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub issue_stats: std::collections::HashMap<
        std::string::String,
        crate::model::issue_model_label_stats::IssueStats,
    >,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IssueModelLabelStats {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [analyzed_conversations_count][crate::model::IssueModelLabelStats::analyzed_conversations_count].
    pub fn set_analyzed_conversations_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.analyzed_conversations_count = v.into();
        self
    }

    /// Sets the value of [unclassified_conversations_count][crate::model::IssueModelLabelStats::unclassified_conversations_count].
    pub fn set_unclassified_conversations_count<T: std::convert::Into<i64>>(
        mut self,
        v: T,
    ) -> Self {
        self.unclassified_conversations_count = v.into();
        self
    }

    /// Sets the value of [issue_stats][crate::model::IssueModelLabelStats::issue_stats].
    pub fn set_issue_stats<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::issue_model_label_stats::IssueStats>,
    {
        use std::iter::Iterator;
        self.issue_stats = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for IssueModelLabelStats {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.IssueModelLabelStats"
    }
}

/// Defines additional types related to [IssueModelLabelStats].
pub mod issue_model_label_stats {
    #[allow(unused_imports)]
    use super::*;

    /// Aggregated statistics about an issue.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct IssueStats {
        /// Issue resource.
        /// Format:
        /// projects/{project}/locations/{location}/issueModels/{issue_model}/issues/{issue}
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub issue: std::string::String,

        /// Number of conversations attached to the issue at this point in time.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub labeled_conversations_count: i64,

        /// Display name of the issue.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub display_name: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl IssueStats {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [issue][crate::model::issue_model_label_stats::IssueStats::issue].
        pub fn set_issue<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.issue = v.into();
            self
        }

        /// Sets the value of [labeled_conversations_count][crate::model::issue_model_label_stats::IssueStats::labeled_conversations_count].
        pub fn set_labeled_conversations_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.labeled_conversations_count = v.into();
            self
        }

        /// Sets the value of [display_name][crate::model::issue_model_label_stats::IssueStats::display_name].
        pub fn set_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.display_name = v.into();
            self
        }
    }

    impl wkt::message::Message for IssueStats {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.IssueModelLabelStats.IssueStats"
        }
    }
}

/// The phrase matcher resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PhraseMatcher {
    /// The resource name of the phrase matcher.
    /// Format:
    /// projects/{project}/locations/{location}/phraseMatchers/{phrase_matcher}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Immutable. The revision ID of the phrase matcher.
    /// A new revision is committed whenever the matcher is changed, except when it
    /// is activated or deactivated. A server generated random ID will be used.
    /// Example: locations/global/phraseMatchers/my-first-matcher@1234567
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub revision_id: std::string::String,

    /// The customized version tag to use for the phrase matcher. If not specified,
    /// it will default to `revision_id`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version_tag: std::string::String,

    /// Output only. The timestamp of when the revision was created. It is also the
    /// create time when a new matcher is added.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub revision_create_time: std::option::Option<wkt::Timestamp>,

    /// The human-readable name of the phrase matcher.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Required. The type of this phrase matcher.
    #[serde(rename = "type")]
    pub r#type: crate::model::phrase_matcher::PhraseMatcherType,

    /// Applies the phrase matcher only when it is active.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub active: bool,

    /// A list of phase match rule groups that are included in this matcher.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub phrase_match_rule_groups: std::vec::Vec<crate::model::PhraseMatchRuleGroup>,

    /// Output only. The most recent time at which the activation status was
    /// updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub activation_update_time: std::option::Option<wkt::Timestamp>,

    /// The role whose utterances the phrase matcher should be matched
    /// against. If the role is ROLE_UNSPECIFIED it will be matched against any
    /// utterances in the transcript.
    pub role_match: crate::model::conversation_participant::Role,

    /// Output only. The most recent time at which the phrase matcher was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PhraseMatcher {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PhraseMatcher::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [revision_id][crate::model::PhraseMatcher::revision_id].
    pub fn set_revision_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision_id = v.into();
        self
    }

    /// Sets the value of [version_tag][crate::model::PhraseMatcher::version_tag].
    pub fn set_version_tag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version_tag = v.into();
        self
    }

    /// Sets the value of [revision_create_time][crate::model::PhraseMatcher::revision_create_time].
    pub fn set_revision_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.revision_create_time = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::PhraseMatcher::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::PhraseMatcher::type].
    pub fn set_type<T: std::convert::Into<crate::model::phrase_matcher::PhraseMatcherType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [active][crate::model::PhraseMatcher::active].
    pub fn set_active<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.active = v.into();
        self
    }

    /// Sets the value of [phrase_match_rule_groups][crate::model::PhraseMatcher::phrase_match_rule_groups].
    pub fn set_phrase_match_rule_groups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PhraseMatchRuleGroup>,
    {
        use std::iter::Iterator;
        self.phrase_match_rule_groups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [activation_update_time][crate::model::PhraseMatcher::activation_update_time].
    pub fn set_activation_update_time<
        T: std::convert::Into<std::option::Option<wkt::Timestamp>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.activation_update_time = v.into();
        self
    }

    /// Sets the value of [role_match][crate::model::PhraseMatcher::role_match].
    pub fn set_role_match<T: std::convert::Into<crate::model::conversation_participant::Role>>(
        mut self,
        v: T,
    ) -> Self {
        self.role_match = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::PhraseMatcher::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }
}

impl wkt::message::Message for PhraseMatcher {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.PhraseMatcher"
    }
}

/// Defines additional types related to [PhraseMatcher].
pub mod phrase_matcher {
    #[allow(unused_imports)]
    use super::*;

    /// Specifies how to combine each phrase match rule group to determine whether
    /// there is a match.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PhraseMatcherType {
        /// Unspecified.
        Unspecified,
        /// Must meet all phrase match rule groups or there is no match.
        AllOf,
        /// If any of the phrase match rule groups are met, there is a match.
        AnyOf,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PhraseMatcherType::value] or
        /// [PhraseMatcherType::name].
        UnknownValue(phrase_matcher_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod phrase_matcher_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PhraseMatcherType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::AllOf => std::option::Option::Some(1),
                Self::AnyOf => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PHRASE_MATCHER_TYPE_UNSPECIFIED"),
                Self::AllOf => std::option::Option::Some("ALL_OF"),
                Self::AnyOf => std::option::Option::Some("ANY_OF"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PhraseMatcherType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PhraseMatcherType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PhraseMatcherType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::AllOf,
                2 => Self::AnyOf,
                _ => Self::UnknownValue(phrase_matcher_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PhraseMatcherType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PHRASE_MATCHER_TYPE_UNSPECIFIED" => Self::Unspecified,
                "ALL_OF" => Self::AllOf,
                "ANY_OF" => Self::AnyOf,
                _ => Self::UnknownValue(phrase_matcher_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PhraseMatcherType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::AllOf => serializer.serialize_i32(1),
                Self::AnyOf => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PhraseMatcherType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PhraseMatcherType>::new(
                ".google.cloud.contactcenterinsights.v1.PhraseMatcher.PhraseMatcherType",
            ))
        }
    }
}

/// A message representing a rule in the phrase matcher.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PhraseMatchRuleGroup {
    /// Required. The type of this phrase match rule group.
    #[serde(rename = "type")]
    pub r#type: crate::model::phrase_match_rule_group::PhraseMatchRuleGroupType,

    /// A list of phrase match rules that are included in this group.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub phrase_match_rules: std::vec::Vec<crate::model::PhraseMatchRule>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PhraseMatchRuleGroup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::PhraseMatchRuleGroup::type].
    pub fn set_type<
        T: std::convert::Into<crate::model::phrase_match_rule_group::PhraseMatchRuleGroupType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [phrase_match_rules][crate::model::PhraseMatchRuleGroup::phrase_match_rules].
    pub fn set_phrase_match_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PhraseMatchRule>,
    {
        use std::iter::Iterator;
        self.phrase_match_rules = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PhraseMatchRuleGroup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.PhraseMatchRuleGroup"
    }
}

/// Defines additional types related to [PhraseMatchRuleGroup].
pub mod phrase_match_rule_group {
    #[allow(unused_imports)]
    use super::*;

    /// Specifies how to combine each phrase match rule for whether there is a
    /// match.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PhraseMatchRuleGroupType {
        /// Unspecified.
        Unspecified,
        /// Must meet all phrase match rules or there is no match.
        AllOf,
        /// If any of the phrase match rules are met, there is a match.
        AnyOf,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PhraseMatchRuleGroupType::value] or
        /// [PhraseMatchRuleGroupType::name].
        UnknownValue(phrase_match_rule_group_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod phrase_match_rule_group_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PhraseMatchRuleGroupType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::AllOf => std::option::Option::Some(1),
                Self::AnyOf => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("PHRASE_MATCH_RULE_GROUP_TYPE_UNSPECIFIED")
                }
                Self::AllOf => std::option::Option::Some("ALL_OF"),
                Self::AnyOf => std::option::Option::Some("ANY_OF"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PhraseMatchRuleGroupType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PhraseMatchRuleGroupType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PhraseMatchRuleGroupType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::AllOf,
                2 => Self::AnyOf,
                _ => Self::UnknownValue(phrase_match_rule_group_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PhraseMatchRuleGroupType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PHRASE_MATCH_RULE_GROUP_TYPE_UNSPECIFIED" => Self::Unspecified,
                "ALL_OF" => Self::AllOf,
                "ANY_OF" => Self::AnyOf,
                _ => Self::UnknownValue(phrase_match_rule_group_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PhraseMatchRuleGroupType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::AllOf => serializer.serialize_i32(1),
                Self::AnyOf => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PhraseMatchRuleGroupType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PhraseMatchRuleGroupType>::new(
                ".google.cloud.contactcenterinsights.v1.PhraseMatchRuleGroup.PhraseMatchRuleGroupType"))
        }
    }
}

/// The data for a phrase match rule.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PhraseMatchRule {
    /// Required. The phrase to be matched.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub query: std::string::String,

    /// Specifies whether the phrase must be missing from the transcript segment or
    /// present in the transcript segment.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub negated: bool,

    /// Provides additional information about the rule that specifies how to apply
    /// the rule.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub config: std::option::Option<crate::model::PhraseMatchRuleConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PhraseMatchRule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [query][crate::model::PhraseMatchRule::query].
    pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query = v.into();
        self
    }

    /// Sets the value of [negated][crate::model::PhraseMatchRule::negated].
    pub fn set_negated<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.negated = v.into();
        self
    }

    /// Sets the value of [config][crate::model::PhraseMatchRule::config].
    pub fn set_config<
        T: std::convert::Into<std::option::Option<crate::model::PhraseMatchRuleConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config = v.into();
        self
    }
}

impl wkt::message::Message for PhraseMatchRule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.PhraseMatchRule"
    }
}

/// Configuration information of a phrase match rule.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PhraseMatchRuleConfig {
    /// The configuration of the phrase match rule.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub config: std::option::Option<crate::model::phrase_match_rule_config::Config>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PhraseMatchRuleConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [config][crate::model::PhraseMatchRuleConfig::config].
    ///
    /// Note that all the setters affecting `config` are mutually
    /// exclusive.
    pub fn set_config<
        T: std::convert::Into<std::option::Option<crate::model::phrase_match_rule_config::Config>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config = v.into();
        self
    }

    /// The value of [config][crate::model::PhraseMatchRuleConfig::config]
    /// if it holds a `ExactMatchConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn exact_match_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ExactMatchConfig>> {
        #[allow(unreachable_patterns)]
        self.config.as_ref().and_then(|v| match v {
            crate::model::phrase_match_rule_config::Config::ExactMatchConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [config][crate::model::PhraseMatchRuleConfig::config]
    /// to hold a `ExactMatchConfig`.
    ///
    /// Note that all the setters affecting `config` are
    /// mutually exclusive.
    pub fn set_exact_match_config<
        T: std::convert::Into<std::boxed::Box<crate::model::ExactMatchConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config = std::option::Option::Some(
            crate::model::phrase_match_rule_config::Config::ExactMatchConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for PhraseMatchRuleConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.PhraseMatchRuleConfig"
    }
}

/// Defines additional types related to [PhraseMatchRuleConfig].
pub mod phrase_match_rule_config {
    #[allow(unused_imports)]
    use super::*;

    /// The configuration of the phrase match rule.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Config {
        /// The configuration for the exact match rule.
        ExactMatchConfig(std::boxed::Box<crate::model::ExactMatchConfig>),
    }
}

/// Exact match configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExactMatchConfig {
    /// Whether to consider case sensitivity when performing an exact match.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub case_sensitive: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExactMatchConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [case_sensitive][crate::model::ExactMatchConfig::case_sensitive].
    pub fn set_case_sensitive<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.case_sensitive = v.into();
        self
    }
}

impl wkt::message::Message for ExactMatchConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ExactMatchConfig"
    }
}

/// The CCAI Insights project wide settings.
/// Use these settings to configure the behavior of Insights.
/// View these settings with
/// [`getsettings`](https://cloud.google.com/contact-center/insights/docs/reference/rest/v1/projects.locations/getSettings)
/// and change the settings with
/// [`updateSettings`](https://cloud.google.com/contact-center/insights/docs/reference/rest/v1/projects.locations/updateSettings).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Settings {
    /// Immutable. The resource name of the settings resource.
    /// Format:
    /// projects/{project}/locations/{location}/settings
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The time at which the settings was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which the settings were last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// A language code to be applied to each transcript segment unless the segment
    /// already specifies a language code. Language code defaults to "en-US" if it
    /// is neither specified on the segment nor here.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub language_code: std::string::String,

    /// The default TTL for newly-created conversations. If a conversation has a
    /// specified expiration, that value will be used instead. Changing this
    /// value will not change the expiration of existing conversations.
    /// Conversations with no expire time persist until they are deleted.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub conversation_ttl: std::option::Option<wkt::Duration>,

    /// A map that maps a notification trigger to a Pub/Sub topic. Each time a
    /// specified trigger occurs, Insights will notify the corresponding Pub/Sub
    /// topic.
    ///
    /// Keys are notification triggers. Supported keys are:
    ///
    /// * "all-triggers": Notify each time any of the supported triggers occurs.
    /// * "create-analysis": Notify each time an analysis is created.
    /// * "create-conversation": Notify each time a conversation is created.
    /// * "export-insights-data": Notify each time an export is complete.
    /// * "ingest-conversations": Notify each time an IngestConversations LRO is
    ///   complete.
    /// * "update-conversation": Notify each time a conversation is updated via
    ///   UpdateConversation.
    /// * "upload-conversation": Notify when an UploadConversation LRO is complete.
    ///
    /// Values are Pub/Sub topics. The format of each Pub/Sub topic is:
    /// projects/{project}/topics/{topic}
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub pubsub_notification_settings:
        std::collections::HashMap<std::string::String, std::string::String>,

    /// Default analysis settings.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub analysis_config: std::option::Option<crate::model::settings::AnalysisConfig>,

    /// Default DLP redaction resources to be applied while ingesting
    /// conversations. This applies to conversations ingested from the
    /// `UploadConversation` and `IngestConversations` endpoints, including
    /// conversations coming from CCAI Platform.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub redaction_config: std::option::Option<crate::model::RedactionConfig>,

    /// Optional. Default Speech-to-Text resources to use while ingesting audio
    /// files. Optional, CCAI Insights will create a default if not provided. This
    /// applies to conversations ingested from the `UploadConversation` and
    /// `IngestConversations` endpoints, including conversations coming from CCAI
    /// Platform.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub speech_config: std::option::Option<crate::model::SpeechConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Settings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Settings::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Settings::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Settings::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::Settings::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [conversation_ttl][crate::model::Settings::conversation_ttl].
    pub fn set_conversation_ttl<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.conversation_ttl = v.into();
        self
    }

    /// Sets the value of [pubsub_notification_settings][crate::model::Settings::pubsub_notification_settings].
    pub fn set_pubsub_notification_settings<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.pubsub_notification_settings =
            v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [analysis_config][crate::model::Settings::analysis_config].
    pub fn set_analysis_config<
        T: std::convert::Into<std::option::Option<crate::model::settings::AnalysisConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.analysis_config = v.into();
        self
    }

    /// Sets the value of [redaction_config][crate::model::Settings::redaction_config].
    pub fn set_redaction_config<
        T: std::convert::Into<std::option::Option<crate::model::RedactionConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.redaction_config = v.into();
        self
    }

    /// Sets the value of [speech_config][crate::model::Settings::speech_config].
    pub fn set_speech_config<
        T: std::convert::Into<std::option::Option<crate::model::SpeechConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.speech_config = v.into();
        self
    }
}

impl wkt::message::Message for Settings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.Settings"
    }
}

/// Defines additional types related to [Settings].
pub mod settings {
    #[allow(unused_imports)]
    use super::*;

    /// Default configuration when creating Analyses in Insights.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct AnalysisConfig {
        /// Percentage of conversations created using Dialogflow runtime integration
        /// to analyze automatically, between [0, 100].
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "wkt::internal::F64")]
        pub runtime_integration_analysis_percentage: f64,

        /// Percentage of conversations created using the UploadConversation endpoint
        /// to analyze automatically, between [0, 100].
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "wkt::internal::F64")]
        pub upload_conversation_analysis_percentage: f64,

        /// To select the annotators to run and the phrase matchers to use
        /// (if any). If not specified, all annotators will be run.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub annotator_selector: std::option::Option<crate::model::AnnotatorSelector>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AnalysisConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [runtime_integration_analysis_percentage][crate::model::settings::AnalysisConfig::runtime_integration_analysis_percentage].
        pub fn set_runtime_integration_analysis_percentage<T: std::convert::Into<f64>>(
            mut self,
            v: T,
        ) -> Self {
            self.runtime_integration_analysis_percentage = v.into();
            self
        }

        /// Sets the value of [upload_conversation_analysis_percentage][crate::model::settings::AnalysisConfig::upload_conversation_analysis_percentage].
        pub fn set_upload_conversation_analysis_percentage<T: std::convert::Into<f64>>(
            mut self,
            v: T,
        ) -> Self {
            self.upload_conversation_analysis_percentage = v.into();
            self
        }

        /// Sets the value of [annotator_selector][crate::model::settings::AnalysisConfig::annotator_selector].
        pub fn set_annotator_selector<
            T: std::convert::Into<std::option::Option<crate::model::AnnotatorSelector>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.annotator_selector = v.into();
            self
        }
    }

    impl wkt::message::Message for AnalysisConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.Settings.AnalysisConfig"
        }
    }
}

/// The CCAI Insights project wide analysis rule. This rule will be applied to
/// all conversations that match the filter defined in the rule. For a
/// conversation matches the filter, the annotators specified in the rule will be
/// run. If a conversation matches multiple rules, a union of all the annotators
/// will be run. One project can have multiple analysis rules.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AnalysisRule {
    /// Identifier. The resource name of the analysis rule.
    /// Format:
    /// projects/{project}/locations/{location}/analysisRules/{analysis_rule}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The time at which this analysis rule was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The most recent time at which this analysis rule was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Display Name of the analysis rule.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub display_name: std::option::Option<std::string::String>,

    /// Filter for the conversations that should apply this analysis
    /// rule. An empty filter means this analysis rule applies to all
    /// conversations.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub conversation_filter: std::string::String,

    /// Selector of annotators to run and the phrase matchers to use for
    /// conversations that matches the conversation_filter. If not specified, NO
    /// annotators will be run.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub annotator_selector: std::option::Option<crate::model::AnnotatorSelector>,

    /// Percentage of conversations that we should apply this analysis setting
    /// automatically, between [0, 1]. For example, 0.1 means 10%. Conversations
    /// are sampled in a determenestic way. The original runtime_percentage &
    /// upload percentage will be replaced by defining filters on the conversation.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F64")]
    pub analysis_percentage: f64,

    /// If true, apply this rule to conversations. Otherwise, this rule is
    /// inactive and saved as a draft.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub active: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnalysisRule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AnalysisRule::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::AnalysisRule::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::AnalysisRule::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::AnalysisRule::display_name].
    pub fn set_display_name<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [conversation_filter][crate::model::AnalysisRule::conversation_filter].
    pub fn set_conversation_filter<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.conversation_filter = v.into();
        self
    }

    /// Sets the value of [annotator_selector][crate::model::AnalysisRule::annotator_selector].
    pub fn set_annotator_selector<
        T: std::convert::Into<std::option::Option<crate::model::AnnotatorSelector>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.annotator_selector = v.into();
        self
    }

    /// Sets the value of [analysis_percentage][crate::model::AnalysisRule::analysis_percentage].
    pub fn set_analysis_percentage<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.analysis_percentage = v.into();
        self
    }

    /// Sets the value of [active][crate::model::AnalysisRule::active].
    pub fn set_active<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.active = v.into();
        self
    }
}

impl wkt::message::Message for AnalysisRule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.AnalysisRule"
    }
}

/// A customer-managed encryption key specification that can be applied to all
/// created resources (e.g. `Conversation`).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EncryptionSpec {
    /// Immutable. The resource name of the encryption key specification resource.
    /// Format:
    /// projects/{project}/locations/{location}/encryptionSpec
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The name of customer-managed encryption key that is used to
    /// secure a resource and its sub-resources. If empty, the resource is secured
    /// by our default encryption key. Only the key in the same location as this
    /// resource is allowed to be used for encryption. Format:
    /// `projects/{project}/locations/{location}/keyRings/{keyRing}/cryptoKeys/{key}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EncryptionSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EncryptionSpec::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [kms_key][crate::model::EncryptionSpec::kms_key].
    pub fn set_kms_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key = v.into();
        self
    }
}

impl wkt::message::Message for EncryptionSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.EncryptionSpec"
    }
}

/// DLP resources used for redaction while ingesting conversations.
/// DLP settings are applied to conversations ingested from the
/// `UploadConversation` and `IngestConversations` endpoints, including
/// conversation coming from CCAI Platform. They are not applied to conversations
/// ingested from the `CreateConversation` endpoint or the Dialogflow / Agent
/// Assist runtime integrations. When using Dialogflow / Agent Assist runtime
/// integrations, redaction should be performed in Dialogflow / Agent Assist.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RedactionConfig {
    /// The fully-qualified DLP deidentify template resource name.
    /// Format:
    /// `projects/{project}/deidentifyTemplates/{template}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub deidentify_template: std::string::String,

    /// The fully-qualified DLP inspect template resource name.
    /// Format:
    /// `projects/{project}/locations/{location}/inspectTemplates/{template}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub inspect_template: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RedactionConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [deidentify_template][crate::model::RedactionConfig::deidentify_template].
    pub fn set_deidentify_template<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deidentify_template = v.into();
        self
    }

    /// Sets the value of [inspect_template][crate::model::RedactionConfig::inspect_template].
    pub fn set_inspect_template<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_template = v.into();
        self
    }
}

impl wkt::message::Message for RedactionConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.RedactionConfig"
    }
}

/// Speech-to-Text configuration.
/// Speech-to-Text settings are applied to conversations ingested from the
/// `UploadConversation` and `IngestConversations` endpoints, including
/// conversation coming from CCAI Platform. They are not applied to conversations
/// ingested from the `CreateConversation` endpoint.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SpeechConfig {
    /// The fully-qualified Speech Recognizer resource name.
    /// Format:
    /// `projects/{project_id}/locations/{location}/recognizer/{recognizer}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub speech_recognizer: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SpeechConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [speech_recognizer][crate::model::SpeechConfig::speech_recognizer].
    pub fn set_speech_recognizer<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.speech_recognizer = v.into();
        self
    }
}

impl wkt::message::Message for SpeechConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.SpeechConfig"
    }
}

/// An annotation that was generated during the customer and agent interaction.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RuntimeAnnotation {
    /// The unique identifier of the annotation.
    /// Format:
    /// projects/{project}/locations/{location}/conversationDatasets/{dataset}/conversationDataItems/{data_item}/conversationAnnotations/{annotation}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub annotation_id: std::string::String,

    /// The time at which this annotation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The boundary in the conversation where the annotation starts, inclusive.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_boundary: std::option::Option<crate::model::AnnotationBoundary>,

    /// The boundary in the conversation where the annotation ends, inclusive.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_boundary: std::option::Option<crate::model::AnnotationBoundary>,

    /// The feedback that the customer has about the answer in `data`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub answer_feedback: std::option::Option<crate::model::AnswerFeedback>,

    /// Explicit input used for generating the answer
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub user_input: std::option::Option<crate::model::runtime_annotation::UserInput>,

    /// The data in the annotation.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub data: std::option::Option<crate::model::runtime_annotation::Data>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RuntimeAnnotation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [annotation_id][crate::model::RuntimeAnnotation::annotation_id].
    pub fn set_annotation_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.annotation_id = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::RuntimeAnnotation::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [start_boundary][crate::model::RuntimeAnnotation::start_boundary].
    pub fn set_start_boundary<
        T: std::convert::Into<std::option::Option<crate::model::AnnotationBoundary>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.start_boundary = v.into();
        self
    }

    /// Sets the value of [end_boundary][crate::model::RuntimeAnnotation::end_boundary].
    pub fn set_end_boundary<
        T: std::convert::Into<std::option::Option<crate::model::AnnotationBoundary>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.end_boundary = v.into();
        self
    }

    /// Sets the value of [answer_feedback][crate::model::RuntimeAnnotation::answer_feedback].
    pub fn set_answer_feedback<
        T: std::convert::Into<std::option::Option<crate::model::AnswerFeedback>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.answer_feedback = v.into();
        self
    }

    /// Sets the value of [user_input][crate::model::RuntimeAnnotation::user_input].
    pub fn set_user_input<
        T: std::convert::Into<std::option::Option<crate::model::runtime_annotation::UserInput>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.user_input = v.into();
        self
    }

    /// Sets the value of [data][crate::model::RuntimeAnnotation::data].
    ///
    /// Note that all the setters affecting `data` are mutually
    /// exclusive.
    pub fn set_data<
        T: std::convert::Into<std::option::Option<crate::model::runtime_annotation::Data>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data = v.into();
        self
    }

    /// The value of [data][crate::model::RuntimeAnnotation::data]
    /// if it holds a `ArticleSuggestion`, `None` if the field is not set or
    /// holds a different branch.
    pub fn article_suggestion(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ArticleSuggestionData>> {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::runtime_annotation::Data::ArticleSuggestion(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data][crate::model::RuntimeAnnotation::data]
    /// to hold a `ArticleSuggestion`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_article_suggestion<
        T: std::convert::Into<std::boxed::Box<crate::model::ArticleSuggestionData>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data = std::option::Option::Some(
            crate::model::runtime_annotation::Data::ArticleSuggestion(v.into()),
        );
        self
    }

    /// The value of [data][crate::model::RuntimeAnnotation::data]
    /// if it holds a `FaqAnswer`, `None` if the field is not set or
    /// holds a different branch.
    pub fn faq_answer(&self) -> std::option::Option<&std::boxed::Box<crate::model::FaqAnswerData>> {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::runtime_annotation::Data::FaqAnswer(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data][crate::model::RuntimeAnnotation::data]
    /// to hold a `FaqAnswer`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_faq_answer<T: std::convert::Into<std::boxed::Box<crate::model::FaqAnswerData>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data =
            std::option::Option::Some(crate::model::runtime_annotation::Data::FaqAnswer(v.into()));
        self
    }

    /// The value of [data][crate::model::RuntimeAnnotation::data]
    /// if it holds a `SmartReply`, `None` if the field is not set or
    /// holds a different branch.
    pub fn smart_reply(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SmartReplyData>> {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::runtime_annotation::Data::SmartReply(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data][crate::model::RuntimeAnnotation::data]
    /// to hold a `SmartReply`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_smart_reply<T: std::convert::Into<std::boxed::Box<crate::model::SmartReplyData>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data =
            std::option::Option::Some(crate::model::runtime_annotation::Data::SmartReply(v.into()));
        self
    }

    /// The value of [data][crate::model::RuntimeAnnotation::data]
    /// if it holds a `SmartComposeSuggestion`, `None` if the field is not set or
    /// holds a different branch.
    pub fn smart_compose_suggestion(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SmartComposeSuggestionData>> {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::runtime_annotation::Data::SmartComposeSuggestion(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data][crate::model::RuntimeAnnotation::data]
    /// to hold a `SmartComposeSuggestion`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_smart_compose_suggestion<
        T: std::convert::Into<std::boxed::Box<crate::model::SmartComposeSuggestionData>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data = std::option::Option::Some(
            crate::model::runtime_annotation::Data::SmartComposeSuggestion(v.into()),
        );
        self
    }

    /// The value of [data][crate::model::RuntimeAnnotation::data]
    /// if it holds a `DialogflowInteraction`, `None` if the field is not set or
    /// holds a different branch.
    pub fn dialogflow_interaction(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DialogflowInteractionData>> {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::runtime_annotation::Data::DialogflowInteraction(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data][crate::model::RuntimeAnnotation::data]
    /// to hold a `DialogflowInteraction`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_dialogflow_interaction<
        T: std::convert::Into<std::boxed::Box<crate::model::DialogflowInteractionData>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data = std::option::Option::Some(
            crate::model::runtime_annotation::Data::DialogflowInteraction(v.into()),
        );
        self
    }

    /// The value of [data][crate::model::RuntimeAnnotation::data]
    /// if it holds a `ConversationSummarizationSuggestion`, `None` if the field is not set or
    /// holds a different branch.
    pub fn conversation_summarization_suggestion(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ConversationSummarizationSuggestionData>>
    {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::runtime_annotation::Data::ConversationSummarizationSuggestion(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data][crate::model::RuntimeAnnotation::data]
    /// to hold a `ConversationSummarizationSuggestion`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_conversation_summarization_suggestion<
        T: std::convert::Into<std::boxed::Box<crate::model::ConversationSummarizationSuggestionData>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data = std::option::Option::Some(
            crate::model::runtime_annotation::Data::ConversationSummarizationSuggestion(v.into()),
        );
        self
    }
}

impl wkt::message::Message for RuntimeAnnotation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.RuntimeAnnotation"
    }
}

/// Defines additional types related to [RuntimeAnnotation].
pub mod runtime_annotation {
    #[allow(unused_imports)]
    use super::*;

    /// Explicit input used for generating the answer
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct UserInput {
        /// Query text. Article Search uses this to store the input query used
        /// to generate the search results.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub query: std::string::String,

        /// The resource name of associated generator. Format:
        /// `projects/<Project ID>/locations/<Location ID>/generators/<Generator ID>`
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub generator_name: std::string::String,

        /// Query source for the answer.
        pub query_source: crate::model::runtime_annotation::user_input::QuerySource,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl UserInput {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [query][crate::model::runtime_annotation::UserInput::query].
        pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.query = v.into();
            self
        }

        /// Sets the value of [generator_name][crate::model::runtime_annotation::UserInput::generator_name].
        pub fn set_generator_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.generator_name = v.into();
            self
        }

        /// Sets the value of [query_source][crate::model::runtime_annotation::UserInput::query_source].
        pub fn set_query_source<
            T: std::convert::Into<crate::model::runtime_annotation::user_input::QuerySource>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.query_source = v.into();
            self
        }
    }

    impl wkt::message::Message for UserInput {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.RuntimeAnnotation.UserInput"
        }
    }

    /// Defines additional types related to [UserInput].
    pub mod user_input {
        #[allow(unused_imports)]
        use super::*;

        /// The source of the query.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum QuerySource {
            /// Unknown query source.
            Unspecified,
            /// The query is from agents.
            AgentQuery,
            /// The query is a query from previous suggestions, e.g. from a preceding
            /// SuggestKnowledgeAssist response.
            SuggestedQuery,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [QuerySource::value] or
            /// [QuerySource::name].
            UnknownValue(query_source::UnknownValue),
        }

        #[doc(hidden)]
        pub mod query_source {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl QuerySource {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::AgentQuery => std::option::Option::Some(1),
                    Self::SuggestedQuery => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("QUERY_SOURCE_UNSPECIFIED"),
                    Self::AgentQuery => std::option::Option::Some("AGENT_QUERY"),
                    Self::SuggestedQuery => std::option::Option::Some("SUGGESTED_QUERY"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for QuerySource {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for QuerySource {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for QuerySource {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::AgentQuery,
                    2 => Self::SuggestedQuery,
                    _ => Self::UnknownValue(query_source::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for QuerySource {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "QUERY_SOURCE_UNSPECIFIED" => Self::Unspecified,
                    "AGENT_QUERY" => Self::AgentQuery,
                    "SUGGESTED_QUERY" => Self::SuggestedQuery,
                    _ => Self::UnknownValue(query_source::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for QuerySource {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::AgentQuery => serializer.serialize_i32(1),
                    Self::SuggestedQuery => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for QuerySource {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<QuerySource>::new(
                    ".google.cloud.contactcenterinsights.v1.RuntimeAnnotation.UserInput.QuerySource"))
            }
        }
    }

    /// The data in the annotation.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Data {
        /// Agent Assist Article Suggestion data.
        ArticleSuggestion(std::boxed::Box<crate::model::ArticleSuggestionData>),
        /// Agent Assist FAQ answer data.
        FaqAnswer(std::boxed::Box<crate::model::FaqAnswerData>),
        /// Agent Assist Smart Reply data.
        SmartReply(std::boxed::Box<crate::model::SmartReplyData>),
        /// Agent Assist Smart Compose suggestion data.
        SmartComposeSuggestion(std::boxed::Box<crate::model::SmartComposeSuggestionData>),
        /// Dialogflow interaction data.
        DialogflowInteraction(std::boxed::Box<crate::model::DialogflowInteractionData>),
        /// Conversation summarization suggestion data.
        ConversationSummarizationSuggestion(
            std::boxed::Box<crate::model::ConversationSummarizationSuggestionData>,
        ),
    }
}

/// The feedback that the customer has about a certain answer in the
/// conversation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AnswerFeedback {
    /// The correctness level of an answer.
    pub correctness_level: crate::model::answer_feedback::CorrectnessLevel,

    /// Indicates whether an answer or item was clicked by the human agent.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub clicked: bool,

    /// Indicates whether an answer or item was displayed to the human agent in the
    /// agent desktop UI.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub displayed: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnswerFeedback {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [correctness_level][crate::model::AnswerFeedback::correctness_level].
    pub fn set_correctness_level<
        T: std::convert::Into<crate::model::answer_feedback::CorrectnessLevel>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.correctness_level = v.into();
        self
    }

    /// Sets the value of [clicked][crate::model::AnswerFeedback::clicked].
    pub fn set_clicked<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.clicked = v.into();
        self
    }

    /// Sets the value of [displayed][crate::model::AnswerFeedback::displayed].
    pub fn set_displayed<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.displayed = v.into();
        self
    }
}

impl wkt::message::Message for AnswerFeedback {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.AnswerFeedback"
    }
}

/// Defines additional types related to [AnswerFeedback].
pub mod answer_feedback {
    #[allow(unused_imports)]
    use super::*;

    /// The correctness level of an answer.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CorrectnessLevel {
        /// Correctness level unspecified.
        Unspecified,
        /// Answer is totally wrong.
        NotCorrect,
        /// Answer is partially correct.
        PartiallyCorrect,
        /// Answer is fully correct.
        FullyCorrect,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CorrectnessLevel::value] or
        /// [CorrectnessLevel::name].
        UnknownValue(correctness_level::UnknownValue),
    }

    #[doc(hidden)]
    pub mod correctness_level {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CorrectnessLevel {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::NotCorrect => std::option::Option::Some(1),
                Self::PartiallyCorrect => std::option::Option::Some(2),
                Self::FullyCorrect => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CORRECTNESS_LEVEL_UNSPECIFIED"),
                Self::NotCorrect => std::option::Option::Some("NOT_CORRECT"),
                Self::PartiallyCorrect => std::option::Option::Some("PARTIALLY_CORRECT"),
                Self::FullyCorrect => std::option::Option::Some("FULLY_CORRECT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CorrectnessLevel {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CorrectnessLevel {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CorrectnessLevel {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::NotCorrect,
                2 => Self::PartiallyCorrect,
                3 => Self::FullyCorrect,
                _ => Self::UnknownValue(correctness_level::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CorrectnessLevel {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CORRECTNESS_LEVEL_UNSPECIFIED" => Self::Unspecified,
                "NOT_CORRECT" => Self::NotCorrect,
                "PARTIALLY_CORRECT" => Self::PartiallyCorrect,
                "FULLY_CORRECT" => Self::FullyCorrect,
                _ => Self::UnknownValue(correctness_level::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CorrectnessLevel {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::NotCorrect => serializer.serialize_i32(1),
                Self::PartiallyCorrect => serializer.serialize_i32(2),
                Self::FullyCorrect => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CorrectnessLevel {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CorrectnessLevel>::new(
                ".google.cloud.contactcenterinsights.v1.AnswerFeedback.CorrectnessLevel",
            ))
        }
    }
}

/// Agent Assist Article Suggestion data.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ArticleSuggestionData {
    /// Article title.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub title: std::string::String,

    /// Article URI.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// The system's confidence score that this article is a good match for this
    /// conversation, ranging from 0.0 (completely uncertain) to 1.0 (completely
    /// certain).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F32")]
    pub confidence_score: f32,

    /// Map that contains metadata about the Article Suggestion and the document
    /// that it originates from.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub metadata: std::collections::HashMap<std::string::String, std::string::String>,

    /// The name of the answer record.
    /// Format:
    /// projects/{project}/locations/{location}/answerRecords/{answer_record}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub query_record: std::string::String,

    /// The knowledge document that this answer was extracted from.
    /// Format:
    /// projects/{project}/knowledgeBases/{knowledge_base}/documents/{document}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ArticleSuggestionData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [title][crate::model::ArticleSuggestionData::title].
    pub fn set_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.title = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::ArticleSuggestionData::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [confidence_score][crate::model::ArticleSuggestionData::confidence_score].
    pub fn set_confidence_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.confidence_score = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::ArticleSuggestionData::metadata].
    pub fn set_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [query_record][crate::model::ArticleSuggestionData::query_record].
    pub fn set_query_record<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query_record = v.into();
        self
    }

    /// Sets the value of [source][crate::model::ArticleSuggestionData::source].
    pub fn set_source<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source = v.into();
        self
    }
}

impl wkt::message::Message for ArticleSuggestionData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ArticleSuggestionData"
    }
}

/// Agent Assist frequently-asked-question answer data.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FaqAnswerData {
    /// The piece of text from the `source` knowledge base document.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub answer: std::string::String,

    /// The system's confidence score that this answer is a good match for this
    /// conversation, ranging from 0.0 (completely uncertain) to 1.0 (completely
    /// certain).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F32")]
    pub confidence_score: f32,

    /// The corresponding FAQ question.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub question: std::string::String,

    /// Map that contains metadata about the FAQ answer and the document that
    /// it originates from.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub metadata: std::collections::HashMap<std::string::String, std::string::String>,

    /// The name of the answer record.
    /// Format:
    /// projects/{project}/locations/{location}/answerRecords/{answer_record}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub query_record: std::string::String,

    /// The knowledge document that this answer was extracted from.
    /// Format:
    /// projects/{project}/knowledgeBases/{knowledge_base}/documents/{document}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FaqAnswerData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [answer][crate::model::FaqAnswerData::answer].
    pub fn set_answer<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.answer = v.into();
        self
    }

    /// Sets the value of [confidence_score][crate::model::FaqAnswerData::confidence_score].
    pub fn set_confidence_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.confidence_score = v.into();
        self
    }

    /// Sets the value of [question][crate::model::FaqAnswerData::question].
    pub fn set_question<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.question = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::FaqAnswerData::metadata].
    pub fn set_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [query_record][crate::model::FaqAnswerData::query_record].
    pub fn set_query_record<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query_record = v.into();
        self
    }

    /// Sets the value of [source][crate::model::FaqAnswerData::source].
    pub fn set_source<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source = v.into();
        self
    }
}

impl wkt::message::Message for FaqAnswerData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.FaqAnswerData"
    }
}

/// Agent Assist Smart Reply data.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SmartReplyData {
    /// The content of the reply.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub reply: std::string::String,

    /// The system's confidence score that this reply is a good match for this
    /// conversation, ranging from 0.0 (completely uncertain) to 1.0 (completely
    /// certain).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F64")]
    pub confidence_score: f64,

    /// Map that contains metadata about the Smart Reply and the document from
    /// which it originates.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub metadata: std::collections::HashMap<std::string::String, std::string::String>,

    /// The name of the answer record.
    /// Format:
    /// projects/{project}/locations/{location}/answerRecords/{answer_record}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub query_record: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SmartReplyData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [reply][crate::model::SmartReplyData::reply].
    pub fn set_reply<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.reply = v.into();
        self
    }

    /// Sets the value of [confidence_score][crate::model::SmartReplyData::confidence_score].
    pub fn set_confidence_score<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.confidence_score = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::SmartReplyData::metadata].
    pub fn set_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [query_record][crate::model::SmartReplyData::query_record].
    pub fn set_query_record<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query_record = v.into();
        self
    }
}

impl wkt::message::Message for SmartReplyData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.SmartReplyData"
    }
}

/// Agent Assist Smart Compose suggestion data.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SmartComposeSuggestionData {
    /// The content of the suggestion.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub suggestion: std::string::String,

    /// The system's confidence score that this suggestion is a good match for this
    /// conversation, ranging from 0.0 (completely uncertain) to 1.0 (completely
    /// certain).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F64")]
    pub confidence_score: f64,

    /// Map that contains metadata about the Smart Compose suggestion and the
    /// document from which it originates.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub metadata: std::collections::HashMap<std::string::String, std::string::String>,

    /// The name of the answer record.
    /// Format:
    /// projects/{project}/locations/{location}/answerRecords/{answer_record}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub query_record: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SmartComposeSuggestionData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [suggestion][crate::model::SmartComposeSuggestionData::suggestion].
    pub fn set_suggestion<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.suggestion = v.into();
        self
    }

    /// Sets the value of [confidence_score][crate::model::SmartComposeSuggestionData::confidence_score].
    pub fn set_confidence_score<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.confidence_score = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::SmartComposeSuggestionData::metadata].
    pub fn set_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [query_record][crate::model::SmartComposeSuggestionData::query_record].
    pub fn set_query_record<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query_record = v.into();
        self
    }
}

impl wkt::message::Message for SmartComposeSuggestionData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.SmartComposeSuggestionData"
    }
}

/// Dialogflow interaction data.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DialogflowInteractionData {
    /// The Dialogflow intent resource path. Format:
    /// projects/{project}/agent/{agent}/intents/{intent}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dialogflow_intent_id: std::string::String,

    /// The confidence of the match ranging from 0.0 (completely uncertain) to 1.0
    /// (completely certain).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F32")]
    pub confidence: f32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DialogflowInteractionData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dialogflow_intent_id][crate::model::DialogflowInteractionData::dialogflow_intent_id].
    pub fn set_dialogflow_intent_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.dialogflow_intent_id = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::DialogflowInteractionData::confidence].
    pub fn set_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }
}

impl wkt::message::Message for DialogflowInteractionData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.DialogflowInteractionData"
    }
}

/// Conversation summarization suggestion data.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConversationSummarizationSuggestionData {
    /// The summarization content that is concatenated into one string.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub text: std::string::String,

    /// The summarization content that is divided into sections. The key is the
    /// section's name and the value is the section's content. There is no
    /// specific format for the key or value.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub text_sections: std::collections::HashMap<std::string::String, std::string::String>,

    /// The confidence score of the summarization.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F32")]
    pub confidence: f32,

    /// A map that contains metadata about the summarization and the document
    /// from which it originates.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub metadata: std::collections::HashMap<std::string::String, std::string::String>,

    /// The name of the answer record.
    /// Format:
    /// projects/{project}/locations/{location}/answerRecords/{answer_record}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub answer_record: std::string::String,

    /// The name of the model that generates this summary.
    /// Format:
    /// projects/{project}/locations/{location}/conversationModels/{conversation_model}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub conversation_model: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConversationSummarizationSuggestionData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [text][crate::model::ConversationSummarizationSuggestionData::text].
    pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.text = v.into();
        self
    }

    /// Sets the value of [text_sections][crate::model::ConversationSummarizationSuggestionData::text_sections].
    pub fn set_text_sections<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.text_sections = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [confidence][crate::model::ConversationSummarizationSuggestionData::confidence].
    pub fn set_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::ConversationSummarizationSuggestionData::metadata].
    pub fn set_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [answer_record][crate::model::ConversationSummarizationSuggestionData::answer_record].
    pub fn set_answer_record<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.answer_record = v.into();
        self
    }

    /// Sets the value of [conversation_model][crate::model::ConversationSummarizationSuggestionData::conversation_model].
    pub fn set_conversation_model<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.conversation_model = v.into();
        self
    }
}

impl wkt::message::Message for ConversationSummarizationSuggestionData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ConversationSummarizationSuggestionData"
    }
}

/// The call participant speaking for a given utterance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConversationParticipant {
    /// Deprecated. Use `dialogflow_participant_name` instead.
    /// The name of the Dialogflow participant. Format:
    /// projects/{project}/locations/{location}/conversations/{conversation}/participants/{participant}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub dialogflow_participant: std::string::String,

    /// Obfuscated user ID from Dialogflow.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub obfuscated_external_user_id: std::string::String,

    /// The role of the participant.
    pub role: crate::model::conversation_participant::Role,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub participant: std::option::Option<crate::model::conversation_participant::Participant>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConversationParticipant {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dialogflow_participant][crate::model::ConversationParticipant::dialogflow_participant].
    #[deprecated]
    pub fn set_dialogflow_participant<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.dialogflow_participant = v.into();
        self
    }

    /// Sets the value of [obfuscated_external_user_id][crate::model::ConversationParticipant::obfuscated_external_user_id].
    pub fn set_obfuscated_external_user_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.obfuscated_external_user_id = v.into();
        self
    }

    /// Sets the value of [role][crate::model::ConversationParticipant::role].
    pub fn set_role<T: std::convert::Into<crate::model::conversation_participant::Role>>(
        mut self,
        v: T,
    ) -> Self {
        self.role = v.into();
        self
    }

    /// Sets the value of [participant][crate::model::ConversationParticipant::participant].
    ///
    /// Note that all the setters affecting `participant` are mutually
    /// exclusive.
    pub fn set_participant<
        T: std::convert::Into<
                std::option::Option<crate::model::conversation_participant::Participant>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.participant = v.into();
        self
    }

    /// The value of [participant][crate::model::ConversationParticipant::participant]
    /// if it holds a `DialogflowParticipantName`, `None` if the field is not set or
    /// holds a different branch.
    pub fn dialogflow_participant_name(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.participant.as_ref().and_then(|v| match v {
            crate::model::conversation_participant::Participant::DialogflowParticipantName(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [participant][crate::model::ConversationParticipant::participant]
    /// to hold a `DialogflowParticipantName`.
    ///
    /// Note that all the setters affecting `participant` are
    /// mutually exclusive.
    pub fn set_dialogflow_participant_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.participant = std::option::Option::Some(
            crate::model::conversation_participant::Participant::DialogflowParticipantName(
                v.into(),
            ),
        );
        self
    }

    /// The value of [participant][crate::model::ConversationParticipant::participant]
    /// if it holds a `UserId`, `None` if the field is not set or
    /// holds a different branch.
    pub fn user_id(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.participant.as_ref().and_then(|v| match v {
            crate::model::conversation_participant::Participant::UserId(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [participant][crate::model::ConversationParticipant::participant]
    /// to hold a `UserId`.
    ///
    /// Note that all the setters affecting `participant` are
    /// mutually exclusive.
    pub fn set_user_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.participant = std::option::Option::Some(
            crate::model::conversation_participant::Participant::UserId(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ConversationParticipant {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.ConversationParticipant"
    }
}

/// Defines additional types related to [ConversationParticipant].
pub mod conversation_participant {
    #[allow(unused_imports)]
    use super::*;

    /// The role of the participant.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Role {
        /// Participant's role is not set.
        Unspecified,
        /// Participant is a human agent.
        HumanAgent,
        /// Participant is an automated agent.
        AutomatedAgent,
        /// Participant is an end user who conversed with the contact center.
        EndUser,
        /// Participant is either a human or automated agent.
        AnyAgent,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Role::value] or
        /// [Role::name].
        UnknownValue(role::UnknownValue),
    }

    #[doc(hidden)]
    pub mod role {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Role {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::HumanAgent => std::option::Option::Some(1),
                Self::AutomatedAgent => std::option::Option::Some(2),
                Self::EndUser => std::option::Option::Some(3),
                Self::AnyAgent => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ROLE_UNSPECIFIED"),
                Self::HumanAgent => std::option::Option::Some("HUMAN_AGENT"),
                Self::AutomatedAgent => std::option::Option::Some("AUTOMATED_AGENT"),
                Self::EndUser => std::option::Option::Some("END_USER"),
                Self::AnyAgent => std::option::Option::Some("ANY_AGENT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Role {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Role {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Role {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::HumanAgent,
                2 => Self::AutomatedAgent,
                3 => Self::EndUser,
                4 => Self::AnyAgent,
                _ => Self::UnknownValue(role::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Role {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ROLE_UNSPECIFIED" => Self::Unspecified,
                "HUMAN_AGENT" => Self::HumanAgent,
                "AUTOMATED_AGENT" => Self::AutomatedAgent,
                "END_USER" => Self::EndUser,
                "ANY_AGENT" => Self::AnyAgent,
                _ => Self::UnknownValue(role::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Role {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::HumanAgent => serializer.serialize_i32(1),
                Self::AutomatedAgent => serializer.serialize_i32(2),
                Self::EndUser => serializer.serialize_i32(3),
                Self::AnyAgent => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Role {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Role>::new(
                ".google.cloud.contactcenterinsights.v1.ConversationParticipant.Role",
            ))
        }
    }

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Participant {
        /// The name of the participant provided by Dialogflow. Format:
        /// projects/{project}/locations/{location}/conversations/{conversation}/participants/{participant}
        DialogflowParticipantName(std::string::String),
        /// A user-specified ID representing the participant.
        UserId(std::string::String),
    }
}

/// The View resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct View {
    /// Immutable. The resource name of the view.
    /// Format:
    /// projects/{project}/locations/{location}/views/{view}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The human-readable display name of the view.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. The time at which this view was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The most recent time at which the view was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// String with specific view properties, must be non-empty.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub value: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl View {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::View::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::View::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::View::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::View::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [value][crate::model::View::value].
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }
}

impl wkt::message::Message for View {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.View"
    }
}

/// Selector of all available annotators and phrase matchers to run.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AnnotatorSelector {
    /// Whether to run the interruption annotator.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub run_interruption_annotator: bool,

    /// Whether to run the silence annotator.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub run_silence_annotator: bool,

    /// Whether to run the active phrase matcher annotator(s).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub run_phrase_matcher_annotator: bool,

    /// The list of phrase matchers to run. If not provided, all active phrase
    /// matchers will be used. If inactive phrase matchers are provided, they will
    /// not be used. Phrase matchers will be run only if
    /// run_phrase_matcher_annotator is set to true. Format:
    /// projects/{project}/locations/{location}/phraseMatchers/{phrase_matcher}
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub phrase_matchers: std::vec::Vec<std::string::String>,

    /// Whether to run the sentiment annotator.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub run_sentiment_annotator: bool,

    /// Whether to run the entity annotator.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub run_entity_annotator: bool,

    /// Whether to run the intent annotator.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub run_intent_annotator: bool,

    /// Whether to run the issue model annotator. A model should have already been
    /// deployed for this to take effect.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub run_issue_model_annotator: bool,

    /// The issue model to run. If not provided, the most recently deployed topic
    /// model will be used. The provided issue model will only be used for
    /// inference if the issue model is deployed and if run_issue_model_annotator
    /// is set to true. If more than one issue model is provided, only the first
    /// provided issue model will be used for inference.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub issue_models: std::vec::Vec<std::string::String>,

    /// Whether to run the summarization annotator.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub run_summarization_annotator: bool,

    /// Configuration for the summarization annotator.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub summarization_config:
        std::option::Option<crate::model::annotator_selector::SummarizationConfig>,

    /// Whether to run the QA annotator.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub run_qa_annotator: bool,

    /// Configuration for the QA annotator.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub qa_config: std::option::Option<crate::model::annotator_selector::QaConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnnotatorSelector {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [run_interruption_annotator][crate::model::AnnotatorSelector::run_interruption_annotator].
    pub fn set_run_interruption_annotator<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.run_interruption_annotator = v.into();
        self
    }

    /// Sets the value of [run_silence_annotator][crate::model::AnnotatorSelector::run_silence_annotator].
    pub fn set_run_silence_annotator<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.run_silence_annotator = v.into();
        self
    }

    /// Sets the value of [run_phrase_matcher_annotator][crate::model::AnnotatorSelector::run_phrase_matcher_annotator].
    pub fn set_run_phrase_matcher_annotator<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.run_phrase_matcher_annotator = v.into();
        self
    }

    /// Sets the value of [phrase_matchers][crate::model::AnnotatorSelector::phrase_matchers].
    pub fn set_phrase_matchers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.phrase_matchers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [run_sentiment_annotator][crate::model::AnnotatorSelector::run_sentiment_annotator].
    pub fn set_run_sentiment_annotator<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.run_sentiment_annotator = v.into();
        self
    }

    /// Sets the value of [run_entity_annotator][crate::model::AnnotatorSelector::run_entity_annotator].
    pub fn set_run_entity_annotator<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.run_entity_annotator = v.into();
        self
    }

    /// Sets the value of [run_intent_annotator][crate::model::AnnotatorSelector::run_intent_annotator].
    pub fn set_run_intent_annotator<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.run_intent_annotator = v.into();
        self
    }

    /// Sets the value of [run_issue_model_annotator][crate::model::AnnotatorSelector::run_issue_model_annotator].
    pub fn set_run_issue_model_annotator<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.run_issue_model_annotator = v.into();
        self
    }

    /// Sets the value of [issue_models][crate::model::AnnotatorSelector::issue_models].
    pub fn set_issue_models<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.issue_models = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [run_summarization_annotator][crate::model::AnnotatorSelector::run_summarization_annotator].
    pub fn set_run_summarization_annotator<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.run_summarization_annotator = v.into();
        self
    }

    /// Sets the value of [summarization_config][crate::model::AnnotatorSelector::summarization_config].
    pub fn set_summarization_config<
        T: std::convert::Into<
                std::option::Option<crate::model::annotator_selector::SummarizationConfig>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.summarization_config = v.into();
        self
    }

    /// Sets the value of [run_qa_annotator][crate::model::AnnotatorSelector::run_qa_annotator].
    pub fn set_run_qa_annotator<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.run_qa_annotator = v.into();
        self
    }

    /// Sets the value of [qa_config][crate::model::AnnotatorSelector::qa_config].
    pub fn set_qa_config<
        T: std::convert::Into<std::option::Option<crate::model::annotator_selector::QaConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.qa_config = v.into();
        self
    }
}

impl wkt::message::Message for AnnotatorSelector {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.AnnotatorSelector"
    }
}

/// Defines additional types related to [AnnotatorSelector].
pub mod annotator_selector {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration for summarization.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SummarizationConfig {
        /// Summarization must use either a preexisting conversation profile or one
        /// of the supported default models.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub model_source: std::option::Option<
            crate::model::annotator_selector::summarization_config::ModelSource,
        >,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SummarizationConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [model_source][crate::model::annotator_selector::SummarizationConfig::model_source].
        ///
        /// Note that all the setters affecting `model_source` are mutually
        /// exclusive.
        pub fn set_model_source<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::annotator_selector::summarization_config::ModelSource,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.model_source = v.into();
            self
        }

        /// The value of [model_source][crate::model::annotator_selector::SummarizationConfig::model_source]
        /// if it holds a `ConversationProfile`, `None` if the field is not set or
        /// holds a different branch.
        pub fn conversation_profile(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.model_source.as_ref().and_then(|v| match v {
                crate::model::annotator_selector::summarization_config::ModelSource::ConversationProfile(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [model_source][crate::model::annotator_selector::SummarizationConfig::model_source]
        /// to hold a `ConversationProfile`.
        ///
        /// Note that all the setters affecting `model_source` are
        /// mutually exclusive.
        pub fn set_conversation_profile<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.model_source = std::option::Option::Some(
                crate::model::annotator_selector::summarization_config::ModelSource::ConversationProfile(
                    v.into()
                )
            );
            self
        }

        /// The value of [model_source][crate::model::annotator_selector::SummarizationConfig::model_source]
        /// if it holds a `SummarizationModel`, `None` if the field is not set or
        /// holds a different branch.
        pub fn summarization_model(
            &self,
        ) -> std::option::Option<
            &crate::model::annotator_selector::summarization_config::SummarizationModel,
        > {
            #[allow(unreachable_patterns)]
            self.model_source.as_ref().and_then(|v| match v {
                crate::model::annotator_selector::summarization_config::ModelSource::SummarizationModel(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [model_source][crate::model::annotator_selector::SummarizationConfig::model_source]
        /// to hold a `SummarizationModel`.
        ///
        /// Note that all the setters affecting `model_source` are
        /// mutually exclusive.
        pub fn set_summarization_model<
            T: std::convert::Into<
                    crate::model::annotator_selector::summarization_config::SummarizationModel,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.model_source = std::option::Option::Some(
                crate::model::annotator_selector::summarization_config::ModelSource::SummarizationModel(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for SummarizationConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.AnnotatorSelector.SummarizationConfig"
        }
    }

    /// Defines additional types related to [SummarizationConfig].
    pub mod summarization_config {
        #[allow(unused_imports)]
        use super::*;

        /// Summarization model to use, if `conversation_profile` is not used.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum SummarizationModel {
            /// Unspecified summarization model.
            Unspecified,
            /// The CCAI baseline model.
            BaselineModel,
            /// The CCAI baseline model, V2.0.
            BaselineModelV20,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [SummarizationModel::value] or
            /// [SummarizationModel::name].
            UnknownValue(summarization_model::UnknownValue),
        }

        #[doc(hidden)]
        pub mod summarization_model {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl SummarizationModel {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::BaselineModel => std::option::Option::Some(1),
                    Self::BaselineModelV20 => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => {
                        std::option::Option::Some("SUMMARIZATION_MODEL_UNSPECIFIED")
                    }
                    Self::BaselineModel => std::option::Option::Some("BASELINE_MODEL"),
                    Self::BaselineModelV20 => std::option::Option::Some("BASELINE_MODEL_V2_0"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for SummarizationModel {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for SummarizationModel {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for SummarizationModel {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::BaselineModel,
                    2 => Self::BaselineModelV20,
                    _ => Self::UnknownValue(summarization_model::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for SummarizationModel {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "SUMMARIZATION_MODEL_UNSPECIFIED" => Self::Unspecified,
                    "BASELINE_MODEL" => Self::BaselineModel,
                    "BASELINE_MODEL_V2_0" => Self::BaselineModelV20,
                    _ => Self::UnknownValue(summarization_model::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for SummarizationModel {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::BaselineModel => serializer.serialize_i32(1),
                    Self::BaselineModelV20 => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for SummarizationModel {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<SummarizationModel>::new(
                    ".google.cloud.contactcenterinsights.v1.AnnotatorSelector.SummarizationConfig.SummarizationModel"))
            }
        }

        /// Summarization must use either a preexisting conversation profile or one
        /// of the supported default models.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum ModelSource {
            /// Resource name of the Dialogflow conversation profile.
            /// Format:
            /// projects/{project}/locations/{location}/conversationProfiles/{conversation_profile}
            ConversationProfile(std::string::String),
            /// Default summarization model to be used.
            SummarizationModel(
                crate::model::annotator_selector::summarization_config::SummarizationModel,
            ),
        }
    }

    /// Configuration for the QA feature.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct QaConfig {
        /// Which scorecards should be scored.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub scorecard_source:
            std::option::Option<crate::model::annotator_selector::qa_config::ScorecardSource>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl QaConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [scorecard_source][crate::model::annotator_selector::QaConfig::scorecard_source].
        ///
        /// Note that all the setters affecting `scorecard_source` are mutually
        /// exclusive.
        pub fn set_scorecard_source<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::annotator_selector::qa_config::ScorecardSource,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.scorecard_source = v.into();
            self
        }

        /// The value of [scorecard_source][crate::model::annotator_selector::QaConfig::scorecard_source]
        /// if it holds a `ScorecardList`, `None` if the field is not set or
        /// holds a different branch.
        pub fn scorecard_list(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::annotator_selector::qa_config::ScorecardList>,
        > {
            #[allow(unreachable_patterns)]
            self.scorecard_source.as_ref().and_then(|v| match v {
                crate::model::annotator_selector::qa_config::ScorecardSource::ScorecardList(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [scorecard_source][crate::model::annotator_selector::QaConfig::scorecard_source]
        /// to hold a `ScorecardList`.
        ///
        /// Note that all the setters affecting `scorecard_source` are
        /// mutually exclusive.
        pub fn set_scorecard_list<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::annotator_selector::qa_config::ScorecardList>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.scorecard_source = std::option::Option::Some(
                crate::model::annotator_selector::qa_config::ScorecardSource::ScorecardList(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for QaConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.AnnotatorSelector.QaConfig"
        }
    }

    /// Defines additional types related to [QaConfig].
    pub mod qa_config {
        #[allow(unused_imports)]
        use super::*;

        /// Container for a list of scorecards.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct ScorecardList {
            /// List of QaScorecardRevisions.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub qa_scorecard_revisions: std::vec::Vec<std::string::String>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl ScorecardList {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [qa_scorecard_revisions][crate::model::annotator_selector::qa_config::ScorecardList::qa_scorecard_revisions].
            pub fn set_qa_scorecard_revisions<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.qa_scorecard_revisions = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for ScorecardList {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.contactcenterinsights.v1.AnnotatorSelector.QaConfig.ScorecardList"
            }
        }

        /// Which scorecards should be scored.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum ScorecardSource {
            /// A manual list of scorecards to score.
            ScorecardList(
                std::boxed::Box<crate::model::annotator_selector::qa_config::ScorecardList>,
            ),
        }
    }
}

/// A single question to be scored by the Insights QA feature.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QaQuestion {
    /// Identifier. The resource name of the question.
    /// Format:
    /// projects/{project}/locations/{location}/qaScorecards/{qa_scorecard}/revisions/{revision}/qaQuestions/{qa_question}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Short, descriptive string, used in the UI where it's not practical
    /// to display the full question body. E.g., "Greeting".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub abbreviation: std::string::String,

    /// Output only. The time at which this question was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The most recent time at which the question was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Question text. E.g., "Did the agent greet the customer?"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub question_body: std::string::String,

    /// Instructions describing how to determine the answer.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub answer_instructions: std::string::String,

    /// A list of valid answers to the question, which the LLM must choose from.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub answer_choices: std::vec::Vec<crate::model::qa_question::AnswerChoice>,

    /// User-defined list of arbitrary tags for the question. Used for
    /// grouping/organization and for weighting the score of each question.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tags: std::vec::Vec<std::string::String>,

    /// Defines the order of the question within its parent scorecard revision.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub order: i32,

    /// Metrics of the underlying tuned LLM over a holdout/test set while fine
    /// tuning the underlying LLM for the given question. This field will only be
    /// populated if and only if the question is part of a scorecard revision that
    /// has been tuned.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metrics: std::option::Option<crate::model::qa_question::Metrics>,

    /// Metadata about the tuning operation for the question.This field will only
    /// be populated if and only if the question is part of a scorecard revision
    /// that has been tuned.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub tuning_metadata: std::option::Option<crate::model::qa_question::TuningMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QaQuestion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::QaQuestion::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [abbreviation][crate::model::QaQuestion::abbreviation].
    pub fn set_abbreviation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.abbreviation = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::QaQuestion::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::QaQuestion::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [question_body][crate::model::QaQuestion::question_body].
    pub fn set_question_body<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.question_body = v.into();
        self
    }

    /// Sets the value of [answer_instructions][crate::model::QaQuestion::answer_instructions].
    pub fn set_answer_instructions<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.answer_instructions = v.into();
        self
    }

    /// Sets the value of [answer_choices][crate::model::QaQuestion::answer_choices].
    pub fn set_answer_choices<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::qa_question::AnswerChoice>,
    {
        use std::iter::Iterator;
        self.answer_choices = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [tags][crate::model::QaQuestion::tags].
    pub fn set_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [order][crate::model::QaQuestion::order].
    pub fn set_order<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.order = v.into();
        self
    }

    /// Sets the value of [metrics][crate::model::QaQuestion::metrics].
    pub fn set_metrics<
        T: std::convert::Into<std::option::Option<crate::model::qa_question::Metrics>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metrics = v.into();
        self
    }

    /// Sets the value of [tuning_metadata][crate::model::QaQuestion::tuning_metadata].
    pub fn set_tuning_metadata<
        T: std::convert::Into<std::option::Option<crate::model::qa_question::TuningMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tuning_metadata = v.into();
        self
    }
}

impl wkt::message::Message for QaQuestion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.QaQuestion"
    }
}

/// Defines additional types related to [QaQuestion].
pub mod qa_question {
    #[allow(unused_imports)]
    use super::*;

    /// Message representing a possible answer to the question.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct AnswerChoice {
        /// A short string used as an identifier.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub key: std::string::String,

        /// Numerical score of the answer, used for generating the overall score of
        /// a QaScorecardResult. If the answer uses na_value, this field is unused.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        #[serde_as(as = "std::option::Option<wkt::internal::F64>")]
        pub score: std::option::Option<f64>,

        /// The answer value may be one of a few different types.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub value: std::option::Option<crate::model::qa_question::answer_choice::Value>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AnswerChoice {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [key][crate::model::qa_question::AnswerChoice::key].
        pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.key = v.into();
            self
        }

        /// Sets the value of [score][crate::model::qa_question::AnswerChoice::score].
        pub fn set_score<T: std::convert::Into<std::option::Option<f64>>>(mut self, v: T) -> Self {
            self.score = v.into();
            self
        }

        /// Sets the value of [value][crate::model::qa_question::AnswerChoice::value].
        ///
        /// Note that all the setters affecting `value` are mutually
        /// exclusive.
        pub fn set_value<
            T: std::convert::Into<
                    std::option::Option<crate::model::qa_question::answer_choice::Value>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.value = v.into();
            self
        }

        /// The value of [value][crate::model::qa_question::AnswerChoice::value]
        /// if it holds a `StrValue`, `None` if the field is not set or
        /// holds a different branch.
        pub fn str_value(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::qa_question::answer_choice::Value::StrValue(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value][crate::model::qa_question::AnswerChoice::value]
        /// to hold a `StrValue`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_str_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.value = std::option::Option::Some(
                crate::model::qa_question::answer_choice::Value::StrValue(v.into()),
            );
            self
        }

        /// The value of [value][crate::model::qa_question::AnswerChoice::value]
        /// if it holds a `NumValue`, `None` if the field is not set or
        /// holds a different branch.
        pub fn num_value(&self) -> std::option::Option<&f64> {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::qa_question::answer_choice::Value::NumValue(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value][crate::model::qa_question::AnswerChoice::value]
        /// to hold a `NumValue`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_num_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.value = std::option::Option::Some(
                crate::model::qa_question::answer_choice::Value::NumValue(v.into()),
            );
            self
        }

        /// The value of [value][crate::model::qa_question::AnswerChoice::value]
        /// if it holds a `BoolValue`, `None` if the field is not set or
        /// holds a different branch.
        pub fn bool_value(&self) -> std::option::Option<&bool> {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::qa_question::answer_choice::Value::BoolValue(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value][crate::model::qa_question::AnswerChoice::value]
        /// to hold a `BoolValue`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_bool_value<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.value = std::option::Option::Some(
                crate::model::qa_question::answer_choice::Value::BoolValue(v.into()),
            );
            self
        }

        /// The value of [value][crate::model::qa_question::AnswerChoice::value]
        /// if it holds a `NaValue`, `None` if the field is not set or
        /// holds a different branch.
        pub fn na_value(&self) -> std::option::Option<&bool> {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::qa_question::answer_choice::Value::NaValue(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value][crate::model::qa_question::AnswerChoice::value]
        /// to hold a `NaValue`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_na_value<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.value = std::option::Option::Some(
                crate::model::qa_question::answer_choice::Value::NaValue(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for AnswerChoice {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.QaQuestion.AnswerChoice"
        }
    }

    /// Defines additional types related to [AnswerChoice].
    pub mod answer_choice {
        #[allow(unused_imports)]
        use super::*;

        /// The answer value may be one of a few different types.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Value {
            /// String value.
            StrValue(std::string::String),
            /// Numerical value.
            NumValue(f64),
            /// Boolean value.
            BoolValue(bool),
            /// A value of "Not Applicable (N/A)". If provided, this field may only
            /// be set to `true`. If a question receives this answer, it will be
            /// excluded from any score calculations.
            NaValue(bool),
        }
    }

    /// A wrapper representing metrics calculated against a test-set on a LLM that
    /// was fine tuned for this question.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Metrics {
        /// Output only. Accuracy of the model. Measures the percentage of correct
        /// answers the model gave on the test set.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "wkt::internal::F64")]
        pub accuracy: f64,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Metrics {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [accuracy][crate::model::qa_question::Metrics::accuracy].
        pub fn set_accuracy<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.accuracy = v.into();
            self
        }
    }

    impl wkt::message::Message for Metrics {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.QaQuestion.Metrics"
        }
    }

    /// Metadata about the tuning operation for the question. Will only be set if a
    /// scorecard containing this question has been tuned.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct TuningMetadata {
        /// Total number of valid labels provided for the question at the time of
        /// tuining.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub total_valid_label_count: i64,

        /// A list of any applicable data validation warnings about the question's
        /// feedback labels.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub dataset_validation_warnings: std::vec::Vec<crate::model::DatasetValidationWarning>,

        /// Error status of the tuning operation for the question. Will only be set
        /// if the tuning operation failed.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub tuning_error: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TuningMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [total_valid_label_count][crate::model::qa_question::TuningMetadata::total_valid_label_count].
        pub fn set_total_valid_label_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.total_valid_label_count = v.into();
            self
        }

        /// Sets the value of [dataset_validation_warnings][crate::model::qa_question::TuningMetadata::dataset_validation_warnings].
        pub fn set_dataset_validation_warnings<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::DatasetValidationWarning>,
        {
            use std::iter::Iterator;
            self.dataset_validation_warnings = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [tuning_error][crate::model::qa_question::TuningMetadata::tuning_error].
        pub fn set_tuning_error<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.tuning_error = v.into();
            self
        }
    }

    impl wkt::message::Message for TuningMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.QaQuestion.TuningMetadata"
        }
    }
}

/// A QaScorecard represents a collection of questions to be scored during
/// analysis.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QaScorecard {
    /// Identifier. The scorecard name.
    /// Format:
    /// projects/{project}/locations/{location}/qaScorecards/{qa_scorecard}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The user-specified display name of the scorecard.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// A text description explaining the intent of the scorecard.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. The time at which this scorecard was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The most recent time at which the scorecard was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QaScorecard {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::QaScorecard::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::QaScorecard::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::QaScorecard::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::QaScorecard::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::QaScorecard::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }
}

impl wkt::message::Message for QaScorecard {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.QaScorecard"
    }
}

/// A revision of a QaScorecard.
///
/// Modifying published scorecard fields would invalidate existing scorecard
/// results — the questions may have changed, or the score weighting will make
/// existing scores impossible to understand. So changes must create a new
/// revision, rather than modifying the existing resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QaScorecardRevision {
    /// Identifier. The name of the scorecard revision.
    /// Format:
    /// projects/{project}/locations/{location}/qaScorecards/{qa_scorecard}/revisions/{revision}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The snapshot of the scorecard at the time of this revision's creation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub snapshot: std::option::Option<crate::model::QaScorecard>,

    /// Output only. The timestamp that the revision was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Alternative IDs for this revision of the scorecard, e.g.,
    /// `latest`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub alternate_ids: std::vec::Vec<std::string::String>,

    /// Output only. State of the scorecard revision, indicating whether it's ready
    /// to be used in analysis.
    pub state: crate::model::qa_scorecard_revision::State,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QaScorecardRevision {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::QaScorecardRevision::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [snapshot][crate::model::QaScorecardRevision::snapshot].
    pub fn set_snapshot<T: std::convert::Into<std::option::Option<crate::model::QaScorecard>>>(
        mut self,
        v: T,
    ) -> Self {
        self.snapshot = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::QaScorecardRevision::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [alternate_ids][crate::model::QaScorecardRevision::alternate_ids].
    pub fn set_alternate_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.alternate_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [state][crate::model::QaScorecardRevision::state].
    pub fn set_state<T: std::convert::Into<crate::model::qa_scorecard_revision::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }
}

impl wkt::message::Message for QaScorecardRevision {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.QaScorecardRevision"
    }
}

/// Defines additional types related to [QaScorecardRevision].
pub mod qa_scorecard_revision {
    #[allow(unused_imports)]
    use super::*;

    /// Enum representing the set of states a scorecard revision may be in.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified.
        Unspecified,
        /// The scorecard revision can be edited.
        Editable,
        /// Scorecard model training is in progress.
        Training,
        /// Scorecard revision model training failed.
        TrainingFailed,
        /// The revision can be used in analysis.
        Ready,
        /// Scorecard is being deleted.
        Deleting,
        /// Scorecard model training was explicitly cancelled by the user.
        TrainingCancelled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Editable => std::option::Option::Some(12),
                Self::Training => std::option::Option::Some(2),
                Self::TrainingFailed => std::option::Option::Some(9),
                Self::Ready => std::option::Option::Some(11),
                Self::Deleting => std::option::Option::Some(7),
                Self::TrainingCancelled => std::option::Option::Some(14),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Editable => std::option::Option::Some("EDITABLE"),
                Self::Training => std::option::Option::Some("TRAINING"),
                Self::TrainingFailed => std::option::Option::Some("TRAINING_FAILED"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::TrainingCancelled => std::option::Option::Some("TRAINING_CANCELLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                2 => Self::Training,
                7 => Self::Deleting,
                9 => Self::TrainingFailed,
                11 => Self::Ready,
                12 => Self::Editable,
                14 => Self::TrainingCancelled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "EDITABLE" => Self::Editable,
                "TRAINING" => Self::Training,
                "TRAINING_FAILED" => Self::TrainingFailed,
                "READY" => Self::Ready,
                "DELETING" => Self::Deleting,
                "TRAINING_CANCELLED" => Self::TrainingCancelled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Editable => serializer.serialize_i32(12),
                Self::Training => serializer.serialize_i32(2),
                Self::TrainingFailed => serializer.serialize_i32(9),
                Self::Ready => serializer.serialize_i32(11),
                Self::Deleting => serializer.serialize_i32(7),
                Self::TrainingCancelled => serializer.serialize_i32(14),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.contactcenterinsights.v1.QaScorecardRevision.State",
            ))
        }
    }
}

/// An answer to a QaQuestion.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QaAnswer {
    /// The QaQuestion answered by this answer.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub qa_question: std::string::String,

    /// The conversation the answer applies to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub conversation: std::string::String,

    /// Question text. E.g., "Did the agent greet the customer?"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub question_body: std::string::String,

    /// The main answer value, incorporating any manual edits if they exist.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub answer_value: std::option::Option<crate::model::qa_answer::AnswerValue>,

    /// User-defined list of arbitrary tags. Matches the value from
    /// QaScorecard.ScorecardQuestion.tags. Used for grouping/organization and
    /// for weighting the score of each answer.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tags: std::vec::Vec<std::string::String>,

    /// List of all individual answers given to the question.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub answer_sources: std::vec::Vec<crate::model::qa_answer::AnswerSource>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QaAnswer {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [qa_question][crate::model::QaAnswer::qa_question].
    pub fn set_qa_question<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.qa_question = v.into();
        self
    }

    /// Sets the value of [conversation][crate::model::QaAnswer::conversation].
    pub fn set_conversation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.conversation = v.into();
        self
    }

    /// Sets the value of [question_body][crate::model::QaAnswer::question_body].
    pub fn set_question_body<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.question_body = v.into();
        self
    }

    /// Sets the value of [answer_value][crate::model::QaAnswer::answer_value].
    pub fn set_answer_value<
        T: std::convert::Into<std::option::Option<crate::model::qa_answer::AnswerValue>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.answer_value = v.into();
        self
    }

    /// Sets the value of [tags][crate::model::QaAnswer::tags].
    pub fn set_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [answer_sources][crate::model::QaAnswer::answer_sources].
    pub fn set_answer_sources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::qa_answer::AnswerSource>,
    {
        use std::iter::Iterator;
        self.answer_sources = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for QaAnswer {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.QaAnswer"
    }
}

/// Defines additional types related to [QaAnswer].
pub mod qa_answer {
    #[allow(unused_imports)]
    use super::*;

    /// Message for holding the value of a
    /// [QaAnswer][google.cloud.contactcenterinsights.v1.QaAnswer].
    /// [QaQuestion.AnswerChoice][google.cloud.contactcenterinsights.v1.QaQuestion.AnswerChoice]
    /// defines the possible answer values for a question.
    ///
    /// [google.cloud.contactcenterinsights.v1.QaAnswer]: crate::model::QaAnswer
    /// [google.cloud.contactcenterinsights.v1.QaQuestion.AnswerChoice]: crate::model::qa_question::AnswerChoice
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct AnswerValue {
        /// A short string used as an identifier. Matches the value used in
        /// QaQuestion.AnswerChoice.key.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub key: std::string::String,

        /// Output only. Numerical score of the answer.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        #[serde_as(as = "std::option::Option<wkt::internal::F64>")]
        pub score: std::option::Option<f64>,

        /// Output only. The maximum potential score of the question.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        #[serde_as(as = "std::option::Option<wkt::internal::F64>")]
        pub potential_score: std::option::Option<f64>,

        /// Output only. Normalized score of the questions. Calculated as score /
        /// potential_score.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        #[serde_as(as = "std::option::Option<wkt::internal::F64>")]
        pub normalized_score: std::option::Option<f64>,

        /// The answer value may be one of a few different types.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub value: std::option::Option<crate::model::qa_answer::answer_value::Value>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AnswerValue {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [key][crate::model::qa_answer::AnswerValue::key].
        pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.key = v.into();
            self
        }

        /// Sets the value of [score][crate::model::qa_answer::AnswerValue::score].
        pub fn set_score<T: std::convert::Into<std::option::Option<f64>>>(mut self, v: T) -> Self {
            self.score = v.into();
            self
        }

        /// Sets the value of [potential_score][crate::model::qa_answer::AnswerValue::potential_score].
        pub fn set_potential_score<T: std::convert::Into<std::option::Option<f64>>>(
            mut self,
            v: T,
        ) -> Self {
            self.potential_score = v.into();
            self
        }

        /// Sets the value of [normalized_score][crate::model::qa_answer::AnswerValue::normalized_score].
        pub fn set_normalized_score<T: std::convert::Into<std::option::Option<f64>>>(
            mut self,
            v: T,
        ) -> Self {
            self.normalized_score = v.into();
            self
        }

        /// Sets the value of [value][crate::model::qa_answer::AnswerValue::value].
        ///
        /// Note that all the setters affecting `value` are mutually
        /// exclusive.
        pub fn set_value<
            T: std::convert::Into<std::option::Option<crate::model::qa_answer::answer_value::Value>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.value = v.into();
            self
        }

        /// The value of [value][crate::model::qa_answer::AnswerValue::value]
        /// if it holds a `StrValue`, `None` if the field is not set or
        /// holds a different branch.
        pub fn str_value(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::qa_answer::answer_value::Value::StrValue(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value][crate::model::qa_answer::AnswerValue::value]
        /// to hold a `StrValue`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_str_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.value = std::option::Option::Some(
                crate::model::qa_answer::answer_value::Value::StrValue(v.into()),
            );
            self
        }

        /// The value of [value][crate::model::qa_answer::AnswerValue::value]
        /// if it holds a `NumValue`, `None` if the field is not set or
        /// holds a different branch.
        pub fn num_value(&self) -> std::option::Option<&f64> {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::qa_answer::answer_value::Value::NumValue(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value][crate::model::qa_answer::AnswerValue::value]
        /// to hold a `NumValue`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_num_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.value = std::option::Option::Some(
                crate::model::qa_answer::answer_value::Value::NumValue(v.into()),
            );
            self
        }

        /// The value of [value][crate::model::qa_answer::AnswerValue::value]
        /// if it holds a `BoolValue`, `None` if the field is not set or
        /// holds a different branch.
        pub fn bool_value(&self) -> std::option::Option<&bool> {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::qa_answer::answer_value::Value::BoolValue(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value][crate::model::qa_answer::AnswerValue::value]
        /// to hold a `BoolValue`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_bool_value<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.value = std::option::Option::Some(
                crate::model::qa_answer::answer_value::Value::BoolValue(v.into()),
            );
            self
        }

        /// The value of [value][crate::model::qa_answer::AnswerValue::value]
        /// if it holds a `NaValue`, `None` if the field is not set or
        /// holds a different branch.
        pub fn na_value(&self) -> std::option::Option<&bool> {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::qa_answer::answer_value::Value::NaValue(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value][crate::model::qa_answer::AnswerValue::value]
        /// to hold a `NaValue`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_na_value<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.value = std::option::Option::Some(
                crate::model::qa_answer::answer_value::Value::NaValue(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for AnswerValue {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.QaAnswer.AnswerValue"
        }
    }

    /// Defines additional types related to [AnswerValue].
    pub mod answer_value {
        #[allow(unused_imports)]
        use super::*;

        /// The answer value may be one of a few different types.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Value {
            /// String value.
            StrValue(std::string::String),
            /// Numerical value.
            NumValue(f64),
            /// Boolean value.
            BoolValue(bool),
            /// A value of "Not Applicable (N/A)". Should only ever be `true`.
            NaValue(bool),
        }
    }

    /// A question may have multiple answers from varying sources, one of which
    /// becomes the "main" answer above. AnswerSource represents each individual
    /// answer.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct AnswerSource {
        /// What created the answer.
        pub source_type: crate::model::qa_answer::answer_source::SourceType,

        /// The answer value from this source.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub answer_value: std::option::Option<crate::model::qa_answer::AnswerValue>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AnswerSource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [source_type][crate::model::qa_answer::AnswerSource::source_type].
        pub fn set_source_type<
            T: std::convert::Into<crate::model::qa_answer::answer_source::SourceType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.source_type = v.into();
            self
        }

        /// Sets the value of [answer_value][crate::model::qa_answer::AnswerSource::answer_value].
        pub fn set_answer_value<
            T: std::convert::Into<std::option::Option<crate::model::qa_answer::AnswerValue>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.answer_value = v.into();
            self
        }
    }

    impl wkt::message::Message for AnswerSource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.QaAnswer.AnswerSource"
        }
    }

    /// Defines additional types related to [AnswerSource].
    pub mod answer_source {
        #[allow(unused_imports)]
        use super::*;

        /// What created the answer.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum SourceType {
            /// Source type is unspecified.
            Unspecified,
            /// Answer was system-generated; created during an Insights analysis.
            SystemGenerated,
            /// Answer was created by a human via manual edit.
            ManualEdit,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [SourceType::value] or
            /// [SourceType::name].
            UnknownValue(source_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod source_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl SourceType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::SystemGenerated => std::option::Option::Some(1),
                    Self::ManualEdit => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("SOURCE_TYPE_UNSPECIFIED"),
                    Self::SystemGenerated => std::option::Option::Some("SYSTEM_GENERATED"),
                    Self::ManualEdit => std::option::Option::Some("MANUAL_EDIT"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for SourceType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for SourceType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for SourceType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::SystemGenerated,
                    2 => Self::ManualEdit,
                    _ => Self::UnknownValue(source_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for SourceType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "SOURCE_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "SYSTEM_GENERATED" => Self::SystemGenerated,
                    "MANUAL_EDIT" => Self::ManualEdit,
                    _ => Self::UnknownValue(source_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for SourceType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::SystemGenerated => serializer.serialize_i32(1),
                    Self::ManualEdit => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for SourceType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<SourceType>::new(
                    ".google.cloud.contactcenterinsights.v1.QaAnswer.AnswerSource.SourceType",
                ))
            }
        }
    }
}

/// The results of scoring a single conversation against a QaScorecard. Contains
/// a collection of QaAnswers and aggregate score.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QaScorecardResult {
    /// Identifier. The name of the scorecard result.
    /// Format:
    /// projects/{project}/locations/{location}/qaScorecardResults/{qa_scorecard_result}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The QaScorecardRevision scored by this result.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub qa_scorecard_revision: std::string::String,

    /// The conversation scored by this result.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub conversation: std::string::String,

    /// Output only. The timestamp that the revision was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// ID of the agent that handled the conversation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub agent_id: std::string::String,

    /// Set of QaAnswers represented in the result.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub qa_answers: std::vec::Vec<crate::model::QaAnswer>,

    /// The overall numerical score of the result, incorporating any manual edits
    /// if they exist.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<wkt::internal::F64>")]
    pub score: std::option::Option<f64>,

    /// The maximum potential overall score of the scorecard. Any questions
    /// answered using `na_value` are excluded from this calculation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<wkt::internal::F64>")]
    pub potential_score: std::option::Option<f64>,

    /// The normalized score, which is the score divided by the potential score.
    /// Any manual edits are included if they exist.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<wkt::internal::F64>")]
    pub normalized_score: std::option::Option<f64>,

    /// Collection of tags and their scores.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub qa_tag_results: std::vec::Vec<crate::model::qa_scorecard_result::QaTagResult>,

    /// List of all individual score sets.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub score_sources: std::vec::Vec<crate::model::qa_scorecard_result::ScoreSource>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QaScorecardResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::QaScorecardResult::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [qa_scorecard_revision][crate::model::QaScorecardResult::qa_scorecard_revision].
    pub fn set_qa_scorecard_revision<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.qa_scorecard_revision = v.into();
        self
    }

    /// Sets the value of [conversation][crate::model::QaScorecardResult::conversation].
    pub fn set_conversation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.conversation = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::QaScorecardResult::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [agent_id][crate::model::QaScorecardResult::agent_id].
    pub fn set_agent_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.agent_id = v.into();
        self
    }

    /// Sets the value of [qa_answers][crate::model::QaScorecardResult::qa_answers].
    pub fn set_qa_answers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::QaAnswer>,
    {
        use std::iter::Iterator;
        self.qa_answers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [score][crate::model::QaScorecardResult::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f64>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }

    /// Sets the value of [potential_score][crate::model::QaScorecardResult::potential_score].
    pub fn set_potential_score<T: std::convert::Into<std::option::Option<f64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.potential_score = v.into();
        self
    }

    /// Sets the value of [normalized_score][crate::model::QaScorecardResult::normalized_score].
    pub fn set_normalized_score<T: std::convert::Into<std::option::Option<f64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.normalized_score = v.into();
        self
    }

    /// Sets the value of [qa_tag_results][crate::model::QaScorecardResult::qa_tag_results].
    pub fn set_qa_tag_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::qa_scorecard_result::QaTagResult>,
    {
        use std::iter::Iterator;
        self.qa_tag_results = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [score_sources][crate::model::QaScorecardResult::score_sources].
    pub fn set_score_sources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::qa_scorecard_result::ScoreSource>,
    {
        use std::iter::Iterator;
        self.score_sources = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for QaScorecardResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.contactcenterinsights.v1.QaScorecardResult"
    }
}

/// Defines additional types related to [QaScorecardResult].
pub mod qa_scorecard_result {
    #[allow(unused_imports)]
    use super::*;

    /// Tags and their corresponding results.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct QaTagResult {
        /// The tag the score applies to.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub tag: std::string::String,

        /// The score the tag applies to.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        #[serde_as(as = "std::option::Option<wkt::internal::F64>")]
        pub score: std::option::Option<f64>,

        /// The potential score the tag applies to.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        #[serde_as(as = "std::option::Option<wkt::internal::F64>")]
        pub potential_score: std::option::Option<f64>,

        /// The normalized score the tag applies to.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        #[serde_as(as = "std::option::Option<wkt::internal::F64>")]
        pub normalized_score: std::option::Option<f64>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl QaTagResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [tag][crate::model::qa_scorecard_result::QaTagResult::tag].
        pub fn set_tag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.tag = v.into();
            self
        }

        /// Sets the value of [score][crate::model::qa_scorecard_result::QaTagResult::score].
        pub fn set_score<T: std::convert::Into<std::option::Option<f64>>>(mut self, v: T) -> Self {
            self.score = v.into();
            self
        }

        /// Sets the value of [potential_score][crate::model::qa_scorecard_result::QaTagResult::potential_score].
        pub fn set_potential_score<T: std::convert::Into<std::option::Option<f64>>>(
            mut self,
            v: T,
        ) -> Self {
            self.potential_score = v.into();
            self
        }

        /// Sets the value of [normalized_score][crate::model::qa_scorecard_result::QaTagResult::normalized_score].
        pub fn set_normalized_score<T: std::convert::Into<std::option::Option<f64>>>(
            mut self,
            v: T,
        ) -> Self {
            self.normalized_score = v.into();
            self
        }
    }

    impl wkt::message::Message for QaTagResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.QaScorecardResult.QaTagResult"
        }
    }

    /// A scorecard result may have multiple sets of scores from varying sources,
    /// one of which becomes the "main" answer above. A ScoreSource represents
    /// each individual set of scores.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ScoreSource {
        /// What created the score.
        pub source_type: crate::model::qa_scorecard_result::score_source::SourceType,

        /// The overall numerical score of the result.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        #[serde_as(as = "std::option::Option<wkt::internal::F64>")]
        pub score: std::option::Option<f64>,

        /// The maximum potential overall score of the scorecard. Any questions
        /// answered using `na_value` are excluded from this calculation.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        #[serde_as(as = "std::option::Option<wkt::internal::F64>")]
        pub potential_score: std::option::Option<f64>,

        /// The normalized score, which is the score divided by the potential score.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        #[serde_as(as = "std::option::Option<wkt::internal::F64>")]
        pub normalized_score: std::option::Option<f64>,

        /// Collection of tags and their scores.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub qa_tag_results: std::vec::Vec<crate::model::qa_scorecard_result::QaTagResult>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ScoreSource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [source_type][crate::model::qa_scorecard_result::ScoreSource::source_type].
        pub fn set_source_type<
            T: std::convert::Into<crate::model::qa_scorecard_result::score_source::SourceType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.source_type = v.into();
            self
        }

        /// Sets the value of [score][crate::model::qa_scorecard_result::ScoreSource::score].
        pub fn set_score<T: std::convert::Into<std::option::Option<f64>>>(mut self, v: T) -> Self {
            self.score = v.into();
            self
        }

        /// Sets the value of [potential_score][crate::model::qa_scorecard_result::ScoreSource::potential_score].
        pub fn set_potential_score<T: std::convert::Into<std::option::Option<f64>>>(
            mut self,
            v: T,
        ) -> Self {
            self.potential_score = v.into();
            self
        }

        /// Sets the value of [normalized_score][crate::model::qa_scorecard_result::ScoreSource::normalized_score].
        pub fn set_normalized_score<T: std::convert::Into<std::option::Option<f64>>>(
            mut self,
            v: T,
        ) -> Self {
            self.normalized_score = v.into();
            self
        }

        /// Sets the value of [qa_tag_results][crate::model::qa_scorecard_result::ScoreSource::qa_tag_results].
        pub fn set_qa_tag_results<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::qa_scorecard_result::QaTagResult>,
        {
            use std::iter::Iterator;
            self.qa_tag_results = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ScoreSource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.contactcenterinsights.v1.QaScorecardResult.ScoreSource"
        }
    }

    /// Defines additional types related to [ScoreSource].
    pub mod score_source {
        #[allow(unused_imports)]
        use super::*;

        /// What created the score.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum SourceType {
            /// Source type is unspecified.
            Unspecified,
            /// Score is derived only from system-generated answers.
            SystemGeneratedOnly,
            /// Score is derived from both system-generated answers, and includes
            /// any manual edits if they exist.
            IncludesManualEdits,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [SourceType::value] or
            /// [SourceType::name].
            UnknownValue(source_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod source_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl SourceType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::SystemGeneratedOnly => std::option::Option::Some(1),
                    Self::IncludesManualEdits => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("SOURCE_TYPE_UNSPECIFIED"),
                    Self::SystemGeneratedOnly => std::option::Option::Some("SYSTEM_GENERATED_ONLY"),
                    Self::IncludesManualEdits => std::option::Option::Some("INCLUDES_MANUAL_EDITS"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for SourceType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for SourceType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for SourceType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::SystemGeneratedOnly,
                    2 => Self::IncludesManualEdits,
                    _ => Self::UnknownValue(source_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for SourceType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "SOURCE_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "SYSTEM_GENERATED_ONLY" => Self::SystemGeneratedOnly,
                    "INCLUDES_MANUAL_EDITS" => Self::IncludesManualEdits,
                    _ => Self::UnknownValue(source_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for SourceType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::SystemGeneratedOnly => serializer.serialize_i32(1),
                    Self::IncludesManualEdits => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for SourceType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<SourceType>::new(
                    ".google.cloud.contactcenterinsights.v1.QaScorecardResult.ScoreSource.SourceType"))
            }
        }
    }
}

/// Represents the options for viewing a conversation.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ConversationView {
    /// The conversation view is not specified.
    ///
    /// * Defaults to `FULL` in `GetConversationRequest`.
    /// * Defaults to `BASIC` in `ListConversationsRequest`.
    Unspecified,
    /// Populates all fields in the conversation.
    Full,
    /// Populates all fields in the conversation except the transcript.
    Basic,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ConversationView::value] or
    /// [ConversationView::name].
    UnknownValue(conversation_view::UnknownValue),
}

#[doc(hidden)]
pub mod conversation_view {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ConversationView {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Full => std::option::Option::Some(2),
            Self::Basic => std::option::Option::Some(1),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("CONVERSATION_VIEW_UNSPECIFIED"),
            Self::Full => std::option::Option::Some("FULL"),
            Self::Basic => std::option::Option::Some("BASIC"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ConversationView {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ConversationView {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ConversationView {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Basic,
            2 => Self::Full,
            _ => Self::UnknownValue(conversation_view::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ConversationView {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "CONVERSATION_VIEW_UNSPECIFIED" => Self::Unspecified,
            "FULL" => Self::Full,
            "BASIC" => Self::Basic,
            _ => Self::UnknownValue(conversation_view::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ConversationView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Full => serializer.serialize_i32(2),
            Self::Basic => serializer.serialize_i32(1),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ConversationView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ConversationView>::new(
            ".google.cloud.contactcenterinsights.v1.ConversationView",
        ))
    }
}

/// Enum for the different types of issues a tuning dataset can have.
/// These warnings are currentlyraised when trying to validate a dataset for
/// tuning a scorecard.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum DatasetValidationWarning {
    /// Unspecified data validation warning.
    Unspecified,
    /// A non-trivial percentage of the feedback labels are invalid.
    TooManyInvalidFeedbackLabels,
    /// The quantity of valid feedback labels provided is less than the
    /// recommended minimum.
    InsufficientFeedbackLabels,
    /// One or more of the answers have less than the recommended minimum of
    /// feedback labels.
    InsufficientFeedbackLabelsPerAnswer,
    /// All the labels in the dataset come from a single answer choice.
    AllFeedbackLabelsHaveTheSameAnswer,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [DatasetValidationWarning::value] or
    /// [DatasetValidationWarning::name].
    UnknownValue(dataset_validation_warning::UnknownValue),
}

#[doc(hidden)]
pub mod dataset_validation_warning {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl DatasetValidationWarning {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::TooManyInvalidFeedbackLabels => std::option::Option::Some(1),
            Self::InsufficientFeedbackLabels => std::option::Option::Some(2),
            Self::InsufficientFeedbackLabelsPerAnswer => std::option::Option::Some(3),
            Self::AllFeedbackLabelsHaveTheSameAnswer => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => {
                std::option::Option::Some("DATASET_VALIDATION_WARNING_UNSPECIFIED")
            }
            Self::TooManyInvalidFeedbackLabels => {
                std::option::Option::Some("TOO_MANY_INVALID_FEEDBACK_LABELS")
            }
            Self::InsufficientFeedbackLabels => {
                std::option::Option::Some("INSUFFICIENT_FEEDBACK_LABELS")
            }
            Self::InsufficientFeedbackLabelsPerAnswer => {
                std::option::Option::Some("INSUFFICIENT_FEEDBACK_LABELS_PER_ANSWER")
            }
            Self::AllFeedbackLabelsHaveTheSameAnswer => {
                std::option::Option::Some("ALL_FEEDBACK_LABELS_HAVE_THE_SAME_ANSWER")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for DatasetValidationWarning {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for DatasetValidationWarning {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for DatasetValidationWarning {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::TooManyInvalidFeedbackLabels,
            2 => Self::InsufficientFeedbackLabels,
            3 => Self::InsufficientFeedbackLabelsPerAnswer,
            4 => Self::AllFeedbackLabelsHaveTheSameAnswer,
            _ => Self::UnknownValue(dataset_validation_warning::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for DatasetValidationWarning {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "DATASET_VALIDATION_WARNING_UNSPECIFIED" => Self::Unspecified,
            "TOO_MANY_INVALID_FEEDBACK_LABELS" => Self::TooManyInvalidFeedbackLabels,
            "INSUFFICIENT_FEEDBACK_LABELS" => Self::InsufficientFeedbackLabels,
            "INSUFFICIENT_FEEDBACK_LABELS_PER_ANSWER" => Self::InsufficientFeedbackLabelsPerAnswer,
            "ALL_FEEDBACK_LABELS_HAVE_THE_SAME_ANSWER" => Self::AllFeedbackLabelsHaveTheSameAnswer,
            _ => Self::UnknownValue(dataset_validation_warning::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for DatasetValidationWarning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::TooManyInvalidFeedbackLabels => serializer.serialize_i32(1),
            Self::InsufficientFeedbackLabels => serializer.serialize_i32(2),
            Self::InsufficientFeedbackLabelsPerAnswer => serializer.serialize_i32(3),
            Self::AllFeedbackLabelsHaveTheSameAnswer => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for DatasetValidationWarning {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<DatasetValidationWarning>::new(
            ".google.cloud.contactcenterinsights.v1.DatasetValidationWarning",
        ))
    }
}
