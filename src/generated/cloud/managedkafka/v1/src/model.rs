// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Request for ListClusters.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListClustersRequest {
    /// Required. The parent location whose clusters are to be listed. Structured
    /// like `projects/{project}/locations/{location}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Optional. The maximum number of clusters to return. The service may return
    /// fewer than this value. If unspecified, server will pick an appropriate
    /// default.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub page_size: i32,

    /// Optional. A page token, received from a previous `ListClusters` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListClusters` must match
    /// the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub page_token: std::string::String,

    /// Optional. Filter expression for the result.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub filter: std::string::String,

    /// Optional. Order by fields for the result.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListClustersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListClustersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListClustersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListClustersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListClustersRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListClustersRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListClustersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.ListClustersRequest"
    }
}

/// Response for ListClusters.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListClustersResponse {
    /// The list of Clusters in the requested parent.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub clusters: std::vec::Vec<crate::model::Cluster>,

    /// A token that can be sent as `page_token` to retrieve the next page of
    /// results. If this field is omitted, there are no more results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListClustersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [clusters][crate::model::ListClustersResponse::clusters].
    pub fn set_clusters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Cluster>,
    {
        use std::iter::Iterator;
        self.clusters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListClustersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListClustersResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListClustersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.ListClustersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListClustersResponse {
    type PageItem = crate::model::Cluster;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.clusters
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request for GetCluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetClusterRequest {
    /// Required. The name of the cluster whose configuration to return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.GetClusterRequest"
    }
}

/// Request for CreateCluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateClusterRequest {
    /// Required. The parent region in which to create the cluster. Structured like
    /// `projects/{project}/locations/{location}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Required. The ID to use for the cluster, which will become the final
    /// component of the cluster's name. The ID must be 1-63 characters long, and
    /// match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` to comply with
    /// RFC 1035.
    ///
    /// This value is structured like: `my-cluster-id`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub cluster_id: std::string::String,

    /// Required. Configuration of the cluster to create. Its `name` field is
    /// ignored.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cluster: std::option::Option<crate::model::Cluster>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID to avoid duplication of requests. If a request times out or
    /// fails, retrying with the same ID allows the server to recognize the
    /// previous attempt. For at least 60 minutes, the server ignores duplicate
    /// requests bearing the same ID.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID
    /// within 60 minutes of the last request, the server checks if an original
    /// operation with the same request ID was received. If so, the server ignores
    /// the second request.
    ///
    /// The request ID must be a valid UUID. A zero UUID is not supported
    /// (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateClusterRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::CreateClusterRequest::cluster_id].
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [cluster][crate::model::CreateClusterRequest::cluster].
    pub fn set_cluster<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Cluster>,
    {
        self.cluster = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cluster][crate::model::CreateClusterRequest::cluster].
    pub fn set_or_clear_cluster<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Cluster>,
    {
        self.cluster = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.CreateClusterRequest"
    }
}

/// Request for UpdateCluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateClusterRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// cluster resource by the update. The fields specified in the update_mask are
    /// relative to the resource, not the full request. A field will be overwritten
    /// if it is in the mask. The mask is required and a value of * will update all
    /// fields.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The cluster to update. Its `name` field must be populated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cluster: std::option::Option<crate::model::Cluster>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID to avoid duplication of requests. If a request times out or
    /// fails, retrying with the same ID allows the server to recognize the
    /// previous attempt. For at least 60 minutes, the server ignores duplicate
    /// requests bearing the same ID.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID
    /// within 60 minutes of the last request, the server checks if an original
    /// operation with the same request ID was received. If so, the server ignores
    /// the second request.
    ///
    /// The request ID must be a valid UUID. A zero UUID is not supported
    /// (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateClusterRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateClusterRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cluster][crate::model::UpdateClusterRequest::cluster].
    pub fn set_cluster<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Cluster>,
    {
        self.cluster = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cluster][crate::model::UpdateClusterRequest::cluster].
    pub fn set_or_clear_cluster<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Cluster>,
    {
        self.cluster = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.UpdateClusterRequest"
    }
}

/// Request for DeleteCluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteClusterRequest {
    /// Required. The name of the cluster to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID to avoid duplication of requests. If a request times out or
    /// fails, retrying with the same ID allows the server to recognize the
    /// previous attempt. For at least 60 minutes, the server ignores duplicate
    /// requests bearing the same ID.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID
    /// within 60 minutes of the last request, the server checks if an original
    /// operation with the same request ID was received. If so, the server ignores
    /// the second request.
    ///
    /// The request ID must be a valid UUID. A zero UUID is not supported
    /// (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.DeleteClusterRequest"
    }
}

/// Request for ListTopics.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTopicsRequest {
    /// Required. The parent cluster whose topics are to be listed. Structured like
    /// `projects/{project}/locations/{location}/clusters/{cluster}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Optional. The maximum number of topics to return. The service may return
    /// fewer than this value. If unset or zero, all topics for the parent is
    /// returned.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub page_size: i32,

    /// Optional. A page token, received from a previous `ListTopics` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListTopics` must match
    /// the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTopicsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTopicsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTopicsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTopicsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTopicsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.ListTopicsRequest"
    }
}

/// Response for ListTopics.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTopicsResponse {
    /// The list of topics in the requested parent. The order of the topics is
    /// unspecified.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub topics: std::vec::Vec<crate::model::Topic>,

    /// A token that can be sent as `page_token` to retrieve the next page of
    /// results. If this field is omitted, there are no more results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTopicsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [topics][crate::model::ListTopicsResponse::topics].
    pub fn set_topics<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Topic>,
    {
        use std::iter::Iterator;
        self.topics = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListTopicsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTopicsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.ListTopicsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListTopicsResponse {
    type PageItem = crate::model::Topic;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.topics
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request for GetTopic.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetTopicRequest {
    /// Required. The name of the topic whose configuration to return. Structured
    /// like:
    /// projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetTopicRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetTopicRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetTopicRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.GetTopicRequest"
    }
}

/// Request for CreateTopic.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateTopicRequest {
    /// Required. The parent cluster in which to create the topic.
    /// Structured like
    /// `projects/{project}/locations/{location}/clusters/{cluster}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Required. The ID to use for the topic, which will become the final
    /// component of the topic's name.
    ///
    /// This value is structured like: `my-topic-name`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub topic_id: std::string::String,

    /// Required. Configuration of the topic to create. Its `name` field is
    /// ignored.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub topic: std::option::Option<crate::model::Topic>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateTopicRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateTopicRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [topic_id][crate::model::CreateTopicRequest::topic_id].
    pub fn set_topic_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.topic_id = v.into();
        self
    }

    /// Sets the value of [topic][crate::model::CreateTopicRequest::topic].
    pub fn set_topic<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Topic>,
    {
        self.topic = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [topic][crate::model::CreateTopicRequest::topic].
    pub fn set_or_clear_topic<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Topic>,
    {
        self.topic = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateTopicRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.CreateTopicRequest"
    }
}

/// Request for UpdateTopic.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateTopicRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// Topic resource by the update. The fields specified in the update_mask are
    /// relative to the resource, not the full request. A field will be overwritten
    /// if it is in the mask. The mask is required and a value of * will update all
    /// fields.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The topic to update. Its `name` field must be populated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub topic: std::option::Option<crate::model::Topic>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateTopicRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateTopicRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateTopicRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [topic][crate::model::UpdateTopicRequest::topic].
    pub fn set_topic<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Topic>,
    {
        self.topic = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [topic][crate::model::UpdateTopicRequest::topic].
    pub fn set_or_clear_topic<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Topic>,
    {
        self.topic = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateTopicRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.UpdateTopicRequest"
    }
}

/// Request for DeleteTopic.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteTopicRequest {
    /// Required. The name of the topic to delete.
    /// `projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteTopicRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTopicRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTopicRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.DeleteTopicRequest"
    }
}

/// Request for ListConsumerGroups.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListConsumerGroupsRequest {
    /// Required. The parent cluster whose consumer groups are to be listed.
    /// Structured like
    /// `projects/{project}/locations/{location}/clusters/{cluster}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Optional. The maximum number of consumer groups to return. The service may
    /// return fewer than this value. If unset or zero, all consumer groups for the
    /// parent is returned.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub page_size: i32,

    /// Optional. A page token, received from a previous `ListConsumerGroups` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListConsumerGroups` must
    /// match the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConsumerGroupsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListConsumerGroupsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListConsumerGroupsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListConsumerGroupsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListConsumerGroupsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.ListConsumerGroupsRequest"
    }
}

/// Response for ListConsumerGroups.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListConsumerGroupsResponse {
    /// The list of consumer group in the requested parent. The order of the
    /// consumer groups is unspecified.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub consumer_groups: std::vec::Vec<crate::model::ConsumerGroup>,

    /// A token that can be sent as `page_token` to retrieve the next page of
    /// results. If this field is omitted, there are no more results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConsumerGroupsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [consumer_groups][crate::model::ListConsumerGroupsResponse::consumer_groups].
    pub fn set_consumer_groups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConsumerGroup>,
    {
        use std::iter::Iterator;
        self.consumer_groups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListConsumerGroupsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListConsumerGroupsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.ListConsumerGroupsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListConsumerGroupsResponse {
    type PageItem = crate::model::ConsumerGroup;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.consumer_groups
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request for GetConsumerGroup.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetConsumerGroupRequest {
    /// Required. The name of the consumer group whose configuration to return.
    /// `projects/{project}/locations/{location}/clusters/{cluster}/consumerGroups/{consumerGroup}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetConsumerGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetConsumerGroupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetConsumerGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.GetConsumerGroupRequest"
    }
}

/// Request for UpdateConsumerGroup.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateConsumerGroupRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// ConsumerGroup resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. The
    /// mask is required and a value of * will update all fields.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The consumer group to update. Its `name` field must be populated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub consumer_group: std::option::Option<crate::model::ConsumerGroup>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateConsumerGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateConsumerGroupRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateConsumerGroupRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [consumer_group][crate::model::UpdateConsumerGroupRequest::consumer_group].
    pub fn set_consumer_group<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ConsumerGroup>,
    {
        self.consumer_group = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [consumer_group][crate::model::UpdateConsumerGroupRequest::consumer_group].
    pub fn set_or_clear_consumer_group<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ConsumerGroup>,
    {
        self.consumer_group = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateConsumerGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.UpdateConsumerGroupRequest"
    }
}

/// Request for DeleteConsumerGroup.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteConsumerGroupRequest {
    /// Required. The name of the consumer group to delete.
    /// `projects/{project}/locations/{location}/clusters/{cluster}/consumerGroups/{consumerGroup}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteConsumerGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteConsumerGroupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteConsumerGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.DeleteConsumerGroupRequest"
    }
}

/// Request for ListAcls.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAclsRequest {
    /// Required. The parent cluster whose acls are to be listed.
    /// Structured like
    /// `projects/{project}/locations/{location}/clusters/{cluster}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Optional. The maximum number of acls to return. The service may return
    /// fewer than this value. If unset or zero, all acls for the parent is
    /// returned.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub page_size: i32,

    /// Optional. A page token, received from a previous `ListAcls` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListAcls` must match
    /// the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAclsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAclsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAclsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAclsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAclsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.ListAclsRequest"
    }
}

/// Response for ListAcls.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAclsResponse {
    /// The list of acls in the requested parent. The order of the acls is
    /// unspecified.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub acls: std::vec::Vec<crate::model::Acl>,

    /// A token that can be sent as `page_token` to retrieve the next page of
    /// results. If this field is omitted, there are no more results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAclsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [acls][crate::model::ListAclsResponse::acls].
    pub fn set_acls<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Acl>,
    {
        use std::iter::Iterator;
        self.acls = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAclsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAclsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.ListAclsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAclsResponse {
    type PageItem = crate::model::Acl;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.acls
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request for GetAcl.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetAclRequest {
    /// Required. The name of the acl to return.
    /// Structured like:
    /// `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`.
    ///
    /// The structure of `acl_id` defines the Resource Pattern (resource_type,
    /// resource_name, pattern_type) of the acl. See `Acl.name` for
    /// details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetAclRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAclRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAclRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.GetAclRequest"
    }
}

/// Request for CreateAcl.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateAclRequest {
    /// Required. The parent cluster in which to create the acl.
    /// Structured like
    /// `projects/{project}/locations/{location}/clusters/{cluster}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Required. The ID to use for the acl, which will become the final component
    /// of the acl's name. The structure of `acl_id` defines the Resource Pattern
    /// (resource_type, resource_name, pattern_type) of the acl. `acl_id` is
    /// structured like one of the following:
    ///
    /// For acls on the cluster:
    /// `cluster`
    ///
    /// For acls on a single resource within the cluster:
    /// `topic/{resource_name}`
    /// `consumerGroup/{resource_name}`
    /// `transactionalId/{resource_name}`
    ///
    /// For acls on all resources that match a prefix:
    /// `topicPrefixed/{resource_name}`
    /// `consumerGroupPrefixed/{resource_name}`
    /// `transactionalIdPrefixed/{resource_name}`
    ///
    /// For acls on all resources of a given type (i.e. the wildcard literal "*"):
    /// `allTopics` (represents `topic/*`)
    /// `allConsumerGroups` (represents `consumerGroup/*`)
    /// `allTransactionalIds` (represents `transactionalId/*`)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub acl_id: std::string::String,

    /// Required. Configuration of the acl to create. Its `name` field is ignored.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub acl: std::option::Option<crate::model::Acl>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateAclRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateAclRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [acl_id][crate::model::CreateAclRequest::acl_id].
    pub fn set_acl_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.acl_id = v.into();
        self
    }

    /// Sets the value of [acl][crate::model::CreateAclRequest::acl].
    pub fn set_acl<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Acl>,
    {
        self.acl = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [acl][crate::model::CreateAclRequest::acl].
    pub fn set_or_clear_acl<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Acl>,
    {
        self.acl = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateAclRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.CreateAclRequest"
    }
}

/// Request for UpdateAcl.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateAclRequest {
    /// Required. The updated acl. Its `name` and `etag` fields must be populated.
    /// `acl_entries` must not be empty in the updated acl; to remove all acl
    /// entries for an acl, use DeleteAcl.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub acl: std::option::Option<crate::model::Acl>,

    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// Acl resource by the update. The fields specified in the update_mask are
    /// relative to the resource, not the full request. A field will be overwritten
    /// if it is in the mask.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateAclRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [acl][crate::model::UpdateAclRequest::acl].
    pub fn set_acl<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Acl>,
    {
        self.acl = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [acl][crate::model::UpdateAclRequest::acl].
    pub fn set_or_clear_acl<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Acl>,
    {
        self.acl = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateAclRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateAclRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateAclRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.UpdateAclRequest"
    }
}

/// Request for DeleteAcl.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteAclRequest {
    /// Required. The name of the acl to delete.
    /// Structured like:
    /// `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`.
    ///
    /// The structure of `acl_id` defines the Resource Pattern (resource_type,
    /// resource_name, pattern_type) of the acl. See `Acl.name` for details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteAclRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteAclRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAclRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.DeleteAclRequest"
    }
}

/// Request for AddAclEntry.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AddAclEntryRequest {
    /// Required. The name of the acl to add the acl entry to.
    /// Structured like:
    /// `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`.
    ///
    /// The structure of `acl_id` defines the Resource Pattern (resource_type,
    /// resource_name, pattern_type) of the acl. See `Acl.name` for
    /// details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub acl: std::string::String,

    /// Required. The acl entry to add.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub acl_entry: std::option::Option<crate::model::AclEntry>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AddAclEntryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [acl][crate::model::AddAclEntryRequest::acl].
    pub fn set_acl<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.acl = v.into();
        self
    }

    /// Sets the value of [acl_entry][crate::model::AddAclEntryRequest::acl_entry].
    pub fn set_acl_entry<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AclEntry>,
    {
        self.acl_entry = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [acl_entry][crate::model::AddAclEntryRequest::acl_entry].
    pub fn set_or_clear_acl_entry<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AclEntry>,
    {
        self.acl_entry = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AddAclEntryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.AddAclEntryRequest"
    }
}

/// Response for AddAclEntry.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AddAclEntryResponse {
    /// The updated acl.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub acl: std::option::Option<crate::model::Acl>,

    /// Whether the acl was created as a result of adding the acl entry.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub acl_created: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AddAclEntryResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [acl][crate::model::AddAclEntryResponse::acl].
    pub fn set_acl<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Acl>,
    {
        self.acl = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [acl][crate::model::AddAclEntryResponse::acl].
    pub fn set_or_clear_acl<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Acl>,
    {
        self.acl = v.map(|x| x.into());
        self
    }

    /// Sets the value of [acl_created][crate::model::AddAclEntryResponse::acl_created].
    pub fn set_acl_created<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.acl_created = v.into();
        self
    }
}

impl wkt::message::Message for AddAclEntryResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.AddAclEntryResponse"
    }
}

/// Request for RemoveAclEntry.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RemoveAclEntryRequest {
    /// Required. The name of the acl to remove the acl entry from.
    /// Structured like:
    /// `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`.
    ///
    /// The structure of `acl_id` defines the Resource Pattern (resource_type,
    /// resource_name, pattern_type) of the acl. See `Acl.name` for
    /// details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub acl: std::string::String,

    /// Required. The acl entry to remove.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub acl_entry: std::option::Option<crate::model::AclEntry>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RemoveAclEntryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [acl][crate::model::RemoveAclEntryRequest::acl].
    pub fn set_acl<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.acl = v.into();
        self
    }

    /// Sets the value of [acl_entry][crate::model::RemoveAclEntryRequest::acl_entry].
    pub fn set_acl_entry<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AclEntry>,
    {
        self.acl_entry = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [acl_entry][crate::model::RemoveAclEntryRequest::acl_entry].
    pub fn set_or_clear_acl_entry<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AclEntry>,
    {
        self.acl_entry = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RemoveAclEntryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.RemoveAclEntryRequest"
    }
}

/// Response for RemoveAclEntry.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RemoveAclEntryResponse {
    /// The result of removing the acl entry, depending on whether the acl was
    /// deleted as a result of removing the acl entry.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub result: std::option::Option<crate::model::remove_acl_entry_response::Result>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RemoveAclEntryResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [result][crate::model::RemoveAclEntryResponse::result].
    ///
    /// Note that all the setters affecting `result` are mutually
    /// exclusive.
    pub fn set_result<
        T: std::convert::Into<std::option::Option<crate::model::remove_acl_entry_response::Result>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = v.into();
        self
    }

    /// The value of [result][crate::model::RemoveAclEntryResponse::result]
    /// if it holds a `Acl`, `None` if the field is not set or
    /// holds a different branch.
    pub fn acl(&self) -> std::option::Option<&std::boxed::Box<crate::model::Acl>> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::remove_acl_entry_response::Result::Acl(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::RemoveAclEntryResponse::result]
    /// to hold a `Acl`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_acl<T: std::convert::Into<std::boxed::Box<crate::model::Acl>>>(
        mut self,
        v: T,
    ) -> Self {
        self.result = std::option::Option::Some(
            crate::model::remove_acl_entry_response::Result::Acl(v.into()),
        );
        self
    }

    /// The value of [result][crate::model::RemoveAclEntryResponse::result]
    /// if it holds a `AclDeleted`, `None` if the field is not set or
    /// holds a different branch.
    pub fn acl_deleted(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::remove_acl_entry_response::Result::AclDeleted(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::RemoveAclEntryResponse::result]
    /// to hold a `AclDeleted`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_acl_deleted<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.result = std::option::Option::Some(
            crate::model::remove_acl_entry_response::Result::AclDeleted(v.into()),
        );
        self
    }
}

impl wkt::message::Message for RemoveAclEntryResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.RemoveAclEntryResponse"
    }
}

/// Defines additional types related to [RemoveAclEntryResponse].
pub mod remove_acl_entry_response {
    #[allow(unused_imports)]
    use super::*;

    /// The result of removing the acl entry, depending on whether the acl was
    /// deleted as a result of removing the acl entry.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Result {
        /// The updated acl. Returned if the removed acl entry was not the last entry
        /// in the acl.
        Acl(std::boxed::Box<crate::model::Acl>),
        /// Returned with value true if the removed acl entry was the last entry in
        /// the acl, resulting in acl deletion.
        AclDeleted(#[serde_as(as = "serde_with::DefaultOnNull<_>")] bool),
    }
}

/// Request for GetConnectCluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetConnectClusterRequest {
    /// Required. The name of the Kafka Connect cluster whose configuration to
    /// return. Structured like
    /// `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetConnectClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetConnectClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetConnectClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.GetConnectClusterRequest"
    }
}

/// Request for CreateConnectCluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateConnectClusterRequest {
    /// Required. The parent project/location in which to create the Kafka Connect
    /// cluster. Structured like
    /// `projects/{project}/locations/{location}/`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Required. The ID to use for the Connect cluster, which will become the
    /// final component of the cluster's name. The ID must be 1-63 characters long,
    /// and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` to comply
    /// with RFC 1035.
    ///
    /// This value is structured like: `my-cluster-id`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub connect_cluster_id: std::string::String,

    /// Required. Configuration of the Kafka Connect cluster to create. Its `name`
    /// field is ignored.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub connect_cluster: std::option::Option<crate::model::ConnectCluster>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID to avoid duplication of requests. If a request times out or
    /// fails, retrying with the same ID allows the server to recognize the
    /// previous attempt. For at least 60 minutes, the server ignores duplicate
    /// requests bearing the same ID.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID
    /// within 60 minutes of the last request, the server checks if an original
    /// operation with the same request ID was received. If so, the server ignores
    /// the second request.
    ///
    /// The request ID must be a valid UUID. A zero UUID is not supported
    /// (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateConnectClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateConnectClusterRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [connect_cluster_id][crate::model::CreateConnectClusterRequest::connect_cluster_id].
    pub fn set_connect_cluster_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.connect_cluster_id = v.into();
        self
    }

    /// Sets the value of [connect_cluster][crate::model::CreateConnectClusterRequest::connect_cluster].
    pub fn set_connect_cluster<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ConnectCluster>,
    {
        self.connect_cluster = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [connect_cluster][crate::model::CreateConnectClusterRequest::connect_cluster].
    pub fn set_or_clear_connect_cluster<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ConnectCluster>,
    {
        self.connect_cluster = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateConnectClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateConnectClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.CreateConnectClusterRequest"
    }
}

/// Request for UpdateConnectCluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateConnectClusterRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// cluster resource by the update. The fields specified in the update_mask are
    /// relative to the resource, not the full request. A field will be overwritten
    /// if it is in the mask. The mask is required and a value of * will update all
    /// fields.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The Kafka Connect cluster to update. Its `name` field must be
    /// populated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub connect_cluster: std::option::Option<crate::model::ConnectCluster>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID to avoid duplication of requests. If a request times out or
    /// fails, retrying with the same ID allows the server to recognize the
    /// previous attempt. For at least 60 minutes, the server ignores duplicate
    /// requests bearing the same ID.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID
    /// within 60 minutes of the last request, the server checks if an original
    /// operation with the same request ID was received. If so, the server ignores
    /// the second request.
    ///
    /// The request ID must be a valid UUID. A zero UUID is not supported
    /// (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateConnectClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateConnectClusterRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateConnectClusterRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [connect_cluster][crate::model::UpdateConnectClusterRequest::connect_cluster].
    pub fn set_connect_cluster<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ConnectCluster>,
    {
        self.connect_cluster = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [connect_cluster][crate::model::UpdateConnectClusterRequest::connect_cluster].
    pub fn set_or_clear_connect_cluster<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ConnectCluster>,
    {
        self.connect_cluster = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateConnectClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateConnectClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.UpdateConnectClusterRequest"
    }
}

/// Request for DeleteConnectCluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteConnectClusterRequest {
    /// Required. The name of the Kafka Connect cluster to delete.
    /// Structured like
    /// `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID to avoid duplication of requests. If a request times out or
    /// fails, retrying with the same ID allows the server to recognize the
    /// previous attempt. For at least 60 minutes, the server ignores duplicate
    /// requests bearing the same ID.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID
    /// within 60 minutes of the last request, the server checks if an original
    /// operation with the same request ID was received. If so, the server ignores
    /// the second request.
    ///
    /// The request ID must be a valid UUID. A zero UUID is not supported
    /// (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteConnectClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteConnectClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteConnectClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteConnectClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.DeleteConnectClusterRequest"
    }
}

/// Request for ListConnectClusters.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListConnectClustersRequest {
    /// Required. The parent project/location whose Connect clusters are to be
    /// listed. Structured like `projects/{project}/locations/{location}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Optional. The maximum number of Connect clusters to return. The service may
    /// return fewer than this value. If unspecified, server will pick an
    /// appropriate default.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub page_size: i32,

    /// Optional. A page token, received from a previous `ListConnectClusters`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListConnectClusters`
    /// must match the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub page_token: std::string::String,

    /// Optional. Filter expression for the result.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub filter: std::string::String,

    /// Optional. Order by fields for the result.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConnectClustersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListConnectClustersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListConnectClustersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListConnectClustersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListConnectClustersRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListConnectClustersRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListConnectClustersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.ListConnectClustersRequest"
    }
}

/// Response for ListConnectClusters.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListConnectClustersResponse {
    /// The list of Connect clusters in the requested parent.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub connect_clusters: std::vec::Vec<crate::model::ConnectCluster>,

    /// A token that can be sent as `page_token` to retrieve the next page of
    /// results. If this field is omitted, there are no more results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConnectClustersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [connect_clusters][crate::model::ListConnectClustersResponse::connect_clusters].
    pub fn set_connect_clusters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConnectCluster>,
    {
        use std::iter::Iterator;
        self.connect_clusters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListConnectClustersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListConnectClustersResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListConnectClustersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.ListConnectClustersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListConnectClustersResponse {
    type PageItem = crate::model::ConnectCluster;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.connect_clusters
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request for GetConnector.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetConnectorRequest {
    /// Required. The name of the connector whose configuration to return.
    /// Structured like:
    /// projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{connector}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetConnectorRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetConnectorRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetConnectorRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.GetConnectorRequest"
    }
}

/// Request for CreateConnector.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateConnectorRequest {
    /// Required. The parent Connect cluster in which to create the connector.
    /// Structured like
    /// `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Required. The ID to use for the connector, which will become the final
    /// component of the connector's name. The ID must be 1-63 characters long, and
    /// match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` to comply with
    /// RFC 1035.
    ///
    /// This value is structured like: `my-connector-id`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub connector_id: std::string::String,

    /// Required. The connector to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub connector: std::option::Option<crate::model::Connector>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateConnectorRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateConnectorRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [connector_id][crate::model::CreateConnectorRequest::connector_id].
    pub fn set_connector_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.connector_id = v.into();
        self
    }

    /// Sets the value of [connector][crate::model::CreateConnectorRequest::connector].
    pub fn set_connector<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Connector>,
    {
        self.connector = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [connector][crate::model::CreateConnectorRequest::connector].
    pub fn set_or_clear_connector<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Connector>,
    {
        self.connector = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateConnectorRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.CreateConnectorRequest"
    }
}

/// Request for UpdateConnector.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateConnectorRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// cluster resource by the update. The fields specified in the update_mask are
    /// relative to the resource, not the full request. A field will be overwritten
    /// if it is in the mask. The mask is required and a value of * will update all
    /// fields.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The connector to update. Its `name` field must be populated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub connector: std::option::Option<crate::model::Connector>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateConnectorRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateConnectorRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateConnectorRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [connector][crate::model::UpdateConnectorRequest::connector].
    pub fn set_connector<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Connector>,
    {
        self.connector = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [connector][crate::model::UpdateConnectorRequest::connector].
    pub fn set_or_clear_connector<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Connector>,
    {
        self.connector = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateConnectorRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.UpdateConnectorRequest"
    }
}

/// Request for DeleteConnector.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteConnectorRequest {
    /// Required. The name of the connector to delete.
    /// Structured like:
    /// projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{connector}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteConnectorRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteConnectorRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteConnectorRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.DeleteConnectorRequest"
    }
}

/// Request for ListConnectors.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListConnectorsRequest {
    /// Required. The parent Connect cluster whose connectors are to be listed.
    /// Structured like
    /// `projects/{project}/locations/{location}/connectClusters/{connect_cluster_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Optional. The maximum number of connectors to return. The service may
    /// return fewer than this value. If unspecified, server will pick an
    /// appropriate default.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub page_size: i32,

    /// Optional. A page token, received from a previous `ListConnectors` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListConnectors`
    /// must match the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConnectorsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListConnectorsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListConnectorsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListConnectorsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListConnectorsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.ListConnectorsRequest"
    }
}

/// Response for ListConnectors.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListConnectorsResponse {
    /// The list of connectors in the requested parent.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub connectors: std::vec::Vec<crate::model::Connector>,

    /// A token that can be sent as `page_token` to retrieve the next page of
    /// results. If this field is omitted, there are no more results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConnectorsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [connectors][crate::model::ListConnectorsResponse::connectors].
    pub fn set_connectors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Connector>,
    {
        use std::iter::Iterator;
        self.connectors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListConnectorsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListConnectorsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.ListConnectorsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListConnectorsResponse {
    type PageItem = crate::model::Connector;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.connectors
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request for PauseConnector.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PauseConnectorRequest {
    /// Required. The name of the connector to pause.
    /// Structured like:
    /// projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{connector}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PauseConnectorRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PauseConnectorRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for PauseConnectorRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.PauseConnectorRequest"
    }
}

/// Response for PauseConnector.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PauseConnectorResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PauseConnectorResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for PauseConnectorResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.PauseConnectorResponse"
    }
}

/// Request for ResumeConnector.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ResumeConnectorRequest {
    /// Required. The name of the connector to pause.
    /// Structured like:
    /// projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{connector}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResumeConnectorRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ResumeConnectorRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for ResumeConnectorRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.ResumeConnectorRequest"
    }
}

/// Response for ResumeConnector.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ResumeConnectorResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResumeConnectorResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ResumeConnectorResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.ResumeConnectorResponse"
    }
}

/// Request for RestartConnector.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RestartConnectorRequest {
    /// Required. The name of the connector to restart.
    /// Structured like:
    /// projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{connector}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RestartConnectorRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RestartConnectorRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for RestartConnectorRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.RestartConnectorRequest"
    }
}

/// Response for RestartConnector.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RestartConnectorResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RestartConnectorResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for RestartConnectorResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.RestartConnectorResponse"
    }
}

/// Request for StopConnector.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StopConnectorRequest {
    /// Required. The name of the connector to stop.
    /// Structured like:
    /// projects/{project}/locations/{location}/connectClusters/{connectCluster}/connectors/{connector}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StopConnectorRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StopConnectorRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for StopConnectorRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.StopConnectorRequest"
    }
}

/// Response for StopConnector.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StopConnectorResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StopConnectorResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for StopConnectorResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.StopConnectorResponse"
    }
}

/// An Apache Kafka cluster deployed in a location.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Cluster {
    /// Identifier. The name of the cluster. Structured like:
    /// projects/{project_number}/locations/{location}/clusters/{cluster_id}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Output only. The time when the cluster was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the cluster was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Labels as key value pairs.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. Capacity configuration for the Kafka cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub capacity_config: std::option::Option<crate::model::CapacityConfig>,

    /// Optional. Rebalance configuration for the Kafka cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rebalance_config: std::option::Option<crate::model::RebalanceConfig>,

    /// Output only. The current state of the cluster.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub state: crate::model::cluster::State,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub satisfies_pzi: std::option::Option<bool>,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub satisfies_pzs: std::option::Option<bool>,

    /// Platform specific configuration properties for a Kafka cluster.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub platform_config: std::option::Option<crate::model::cluster::PlatformConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Cluster {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Cluster::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Cluster::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Cluster::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Cluster::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Cluster::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Cluster::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [capacity_config][crate::model::Cluster::capacity_config].
    pub fn set_capacity_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CapacityConfig>,
    {
        self.capacity_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [capacity_config][crate::model::Cluster::capacity_config].
    pub fn set_or_clear_capacity_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CapacityConfig>,
    {
        self.capacity_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [rebalance_config][crate::model::Cluster::rebalance_config].
    pub fn set_rebalance_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RebalanceConfig>,
    {
        self.rebalance_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rebalance_config][crate::model::Cluster::rebalance_config].
    pub fn set_or_clear_rebalance_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RebalanceConfig>,
    {
        self.rebalance_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::Cluster::state].
    pub fn set_state<T: std::convert::Into<crate::model::cluster::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::Cluster::satisfies_pzi].
    pub fn set_satisfies_pzi<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzi = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [satisfies_pzi][crate::model::Cluster::satisfies_pzi].
    pub fn set_or_clear_satisfies_pzi<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzi = v.map(|x| x.into());
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Cluster::satisfies_pzs].
    pub fn set_satisfies_pzs<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzs = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [satisfies_pzs][crate::model::Cluster::satisfies_pzs].
    pub fn set_or_clear_satisfies_pzs<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzs = v.map(|x| x.into());
        self
    }

    /// Sets the value of [platform_config][crate::model::Cluster::platform_config].
    ///
    /// Note that all the setters affecting `platform_config` are mutually
    /// exclusive.
    pub fn set_platform_config<
        T: std::convert::Into<std::option::Option<crate::model::cluster::PlatformConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.platform_config = v.into();
        self
    }

    /// The value of [platform_config][crate::model::Cluster::platform_config]
    /// if it holds a `GcpConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcp_config(&self) -> std::option::Option<&std::boxed::Box<crate::model::GcpConfig>> {
        #[allow(unreachable_patterns)]
        self.platform_config.as_ref().and_then(|v| match v {
            crate::model::cluster::PlatformConfig::GcpConfig(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [platform_config][crate::model::Cluster::platform_config]
    /// to hold a `GcpConfig`.
    ///
    /// Note that all the setters affecting `platform_config` are
    /// mutually exclusive.
    pub fn set_gcp_config<T: std::convert::Into<std::boxed::Box<crate::model::GcpConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.platform_config =
            std::option::Option::Some(crate::model::cluster::PlatformConfig::GcpConfig(v.into()));
        self
    }
}

impl wkt::message::Message for Cluster {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.Cluster"
    }
}

/// Defines additional types related to [Cluster].
pub mod cluster {
    #[allow(unused_imports)]
    use super::*;

    /// The state of the cluster.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// A state was not specified.
        Unspecified,
        /// The cluster is being created.
        Creating,
        /// The cluster is active.
        Active,
        /// The cluster is being deleted.
        Deleting,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Active => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Active,
                3 => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "ACTIVE" => Self::Active,
                "DELETING" => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Active => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.managedkafka.v1.Cluster.State",
            ))
        }
    }

    /// Platform specific configuration properties for a Kafka cluster.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum PlatformConfig {
        /// Required. Configuration properties for a Kafka cluster deployed to Google
        /// Cloud Platform.
        GcpConfig(std::boxed::Box<crate::model::GcpConfig>),
    }
}

/// A capacity configuration of a Kafka cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CapacityConfig {
    /// Required. The number of vCPUs to provision for the cluster. Minimum: 3.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I64>")]
    pub vcpu_count: i64,

    /// Required. The memory to provision for the cluster in bytes.
    /// The CPU:memory ratio (vCPU:GiB) must be between 1:1 and 1:8.
    /// Minimum: 3221225472 (3 GiB).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I64>")]
    pub memory_bytes: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CapacityConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vcpu_count][crate::model::CapacityConfig::vcpu_count].
    pub fn set_vcpu_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.vcpu_count = v.into();
        self
    }

    /// Sets the value of [memory_bytes][crate::model::CapacityConfig::memory_bytes].
    pub fn set_memory_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.memory_bytes = v.into();
        self
    }
}

impl wkt::message::Message for CapacityConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.CapacityConfig"
    }
}

/// Defines rebalancing behavior of a Kafka cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RebalanceConfig {
    /// Optional. The rebalance behavior for the cluster.
    /// When not specified, defaults to `NO_REBALANCE`.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub mode: crate::model::rebalance_config::Mode,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RebalanceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mode][crate::model::RebalanceConfig::mode].
    pub fn set_mode<T: std::convert::Into<crate::model::rebalance_config::Mode>>(
        mut self,
        v: T,
    ) -> Self {
        self.mode = v.into();
        self
    }
}

impl wkt::message::Message for RebalanceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.RebalanceConfig"
    }
}

/// Defines additional types related to [RebalanceConfig].
pub mod rebalance_config {
    #[allow(unused_imports)]
    use super::*;

    /// The partition rebalance mode for the cluster.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Mode {
        /// A mode was not specified. Do not use.
        Unspecified,
        /// Do not rebalance automatically.
        NoRebalance,
        /// Automatically rebalance topic partitions among brokers when the
        /// cluster is scaled up.
        AutoRebalanceOnScaleUp,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Mode::value] or
        /// [Mode::name].
        UnknownValue(mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Mode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::NoRebalance => std::option::Option::Some(1),
                Self::AutoRebalanceOnScaleUp => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MODE_UNSPECIFIED"),
                Self::NoRebalance => std::option::Option::Some("NO_REBALANCE"),
                Self::AutoRebalanceOnScaleUp => {
                    std::option::Option::Some("AUTO_REBALANCE_ON_SCALE_UP")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Mode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Mode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Mode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::NoRebalance,
                2 => Self::AutoRebalanceOnScaleUp,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Mode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MODE_UNSPECIFIED" => Self::Unspecified,
                "NO_REBALANCE" => Self::NoRebalance,
                "AUTO_REBALANCE_ON_SCALE_UP" => Self::AutoRebalanceOnScaleUp,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Mode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::NoRebalance => serializer.serialize_i32(1),
                Self::AutoRebalanceOnScaleUp => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Mode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Mode>::new(
                ".google.cloud.managedkafka.v1.RebalanceConfig.Mode",
            ))
        }
    }
}

/// The configuration of a Virtual Private Cloud (VPC) network that can access
/// the Kafka cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NetworkConfig {
    /// Required. Name of the VPC subnet in which to create Private Service Connect
    /// (PSC) endpoints for the Kafka brokers and bootstrap address. Structured
    /// like: projects/{project}/regions/{region}/subnetworks/{subnet_id}
    ///
    /// The subnet must be located in the same region as the Kafka cluster. The
    /// project may differ. Multiple subnets from the same parent network must not
    /// be specified.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub subnet: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NetworkConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [subnet][crate::model::NetworkConfig::subnet].
    pub fn set_subnet<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnet = v.into();
        self
    }
}

impl wkt::message::Message for NetworkConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.NetworkConfig"
    }
}

/// The configuration of access to the Kafka cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AccessConfig {
    /// Required. Virtual Private Cloud (VPC) networks that must be granted direct
    /// access to the Kafka cluster. Minimum of 1 network is required. Maximum 10
    /// networks can be specified.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub network_configs: std::vec::Vec<crate::model::NetworkConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AccessConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [network_configs][crate::model::AccessConfig::network_configs].
    pub fn set_network_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NetworkConfig>,
    {
        use std::iter::Iterator;
        self.network_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AccessConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.AccessConfig"
    }
}

/// Configuration properties for a Kafka cluster deployed to Google Cloud
/// Platform.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GcpConfig {
    /// Required. Access configuration for the Kafka cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub access_config: std::option::Option<crate::model::AccessConfig>,

    /// Optional. Immutable. The Cloud KMS Key name to use for encryption. The key
    /// must be located in the same region as the cluster and cannot be changed.
    /// Structured like:
    /// projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub kms_key: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcpConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [access_config][crate::model::GcpConfig::access_config].
    pub fn set_access_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AccessConfig>,
    {
        self.access_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [access_config][crate::model::GcpConfig::access_config].
    pub fn set_or_clear_access_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AccessConfig>,
    {
        self.access_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kms_key][crate::model::GcpConfig::kms_key].
    pub fn set_kms_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key = v.into();
        self
    }
}

impl wkt::message::Message for GcpConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.GcpConfig"
    }
}

/// A Kafka topic in a given cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Topic {
    /// Identifier. The name of the topic. The `topic` segment is used when
    /// connecting directly to the cluster. Structured like:
    /// projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Required. The number of partitions this topic has. The partition count can
    /// only be increased, not decreased. Please note that if partitions are
    /// increased for a topic that has a key, the partitioning logic or the
    /// ordering of the messages will be affected.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub partition_count: i32,

    /// Required. Immutable. The number of replicas of each partition. A
    /// replication factor of 3 is recommended for high availability.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub replication_factor: i32,

    /// Optional. Configurations for the topic that are overridden from the cluster
    /// defaults. The key of the map is a Kafka topic property name, for example:
    /// `cleanup.policy`, `compression.type`.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub configs: std::collections::HashMap<std::string::String, std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Topic {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Topic::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [partition_count][crate::model::Topic::partition_count].
    pub fn set_partition_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.partition_count = v.into();
        self
    }

    /// Sets the value of [replication_factor][crate::model::Topic::replication_factor].
    pub fn set_replication_factor<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.replication_factor = v.into();
        self
    }

    /// Sets the value of [configs][crate::model::Topic::configs].
    pub fn set_configs<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.configs = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Topic {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.Topic"
    }
}

/// Metadata for a consumer group corresponding to a specific topic.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConsumerTopicMetadata {
    /// Optional. Metadata for this consumer group and topic for all partition
    /// indexes it has metadata for.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<wkt::internal::I32, _>>")]
    pub partitions: std::collections::HashMap<i32, crate::model::ConsumerPartitionMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConsumerTopicMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [partitions][crate::model::ConsumerTopicMetadata::partitions].
    pub fn set_partitions<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<i32>,
        V: std::convert::Into<crate::model::ConsumerPartitionMetadata>,
    {
        use std::iter::Iterator;
        self.partitions = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for ConsumerTopicMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.ConsumerTopicMetadata"
    }
}

/// Metadata for a consumer group corresponding to a specific partition.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConsumerPartitionMetadata {
    /// Required. The current offset for this partition, or 0 if no offset has been
    /// committed.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I64>")]
    pub offset: i64,

    /// Optional. The associated metadata for this partition, or empty if it does
    /// not exist.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub metadata: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConsumerPartitionMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [offset][crate::model::ConsumerPartitionMetadata::offset].
    pub fn set_offset<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.offset = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::ConsumerPartitionMetadata::metadata].
    pub fn set_metadata<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.metadata = v.into();
        self
    }
}

impl wkt::message::Message for ConsumerPartitionMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.ConsumerPartitionMetadata"
    }
}

/// A Kafka consumer group in a given cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConsumerGroup {
    /// Identifier. The name of the consumer group. The `consumer_group` segment is
    /// used when connecting directly to the cluster. Structured like:
    /// projects/{project}/locations/{location}/clusters/{cluster}/consumerGroups/{consumer_group}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Optional. Metadata for this consumer group for all topics it has metadata
    /// for. The key of the map is a topic name, structured like:
    /// projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub topics: std::collections::HashMap<std::string::String, crate::model::ConsumerTopicMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConsumerGroup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ConsumerGroup::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [topics][crate::model::ConsumerGroup::topics].
    pub fn set_topics<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::ConsumerTopicMetadata>,
    {
        use std::iter::Iterator;
        self.topics = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for ConsumerGroup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.ConsumerGroup"
    }
}

/// Represents the metadata of the long-running operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have been cancelled successfully
    /// have [Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    ///
    /// [google.rpc.Status.code]: rpc::model::Status::code
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub api_version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.OperationMetadata"
    }
}

/// An Apache Kafka Connect cluster deployed in a location.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConnectCluster {
    /// Identifier. The name of the Kafka Connect cluster. Structured like:
    /// projects/{project_number}/locations/{location}/connectClusters/{connect_cluster_id}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Required. Immutable. The name of the Kafka cluster this Kafka Connect
    /// cluster is attached to. Structured like:
    /// projects/{project}/locations/{location}/clusters/{cluster}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub kafka_cluster: std::string::String,

    /// Output only. The time when the cluster was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the cluster was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Labels as key value pairs.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. Capacity configuration for the Kafka Connect cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub capacity_config: std::option::Option<crate::model::CapacityConfig>,

    /// Output only. The current state of the cluster.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub state: crate::model::connect_cluster::State,

    /// Optional. Configurations for the worker that are overridden from the
    /// defaults. The key of the map is a Kafka Connect worker property name, for
    /// example: `exactly.once.source.support`.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub config: std::collections::HashMap<std::string::String, std::string::String>,

    /// Platform specific configuration properties for a Kafka Connect cluster.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub platform_config: std::option::Option<crate::model::connect_cluster::PlatformConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConnectCluster {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ConnectCluster::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [kafka_cluster][crate::model::ConnectCluster::kafka_cluster].
    pub fn set_kafka_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kafka_cluster = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ConnectCluster::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ConnectCluster::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::ConnectCluster::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::ConnectCluster::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::ConnectCluster::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [capacity_config][crate::model::ConnectCluster::capacity_config].
    pub fn set_capacity_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CapacityConfig>,
    {
        self.capacity_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [capacity_config][crate::model::ConnectCluster::capacity_config].
    pub fn set_or_clear_capacity_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CapacityConfig>,
    {
        self.capacity_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::ConnectCluster::state].
    pub fn set_state<T: std::convert::Into<crate::model::connect_cluster::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [config][crate::model::ConnectCluster::config].
    pub fn set_config<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.config = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [platform_config][crate::model::ConnectCluster::platform_config].
    ///
    /// Note that all the setters affecting `platform_config` are mutually
    /// exclusive.
    pub fn set_platform_config<
        T: std::convert::Into<std::option::Option<crate::model::connect_cluster::PlatformConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.platform_config = v.into();
        self
    }

    /// The value of [platform_config][crate::model::ConnectCluster::platform_config]
    /// if it holds a `GcpConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcp_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ConnectGcpConfig>> {
        #[allow(unreachable_patterns)]
        self.platform_config.as_ref().and_then(|v| match v {
            crate::model::connect_cluster::PlatformConfig::GcpConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [platform_config][crate::model::ConnectCluster::platform_config]
    /// to hold a `GcpConfig`.
    ///
    /// Note that all the setters affecting `platform_config` are
    /// mutually exclusive.
    pub fn set_gcp_config<
        T: std::convert::Into<std::boxed::Box<crate::model::ConnectGcpConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.platform_config = std::option::Option::Some(
            crate::model::connect_cluster::PlatformConfig::GcpConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ConnectCluster {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.ConnectCluster"
    }
}

/// Defines additional types related to [ConnectCluster].
pub mod connect_cluster {
    #[allow(unused_imports)]
    use super::*;

    /// The state of the cluster.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// A state was not specified.
        Unspecified,
        /// The cluster is being created.
        Creating,
        /// The cluster is active.
        Active,
        /// The cluster is being deleted.
        Deleting,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Active => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Active,
                3 => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "ACTIVE" => Self::Active,
                "DELETING" => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Active => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.managedkafka.v1.ConnectCluster.State",
            ))
        }
    }

    /// Platform specific configuration properties for a Kafka Connect cluster.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum PlatformConfig {
        /// Required. Configuration properties for a Kafka Connect cluster deployed
        /// to Google Cloud Platform.
        GcpConfig(std::boxed::Box<crate::model::ConnectGcpConfig>),
    }
}

/// The configuration of a Virtual Private Cloud (VPC) network that can access
/// the Kafka Connect cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConnectNetworkConfig {
    /// Required. VPC subnet to make available to the Kafka Connect cluster.
    /// Structured like:
    /// projects/{project}/regions/{region}/subnetworks/{subnet_id}
    ///
    /// It is used to create a Private Service Connect (PSC) interface for the
    /// Kafka Connect workers. It must be located in the same region as the
    /// Kafka Connect cluster.
    ///
    /// The CIDR range of the subnet must be within the IPv4 address ranges for
    /// private networks, as specified in RFC 1918. The primary subnet CIDR range
    /// must have a minimum size of /22 (1024 addresses).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub primary_subnet: std::string::String,

    /// Optional. Additional subnets may be specified. They may be in another
    /// region, but must be in the same VPC network. The Connect workers can
    /// communicate with network endpoints in either the primary or additional
    /// subnets.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub additional_subnets: std::vec::Vec<std::string::String>,

    /// Optional. Additional DNS domain names from the subnet's network to be made
    /// visible to the Connect Cluster. When using MirrorMaker2, it's necessary to
    /// add the bootstrap address's dns domain name of the target cluster to make
    /// it visible to the connector. For example:
    /// my-kafka-cluster.us-central1.managedkafka.my-project.cloud.goog
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub dns_domain_names: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConnectNetworkConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [primary_subnet][crate::model::ConnectNetworkConfig::primary_subnet].
    pub fn set_primary_subnet<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.primary_subnet = v.into();
        self
    }

    /// Sets the value of [additional_subnets][crate::model::ConnectNetworkConfig::additional_subnets].
    pub fn set_additional_subnets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.additional_subnets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [dns_domain_names][crate::model::ConnectNetworkConfig::dns_domain_names].
    pub fn set_dns_domain_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.dns_domain_names = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ConnectNetworkConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.ConnectNetworkConfig"
    }
}

/// The configuration of access to the Kafka Connect cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConnectAccessConfig {
    /// Required.
    /// Virtual Private Cloud (VPC) networks that must be granted direct access to
    /// the Kafka Connect cluster. Minimum of 1 network is required. Maximum 10
    /// networks can be specified.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub network_configs: std::vec::Vec<crate::model::ConnectNetworkConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConnectAccessConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [network_configs][crate::model::ConnectAccessConfig::network_configs].
    pub fn set_network_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConnectNetworkConfig>,
    {
        use std::iter::Iterator;
        self.network_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ConnectAccessConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.ConnectAccessConfig"
    }
}

/// Configuration properties for a Kafka Connect cluster deployed to Google Cloud
/// Platform.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConnectGcpConfig {
    /// Required. Access configuration for the Kafka Connect cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub access_config: std::option::Option<crate::model::ConnectAccessConfig>,

    /// Optional. Secrets to load into workers. Exact SecretVersions from Secret
    /// Manager must be provided -- aliases are not supported. Up to 32 secrets may
    /// be loaded into one cluster. Format:
    /// projects/\<project-id\>/secrets/\<secret-name\>/versions/\<version-id\>
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub secret_paths: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConnectGcpConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [access_config][crate::model::ConnectGcpConfig::access_config].
    pub fn set_access_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ConnectAccessConfig>,
    {
        self.access_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [access_config][crate::model::ConnectGcpConfig::access_config].
    pub fn set_or_clear_access_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ConnectAccessConfig>,
    {
        self.access_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [secret_paths][crate::model::ConnectGcpConfig::secret_paths].
    pub fn set_secret_paths<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.secret_paths = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ConnectGcpConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.ConnectGcpConfig"
    }
}

/// A Kafka Connect connector in a given ConnectCluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Connector {
    /// Identifier. The name of the connector.
    /// Structured like:
    /// projects/{project}/locations/{location}/connectClusters/{connect_cluster}/connectors/{connector}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Optional. Connector config as keys/values.
    /// The keys of the map are connector property names, for example:
    /// `connector.class`, `tasks.max`, `key.converter`.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub configs: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The current state of the connector.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub state: crate::model::connector::State,

    /// A policy that specifies how to restart the failed connectors/tasks in a
    /// Cluster resource. If not set, the failed connectors/tasks won't be
    /// restarted.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub restart_policy: std::option::Option<crate::model::connector::RestartPolicy>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Connector {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Connector::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [configs][crate::model::Connector::configs].
    pub fn set_configs<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.configs = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [state][crate::model::Connector::state].
    pub fn set_state<T: std::convert::Into<crate::model::connector::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [restart_policy][crate::model::Connector::restart_policy].
    ///
    /// Note that all the setters affecting `restart_policy` are mutually
    /// exclusive.
    pub fn set_restart_policy<
        T: std::convert::Into<std::option::Option<crate::model::connector::RestartPolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.restart_policy = v.into();
        self
    }

    /// The value of [restart_policy][crate::model::Connector::restart_policy]
    /// if it holds a `TaskRestartPolicy`, `None` if the field is not set or
    /// holds a different branch.
    pub fn task_restart_policy(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TaskRetryPolicy>> {
        #[allow(unreachable_patterns)]
        self.restart_policy.as_ref().and_then(|v| match v {
            crate::model::connector::RestartPolicy::TaskRestartPolicy(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [restart_policy][crate::model::Connector::restart_policy]
    /// to hold a `TaskRestartPolicy`.
    ///
    /// Note that all the setters affecting `restart_policy` are
    /// mutually exclusive.
    pub fn set_task_restart_policy<
        T: std::convert::Into<std::boxed::Box<crate::model::TaskRetryPolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.restart_policy = std::option::Option::Some(
            crate::model::connector::RestartPolicy::TaskRestartPolicy(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Connector {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.Connector"
    }
}

/// Defines additional types related to [Connector].
pub mod connector {
    #[allow(unused_imports)]
    use super::*;

    /// The state of the connector.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// A state was not specified.
        Unspecified,
        /// The connector is not assigned to any tasks, usually transient.
        Unassigned,
        /// The connector is running.
        Running,
        /// The connector has been paused.
        Paused,
        /// The connector has failed. See logs for why.
        Failed,
        /// The connector is restarting.
        Restarting,
        /// The connector has been stopped.
        Stopped,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Unassigned => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::Paused => std::option::Option::Some(3),
                Self::Failed => std::option::Option::Some(4),
                Self::Restarting => std::option::Option::Some(5),
                Self::Stopped => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Unassigned => std::option::Option::Some("UNASSIGNED"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Paused => std::option::Option::Some("PAUSED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Restarting => std::option::Option::Some("RESTARTING"),
                Self::Stopped => std::option::Option::Some("STOPPED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Unassigned,
                2 => Self::Running,
                3 => Self::Paused,
                4 => Self::Failed,
                5 => Self::Restarting,
                6 => Self::Stopped,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "UNASSIGNED" => Self::Unassigned,
                "RUNNING" => Self::Running,
                "PAUSED" => Self::Paused,
                "FAILED" => Self::Failed,
                "RESTARTING" => Self::Restarting,
                "STOPPED" => Self::Stopped,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Unassigned => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::Paused => serializer.serialize_i32(3),
                Self::Failed => serializer.serialize_i32(4),
                Self::Restarting => serializer.serialize_i32(5),
                Self::Stopped => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.managedkafka.v1.Connector.State",
            ))
        }
    }

    /// A policy that specifies how to restart the failed connectors/tasks in a
    /// Cluster resource. If not set, the failed connectors/tasks won't be
    /// restarted.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum RestartPolicy {
        /// Optional. Restarts the individual tasks of a Connector.
        TaskRestartPolicy(std::boxed::Box<crate::model::TaskRetryPolicy>),
    }
}

/// Task Retry Policy is implemented on a best-effort
/// basis.
/// Retry delay will be exponential based on provided minimum and maximum
/// backoffs. <https://en.wikipedia.org/wiki/Exponential_backoff>.
/// Note that the delay between consecutive task restarts may not always
/// precisely match the configured settings. This can happen when the
/// ConnectCluster is in rebalancing state or if the ConnectCluster is
/// unresponsive etc. The default values for minimum and maximum backoffs are
/// 60 seconds and 30 minutes respectively.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TaskRetryPolicy {
    /// Optional. The minimum amount of time to wait before retrying a failed task.
    /// This sets a lower bound for the backoff delay.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub minimum_backoff: std::option::Option<wkt::Duration>,

    /// Optional. The maximum amount of time to wait before retrying a failed task.
    /// This sets an upper bound for the backoff delay.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub maximum_backoff: std::option::Option<wkt::Duration>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TaskRetryPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [minimum_backoff][crate::model::TaskRetryPolicy::minimum_backoff].
    pub fn set_minimum_backoff<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.minimum_backoff = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [minimum_backoff][crate::model::TaskRetryPolicy::minimum_backoff].
    pub fn set_or_clear_minimum_backoff<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.minimum_backoff = v.map(|x| x.into());
        self
    }

    /// Sets the value of [maximum_backoff][crate::model::TaskRetryPolicy::maximum_backoff].
    pub fn set_maximum_backoff<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.maximum_backoff = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [maximum_backoff][crate::model::TaskRetryPolicy::maximum_backoff].
    pub fn set_or_clear_maximum_backoff<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.maximum_backoff = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for TaskRetryPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.TaskRetryPolicy"
    }
}

/// Represents the set of ACLs for a given Kafka Resource Pattern, which consists
/// of resource_type, resource_name and pattern_type.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Acl {
    /// Identifier. The name for the acl. Represents a single Resource Pattern.
    /// Structured like:
    /// projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}
    ///
    /// The structure of `acl_id` defines the Resource Pattern (resource_type,
    /// resource_name, pattern_type) of the acl. `acl_id` is structured like one of
    /// the following:
    ///
    /// For acls on the cluster:
    /// `cluster`
    ///
    /// For acls on a single resource within the cluster:
    /// `topic/{resource_name}`
    /// `consumerGroup/{resource_name}`
    /// `transactionalId/{resource_name}`
    ///
    /// For acls on all resources that match a prefix:
    /// `topicPrefixed/{resource_name}`
    /// `consumerGroupPrefixed/{resource_name}`
    /// `transactionalIdPrefixed/{resource_name}`
    ///
    /// For acls on all resources of a given type (i.e. the wildcard literal "*"):
    /// `allTopics` (represents `topic/*`)
    /// `allConsumerGroups` (represents `consumerGroup/*`)
    /// `allTransactionalIds` (represents `transactionalId/*`)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Required. The ACL entries that apply to the resource pattern. The maximum
    /// number of allowed entries 100.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub acl_entries: std::vec::Vec<crate::model::AclEntry>,

    /// Optional. `etag` is used for concurrency control. An `etag` is returned in
    /// the response to `GetAcl` and `CreateAcl`. Callers are required to put that
    /// etag in the request to `UpdateAcl` to ensure that their change will be
    /// applied to the same version of the acl that exists in the Kafka Cluster.
    ///
    /// A terminal 'T' character in the etag indicates that the AclEntries were
    /// truncated; more entries for the Acl exist on the Kafka Cluster, but can't
    /// be returned in the Acl due to repeated field limits.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub etag: std::string::String,

    /// Output only. The ACL resource type derived from the name. One of: CLUSTER,
    /// TOPIC, GROUP, TRANSACTIONAL_ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub resource_type: std::string::String,

    /// Output only. The ACL resource name derived from the name. For cluster
    /// resource_type, this is always "kafka-cluster". Can be the wildcard literal
    /// "*".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub resource_name: std::string::String,

    /// Output only. The ACL pattern type derived from the name. One of: LITERAL,
    /// PREFIXED.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub pattern_type: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Acl {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Acl::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [acl_entries][crate::model::Acl::acl_entries].
    pub fn set_acl_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AclEntry>,
    {
        use std::iter::Iterator;
        self.acl_entries = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [etag][crate::model::Acl::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [resource_type][crate::model::Acl::resource_type].
    pub fn set_resource_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_type = v.into();
        self
    }

    /// Sets the value of [resource_name][crate::model::Acl::resource_name].
    pub fn set_resource_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_name = v.into();
        self
    }

    /// Sets the value of [pattern_type][crate::model::Acl::pattern_type].
    pub fn set_pattern_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pattern_type = v.into();
        self
    }
}

impl wkt::message::Message for Acl {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.Acl"
    }
}

/// Represents the access granted for a given Resource Pattern in an ACL.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AclEntry {
    /// Required. The principal. Specified as Google Cloud account, with the Kafka
    /// StandardAuthorizer prefix "User:". For example:
    /// "User:test-kafka-client@test-project.iam.gserviceaccount.com".
    /// Can be the wildcard "User:*" to refer to all users.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub principal: std::string::String,

    /// Required. The permission type. Accepted values are (case insensitive):
    /// ALLOW, DENY.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub permission_type: std::string::String,

    /// Required. The operation type. Allowed values are (case insensitive): ALL,
    /// READ, WRITE, CREATE, DELETE, ALTER, DESCRIBE, CLUSTER_ACTION,
    /// DESCRIBE_CONFIGS, ALTER_CONFIGS, and IDEMPOTENT_WRITE. See
    /// <https://kafka.apache.org/documentation/#operations_resources_and_protocols>
    /// for valid combinations of resource_type and operation for different Kafka
    /// API requests.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub operation: std::string::String,

    /// Required. The host. Must be set to "*" for Managed Service for Apache
    /// Kafka.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub host: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AclEntry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [principal][crate::model::AclEntry::principal].
    pub fn set_principal<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.principal = v.into();
        self
    }

    /// Sets the value of [permission_type][crate::model::AclEntry::permission_type].
    pub fn set_permission_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.permission_type = v.into();
        self
    }

    /// Sets the value of [operation][crate::model::AclEntry::operation].
    pub fn set_operation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.operation = v.into();
        self
    }

    /// Sets the value of [host][crate::model::AclEntry::host].
    pub fn set_host<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host = v.into();
        self
    }
}

impl wkt::message::Message for AclEntry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.v1.AclEntry"
    }
}
