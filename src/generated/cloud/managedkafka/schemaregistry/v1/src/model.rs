// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate api;
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

mod debug;
mod deserialize;
mod serialize;

/// Request for GetSchemaRegistry.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetSchemaRegistryRequest {
    /// Required. The name of the schema registry instance to return. Structured
    /// like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSchemaRegistryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSchemaRegistryRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetSchemaRegistryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.GetSchemaRegistryRequest"
    }
}

/// Request for ListSchemaRegistries.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSchemaRegistriesRequest {
    /// Required. The parent whose schema registry instances are to be listed.
    /// Structured like: `projects/{project}/locations/{location}`
    pub parent: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSchemaRegistriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSchemaRegistriesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for ListSchemaRegistriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.ListSchemaRegistriesRequest"
    }
}

/// Request for ListSchemaRegistries.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSchemaRegistriesResponse {
    /// The schema registry instances.
    pub schema_registries: std::vec::Vec<crate::model::SchemaRegistry>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSchemaRegistriesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [schema_registries][crate::model::ListSchemaRegistriesResponse::schema_registries].
    pub fn set_schema_registries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SchemaRegistry>,
    {
        use std::iter::Iterator;
        self.schema_registries = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListSchemaRegistriesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.ListSchemaRegistriesResponse"
    }
}

/// Request to create a schema registry instance.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateSchemaRegistryRequest {
    /// Required. The parent whose schema registry instance is to be created.
    /// Structured like: `projects/{project}/locations/{location}`
    pub parent: std::string::String,

    /// Required. The schema registry instance ID to use for this schema registry.
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9), and underscores
    /// (-). The maximum length is 63 characters.
    /// The ID must not start with a number.
    pub schema_registry_id: std::string::String,

    /// Required. The schema registry instance to create.
    /// The name field is ignored.
    pub schema_registry: std::option::Option<crate::model::SchemaRegistry>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateSchemaRegistryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateSchemaRegistryRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [schema_registry_id][crate::model::CreateSchemaRegistryRequest::schema_registry_id].
    pub fn set_schema_registry_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.schema_registry_id = v.into();
        self
    }

    /// Sets the value of [schema_registry][crate::model::CreateSchemaRegistryRequest::schema_registry].
    pub fn set_schema_registry<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SchemaRegistry>,
    {
        self.schema_registry = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [schema_registry][crate::model::CreateSchemaRegistryRequest::schema_registry].
    pub fn set_or_clear_schema_registry<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SchemaRegistry>,
    {
        self.schema_registry = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateSchemaRegistryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.CreateSchemaRegistryRequest"
    }
}

/// Request for DeleteSchemaRegistry.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteSchemaRegistryRequest {
    /// Required. The name of the schema registry instance to delete. Structured
    /// like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteSchemaRegistryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteSchemaRegistryRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteSchemaRegistryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.DeleteSchemaRegistryRequest"
    }
}

/// Request for GetContext
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetContextRequest {
    /// Required. The name of the context to return. Structured like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}`
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetContextRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetContextRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetContextRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.GetContextRequest"
    }
}

/// Request for ListContexts.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListContextsRequest {
    /// Required. The parent of the contexts. Structured like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
    pub parent: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListContextsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListContextsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for ListContextsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.ListContextsRequest"
    }
}

/// Request for GetSchema.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetSchemaRequest {
    /// Required. The name of the schema to return. Structured like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{schema}`
    pub name: std::string::String,

    /// Optional. Used to limit the search for the schema ID to a specific subject,
    /// otherwise the schema ID will be searched for in all subjects in the given
    /// specified context.
    pub subject: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSchemaRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSchemaRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [subject][crate::model::GetSchemaRequest::subject].
    pub fn set_subject<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.subject = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [subject][crate::model::GetSchemaRequest::subject].
    pub fn set_or_clear_subject<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.subject = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for GetSchemaRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.GetSchemaRequest"
    }
}

/// Request for ListSchemaTypes.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSchemaTypesRequest {
    /// Required. The parent schema registry whose schema types are to be listed.
    /// Structured like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
    pub parent: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSchemaTypesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSchemaTypesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for ListSchemaTypesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.ListSchemaTypesRequest"
    }
}

/// Request for ListSchemaVersions.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSchemaVersionsRequest {
    /// Required. The schema whose schema versions are to be listed. Structured
    /// like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{schema}`
    /// or
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/schemas/ids/{schema}`
    pub parent: std::string::String,

    /// Optional. The subject to filter the subjects by.
    pub subject: std::option::Option<std::string::String>,

    /// Optional. If true, the response will include soft-deleted versions of the
    /// schema, even if the subject is soft-deleted. The default is false.
    pub deleted: std::option::Option<bool>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSchemaVersionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSchemaVersionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [subject][crate::model::ListSchemaVersionsRequest::subject].
    pub fn set_subject<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.subject = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [subject][crate::model::ListSchemaVersionsRequest::subject].
    pub fn set_or_clear_subject<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.subject = v.map(|x| x.into());
        self
    }

    /// Sets the value of [deleted][crate::model::ListSchemaVersionsRequest::deleted].
    pub fn set_deleted<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.deleted = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deleted][crate::model::ListSchemaVersionsRequest::deleted].
    pub fn set_or_clear_deleted<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.deleted = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ListSchemaVersionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.ListSchemaVersionsRequest"
    }
}

/// Request for listing subjects.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSubjectsRequest {
    /// Required. The parent schema registry/context whose subjects are to be
    /// listed. Structured like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
    /// or
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}`
    pub parent: std::string::String,

    /// Optional. The context to filter the subjects by, in the format of
    /// `:.{context}:`. If unset, all subjects in the registry are returned. Set to
    /// empty string or add as
    /// '?subjectPrefix=' at the end of this request to list subjects in the
    /// default context.
    pub subject_prefix: std::option::Option<std::string::String>,

    /// Optional. If true, the response will include soft-deleted subjects. The
    /// default is false.
    pub deleted: std::option::Option<bool>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSubjectsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSubjectsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [subject_prefix][crate::model::ListSubjectsRequest::subject_prefix].
    pub fn set_subject_prefix<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.subject_prefix = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [subject_prefix][crate::model::ListSubjectsRequest::subject_prefix].
    pub fn set_or_clear_subject_prefix<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.subject_prefix = v.map(|x| x.into());
        self
    }

    /// Sets the value of [deleted][crate::model::ListSubjectsRequest::deleted].
    pub fn set_deleted<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.deleted = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deleted][crate::model::ListSubjectsRequest::deleted].
    pub fn set_or_clear_deleted<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.deleted = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ListSubjectsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.ListSubjectsRequest"
    }
}

/// Request for listing subjects.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSubjectsBySchemaIdRequest {
    /// Required. The schema resource whose associated subjects are to be listed.
    /// Structured like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{schema}`
    /// or
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/schemas/ids/{schema}`
    pub parent: std::string::String,

    /// Optional. The subject to filter the subjects by.
    pub subject: std::option::Option<std::string::String>,

    /// Optional. If true, the response will include soft-deleted subjects. The
    /// default is false.
    pub deleted: std::option::Option<bool>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSubjectsBySchemaIdRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSubjectsBySchemaIdRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [subject][crate::model::ListSubjectsBySchemaIdRequest::subject].
    pub fn set_subject<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.subject = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [subject][crate::model::ListSubjectsBySchemaIdRequest::subject].
    pub fn set_or_clear_subject<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.subject = v.map(|x| x.into());
        self
    }

    /// Sets the value of [deleted][crate::model::ListSubjectsBySchemaIdRequest::deleted].
    pub fn set_deleted<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.deleted = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deleted][crate::model::ListSubjectsBySchemaIdRequest::deleted].
    pub fn set_or_clear_deleted<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.deleted = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ListSubjectsBySchemaIdRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.ListSubjectsBySchemaIdRequest"
    }
}

/// Request for GetVersions.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListVersionsRequest {
    /// Required. The subject whose versions are to be listed. Structured like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}`
    /// or
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}`
    pub parent: std::string::String,

    /// Optional. If true, the response will include soft-deleted versions of an
    /// active or soft-deleted subject. The default is false.
    pub deleted: std::option::Option<bool>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVersionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListVersionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [deleted][crate::model::ListVersionsRequest::deleted].
    pub fn set_deleted<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.deleted = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deleted][crate::model::ListVersionsRequest::deleted].
    pub fn set_or_clear_deleted<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.deleted = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ListVersionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.ListVersionsRequest"
    }
}

/// Request for DeleteSubject.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteSubjectRequest {
    /// Required. The name of the subject to delete. Structured like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}`
    /// or
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}`
    pub name: std::string::String,

    /// Optional. If true, the subject and all associated metadata including the
    /// schema ID will be deleted permanently. Otherwise, only the subject is
    /// soft-deleted. The default is false. Soft-deleted subjects can still be
    /// searched in ListSubjects API call with deleted=true query parameter. A
    /// soft-delete of a subject must be performed before a hard-delete.
    pub permanent: std::option::Option<bool>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteSubjectRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteSubjectRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [permanent][crate::model::DeleteSubjectRequest::permanent].
    pub fn set_permanent<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.permanent = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [permanent][crate::model::DeleteSubjectRequest::permanent].
    pub fn set_or_clear_permanent<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.permanent = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DeleteSubjectRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.DeleteSubjectRequest"
    }
}

/// Request for GetVersion.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetVersionRequest {
    /// Required. The name of the subject to return versions. Structured like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}`
    /// or
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}/versions/{version}`
    pub name: std::string::String,

    /// Optional. If true, no matter if the subject/version is soft-deleted or not,
    /// it returns the version details. If false, it returns NOT_FOUND error if the
    /// subject/version is soft-deleted. The default is false.
    pub deleted: std::option::Option<bool>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetVersionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [deleted][crate::model::GetVersionRequest::deleted].
    pub fn set_deleted<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.deleted = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deleted][crate::model::GetVersionRequest::deleted].
    pub fn set_or_clear_deleted<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.deleted = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for GetVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.GetVersionRequest"
    }
}

/// Request for CreateVersion.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateVersionRequest {
    /// Required. The subject to create the version for. Structured like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}`
    /// or
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}`
    pub parent: std::string::String,

    /// Optional. The version to create. It is optional. If not specified, the
    /// version will be created with the max version ID of the subject increased
    /// by 1. If the version ID is specified, it will be used as the new version ID
    /// and must not be used by an existing version of the subject.
    pub version: std::option::Option<i32>,

    /// Optional. The schema ID of the schema. If not specified, the schema ID will
    /// be generated by the server. If the schema ID is specified, it must not be
    /// used by an existing schema that is different from the schema to be created.
    pub id: std::option::Option<i32>,

    /// Optional. The type of the schema. It is optional. If not specified, the
    /// schema type will be AVRO.
    pub schema_type: std::option::Option<crate::model::schema::SchemaType>,

    /// Required. The schema payload
    pub schema: std::string::String,

    /// Optional. The schema references used by the schema.
    pub references: std::vec::Vec<crate::model::schema::SchemaReference>,

    /// Optional. If true, the schema will be normalized before being stored. The
    /// default is false.
    pub normalize: std::option::Option<bool>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateVersionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [version][crate::model::CreateVersionRequest::version].
    pub fn set_version<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.version = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [version][crate::model::CreateVersionRequest::version].
    pub fn set_or_clear_version<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.version = v.map(|x| x.into());
        self
    }

    /// Sets the value of [id][crate::model::CreateVersionRequest::id].
    pub fn set_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [id][crate::model::CreateVersionRequest::id].
    pub fn set_or_clear_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [schema_type][crate::model::CreateVersionRequest::schema_type].
    pub fn set_schema_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::schema::SchemaType>,
    {
        self.schema_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [schema_type][crate::model::CreateVersionRequest::schema_type].
    pub fn set_or_clear_schema_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::schema::SchemaType>,
    {
        self.schema_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [schema][crate::model::CreateVersionRequest::schema].
    pub fn set_schema<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schema = v.into();
        self
    }

    /// Sets the value of [references][crate::model::CreateVersionRequest::references].
    pub fn set_references<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::schema::SchemaReference>,
    {
        use std::iter::Iterator;
        self.references = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [normalize][crate::model::CreateVersionRequest::normalize].
    pub fn set_normalize<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.normalize = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [normalize][crate::model::CreateVersionRequest::normalize].
    pub fn set_or_clear_normalize<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.normalize = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.CreateVersionRequest"
    }
}

/// Response for CreateVersion.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateVersionResponse {
    /// The unique identifier of the schema created.
    pub id: i32,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateVersionResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::CreateVersionResponse::id].
    pub fn set_id<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }
}

impl wkt::message::Message for CreateVersionResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.CreateVersionResponse"
    }
}

/// Request for LookupVersion.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LookupVersionRequest {
    /// Required. The subject to lookup the schema in. Structured like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}`
    /// or
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}`
    pub parent: std::string::String,

    /// Optional. The schema type of the schema.
    pub schema_type: std::option::Option<crate::model::schema::SchemaType>,

    /// Required. The schema payload
    pub schema: std::string::String,

    /// Optional. The schema references used by the schema.
    pub references: std::vec::Vec<crate::model::schema::SchemaReference>,

    /// Optional. If true, the schema will be normalized before being looked up.
    /// The default is false.
    pub normalize: std::option::Option<bool>,

    /// Optional. If true, soft-deleted versions will be included in lookup, no
    /// matter if the subject is active or soft-deleted. If false, soft-deleted
    /// versions will be excluded. The default is false.
    pub deleted: std::option::Option<bool>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LookupVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::LookupVersionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [schema_type][crate::model::LookupVersionRequest::schema_type].
    pub fn set_schema_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::schema::SchemaType>,
    {
        self.schema_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [schema_type][crate::model::LookupVersionRequest::schema_type].
    pub fn set_or_clear_schema_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::schema::SchemaType>,
    {
        self.schema_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [schema][crate::model::LookupVersionRequest::schema].
    pub fn set_schema<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schema = v.into();
        self
    }

    /// Sets the value of [references][crate::model::LookupVersionRequest::references].
    pub fn set_references<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::schema::SchemaReference>,
    {
        use std::iter::Iterator;
        self.references = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [normalize][crate::model::LookupVersionRequest::normalize].
    pub fn set_normalize<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.normalize = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [normalize][crate::model::LookupVersionRequest::normalize].
    pub fn set_or_clear_normalize<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.normalize = v.map(|x| x.into());
        self
    }

    /// Sets the value of [deleted][crate::model::LookupVersionRequest::deleted].
    pub fn set_deleted<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.deleted = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deleted][crate::model::LookupVersionRequest::deleted].
    pub fn set_or_clear_deleted<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.deleted = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for LookupVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.LookupVersionRequest"
    }
}

/// Request for DeleteVersion.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteVersionRequest {
    /// Required. The name of the subject version to delete. Structured like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}`
    /// or
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}/versions/{version}`
    pub name: std::string::String,

    /// Optional. If true, both the version and the referenced schema ID will be
    /// permanently deleted. The default is false. If false, the version will be
    /// deleted but the schema ID will be retained. Soft-deleted versions can still
    /// be searched in ListVersions API call with deleted=true query parameter. A
    /// soft-delete of a version must be performed before a hard-delete.
    pub permanent: std::option::Option<bool>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteVersionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [permanent][crate::model::DeleteVersionRequest::permanent].
    pub fn set_permanent<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.permanent = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [permanent][crate::model::DeleteVersionRequest::permanent].
    pub fn set_or_clear_permanent<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.permanent = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DeleteVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.DeleteVersionRequest"
    }
}

/// Request for ListReferencedSchemas.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListReferencedSchemasRequest {
    /// Required. The version to list referenced by. Structured like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}`
    /// or
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}/versions/{version}`
    pub parent: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListReferencedSchemasRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListReferencedSchemasRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for ListReferencedSchemasRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.ListReferencedSchemasRequest"
    }
}

/// Request for CheckCompatibility.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CheckCompatibilityRequest {
    /// Required. The name of the resource to check compatibility for. The format
    /// is either of following:
    ///
    /// * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/compatibility/subjects/*/versions: Check compatibility with one or
    ///   more versions of the specified subject.
    /// * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/compatibility/subjects/{subject}/versions/{version}: Check
    ///   compatibility with a specific version of the subject.
    pub name: std::string::String,

    /// Optional. The schema type of the schema.
    pub schema_type: std::option::Option<crate::model::schema::SchemaType>,

    /// Required. The schema payload
    pub schema: std::string::String,

    /// Optional. The schema references used by the schema.
    pub references: std::vec::Vec<crate::model::schema::SchemaReference>,

    /// Optional. If true, the response will contain the compatibility check result
    /// with reasons for failed checks. The default is false.
    pub verbose: std::option::Option<bool>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CheckCompatibilityRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CheckCompatibilityRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [schema_type][crate::model::CheckCompatibilityRequest::schema_type].
    pub fn set_schema_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::schema::SchemaType>,
    {
        self.schema_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [schema_type][crate::model::CheckCompatibilityRequest::schema_type].
    pub fn set_or_clear_schema_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::schema::SchemaType>,
    {
        self.schema_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [schema][crate::model::CheckCompatibilityRequest::schema].
    pub fn set_schema<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schema = v.into();
        self
    }

    /// Sets the value of [references][crate::model::CheckCompatibilityRequest::references].
    pub fn set_references<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::schema::SchemaReference>,
    {
        use std::iter::Iterator;
        self.references = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [verbose][crate::model::CheckCompatibilityRequest::verbose].
    pub fn set_verbose<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.verbose = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [verbose][crate::model::CheckCompatibilityRequest::verbose].
    pub fn set_or_clear_verbose<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.verbose = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CheckCompatibilityRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.CheckCompatibilityRequest"
    }
}

/// Response for CheckCompatibility.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CheckCompatibilityResponse {
    /// The compatibility check result. If true, the schema is compatible with the
    /// resource.
    pub is_compatible: bool,

    /// Failure reasons if verbose = true.
    pub messages: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CheckCompatibilityResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [is_compatible][crate::model::CheckCompatibilityResponse::is_compatible].
    pub fn set_is_compatible<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_compatible = v.into();
        self
    }

    /// Sets the value of [messages][crate::model::CheckCompatibilityResponse::messages].
    pub fn set_messages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.messages = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CheckCompatibilityResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.CheckCompatibilityResponse"
    }
}

/// Request for getting config.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetSchemaConfigRequest {
    /// Required. The resource name to get the config for. It can be either of
    /// following:
    ///
    /// * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config: Get config at global level.
    /// * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config/{subject}: Get config for a specific subject.
    pub name: std::string::String,

    /// Optional. If true, the config will fall back to the config at the global
    /// level if no subject level config is found.
    pub default_to_global: std::option::Option<bool>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSchemaConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSchemaConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [default_to_global][crate::model::GetSchemaConfigRequest::default_to_global].
    pub fn set_default_to_global<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.default_to_global = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [default_to_global][crate::model::GetSchemaConfigRequest::default_to_global].
    pub fn set_or_clear_default_to_global<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.default_to_global = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for GetSchemaConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.GetSchemaConfigRequest"
    }
}

/// Request for updating schema config.
/// On a SchemaSubject-level SchemaConfig, an unset field will be removed from
/// the SchemaConfig.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateSchemaConfigRequest {
    /// Required. The resource name to update the config for. It can be either of
    /// following:
    ///
    /// * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config: Update config at global level.
    /// * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config/{subject}: Update config for a specific subject.
    pub name: std::string::String,

    /// Required. The compatibility type of the schemas.
    /// Cannot be unset for a SchemaRegistry-level SchemaConfig.
    /// If unset on a SchemaSubject-level SchemaConfig, removes the compatibility
    /// field for the SchemaConfig.
    pub compatibility: std::option::Option<crate::model::schema_config::CompatibilityType>,

    /// Optional. If true, the schema will be normalized before being stored or
    /// looked up. The default is false. Cannot be unset for a SchemaRegistry-level
    /// SchemaConfig. If unset on a SchemaSubject-level SchemaConfig, removes the
    /// normalize field for the SchemaConfig.
    pub normalize: std::option::Option<bool>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateSchemaConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateSchemaConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [compatibility][crate::model::UpdateSchemaConfigRequest::compatibility].
    pub fn set_compatibility<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::schema_config::CompatibilityType>,
    {
        self.compatibility = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [compatibility][crate::model::UpdateSchemaConfigRequest::compatibility].
    pub fn set_or_clear_compatibility<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::schema_config::CompatibilityType>,
    {
        self.compatibility = v.map(|x| x.into());
        self
    }

    /// Sets the value of [normalize][crate::model::UpdateSchemaConfigRequest::normalize].
    pub fn set_normalize<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.normalize = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [normalize][crate::model::UpdateSchemaConfigRequest::normalize].
    pub fn set_or_clear_normalize<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.normalize = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateSchemaConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.UpdateSchemaConfigRequest"
    }
}

/// Request for deleting schema config.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteSchemaConfigRequest {
    /// Required. The resource name of subject to delete the config for. The format
    /// is
    ///
    /// * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config/{subject}
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteSchemaConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteSchemaConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteSchemaConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.DeleteSchemaConfigRequest"
    }
}

/// Request for getting schema registry or subject mode.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetSchemaModeRequest {
    /// Required. The resource name of the mode. The format is
    ///
    /// * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/mode/{subject}: mode for a schema registry, or
    /// * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/mode/{subject}: mode for a specific subject in a specific context
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSchemaModeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSchemaModeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetSchemaModeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.GetSchemaModeRequest"
    }
}

/// Request for updating schema registry or subject mode.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateSchemaModeRequest {
    /// Required. The resource name of the mode. The format is
    ///
    /// * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/mode/{subject}: mode for a schema registry, or
    /// * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/mode/{subject}: mode for a specific subject in a specific context
    pub name: std::string::String,

    /// Required. The mode type.
    pub mode: crate::model::schema_mode::ModeType,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateSchemaModeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateSchemaModeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [mode][crate::model::UpdateSchemaModeRequest::mode].
    pub fn set_mode<T: std::convert::Into<crate::model::schema_mode::ModeType>>(
        mut self,
        v: T,
    ) -> Self {
        self.mode = v.into();
        self
    }
}

impl wkt::message::Message for UpdateSchemaModeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.UpdateSchemaModeRequest"
    }
}

/// Request for deleting schema mode.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteSchemaModeRequest {
    /// Required. The resource name of subject to delete the mode for. The format
    /// is
    ///
    /// * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/mode/{subject}
    /// * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/mode/{subject}
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteSchemaModeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteSchemaModeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteSchemaModeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.DeleteSchemaModeRequest"
    }
}

/// SchemaRegistry is a schema registry instance.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SchemaRegistry {
    /// Identifier. The name of the schema registry instance. Structured like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
    /// The instance name {schema_registry} can contain the following:
    ///
    /// * Up to 255 characters.
    /// * Letters (uppercase or lowercase), numbers, and underscores.
    pub name: std::string::String,

    /// Output only. The contexts of the schema registry instance.
    pub contexts: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SchemaRegistry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SchemaRegistry::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [contexts][crate::model::SchemaRegistry::contexts].
    pub fn set_contexts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.contexts = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SchemaRegistry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.SchemaRegistry"
    }
}

/// Context represents an independent schema grouping in a schema registry
/// instance.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Context {
    /// Identifier. The name of the context. Structured like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}`
    /// The context name {context} can contain the following:
    ///
    /// * Up to 255 characters.
    /// * Allowed characters: letters (uppercase or lowercase), numbers, and the
    ///   following special characters: `.`, `-`, `_`, `+`, `%`, and `~`.
    pub name: std::string::String,

    /// Optional. The subjects of the context.
    pub subjects: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Context {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Context::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [subjects][crate::model::Context::subjects].
    pub fn set_subjects<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.subjects = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Context {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.Context"
    }
}

/// Schema for a Kafka message.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Schema {
    /// Optional. The schema type of the schema.
    pub schema_type: crate::model::schema::SchemaType,

    /// The schema payload.
    pub schema_payload: std::string::String,

    /// Optional. The schema references used by the schema.
    pub references: std::vec::Vec<crate::model::schema::SchemaReference>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Schema {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [schema_type][crate::model::Schema::schema_type].
    pub fn set_schema_type<T: std::convert::Into<crate::model::schema::SchemaType>>(
        mut self,
        v: T,
    ) -> Self {
        self.schema_type = v.into();
        self
    }

    /// Sets the value of [schema_payload][crate::model::Schema::schema_payload].
    pub fn set_schema_payload<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schema_payload = v.into();
        self
    }

    /// Sets the value of [references][crate::model::Schema::references].
    pub fn set_references<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::schema::SchemaReference>,
    {
        use std::iter::Iterator;
        self.references = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Schema {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.Schema"
    }
}

/// Defines additional types related to [Schema].
pub mod schema {
    #[allow(unused_imports)]
    use super::*;

    /// SchemaReference is a reference to a schema.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SchemaReference {
        /// Required. The name of the reference.
        pub name: std::string::String,

        /// Required. The subject of the reference.
        pub subject: std::string::String,

        /// Required. The version of the reference.
        pub version: i32,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SchemaReference {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::schema::SchemaReference::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [subject][crate::model::schema::SchemaReference::subject].
        pub fn set_subject<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.subject = v.into();
            self
        }

        /// Sets the value of [version][crate::model::schema::SchemaReference::version].
        pub fn set_version<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.version = v.into();
            self
        }
    }

    impl wkt::message::Message for SchemaReference {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.Schema.SchemaReference"
        }
    }

    /// Schema types.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SchemaType {
        /// No schema type. The default will be AVRO.
        Unspecified,
        /// Avro schema type.
        Avro,
        /// JSON schema type.
        Json,
        /// Protobuf schema type.
        Protobuf,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SchemaType::value] or
        /// [SchemaType::name].
        UnknownValue(schema_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod schema_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SchemaType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Avro => std::option::Option::Some(1),
                Self::Json => std::option::Option::Some(2),
                Self::Protobuf => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SCHEMA_TYPE_UNSPECIFIED"),
                Self::Avro => std::option::Option::Some("AVRO"),
                Self::Json => std::option::Option::Some("JSON"),
                Self::Protobuf => std::option::Option::Some("PROTOBUF"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SchemaType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SchemaType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SchemaType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Avro,
                2 => Self::Json,
                3 => Self::Protobuf,
                _ => Self::UnknownValue(schema_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SchemaType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SCHEMA_TYPE_UNSPECIFIED" => Self::Unspecified,
                "AVRO" => Self::Avro,
                "JSON" => Self::Json,
                "PROTOBUF" => Self::Protobuf,
                _ => Self::UnknownValue(schema_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SchemaType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Avro => serializer.serialize_i32(1),
                Self::Json => serializer.serialize_i32(2),
                Self::Protobuf => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SchemaType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SchemaType>::new(
                ".google.cloud.managedkafka.schemaregistry.v1.Schema.SchemaType",
            ))
        }
    }
}

/// Subject defines the evolution scope of schemas as a holder of schema
/// versions.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SchemaSubject {
    /// The name of the subject. Structured like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}`
    /// or
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}`
    ///
    /// Subject name {subject} can contain the following:
    ///
    /// * Up to 255 UTF-8 bytes.
    /// * Allowed characters: letters (uppercase or lowercase), numbers, and the
    ///   following special characters: `.`, `-`, `_`, `+`, `%`, and `~`.
    pub name: std::string::String,

    /// The versions of the subject.
    pub versions: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SchemaSubject {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SchemaSubject::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [versions][crate::model::SchemaSubject::versions].
    pub fn set_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.versions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SchemaSubject {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.SchemaSubject"
    }
}

/// Version of a schema.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SchemaVersion {
    /// Required. The subject of the version.
    pub subject: std::string::String,

    /// Required. The version ID
    pub version_id: i32,

    /// Required. The schema ID.
    pub schema_id: i32,

    /// Optional. The schema type of the schema.
    pub schema_type: crate::model::schema::SchemaType,

    /// Required. The schema payload.
    pub schema_payload: std::string::String,

    /// Optional. The schema references used by the schema.
    pub references: std::vec::Vec<crate::model::schema::SchemaReference>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SchemaVersion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [subject][crate::model::SchemaVersion::subject].
    pub fn set_subject<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subject = v.into();
        self
    }

    /// Sets the value of [version_id][crate::model::SchemaVersion::version_id].
    pub fn set_version_id<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.version_id = v.into();
        self
    }

    /// Sets the value of [schema_id][crate::model::SchemaVersion::schema_id].
    pub fn set_schema_id<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.schema_id = v.into();
        self
    }

    /// Sets the value of [schema_type][crate::model::SchemaVersion::schema_type].
    pub fn set_schema_type<T: std::convert::Into<crate::model::schema::SchemaType>>(
        mut self,
        v: T,
    ) -> Self {
        self.schema_type = v.into();
        self
    }

    /// Sets the value of [schema_payload][crate::model::SchemaVersion::schema_payload].
    pub fn set_schema_payload<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schema_payload = v.into();
        self
    }

    /// Sets the value of [references][crate::model::SchemaVersion::references].
    pub fn set_references<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::schema::SchemaReference>,
    {
        use std::iter::Iterator;
        self.references = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SchemaVersion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.SchemaVersion"
    }
}

/// SchemaConfig represents configuration for a schema registry or a specific
/// subject.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SchemaConfig {
    /// Required. The compatibility type of the schema.
    /// The default value is BACKWARD.
    /// If unset in a SchemaSubject-level SchemaConfig, defaults to the global
    /// value. If unset in a SchemaRegistry-level SchemaConfig, reverts to the
    /// default value.
    pub compatibility: std::option::Option<crate::model::schema_config::CompatibilityType>,

    /// Optional. If true, the schema will be normalized before being stored or
    /// looked up. The default is false. If unset in a SchemaSubject-level
    /// SchemaConfig, the global value will be used. If unset in a
    /// SchemaRegistry-level SchemaConfig, reverts to the default value.
    pub normalize: std::option::Option<bool>,

    /// Optional. The subject to which this subject is an alias of. Only applicable
    /// for subject config.
    pub alias: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SchemaConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [compatibility][crate::model::SchemaConfig::compatibility].
    pub fn set_compatibility<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::schema_config::CompatibilityType>,
    {
        self.compatibility = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [compatibility][crate::model::SchemaConfig::compatibility].
    pub fn set_or_clear_compatibility<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::schema_config::CompatibilityType>,
    {
        self.compatibility = v.map(|x| x.into());
        self
    }

    /// Sets the value of [normalize][crate::model::SchemaConfig::normalize].
    pub fn set_normalize<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.normalize = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [normalize][crate::model::SchemaConfig::normalize].
    pub fn set_or_clear_normalize<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.normalize = v.map(|x| x.into());
        self
    }

    /// Sets the value of [alias][crate::model::SchemaConfig::alias].
    pub fn set_alias<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.alias = v.into();
        self
    }
}

impl wkt::message::Message for SchemaConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.SchemaConfig"
    }
}

/// Defines additional types related to [SchemaConfig].
pub mod schema_config {
    #[allow(unused_imports)]
    use super::*;

    /// Compatibility type of the schemas.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CompatibilityType {
        /// No compatibility check.
        None,
        /// Backwards compatible with the most recent version.
        Backward,
        /// Backwards compatible with all previous versions.
        BackwardTransitive,
        /// Forwards compatible with the most recent version.
        Forward,
        /// Forwards compatible with all previous versions.
        ForwardTransitive,
        /// Backwards and forwards compatible with the most recent version.
        Full,
        /// Backwards and forwards compatible with all previous versions.
        FullTransitive,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CompatibilityType::value] or
        /// [CompatibilityType::name].
        UnknownValue(compatibility_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod compatibility_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CompatibilityType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::None => std::option::Option::Some(0),
                Self::Backward => std::option::Option::Some(1),
                Self::BackwardTransitive => std::option::Option::Some(2),
                Self::Forward => std::option::Option::Some(3),
                Self::ForwardTransitive => std::option::Option::Some(4),
                Self::Full => std::option::Option::Some(5),
                Self::FullTransitive => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::None => std::option::Option::Some("NONE"),
                Self::Backward => std::option::Option::Some("BACKWARD"),
                Self::BackwardTransitive => std::option::Option::Some("BACKWARD_TRANSITIVE"),
                Self::Forward => std::option::Option::Some("FORWARD"),
                Self::ForwardTransitive => std::option::Option::Some("FORWARD_TRANSITIVE"),
                Self::Full => std::option::Option::Some("FULL"),
                Self::FullTransitive => std::option::Option::Some("FULL_TRANSITIVE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CompatibilityType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CompatibilityType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CompatibilityType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::None,
                1 => Self::Backward,
                2 => Self::BackwardTransitive,
                3 => Self::Forward,
                4 => Self::ForwardTransitive,
                5 => Self::Full,
                6 => Self::FullTransitive,
                _ => Self::UnknownValue(compatibility_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CompatibilityType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "NONE" => Self::None,
                "BACKWARD" => Self::Backward,
                "BACKWARD_TRANSITIVE" => Self::BackwardTransitive,
                "FORWARD" => Self::Forward,
                "FORWARD_TRANSITIVE" => Self::ForwardTransitive,
                "FULL" => Self::Full,
                "FULL_TRANSITIVE" => Self::FullTransitive,
                _ => Self::UnknownValue(compatibility_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CompatibilityType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::None => serializer.serialize_i32(0),
                Self::Backward => serializer.serialize_i32(1),
                Self::BackwardTransitive => serializer.serialize_i32(2),
                Self::Forward => serializer.serialize_i32(3),
                Self::ForwardTransitive => serializer.serialize_i32(4),
                Self::Full => serializer.serialize_i32(5),
                Self::FullTransitive => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CompatibilityType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CompatibilityType>::new(
                ".google.cloud.managedkafka.schemaregistry.v1.SchemaConfig.CompatibilityType",
            ))
        }
    }
}

/// SchemaMode represents the mode of a schema registry or a specific subject.
/// Four modes are supported:
///
/// * NONE: deprecated. This was the default mode for a subject, but now the
///   default is unset (which means use the global schema registry setting)
/// * READONLY: The schema registry is in read-only mode.
/// * READWRITE: The schema registry is in read-write mode, which allows limited
///   write operations on the schema.
/// * IMPORT: The schema registry is in import mode, which allows more editing
///   operations on the schema for data importing purposes.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SchemaMode {
    /// Required. The mode type of a schema registry (READWRITE by default) or of a
    /// subject (unset by default, which means use the global schema registry
    /// setting).
    pub mode: crate::model::schema_mode::ModeType,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SchemaMode {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mode][crate::model::SchemaMode::mode].
    pub fn set_mode<T: std::convert::Into<crate::model::schema_mode::ModeType>>(
        mut self,
        v: T,
    ) -> Self {
        self.mode = v.into();
        self
    }
}

impl wkt::message::Message for SchemaMode {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.SchemaMode"
    }
}

/// Defines additional types related to [SchemaMode].
pub mod schema_mode {
    #[allow(unused_imports)]
    use super::*;

    /// Mode type of the schemas or subjects.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ModeType {
        /// The default / unset value.
        /// The subject mode is NONE/unset by default, which means use the global
        /// schema registry mode. This should not be used for setting the mode.
        None,
        /// READONLY mode.
        Readonly,
        /// READWRITE mode.
        Readwrite,
        /// IMPORT mode.
        Import,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ModeType::value] or
        /// [ModeType::name].
        UnknownValue(mode_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod mode_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ModeType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::None => std::option::Option::Some(0),
                Self::Readonly => std::option::Option::Some(1),
                Self::Readwrite => std::option::Option::Some(2),
                Self::Import => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::None => std::option::Option::Some("NONE"),
                Self::Readonly => std::option::Option::Some("READONLY"),
                Self::Readwrite => std::option::Option::Some("READWRITE"),
                Self::Import => std::option::Option::Some("IMPORT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ModeType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ModeType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ModeType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::None,
                1 => Self::Readonly,
                2 => Self::Readwrite,
                3 => Self::Import,
                _ => Self::UnknownValue(mode_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ModeType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "NONE" => Self::None,
                "READONLY" => Self::Readonly,
                "READWRITE" => Self::Readwrite,
                "IMPORT" => Self::Import,
                _ => Self::UnknownValue(mode_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ModeType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::None => serializer.serialize_i32(0),
                Self::Readonly => serializer.serialize_i32(1),
                Self::Readwrite => serializer.serialize_i32(2),
                Self::Import => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ModeType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ModeType>::new(
                ".google.cloud.managedkafka.schemaregistry.v1.SchemaMode.ModeType",
            ))
        }
    }
}
