// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate api;
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Request for GetSchemaRegistry.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetSchemaRegistryRequest {
    /// Required. The name of the schema registry instance to return. Structured
    /// like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSchemaRegistryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSchemaRegistryRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetSchemaRegistryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.GetSchemaRegistryRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetSchemaRegistryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetSchemaRegistryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetSchemaRegistryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetSchemaRegistryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetSchemaRegistryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetSchemaRegistryRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetSchemaRegistryRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for ListSchemaRegistries.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSchemaRegistriesRequest {
    /// Required. The parent whose schema registry instances are to be listed.
    /// Structured like: `projects/{project}/locations/{location}`
    pub parent: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSchemaRegistriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSchemaRegistriesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for ListSchemaRegistriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.ListSchemaRegistriesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSchemaRegistriesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSchemaRegistriesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSchemaRegistriesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSchemaRegistriesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSchemaRegistriesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListSchemaRegistriesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListSchemaRegistriesRequest");
        debug_struct.field("parent", &self.parent);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for ListSchemaRegistries.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSchemaRegistriesResponse {
    /// The schema registry instances.
    pub schema_registries: std::vec::Vec<crate::model::SchemaRegistry>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSchemaRegistriesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [schema_registries][crate::model::ListSchemaRegistriesResponse::schema_registries].
    pub fn set_schema_registries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SchemaRegistry>,
    {
        use std::iter::Iterator;
        self.schema_registries = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListSchemaRegistriesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.ListSchemaRegistriesResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSchemaRegistriesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __schema_registries,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSchemaRegistriesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "schemaRegistries" => Ok(__FieldTag::__schema_registries),
                            "schema_registries" => Ok(__FieldTag::__schema_registries),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSchemaRegistriesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSchemaRegistriesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__schema_registries => {
                            if !fields.insert(__FieldTag::__schema_registries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schema_registries",
                                ));
                            }
                            result.schema_registries =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SchemaRegistry>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSchemaRegistriesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.schema_registries.is_empty() {
            state.serialize_entry("schemaRegistries", &self.schema_registries)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListSchemaRegistriesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListSchemaRegistriesResponse");
        debug_struct.field("schema_registries", &self.schema_registries);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request to create a schema registry instance.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateSchemaRegistryRequest {
    /// Required. The parent whose schema registry instance is to be created.
    /// Structured like: `projects/{project}/locations/{location}`
    pub parent: std::string::String,

    /// Required. The schema registry instance ID to use for this schema registry.
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9), and underscores
    /// (-). The maximum length is 63 characters.
    /// The ID must not start with a number.
    pub schema_registry_id: std::string::String,

    /// Required. The schema registry instance to create.
    /// The name field is ignored.
    pub schema_registry: std::option::Option<crate::model::SchemaRegistry>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateSchemaRegistryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateSchemaRegistryRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [schema_registry_id][crate::model::CreateSchemaRegistryRequest::schema_registry_id].
    pub fn set_schema_registry_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.schema_registry_id = v.into();
        self
    }

    /// Sets the value of [schema_registry][crate::model::CreateSchemaRegistryRequest::schema_registry].
    pub fn set_schema_registry<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SchemaRegistry>,
    {
        self.schema_registry = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [schema_registry][crate::model::CreateSchemaRegistryRequest::schema_registry].
    pub fn set_or_clear_schema_registry<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SchemaRegistry>,
    {
        self.schema_registry = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateSchemaRegistryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.CreateSchemaRegistryRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateSchemaRegistryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __schema_registry_id,
            __schema_registry,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateSchemaRegistryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "schemaRegistryId" => Ok(__FieldTag::__schema_registry_id),
                            "schema_registry_id" => Ok(__FieldTag::__schema_registry_id),
                            "schemaRegistry" => Ok(__FieldTag::__schema_registry),
                            "schema_registry" => Ok(__FieldTag::__schema_registry),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateSchemaRegistryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateSchemaRegistryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__schema_registry_id => {
                            if !fields.insert(__FieldTag::__schema_registry_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schema_registry_id",
                                ));
                            }
                            result.schema_registry_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__schema_registry => {
                            if !fields.insert(__FieldTag::__schema_registry) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schema_registry",
                                ));
                            }
                            result.schema_registry = map
                                .next_value::<std::option::Option<crate::model::SchemaRegistry>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateSchemaRegistryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.schema_registry_id.is_empty() {
            state.serialize_entry("schemaRegistryId", &self.schema_registry_id)?;
        }
        if self.schema_registry.is_some() {
            state.serialize_entry("schemaRegistry", &self.schema_registry)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateSchemaRegistryRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateSchemaRegistryRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("schema_registry_id", &self.schema_registry_id);
        debug_struct.field("schema_registry", &self.schema_registry);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for DeleteSchemaRegistry.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteSchemaRegistryRequest {
    /// Required. The name of the schema registry instance to delete. Structured
    /// like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteSchemaRegistryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteSchemaRegistryRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteSchemaRegistryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.DeleteSchemaRegistryRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteSchemaRegistryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteSchemaRegistryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteSchemaRegistryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteSchemaRegistryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteSchemaRegistryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteSchemaRegistryRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteSchemaRegistryRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for GetContext
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetContextRequest {
    /// Required. The name of the context to return. Structured like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetContextRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetContextRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetContextRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.GetContextRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetContextRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetContextRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetContextRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetContextRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetContextRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetContextRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetContextRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for ListContexts.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListContextsRequest {
    /// Required. The parent of the contexts. Structured like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
    pub parent: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListContextsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListContextsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for ListContextsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.ListContextsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListContextsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListContextsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListContextsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListContextsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListContextsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListContextsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListContextsRequest");
        debug_struct.field("parent", &self.parent);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for GetSchema.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetSchemaRequest {
    /// Required. The name of the schema to return. Structured like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{schema}`
    pub name: std::string::String,

    /// Optional. Used to limit the search for the schema ID to a specific subject,
    /// otherwise the schema ID will be searched for in all subjects in the given
    /// specified context.
    pub subject: std::option::Option<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSchemaRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSchemaRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [subject][crate::model::GetSchemaRequest::subject].
    pub fn set_subject<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.subject = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [subject][crate::model::GetSchemaRequest::subject].
    pub fn set_or_clear_subject<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.subject = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for GetSchemaRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.GetSchemaRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetSchemaRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __subject,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetSchemaRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "subject" => Ok(__FieldTag::__subject),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetSchemaRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetSchemaRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subject => {
                            if !fields.insert(__FieldTag::__subject) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subject",
                                ));
                            }
                            result.subject =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetSchemaRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.subject.is_some() {
            state.serialize_entry("subject", &self.subject)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetSchemaRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetSchemaRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("subject", &self.subject);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for ListSchemaTypes.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSchemaTypesRequest {
    /// Required. The parent schema registry whose schema types are to be listed.
    /// Structured like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
    pub parent: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSchemaTypesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSchemaTypesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for ListSchemaTypesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.ListSchemaTypesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSchemaTypesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSchemaTypesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSchemaTypesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSchemaTypesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSchemaTypesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListSchemaTypesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListSchemaTypesRequest");
        debug_struct.field("parent", &self.parent);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for ListSchemaVersions.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSchemaVersionsRequest {
    /// Required. The schema whose schema versions are to be listed. Structured
    /// like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{schema}`
    /// or
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/schemas/ids/{schema}`
    pub parent: std::string::String,

    /// Optional. The subject to filter the subjects by.
    pub subject: std::option::Option<std::string::String>,

    /// Optional. If true, the response will include soft-deleted versions of the
    /// schema, even if the subject is soft-deleted. The default is false.
    pub deleted: std::option::Option<bool>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSchemaVersionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSchemaVersionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [subject][crate::model::ListSchemaVersionsRequest::subject].
    pub fn set_subject<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.subject = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [subject][crate::model::ListSchemaVersionsRequest::subject].
    pub fn set_or_clear_subject<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.subject = v.map(|x| x.into());
        self
    }

    /// Sets the value of [deleted][crate::model::ListSchemaVersionsRequest::deleted].
    pub fn set_deleted<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.deleted = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deleted][crate::model::ListSchemaVersionsRequest::deleted].
    pub fn set_or_clear_deleted<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.deleted = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ListSchemaVersionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.ListSchemaVersionsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSchemaVersionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __subject,
            __deleted,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSchemaVersionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "subject" => Ok(__FieldTag::__subject),
                            "deleted" => Ok(__FieldTag::__deleted),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSchemaVersionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSchemaVersionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subject => {
                            if !fields.insert(__FieldTag::__subject) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subject",
                                ));
                            }
                            result.subject =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__deleted => {
                            if !fields.insert(__FieldTag::__deleted) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deleted",
                                ));
                            }
                            result.deleted = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSchemaVersionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.subject.is_some() {
            state.serialize_entry("subject", &self.subject)?;
        }
        if self.deleted.is_some() {
            state.serialize_entry("deleted", &self.deleted)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListSchemaVersionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListSchemaVersionsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("subject", &self.subject);
        debug_struct.field("deleted", &self.deleted);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for listing subjects.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSubjectsRequest {
    /// Required. The parent schema registry/context whose subjects are to be
    /// listed. Structured like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
    /// or
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}`
    pub parent: std::string::String,

    /// Optional. The context to filter the subjects by, in the format of
    /// `:.{context}:`. If unset, all subjects in the registry are returned. Set to
    /// empty string or add as
    /// '?subjectPrefix=' at the end of this request to list subjects in the
    /// default context.
    pub subject_prefix: std::option::Option<std::string::String>,

    /// Optional. If true, the response will include soft-deleted subjects. The
    /// default is false.
    pub deleted: std::option::Option<bool>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSubjectsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSubjectsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [subject_prefix][crate::model::ListSubjectsRequest::subject_prefix].
    pub fn set_subject_prefix<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.subject_prefix = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [subject_prefix][crate::model::ListSubjectsRequest::subject_prefix].
    pub fn set_or_clear_subject_prefix<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.subject_prefix = v.map(|x| x.into());
        self
    }

    /// Sets the value of [deleted][crate::model::ListSubjectsRequest::deleted].
    pub fn set_deleted<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.deleted = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deleted][crate::model::ListSubjectsRequest::deleted].
    pub fn set_or_clear_deleted<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.deleted = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ListSubjectsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.ListSubjectsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSubjectsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __subject_prefix,
            __deleted,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSubjectsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "subjectPrefix" => Ok(__FieldTag::__subject_prefix),
                            "subject_prefix" => Ok(__FieldTag::__subject_prefix),
                            "deleted" => Ok(__FieldTag::__deleted),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSubjectsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSubjectsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subject_prefix => {
                            if !fields.insert(__FieldTag::__subject_prefix) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subject_prefix",
                                ));
                            }
                            result.subject_prefix =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__deleted => {
                            if !fields.insert(__FieldTag::__deleted) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deleted",
                                ));
                            }
                            result.deleted = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSubjectsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.subject_prefix.is_some() {
            state.serialize_entry("subjectPrefix", &self.subject_prefix)?;
        }
        if self.deleted.is_some() {
            state.serialize_entry("deleted", &self.deleted)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListSubjectsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListSubjectsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("subject_prefix", &self.subject_prefix);
        debug_struct.field("deleted", &self.deleted);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for listing subjects.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSubjectsBySchemaIdRequest {
    /// Required. The schema resource whose associated subjects are to be listed.
    /// Structured like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{schema}`
    /// or
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/schemas/ids/{schema}`
    pub parent: std::string::String,

    /// Optional. The subject to filter the subjects by.
    pub subject: std::option::Option<std::string::String>,

    /// Optional. If true, the response will include soft-deleted subjects. The
    /// default is false.
    pub deleted: std::option::Option<bool>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSubjectsBySchemaIdRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSubjectsBySchemaIdRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [subject][crate::model::ListSubjectsBySchemaIdRequest::subject].
    pub fn set_subject<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.subject = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [subject][crate::model::ListSubjectsBySchemaIdRequest::subject].
    pub fn set_or_clear_subject<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.subject = v.map(|x| x.into());
        self
    }

    /// Sets the value of [deleted][crate::model::ListSubjectsBySchemaIdRequest::deleted].
    pub fn set_deleted<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.deleted = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deleted][crate::model::ListSubjectsBySchemaIdRequest::deleted].
    pub fn set_or_clear_deleted<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.deleted = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ListSubjectsBySchemaIdRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.ListSubjectsBySchemaIdRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSubjectsBySchemaIdRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __subject,
            __deleted,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSubjectsBySchemaIdRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "subject" => Ok(__FieldTag::__subject),
                            "deleted" => Ok(__FieldTag::__deleted),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSubjectsBySchemaIdRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSubjectsBySchemaIdRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subject => {
                            if !fields.insert(__FieldTag::__subject) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subject",
                                ));
                            }
                            result.subject =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__deleted => {
                            if !fields.insert(__FieldTag::__deleted) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deleted",
                                ));
                            }
                            result.deleted = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSubjectsBySchemaIdRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.subject.is_some() {
            state.serialize_entry("subject", &self.subject)?;
        }
        if self.deleted.is_some() {
            state.serialize_entry("deleted", &self.deleted)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListSubjectsBySchemaIdRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListSubjectsBySchemaIdRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("subject", &self.subject);
        debug_struct.field("deleted", &self.deleted);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for GetVersions.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListVersionsRequest {
    /// Required. The subject whose versions are to be listed. Structured like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}`
    /// or
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}`
    pub parent: std::string::String,

    /// Optional. If true, the response will include soft-deleted versions of an
    /// active or soft-deleted subject. The default is false.
    pub deleted: std::option::Option<bool>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVersionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListVersionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [deleted][crate::model::ListVersionsRequest::deleted].
    pub fn set_deleted<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.deleted = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deleted][crate::model::ListVersionsRequest::deleted].
    pub fn set_or_clear_deleted<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.deleted = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ListVersionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.ListVersionsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListVersionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __deleted,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListVersionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "deleted" => Ok(__FieldTag::__deleted),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListVersionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListVersionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__deleted => {
                            if !fields.insert(__FieldTag::__deleted) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deleted",
                                ));
                            }
                            result.deleted = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListVersionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.deleted.is_some() {
            state.serialize_entry("deleted", &self.deleted)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListVersionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListVersionsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("deleted", &self.deleted);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for DeleteSubject.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteSubjectRequest {
    /// Required. The name of the subject to delete. Structured like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}`
    /// or
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}`
    pub name: std::string::String,

    /// Optional. If true, the subject and all associated metadata including the
    /// schema ID will be deleted permanently. Otherwise, only the subject is
    /// soft-deleted. The default is false. Soft-deleted subjects can still be
    /// searched in ListSubjects API call with deleted=true query parameter. A
    /// soft-delete of a subject must be performed before a hard-delete.
    pub permanent: std::option::Option<bool>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteSubjectRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteSubjectRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [permanent][crate::model::DeleteSubjectRequest::permanent].
    pub fn set_permanent<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.permanent = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [permanent][crate::model::DeleteSubjectRequest::permanent].
    pub fn set_or_clear_permanent<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.permanent = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DeleteSubjectRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.DeleteSubjectRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteSubjectRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __permanent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteSubjectRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "permanent" => Ok(__FieldTag::__permanent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteSubjectRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteSubjectRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__permanent => {
                            if !fields.insert(__FieldTag::__permanent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for permanent",
                                ));
                            }
                            result.permanent = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteSubjectRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.permanent.is_some() {
            state.serialize_entry("permanent", &self.permanent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteSubjectRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteSubjectRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("permanent", &self.permanent);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for GetVersion.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetVersionRequest {
    /// Required. The name of the subject to return versions. Structured like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}`
    /// or
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}/versions/{version}`
    pub name: std::string::String,

    /// Optional. If true, no matter if the subject/version is soft-deleted or not,
    /// it returns the version details. If false, it returns NOT_FOUND error if the
    /// subject/version is soft-deleted. The default is false.
    pub deleted: std::option::Option<bool>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetVersionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [deleted][crate::model::GetVersionRequest::deleted].
    pub fn set_deleted<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.deleted = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deleted][crate::model::GetVersionRequest::deleted].
    pub fn set_or_clear_deleted<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.deleted = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for GetVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.GetVersionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetVersionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __deleted,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetVersionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "deleted" => Ok(__FieldTag::__deleted),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetVersionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetVersionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__deleted => {
                            if !fields.insert(__FieldTag::__deleted) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deleted",
                                ));
                            }
                            result.deleted = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.deleted.is_some() {
            state.serialize_entry("deleted", &self.deleted)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetVersionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetVersionRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("deleted", &self.deleted);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for CreateVersion.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateVersionRequest {
    /// Required. The subject to create the version for. Structured like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}`
    /// or
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}`
    pub parent: std::string::String,

    /// Optional. The version to create. It is optional. If not specified, the
    /// version will be created with the max version ID of the subject increased
    /// by 1. If the version ID is specified, it will be used as the new version ID
    /// and must not be used by an existing version of the subject.
    pub version: std::option::Option<i32>,

    /// Optional. The schema ID of the schema. If not specified, the schema ID will
    /// be generated by the server. If the schema ID is specified, it must not be
    /// used by an existing schema that is different from the schema to be created.
    pub id: std::option::Option<i32>,

    /// Optional. The type of the schema. It is optional. If not specified, the
    /// schema type will be AVRO.
    pub schema_type: std::option::Option<crate::model::schema::SchemaType>,

    /// Required. The schema payload
    pub schema: std::string::String,

    /// Optional. The schema references used by the schema.
    pub references: std::vec::Vec<crate::model::schema::SchemaReference>,

    /// Optional. If true, the schema will be normalized before being stored. The
    /// default is false.
    pub normalize: std::option::Option<bool>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateVersionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [version][crate::model::CreateVersionRequest::version].
    pub fn set_version<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.version = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [version][crate::model::CreateVersionRequest::version].
    pub fn set_or_clear_version<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.version = v.map(|x| x.into());
        self
    }

    /// Sets the value of [id][crate::model::CreateVersionRequest::id].
    pub fn set_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [id][crate::model::CreateVersionRequest::id].
    pub fn set_or_clear_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [schema_type][crate::model::CreateVersionRequest::schema_type].
    pub fn set_schema_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::schema::SchemaType>,
    {
        self.schema_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [schema_type][crate::model::CreateVersionRequest::schema_type].
    pub fn set_or_clear_schema_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::schema::SchemaType>,
    {
        self.schema_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [schema][crate::model::CreateVersionRequest::schema].
    pub fn set_schema<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schema = v.into();
        self
    }

    /// Sets the value of [references][crate::model::CreateVersionRequest::references].
    pub fn set_references<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::schema::SchemaReference>,
    {
        use std::iter::Iterator;
        self.references = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [normalize][crate::model::CreateVersionRequest::normalize].
    pub fn set_normalize<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.normalize = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [normalize][crate::model::CreateVersionRequest::normalize].
    pub fn set_or_clear_normalize<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.normalize = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.CreateVersionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateVersionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __version,
            __id,
            __schema_type,
            __schema,
            __references,
            __normalize,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateVersionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "version" => Ok(__FieldTag::__version),
                            "id" => Ok(__FieldTag::__id),
                            "schemaType" => Ok(__FieldTag::__schema_type),
                            "schema_type" => Ok(__FieldTag::__schema_type),
                            "schema" => Ok(__FieldTag::__schema),
                            "references" => Ok(__FieldTag::__references),
                            "normalize" => Ok(__FieldTag::__normalize),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateVersionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateVersionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.version = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.id = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__schema_type => {
                            if !fields.insert(__FieldTag::__schema_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schema_type",
                                ));
                            }
                            result.schema_type = map.next_value::<std::option::Option<crate::model::schema::SchemaType>>()?
                                ;
                        }
                        __FieldTag::__schema => {
                            if !fields.insert(__FieldTag::__schema) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schema",
                                ));
                            }
                            result.schema = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__references => {
                            if !fields.insert(__FieldTag::__references) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for references",
                                ));
                            }
                            result.references = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::schema::SchemaReference>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__normalize => {
                            if !fields.insert(__FieldTag::__normalize) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for normalize",
                                ));
                            }
                            result.normalize = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.version.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("version", &__With(&self.version))?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.schema_type.is_some() {
            state.serialize_entry("schemaType", &self.schema_type)?;
        }
        if !self.schema.is_empty() {
            state.serialize_entry("schema", &self.schema)?;
        }
        if !self.references.is_empty() {
            state.serialize_entry("references", &self.references)?;
        }
        if self.normalize.is_some() {
            state.serialize_entry("normalize", &self.normalize)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateVersionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateVersionRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("version", &self.version);
        debug_struct.field("id", &self.id);
        debug_struct.field("schema_type", &self.schema_type);
        debug_struct.field("schema", &self.schema);
        debug_struct.field("references", &self.references);
        debug_struct.field("normalize", &self.normalize);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response for CreateVersion.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateVersionResponse {
    /// The unique identifier of the schema created.
    pub id: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateVersionResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::CreateVersionResponse::id].
    pub fn set_id<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }
}

impl wkt::message::Message for CreateVersionResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.CreateVersionResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateVersionResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateVersionResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateVersionResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateVersionResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.id = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateVersionResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.id) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateVersionResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateVersionResponse");
        debug_struct.field("id", &self.id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for LookupVersion.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LookupVersionRequest {
    /// Required. The subject to lookup the schema in. Structured like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}`
    /// or
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}`
    pub parent: std::string::String,

    /// Optional. The schema type of the schema.
    pub schema_type: std::option::Option<crate::model::schema::SchemaType>,

    /// Required. The schema payload
    pub schema: std::string::String,

    /// Optional. The schema references used by the schema.
    pub references: std::vec::Vec<crate::model::schema::SchemaReference>,

    /// Optional. If true, the schema will be normalized before being looked up.
    /// The default is false.
    pub normalize: std::option::Option<bool>,

    /// Optional. If true, soft-deleted versions will be included in lookup, no
    /// matter if the subject is active or soft-deleted. If false, soft-deleted
    /// versions will be excluded. The default is false.
    pub deleted: std::option::Option<bool>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LookupVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::LookupVersionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [schema_type][crate::model::LookupVersionRequest::schema_type].
    pub fn set_schema_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::schema::SchemaType>,
    {
        self.schema_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [schema_type][crate::model::LookupVersionRequest::schema_type].
    pub fn set_or_clear_schema_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::schema::SchemaType>,
    {
        self.schema_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [schema][crate::model::LookupVersionRequest::schema].
    pub fn set_schema<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schema = v.into();
        self
    }

    /// Sets the value of [references][crate::model::LookupVersionRequest::references].
    pub fn set_references<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::schema::SchemaReference>,
    {
        use std::iter::Iterator;
        self.references = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [normalize][crate::model::LookupVersionRequest::normalize].
    pub fn set_normalize<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.normalize = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [normalize][crate::model::LookupVersionRequest::normalize].
    pub fn set_or_clear_normalize<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.normalize = v.map(|x| x.into());
        self
    }

    /// Sets the value of [deleted][crate::model::LookupVersionRequest::deleted].
    pub fn set_deleted<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.deleted = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deleted][crate::model::LookupVersionRequest::deleted].
    pub fn set_or_clear_deleted<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.deleted = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for LookupVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.LookupVersionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LookupVersionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __schema_type,
            __schema,
            __references,
            __normalize,
            __deleted,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LookupVersionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "schemaType" => Ok(__FieldTag::__schema_type),
                            "schema_type" => Ok(__FieldTag::__schema_type),
                            "schema" => Ok(__FieldTag::__schema),
                            "references" => Ok(__FieldTag::__references),
                            "normalize" => Ok(__FieldTag::__normalize),
                            "deleted" => Ok(__FieldTag::__deleted),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LookupVersionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LookupVersionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__schema_type => {
                            if !fields.insert(__FieldTag::__schema_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schema_type",
                                ));
                            }
                            result.schema_type = map.next_value::<std::option::Option<crate::model::schema::SchemaType>>()?
                                ;
                        }
                        __FieldTag::__schema => {
                            if !fields.insert(__FieldTag::__schema) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schema",
                                ));
                            }
                            result.schema = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__references => {
                            if !fields.insert(__FieldTag::__references) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for references",
                                ));
                            }
                            result.references = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::schema::SchemaReference>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__normalize => {
                            if !fields.insert(__FieldTag::__normalize) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for normalize",
                                ));
                            }
                            result.normalize = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__deleted => {
                            if !fields.insert(__FieldTag::__deleted) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deleted",
                                ));
                            }
                            result.deleted = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LookupVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.schema_type.is_some() {
            state.serialize_entry("schemaType", &self.schema_type)?;
        }
        if !self.schema.is_empty() {
            state.serialize_entry("schema", &self.schema)?;
        }
        if !self.references.is_empty() {
            state.serialize_entry("references", &self.references)?;
        }
        if self.normalize.is_some() {
            state.serialize_entry("normalize", &self.normalize)?;
        }
        if self.deleted.is_some() {
            state.serialize_entry("deleted", &self.deleted)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for LookupVersionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LookupVersionRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("schema_type", &self.schema_type);
        debug_struct.field("schema", &self.schema);
        debug_struct.field("references", &self.references);
        debug_struct.field("normalize", &self.normalize);
        debug_struct.field("deleted", &self.deleted);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for DeleteVersion.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteVersionRequest {
    /// Required. The name of the subject version to delete. Structured like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}`
    /// or
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}/versions/{version}`
    pub name: std::string::String,

    /// Optional. If true, both the version and the referenced schema ID will be
    /// permanently deleted. The default is false. If false, the version will be
    /// deleted but the schema ID will be retained. Soft-deleted versions can still
    /// be searched in ListVersions API call with deleted=true query parameter. A
    /// soft-delete of a version must be performed before a hard-delete.
    pub permanent: std::option::Option<bool>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteVersionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [permanent][crate::model::DeleteVersionRequest::permanent].
    pub fn set_permanent<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.permanent = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [permanent][crate::model::DeleteVersionRequest::permanent].
    pub fn set_or_clear_permanent<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.permanent = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DeleteVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.DeleteVersionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteVersionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __permanent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteVersionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "permanent" => Ok(__FieldTag::__permanent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteVersionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteVersionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__permanent => {
                            if !fields.insert(__FieldTag::__permanent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for permanent",
                                ));
                            }
                            result.permanent = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.permanent.is_some() {
            state.serialize_entry("permanent", &self.permanent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteVersionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteVersionRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("permanent", &self.permanent);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for ListReferencedSchemas.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListReferencedSchemasRequest {
    /// Required. The version to list referenced by. Structured like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}`
    /// or
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}/versions/{version}`
    pub parent: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListReferencedSchemasRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListReferencedSchemasRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for ListReferencedSchemasRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.ListReferencedSchemasRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListReferencedSchemasRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListReferencedSchemasRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListReferencedSchemasRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListReferencedSchemasRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListReferencedSchemasRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListReferencedSchemasRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListReferencedSchemasRequest");
        debug_struct.field("parent", &self.parent);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for CheckCompatibility.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CheckCompatibilityRequest {
    /// Required. The name of the resource to check compatibility for. The format
    /// is either of following:
    ///
    /// * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/compatibility/subjects/*/versions: Check compatibility with one or
    ///   more versions of the specified subject.
    /// * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/compatibility/subjects/{subject}/versions/{version}: Check
    ///   compatibility with a specific version of the subject.
    pub name: std::string::String,

    /// Optional. The schema type of the schema.
    pub schema_type: std::option::Option<crate::model::schema::SchemaType>,

    /// Required. The schema payload
    pub schema: std::string::String,

    /// Optional. The schema references used by the schema.
    pub references: std::vec::Vec<crate::model::schema::SchemaReference>,

    /// Optional. If true, the response will contain the compatibility check result
    /// with reasons for failed checks. The default is false.
    pub verbose: std::option::Option<bool>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CheckCompatibilityRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CheckCompatibilityRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [schema_type][crate::model::CheckCompatibilityRequest::schema_type].
    pub fn set_schema_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::schema::SchemaType>,
    {
        self.schema_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [schema_type][crate::model::CheckCompatibilityRequest::schema_type].
    pub fn set_or_clear_schema_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::schema::SchemaType>,
    {
        self.schema_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [schema][crate::model::CheckCompatibilityRequest::schema].
    pub fn set_schema<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schema = v.into();
        self
    }

    /// Sets the value of [references][crate::model::CheckCompatibilityRequest::references].
    pub fn set_references<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::schema::SchemaReference>,
    {
        use std::iter::Iterator;
        self.references = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [verbose][crate::model::CheckCompatibilityRequest::verbose].
    pub fn set_verbose<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.verbose = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [verbose][crate::model::CheckCompatibilityRequest::verbose].
    pub fn set_or_clear_verbose<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.verbose = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CheckCompatibilityRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.CheckCompatibilityRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CheckCompatibilityRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __schema_type,
            __schema,
            __references,
            __verbose,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CheckCompatibilityRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "schemaType" => Ok(__FieldTag::__schema_type),
                            "schema_type" => Ok(__FieldTag::__schema_type),
                            "schema" => Ok(__FieldTag::__schema),
                            "references" => Ok(__FieldTag::__references),
                            "verbose" => Ok(__FieldTag::__verbose),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CheckCompatibilityRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CheckCompatibilityRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__schema_type => {
                            if !fields.insert(__FieldTag::__schema_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schema_type",
                                ));
                            }
                            result.schema_type = map.next_value::<std::option::Option<crate::model::schema::SchemaType>>()?
                                ;
                        }
                        __FieldTag::__schema => {
                            if !fields.insert(__FieldTag::__schema) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schema",
                                ));
                            }
                            result.schema = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__references => {
                            if !fields.insert(__FieldTag::__references) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for references",
                                ));
                            }
                            result.references = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::schema::SchemaReference>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verbose => {
                            if !fields.insert(__FieldTag::__verbose) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verbose",
                                ));
                            }
                            result.verbose = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CheckCompatibilityRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.schema_type.is_some() {
            state.serialize_entry("schemaType", &self.schema_type)?;
        }
        if !self.schema.is_empty() {
            state.serialize_entry("schema", &self.schema)?;
        }
        if !self.references.is_empty() {
            state.serialize_entry("references", &self.references)?;
        }
        if self.verbose.is_some() {
            state.serialize_entry("verbose", &self.verbose)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CheckCompatibilityRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CheckCompatibilityRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("schema_type", &self.schema_type);
        debug_struct.field("schema", &self.schema);
        debug_struct.field("references", &self.references);
        debug_struct.field("verbose", &self.verbose);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response for CheckCompatibility.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CheckCompatibilityResponse {
    /// The compatibility check result. If true, the schema is compatible with the
    /// resource.
    pub is_compatible: bool,

    /// Failure reasons if verbose = true.
    pub messages: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CheckCompatibilityResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [is_compatible][crate::model::CheckCompatibilityResponse::is_compatible].
    pub fn set_is_compatible<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_compatible = v.into();
        self
    }

    /// Sets the value of [messages][crate::model::CheckCompatibilityResponse::messages].
    pub fn set_messages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.messages = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CheckCompatibilityResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.CheckCompatibilityResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CheckCompatibilityResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __is_compatible,
            __messages,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CheckCompatibilityResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "is_compatible" => Ok(__FieldTag::__is_compatible),
                            "messages" => Ok(__FieldTag::__messages),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CheckCompatibilityResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CheckCompatibilityResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__is_compatible => {
                            if !fields.insert(__FieldTag::__is_compatible) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_compatible",
                                ));
                            }
                            result.is_compatible = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__messages => {
                            if !fields.insert(__FieldTag::__messages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for messages",
                                ));
                            }
                            result.messages = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CheckCompatibilityResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.is_compatible) {
            state.serialize_entry("is_compatible", &self.is_compatible)?;
        }
        if !self.messages.is_empty() {
            state.serialize_entry("messages", &self.messages)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CheckCompatibilityResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CheckCompatibilityResponse");
        debug_struct.field("is_compatible", &self.is_compatible);
        debug_struct.field("messages", &self.messages);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for getting config.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetSchemaConfigRequest {
    /// Required. The resource name to get the config for. It can be either of
    /// following:
    ///
    /// * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config: Get config at global level.
    /// * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config/{subject}: Get config for a specific subject.
    pub name: std::string::String,

    /// Optional. If true, the config will fall back to the config at the global
    /// level if no subject level config is found.
    pub default_to_global: std::option::Option<bool>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSchemaConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSchemaConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [default_to_global][crate::model::GetSchemaConfigRequest::default_to_global].
    pub fn set_default_to_global<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.default_to_global = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [default_to_global][crate::model::GetSchemaConfigRequest::default_to_global].
    pub fn set_or_clear_default_to_global<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.default_to_global = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for GetSchemaConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.GetSchemaConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetSchemaConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __default_to_global,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetSchemaConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "defaultToGlobal" => Ok(__FieldTag::__default_to_global),
                            "default_to_global" => Ok(__FieldTag::__default_to_global),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetSchemaConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetSchemaConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__default_to_global => {
                            if !fields.insert(__FieldTag::__default_to_global) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_to_global",
                                ));
                            }
                            result.default_to_global =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetSchemaConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.default_to_global.is_some() {
            state.serialize_entry("defaultToGlobal", &self.default_to_global)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetSchemaConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetSchemaConfigRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("default_to_global", &self.default_to_global);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for updating schema config.
/// On a SchemaSubject-level SchemaConfig, an unset field will be removed from
/// the SchemaConfig.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateSchemaConfigRequest {
    /// Required. The resource name to update the config for. It can be either of
    /// following:
    ///
    /// * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config: Update config at global level.
    /// * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config/{subject}: Update config for a specific subject.
    pub name: std::string::String,

    /// Required. The compatibility type of the schemas.
    /// Cannot be unset for a SchemaRegistry-level SchemaConfig.
    /// If unset on a SchemaSubject-level SchemaConfig, removes the compatibility
    /// field for the SchemaConfig.
    pub compatibility: std::option::Option<crate::model::schema_config::CompatibilityType>,

    /// Optional. If true, the schema will be normalized before being stored or
    /// looked up. The default is false. Cannot be unset for a SchemaRegistry-level
    /// SchemaConfig. If unset on a SchemaSubject-level SchemaConfig, removes the
    /// normalize field for the SchemaConfig.
    pub normalize: std::option::Option<bool>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateSchemaConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateSchemaConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [compatibility][crate::model::UpdateSchemaConfigRequest::compatibility].
    pub fn set_compatibility<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::schema_config::CompatibilityType>,
    {
        self.compatibility = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [compatibility][crate::model::UpdateSchemaConfigRequest::compatibility].
    pub fn set_or_clear_compatibility<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::schema_config::CompatibilityType>,
    {
        self.compatibility = v.map(|x| x.into());
        self
    }

    /// Sets the value of [normalize][crate::model::UpdateSchemaConfigRequest::normalize].
    pub fn set_normalize<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.normalize = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [normalize][crate::model::UpdateSchemaConfigRequest::normalize].
    pub fn set_or_clear_normalize<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.normalize = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateSchemaConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.UpdateSchemaConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateSchemaConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __compatibility,
            __normalize,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateSchemaConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "compatibility" => Ok(__FieldTag::__compatibility),
                            "normalize" => Ok(__FieldTag::__normalize),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateSchemaConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateSchemaConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__compatibility => {
                            if !fields.insert(__FieldTag::__compatibility) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compatibility",
                                ));
                            }
                            result.compatibility = map.next_value::<std::option::Option<
                                crate::model::schema_config::CompatibilityType,
                            >>()?;
                        }
                        __FieldTag::__normalize => {
                            if !fields.insert(__FieldTag::__normalize) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for normalize",
                                ));
                            }
                            result.normalize = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateSchemaConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.compatibility.is_some() {
            state.serialize_entry("compatibility", &self.compatibility)?;
        }
        if self.normalize.is_some() {
            state.serialize_entry("normalize", &self.normalize)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateSchemaConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateSchemaConfigRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("compatibility", &self.compatibility);
        debug_struct.field("normalize", &self.normalize);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for deleting schema config.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteSchemaConfigRequest {
    /// Required. The resource name of subject to delete the config for. The format
    /// is
    ///
    /// * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config/{subject}
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteSchemaConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteSchemaConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteSchemaConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.DeleteSchemaConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteSchemaConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteSchemaConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteSchemaConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteSchemaConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteSchemaConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteSchemaConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteSchemaConfigRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for getting schema registry or subject mode.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetSchemaModeRequest {
    /// Required. The resource name of the mode. The format is
    ///
    /// * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/mode/{subject}: mode for a schema registry, or
    /// * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/mode/{subject}: mode for a specific subject in a specific context
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSchemaModeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSchemaModeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetSchemaModeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.GetSchemaModeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetSchemaModeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetSchemaModeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetSchemaModeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetSchemaModeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetSchemaModeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetSchemaModeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetSchemaModeRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for updating schema registry or subject mode.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateSchemaModeRequest {
    /// Required. The resource name of the mode. The format is
    ///
    /// * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/mode/{subject}: mode for a schema registry, or
    /// * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/mode/{subject}: mode for a specific subject in a specific context
    pub name: std::string::String,

    /// Required. The mode type.
    pub mode: crate::model::schema_mode::ModeType,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateSchemaModeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateSchemaModeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [mode][crate::model::UpdateSchemaModeRequest::mode].
    pub fn set_mode<T: std::convert::Into<crate::model::schema_mode::ModeType>>(
        mut self,
        v: T,
    ) -> Self {
        self.mode = v.into();
        self
    }
}

impl wkt::message::Message for UpdateSchemaModeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.UpdateSchemaModeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateSchemaModeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __mode,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateSchemaModeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "mode" => Ok(__FieldTag::__mode),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateSchemaModeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateSchemaModeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mode => {
                            if !fields.insert(__FieldTag::__mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mode",
                                ));
                            }
                            result.mode = map.next_value::<std::option::Option<crate::model::schema_mode::ModeType>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateSchemaModeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.mode) {
            state.serialize_entry("mode", &self.mode)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateSchemaModeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateSchemaModeRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("mode", &self.mode);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for deleting schema mode.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteSchemaModeRequest {
    /// Required. The resource name of subject to delete the mode for. The format
    /// is
    ///
    /// * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/mode/{subject}
    /// * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/mode/{subject}
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteSchemaModeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteSchemaModeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteSchemaModeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.DeleteSchemaModeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteSchemaModeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteSchemaModeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteSchemaModeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteSchemaModeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteSchemaModeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteSchemaModeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteSchemaModeRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// SchemaRegistry is a schema registry instance.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SchemaRegistry {
    /// Identifier. The name of the schema registry instance. Structured like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
    /// The instance name {schema_registry} can contain the following:
    ///
    /// * Up to 255 characters.
    /// * Letters (uppercase or lowercase), numbers, and underscores.
    pub name: std::string::String,

    /// Output only. The contexts of the schema registry instance.
    pub contexts: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SchemaRegistry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SchemaRegistry::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [contexts][crate::model::SchemaRegistry::contexts].
    pub fn set_contexts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.contexts = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SchemaRegistry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.SchemaRegistry"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SchemaRegistry {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __contexts,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SchemaRegistry")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "contexts" => Ok(__FieldTag::__contexts),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SchemaRegistry;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SchemaRegistry")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__contexts => {
                            if !fields.insert(__FieldTag::__contexts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for contexts",
                                ));
                            }
                            result.contexts = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SchemaRegistry {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.contexts.is_empty() {
            state.serialize_entry("contexts", &self.contexts)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SchemaRegistry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SchemaRegistry");
        debug_struct.field("name", &self.name);
        debug_struct.field("contexts", &self.contexts);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Context represents an independent schema grouping in a schema registry
/// instance.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Context {
    /// Identifier. The name of the context. Structured like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}`
    /// The context name {context} can contain the following:
    ///
    /// * Up to 255 characters.
    /// * Allowed characters: letters (uppercase or lowercase), numbers, and the
    ///   following special characters: `.`, `-`, `_`, `+`, `%`, and `~`.
    pub name: std::string::String,

    /// Optional. The subjects of the context.
    pub subjects: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Context {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Context::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [subjects][crate::model::Context::subjects].
    pub fn set_subjects<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.subjects = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Context {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.Context"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Context {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __subjects,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Context")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "subjects" => Ok(__FieldTag::__subjects),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Context;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Context")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subjects => {
                            if !fields.insert(__FieldTag::__subjects) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subjects",
                                ));
                            }
                            result.subjects = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Context {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.subjects.is_empty() {
            state.serialize_entry("subjects", &self.subjects)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Context {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Context");
        debug_struct.field("name", &self.name);
        debug_struct.field("subjects", &self.subjects);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Schema for a Kafka message.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Schema {
    /// Optional. The schema type of the schema.
    pub schema_type: crate::model::schema::SchemaType,

    /// The schema payload.
    pub schema_payload: std::string::String,

    /// Optional. The schema references used by the schema.
    pub references: std::vec::Vec<crate::model::schema::SchemaReference>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Schema {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [schema_type][crate::model::Schema::schema_type].
    pub fn set_schema_type<T: std::convert::Into<crate::model::schema::SchemaType>>(
        mut self,
        v: T,
    ) -> Self {
        self.schema_type = v.into();
        self
    }

    /// Sets the value of [schema_payload][crate::model::Schema::schema_payload].
    pub fn set_schema_payload<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schema_payload = v.into();
        self
    }

    /// Sets the value of [references][crate::model::Schema::references].
    pub fn set_references<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::schema::SchemaReference>,
    {
        use std::iter::Iterator;
        self.references = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Schema {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.Schema"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Schema {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __schema_type,
            __schema_payload,
            __references,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Schema")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "schemaType" => Ok(__FieldTag::__schema_type),
                            "schema_type" => Ok(__FieldTag::__schema_type),
                            "schema" => Ok(__FieldTag::__schema_payload),
                            "schema_payload" => Ok(__FieldTag::__schema_payload),
                            "references" => Ok(__FieldTag::__references),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Schema;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Schema")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__schema_type => {
                            if !fields.insert(__FieldTag::__schema_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schema_type",
                                ));
                            }
                            result.schema_type = map.next_value::<std::option::Option<crate::model::schema::SchemaType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__schema_payload => {
                            if !fields.insert(__FieldTag::__schema_payload) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schema_payload",
                                ));
                            }
                            result.schema_payload = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__references => {
                            if !fields.insert(__FieldTag::__references) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for references",
                                ));
                            }
                            result.references = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::schema::SchemaReference>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Schema {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.schema_type) {
            state.serialize_entry("schemaType", &self.schema_type)?;
        }
        if !self.schema_payload.is_empty() {
            state.serialize_entry("schema", &self.schema_payload)?;
        }
        if !self.references.is_empty() {
            state.serialize_entry("references", &self.references)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Schema {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Schema");
        debug_struct.field("schema_type", &self.schema_type);
        debug_struct.field("schema_payload", &self.schema_payload);
        debug_struct.field("references", &self.references);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Schema].
pub mod schema {
    #[allow(unused_imports)]
    use super::*;

    /// SchemaReference is a reference to a schema.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SchemaReference {
        /// Required. The name of the reference.
        pub name: std::string::String,

        /// Required. The subject of the reference.
        pub subject: std::string::String,

        /// Required. The version of the reference.
        pub version: i32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SchemaReference {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::schema::SchemaReference::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [subject][crate::model::schema::SchemaReference::subject].
        pub fn set_subject<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.subject = v.into();
            self
        }

        /// Sets the value of [version][crate::model::schema::SchemaReference::version].
        pub fn set_version<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.version = v.into();
            self
        }
    }

    impl wkt::message::Message for SchemaReference {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.Schema.SchemaReference"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SchemaReference {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __name,
                __subject,
                __version,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SchemaReference")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "name" => Ok(__FieldTag::__name),
                                "subject" => Ok(__FieldTag::__subject),
                                "version" => Ok(__FieldTag::__version),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SchemaReference;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SchemaReference")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__subject => {
                                if !fields.insert(__FieldTag::__subject) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for subject",
                                    ));
                                }
                                result.subject = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__version => {
                                if !fields.insert(__FieldTag::__version) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for version",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.version = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SchemaReference {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !self.subject.is_empty() {
                state.serialize_entry("subject", &self.subject)?;
            }
            if !wkt::internal::is_default(&self.version) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("version", &__With(&self.version))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for SchemaReference {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("SchemaReference");
            debug_struct.field("name", &self.name);
            debug_struct.field("subject", &self.subject);
            debug_struct.field("version", &self.version);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Schema types.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SchemaType {
        /// No schema type. The default will be AVRO.
        Unspecified,
        /// Avro schema type.
        Avro,
        /// JSON schema type.
        Json,
        /// Protobuf schema type.
        Protobuf,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SchemaType::value] or
        /// [SchemaType::name].
        UnknownValue(schema_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod schema_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SchemaType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Avro => std::option::Option::Some(1),
                Self::Json => std::option::Option::Some(2),
                Self::Protobuf => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SCHEMA_TYPE_UNSPECIFIED"),
                Self::Avro => std::option::Option::Some("AVRO"),
                Self::Json => std::option::Option::Some("JSON"),
                Self::Protobuf => std::option::Option::Some("PROTOBUF"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SchemaType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SchemaType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SchemaType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Avro,
                2 => Self::Json,
                3 => Self::Protobuf,
                _ => Self::UnknownValue(schema_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SchemaType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SCHEMA_TYPE_UNSPECIFIED" => Self::Unspecified,
                "AVRO" => Self::Avro,
                "JSON" => Self::Json,
                "PROTOBUF" => Self::Protobuf,
                _ => Self::UnknownValue(schema_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SchemaType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Avro => serializer.serialize_i32(1),
                Self::Json => serializer.serialize_i32(2),
                Self::Protobuf => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SchemaType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SchemaType>::new(
                ".google.cloud.managedkafka.schemaregistry.v1.Schema.SchemaType",
            ))
        }
    }
}

/// Subject defines the evolution scope of schemas as a holder of schema
/// versions.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SchemaSubject {
    /// The name of the subject. Structured like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}`
    /// or
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}`
    ///
    /// Subject name {subject} can contain the following:
    ///
    /// * Up to 255 UTF-8 bytes.
    /// * Allowed characters: letters (uppercase or lowercase), numbers, and the
    ///   following special characters: `.`, `-`, `_`, `+`, `%`, and `~`.
    pub name: std::string::String,

    /// The versions of the subject.
    pub versions: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SchemaSubject {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SchemaSubject::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [versions][crate::model::SchemaSubject::versions].
    pub fn set_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.versions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SchemaSubject {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.SchemaSubject"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SchemaSubject {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __versions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SchemaSubject")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "versions" => Ok(__FieldTag::__versions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SchemaSubject;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SchemaSubject")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__versions => {
                            if !fields.insert(__FieldTag::__versions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for versions",
                                ));
                            }
                            result.versions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SchemaSubject {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.versions.is_empty() {
            state.serialize_entry("versions", &self.versions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SchemaSubject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SchemaSubject");
        debug_struct.field("name", &self.name);
        debug_struct.field("versions", &self.versions);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Version of a schema.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SchemaVersion {
    /// Required. The subject of the version.
    pub subject: std::string::String,

    /// Required. The version ID
    pub version_id: i32,

    /// Required. The schema ID.
    pub schema_id: i32,

    /// Optional. The schema type of the schema.
    pub schema_type: crate::model::schema::SchemaType,

    /// Required. The schema payload.
    pub schema_payload: std::string::String,

    /// Optional. The schema references used by the schema.
    pub references: std::vec::Vec<crate::model::schema::SchemaReference>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SchemaVersion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [subject][crate::model::SchemaVersion::subject].
    pub fn set_subject<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subject = v.into();
        self
    }

    /// Sets the value of [version_id][crate::model::SchemaVersion::version_id].
    pub fn set_version_id<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.version_id = v.into();
        self
    }

    /// Sets the value of [schema_id][crate::model::SchemaVersion::schema_id].
    pub fn set_schema_id<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.schema_id = v.into();
        self
    }

    /// Sets the value of [schema_type][crate::model::SchemaVersion::schema_type].
    pub fn set_schema_type<T: std::convert::Into<crate::model::schema::SchemaType>>(
        mut self,
        v: T,
    ) -> Self {
        self.schema_type = v.into();
        self
    }

    /// Sets the value of [schema_payload][crate::model::SchemaVersion::schema_payload].
    pub fn set_schema_payload<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schema_payload = v.into();
        self
    }

    /// Sets the value of [references][crate::model::SchemaVersion::references].
    pub fn set_references<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::schema::SchemaReference>,
    {
        use std::iter::Iterator;
        self.references = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SchemaVersion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.SchemaVersion"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SchemaVersion {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __subject,
            __version_id,
            __schema_id,
            __schema_type,
            __schema_payload,
            __references,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SchemaVersion")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "subject" => Ok(__FieldTag::__subject),
                            "version" => Ok(__FieldTag::__version_id),
                            "version_id" => Ok(__FieldTag::__version_id),
                            "id" => Ok(__FieldTag::__schema_id),
                            "schema_id" => Ok(__FieldTag::__schema_id),
                            "schemaType" => Ok(__FieldTag::__schema_type),
                            "schema_type" => Ok(__FieldTag::__schema_type),
                            "schema" => Ok(__FieldTag::__schema_payload),
                            "schema_payload" => Ok(__FieldTag::__schema_payload),
                            "references" => Ok(__FieldTag::__references),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SchemaVersion;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SchemaVersion")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__subject => {
                            if !fields.insert(__FieldTag::__subject) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subject",
                                ));
                            }
                            result.subject = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version_id => {
                            if !fields.insert(__FieldTag::__version_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version_id",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.version_id = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__schema_id => {
                            if !fields.insert(__FieldTag::__schema_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schema_id",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.schema_id = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__schema_type => {
                            if !fields.insert(__FieldTag::__schema_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schema_type",
                                ));
                            }
                            result.schema_type = map.next_value::<std::option::Option<crate::model::schema::SchemaType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__schema_payload => {
                            if !fields.insert(__FieldTag::__schema_payload) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schema_payload",
                                ));
                            }
                            result.schema_payload = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__references => {
                            if !fields.insert(__FieldTag::__references) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for references",
                                ));
                            }
                            result.references = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::schema::SchemaReference>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SchemaVersion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.subject.is_empty() {
            state.serialize_entry("subject", &self.subject)?;
        }
        if !wkt::internal::is_default(&self.version_id) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("version", &__With(&self.version_id))?;
        }
        if !wkt::internal::is_default(&self.schema_id) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("id", &__With(&self.schema_id))?;
        }
        if !wkt::internal::is_default(&self.schema_type) {
            state.serialize_entry("schemaType", &self.schema_type)?;
        }
        if !self.schema_payload.is_empty() {
            state.serialize_entry("schema", &self.schema_payload)?;
        }
        if !self.references.is_empty() {
            state.serialize_entry("references", &self.references)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SchemaVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SchemaVersion");
        debug_struct.field("subject", &self.subject);
        debug_struct.field("version_id", &self.version_id);
        debug_struct.field("schema_id", &self.schema_id);
        debug_struct.field("schema_type", &self.schema_type);
        debug_struct.field("schema_payload", &self.schema_payload);
        debug_struct.field("references", &self.references);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// SchemaConfig represents configuration for a schema registry or a specific
/// subject.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SchemaConfig {
    /// Required. The compatibility type of the schema.
    /// The default value is BACKWARD.
    /// If unset in a SchemaSubject-level SchemaConfig, defaults to the global
    /// value. If unset in a SchemaRegistry-level SchemaConfig, reverts to the
    /// default value.
    pub compatibility: std::option::Option<crate::model::schema_config::CompatibilityType>,

    /// Optional. If true, the schema will be normalized before being stored or
    /// looked up. The default is false. If unset in a SchemaSubject-level
    /// SchemaConfig, the global value will be used. If unset in a
    /// SchemaRegistry-level SchemaConfig, reverts to the default value.
    pub normalize: std::option::Option<bool>,

    /// Optional. The subject to which this subject is an alias of. Only applicable
    /// for subject config.
    pub alias: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SchemaConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [compatibility][crate::model::SchemaConfig::compatibility].
    pub fn set_compatibility<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::schema_config::CompatibilityType>,
    {
        self.compatibility = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [compatibility][crate::model::SchemaConfig::compatibility].
    pub fn set_or_clear_compatibility<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::schema_config::CompatibilityType>,
    {
        self.compatibility = v.map(|x| x.into());
        self
    }

    /// Sets the value of [normalize][crate::model::SchemaConfig::normalize].
    pub fn set_normalize<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.normalize = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [normalize][crate::model::SchemaConfig::normalize].
    pub fn set_or_clear_normalize<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.normalize = v.map(|x| x.into());
        self
    }

    /// Sets the value of [alias][crate::model::SchemaConfig::alias].
    pub fn set_alias<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.alias = v.into();
        self
    }
}

impl wkt::message::Message for SchemaConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.SchemaConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SchemaConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __compatibility,
            __normalize,
            __alias,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SchemaConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "compatibility" => Ok(__FieldTag::__compatibility),
                            "normalize" => Ok(__FieldTag::__normalize),
                            "alias" => Ok(__FieldTag::__alias),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SchemaConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SchemaConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__compatibility => {
                            if !fields.insert(__FieldTag::__compatibility) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compatibility",
                                ));
                            }
                            result.compatibility = map.next_value::<std::option::Option<
                                crate::model::schema_config::CompatibilityType,
                            >>()?;
                        }
                        __FieldTag::__normalize => {
                            if !fields.insert(__FieldTag::__normalize) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for normalize",
                                ));
                            }
                            result.normalize = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__alias => {
                            if !fields.insert(__FieldTag::__alias) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for alias",
                                ));
                            }
                            result.alias = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SchemaConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.compatibility.is_some() {
            state.serialize_entry("compatibility", &self.compatibility)?;
        }
        if self.normalize.is_some() {
            state.serialize_entry("normalize", &self.normalize)?;
        }
        if !self.alias.is_empty() {
            state.serialize_entry("alias", &self.alias)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SchemaConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SchemaConfig");
        debug_struct.field("compatibility", &self.compatibility);
        debug_struct.field("normalize", &self.normalize);
        debug_struct.field("alias", &self.alias);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [SchemaConfig].
pub mod schema_config {
    #[allow(unused_imports)]
    use super::*;

    /// Compatibility type of the schemas.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CompatibilityType {
        /// No compatibility check.
        None,
        /// Backwards compatible with the most recent version.
        Backward,
        /// Backwards compatible with all previous versions.
        BackwardTransitive,
        /// Forwards compatible with the most recent version.
        Forward,
        /// Forwards compatible with all previous versions.
        ForwardTransitive,
        /// Backwards and forwards compatible with the most recent version.
        Full,
        /// Backwards and forwards compatible with all previous versions.
        FullTransitive,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CompatibilityType::value] or
        /// [CompatibilityType::name].
        UnknownValue(compatibility_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod compatibility_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CompatibilityType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::None => std::option::Option::Some(0),
                Self::Backward => std::option::Option::Some(1),
                Self::BackwardTransitive => std::option::Option::Some(2),
                Self::Forward => std::option::Option::Some(3),
                Self::ForwardTransitive => std::option::Option::Some(4),
                Self::Full => std::option::Option::Some(5),
                Self::FullTransitive => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::None => std::option::Option::Some("NONE"),
                Self::Backward => std::option::Option::Some("BACKWARD"),
                Self::BackwardTransitive => std::option::Option::Some("BACKWARD_TRANSITIVE"),
                Self::Forward => std::option::Option::Some("FORWARD"),
                Self::ForwardTransitive => std::option::Option::Some("FORWARD_TRANSITIVE"),
                Self::Full => std::option::Option::Some("FULL"),
                Self::FullTransitive => std::option::Option::Some("FULL_TRANSITIVE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CompatibilityType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CompatibilityType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CompatibilityType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::None,
                1 => Self::Backward,
                2 => Self::BackwardTransitive,
                3 => Self::Forward,
                4 => Self::ForwardTransitive,
                5 => Self::Full,
                6 => Self::FullTransitive,
                _ => Self::UnknownValue(compatibility_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CompatibilityType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "NONE" => Self::None,
                "BACKWARD" => Self::Backward,
                "BACKWARD_TRANSITIVE" => Self::BackwardTransitive,
                "FORWARD" => Self::Forward,
                "FORWARD_TRANSITIVE" => Self::ForwardTransitive,
                "FULL" => Self::Full,
                "FULL_TRANSITIVE" => Self::FullTransitive,
                _ => Self::UnknownValue(compatibility_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CompatibilityType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::None => serializer.serialize_i32(0),
                Self::Backward => serializer.serialize_i32(1),
                Self::BackwardTransitive => serializer.serialize_i32(2),
                Self::Forward => serializer.serialize_i32(3),
                Self::ForwardTransitive => serializer.serialize_i32(4),
                Self::Full => serializer.serialize_i32(5),
                Self::FullTransitive => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CompatibilityType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CompatibilityType>::new(
                ".google.cloud.managedkafka.schemaregistry.v1.SchemaConfig.CompatibilityType",
            ))
        }
    }
}

/// SchemaMode represents the mode of a schema registry or a specific subject.
/// Four modes are supported:
///
/// * NONE: deprecated. This was the default mode for a subject, but now the
///   default is unset (which means use the global schema registry setting)
/// * READONLY: The schema registry is in read-only mode.
/// * READWRITE: The schema registry is in read-write mode, which allows limited
///   write operations on the schema.
/// * IMPORT: The schema registry is in import mode, which allows more editing
///   operations on the schema for data importing purposes.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SchemaMode {
    /// Required. The mode type of a schema registry (READWRITE by default) or of a
    /// subject (unset by default, which means use the global schema registry
    /// setting).
    pub mode: crate::model::schema_mode::ModeType,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SchemaMode {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mode][crate::model::SchemaMode::mode].
    pub fn set_mode<T: std::convert::Into<crate::model::schema_mode::ModeType>>(
        mut self,
        v: T,
    ) -> Self {
        self.mode = v.into();
        self
    }
}

impl wkt::message::Message for SchemaMode {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedkafka.schemaregistry.v1.SchemaMode"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SchemaMode {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __mode,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SchemaMode")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "mode" => Ok(__FieldTag::__mode),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SchemaMode;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SchemaMode")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__mode => {
                            if !fields.insert(__FieldTag::__mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mode",
                                ));
                            }
                            result.mode = map.next_value::<std::option::Option<crate::model::schema_mode::ModeType>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SchemaMode {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.mode) {
            state.serialize_entry("mode", &self.mode)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SchemaMode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SchemaMode");
        debug_struct.field("mode", &self.mode);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [SchemaMode].
pub mod schema_mode {
    #[allow(unused_imports)]
    use super::*;

    /// Mode type of the schemas or subjects.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ModeType {
        /// The default / unset value.
        /// The subject mode is NONE/unset by default, which means use the global
        /// schema registry mode. This should not be used for setting the mode.
        None,
        /// READONLY mode.
        Readonly,
        /// READWRITE mode.
        Readwrite,
        /// IMPORT mode.
        Import,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ModeType::value] or
        /// [ModeType::name].
        UnknownValue(mode_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod mode_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ModeType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::None => std::option::Option::Some(0),
                Self::Readonly => std::option::Option::Some(1),
                Self::Readwrite => std::option::Option::Some(2),
                Self::Import => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::None => std::option::Option::Some("NONE"),
                Self::Readonly => std::option::Option::Some("READONLY"),
                Self::Readwrite => std::option::Option::Some("READWRITE"),
                Self::Import => std::option::Option::Some("IMPORT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ModeType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ModeType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ModeType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::None,
                1 => Self::Readonly,
                2 => Self::Readwrite,
                3 => Self::Import,
                _ => Self::UnknownValue(mode_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ModeType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "NONE" => Self::None,
                "READONLY" => Self::Readonly,
                "READWRITE" => Self::Readwrite,
                "IMPORT" => Self::Import,
                _ => Self::UnknownValue(mode_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ModeType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::None => serializer.serialize_i32(0),
                Self::Readonly => serializer.serialize_i32(1),
                Self::Readwrite => serializer.serialize_i32(2),
                Self::Import => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ModeType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ModeType>::new(
                ".google.cloud.managedkafka.schemaregistry.v1.SchemaMode.ModeType",
            ))
        }
    }
}
