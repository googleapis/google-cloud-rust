// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Request message for
/// [GkeInferenceQuickstart.FetchModels][google.cloud.gkerecommender.v1.GkeInferenceQuickstart.FetchModels].
///
/// [google.cloud.gkerecommender.v1.GkeInferenceQuickstart.FetchModels]: crate::client::GkeInferenceQuickstart::fetch_models
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchModelsRequest {
    /// Optional. The target number of results to return in a single response.
    /// If not specified, a default value will be chosen by the service.
    /// Note that the response may include a partial list and a caller should
    /// only rely on the response's
    /// [next_page_token][google.cloud.gkerecommender.v1.FetchModelsResponse.next_page_token]
    /// to determine if there are more instances left to be queried.
    ///
    /// [google.cloud.gkerecommender.v1.FetchModelsResponse.next_page_token]: crate::model::FetchModelsResponse::next_page_token
    pub page_size: std::option::Option<i32>,

    /// Optional. The value of
    /// [next_page_token][google.cloud.gkerecommender.v1.FetchModelsResponse.next_page_token]
    /// received from a previous `FetchModelsRequest` call.
    /// Provide this to retrieve the subsequent page in a multi-page list of
    /// results. When paginating, all other parameters provided to
    /// `FetchModelsRequest` must match the call that provided the page token.
    ///
    /// [google.cloud.gkerecommender.v1.FetchModelsResponse.next_page_token]: crate::model::FetchModelsResponse::next_page_token
    pub page_token: std::option::Option<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchModelsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [page_size][crate::model::FetchModelsRequest::page_size].
    pub fn set_page_size<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.page_size = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [page_size][crate::model::FetchModelsRequest::page_size].
    pub fn set_or_clear_page_size<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.page_size = v.map(|x| x.into());
        self
    }

    /// Sets the value of [page_token][crate::model::FetchModelsRequest::page_token].
    pub fn set_page_token<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.page_token = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [page_token][crate::model::FetchModelsRequest::page_token].
    pub fn set_or_clear_page_token<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.page_token = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for FetchModelsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkerecommender.v1.FetchModelsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchModelsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchModelsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchModelsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchModelsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchModelsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.page_size.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if self.page_token.is_some() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FetchModelsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchModelsRequest");
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for
/// [GkeInferenceQuickstart.FetchModels][google.cloud.gkerecommender.v1.GkeInferenceQuickstart.FetchModels].
///
/// [google.cloud.gkerecommender.v1.GkeInferenceQuickstart.FetchModels]: crate::client::GkeInferenceQuickstart::fetch_models
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchModelsResponse {
    /// Output only. List of available models. Open-source models follow the
    /// Huggingface Hub `owner/model_name` format.
    pub models: std::vec::Vec<std::string::String>,

    /// Output only. A token which may be sent as
    /// [page_token][FetchModelsResponse.page_token] in a subsequent
    /// `FetchModelsResponse` call to retrieve the next page of results.
    /// If this field is omitted or empty, then there are no more results to
    /// return.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchModelsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [models][crate::model::FetchModelsResponse::models].
    pub fn set_models<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.models = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::FetchModelsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for FetchModelsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkerecommender.v1.FetchModelsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchModelsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __models,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchModelsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "models" => Ok(__FieldTag::__models),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchModelsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchModelsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__models => {
                            if !fields.insert(__FieldTag::__models) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for models",
                                ));
                            }
                            result.models = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchModelsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.models.is_empty() {
            state.serialize_entry("models", &self.models)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FetchModelsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchModelsResponse");
        debug_struct.field("models", &self.models);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for
/// [GkeInferenceQuickstart.FetchModelServers][google.cloud.gkerecommender.v1.GkeInferenceQuickstart.FetchModelServers].
///
/// [google.cloud.gkerecommender.v1.GkeInferenceQuickstart.FetchModelServers]: crate::client::GkeInferenceQuickstart::fetch_model_servers
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchModelServersRequest {
    /// Required. The model for which to list model servers. Open-source models
    /// follow the Huggingface Hub `owner/model_name` format. Use
    /// [GkeInferenceQuickstart.FetchModels][google.cloud.gkerecommender.v1.GkeInferenceQuickstart.FetchModels]
    /// to find available models.
    ///
    /// [google.cloud.gkerecommender.v1.GkeInferenceQuickstart.FetchModels]: crate::client::GkeInferenceQuickstart::fetch_models
    pub model: std::string::String,

    /// Optional. The target number of results to return in a single response.
    /// If not specified, a default value will be chosen by the service.
    /// Note that the response may include a partial list and a caller should
    /// only rely on the response's
    /// [next_page_token][google.cloud.gkerecommender.v1.FetchModelServersResponse.next_page_token]
    /// to determine if there are more instances left to be queried.
    ///
    /// [google.cloud.gkerecommender.v1.FetchModelServersResponse.next_page_token]: crate::model::FetchModelServersResponse::next_page_token
    pub page_size: std::option::Option<i32>,

    /// Optional. The value of
    /// [next_page_token][google.cloud.gkerecommender.v1.FetchModelServersResponse.next_page_token]
    /// received from a previous `FetchModelServersRequest` call.
    /// Provide this to retrieve the subsequent page in a multi-page list of
    /// results. When paginating, all other parameters provided to
    /// `FetchModelServersRequest` must match the call that provided the page
    /// token.
    ///
    /// [google.cloud.gkerecommender.v1.FetchModelServersResponse.next_page_token]: crate::model::FetchModelServersResponse::next_page_token
    pub page_token: std::option::Option<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchModelServersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [model][crate::model::FetchModelServersRequest::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::FetchModelServersRequest::page_size].
    pub fn set_page_size<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.page_size = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [page_size][crate::model::FetchModelServersRequest::page_size].
    pub fn set_or_clear_page_size<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.page_size = v.map(|x| x.into());
        self
    }

    /// Sets the value of [page_token][crate::model::FetchModelServersRequest::page_token].
    pub fn set_page_token<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.page_token = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [page_token][crate::model::FetchModelServersRequest::page_token].
    pub fn set_or_clear_page_token<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.page_token = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for FetchModelServersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkerecommender.v1.FetchModelServersRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchModelServersRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __model,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchModelServersRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "model" => Ok(__FieldTag::__model),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchModelServersRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchModelServersRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__model => {
                            if !fields.insert(__FieldTag::__model) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model",
                                ));
                            }
                            result.model = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchModelServersRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.model.is_empty() {
            state.serialize_entry("model", &self.model)?;
        }
        if self.page_size.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if self.page_token.is_some() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FetchModelServersRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchModelServersRequest");
        debug_struct.field("model", &self.model);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for
/// [GkeInferenceQuickstart.FetchModelServers][google.cloud.gkerecommender.v1.GkeInferenceQuickstart.FetchModelServers].
///
/// [google.cloud.gkerecommender.v1.GkeInferenceQuickstart.FetchModelServers]: crate::client::GkeInferenceQuickstart::fetch_model_servers
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchModelServersResponse {
    /// Output only. List of available model servers. Open-source model servers use
    /// simplified, lowercase names (e.g., `vllm`).
    pub model_servers: std::vec::Vec<std::string::String>,

    /// Output only. A token which may be sent as
    /// [page_token][FetchModelServersResponse.page_token] in a subsequent
    /// `FetchModelServersResponse` call to retrieve the next page of results.
    /// If this field is omitted or empty, then there are no more results to
    /// return.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchModelServersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [model_servers][crate::model::FetchModelServersResponse::model_servers].
    pub fn set_model_servers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.model_servers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::FetchModelServersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for FetchModelServersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkerecommender.v1.FetchModelServersResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchModelServersResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __model_servers,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchModelServersResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "modelServers" => Ok(__FieldTag::__model_servers),
                            "model_servers" => Ok(__FieldTag::__model_servers),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchModelServersResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchModelServersResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__model_servers => {
                            if !fields.insert(__FieldTag::__model_servers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model_servers",
                                ));
                            }
                            result.model_servers = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchModelServersResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.model_servers.is_empty() {
            state.serialize_entry("modelServers", &self.model_servers)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FetchModelServersResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchModelServersResponse");
        debug_struct.field("model_servers", &self.model_servers);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for
/// [GkeInferenceQuickstart.FetchModelServerVersions][google.cloud.gkerecommender.v1.GkeInferenceQuickstart.FetchModelServerVersions].
///
/// [google.cloud.gkerecommender.v1.GkeInferenceQuickstart.FetchModelServerVersions]: crate::client::GkeInferenceQuickstart::fetch_model_server_versions
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchModelServerVersionsRequest {
    /// Required. The model for which to list model server versions. Open-source
    /// models follow the Huggingface Hub `owner/model_name` format. Use
    /// [GkeInferenceQuickstart.FetchModels][google.cloud.gkerecommender.v1.GkeInferenceQuickstart.FetchModels]
    /// to find available models.
    ///
    /// [google.cloud.gkerecommender.v1.GkeInferenceQuickstart.FetchModels]: crate::client::GkeInferenceQuickstart::fetch_models
    pub model: std::string::String,

    /// Required. The model server for which to list versions. Open-source model
    /// servers use simplified, lowercase names (e.g., `vllm`). Use
    /// [GkeInferenceQuickstart.FetchModelServers][google.cloud.gkerecommender.v1.GkeInferenceQuickstart.FetchModelServers]
    /// to find available model servers.
    ///
    /// [google.cloud.gkerecommender.v1.GkeInferenceQuickstart.FetchModelServers]: crate::client::GkeInferenceQuickstart::fetch_model_servers
    pub model_server: std::string::String,

    /// Optional. The target number of results to return in a single response.
    /// If not specified, a default value will be chosen by the service.
    /// Note that the response may include a partial list and a caller should
    /// only rely on the response's
    /// [next_page_token][google.cloud.gkerecommender.v1.FetchModelServerVersionsResponse.next_page_token]
    /// to determine if there are more instances left to be queried.
    ///
    /// [google.cloud.gkerecommender.v1.FetchModelServerVersionsResponse.next_page_token]: crate::model::FetchModelServerVersionsResponse::next_page_token
    pub page_size: std::option::Option<i32>,

    /// Optional. The value of
    /// [next_page_token][google.cloud.gkerecommender.v1.FetchModelServerVersionsResponse.next_page_token]
    /// received from a previous `FetchModelServerVersionsRequest` call.
    /// Provide this to retrieve the subsequent page in a multi-page list of
    /// results. When paginating, all other parameters provided to
    /// `FetchModelServerVersionsRequest` must match the call that provided the
    /// page token.
    ///
    /// [google.cloud.gkerecommender.v1.FetchModelServerVersionsResponse.next_page_token]: crate::model::FetchModelServerVersionsResponse::next_page_token
    pub page_token: std::option::Option<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchModelServerVersionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [model][crate::model::FetchModelServerVersionsRequest::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [model_server][crate::model::FetchModelServerVersionsRequest::model_server].
    pub fn set_model_server<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model_server = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::FetchModelServerVersionsRequest::page_size].
    pub fn set_page_size<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.page_size = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [page_size][crate::model::FetchModelServerVersionsRequest::page_size].
    pub fn set_or_clear_page_size<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.page_size = v.map(|x| x.into());
        self
    }

    /// Sets the value of [page_token][crate::model::FetchModelServerVersionsRequest::page_token].
    pub fn set_page_token<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.page_token = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [page_token][crate::model::FetchModelServerVersionsRequest::page_token].
    pub fn set_or_clear_page_token<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.page_token = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for FetchModelServerVersionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkerecommender.v1.FetchModelServerVersionsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchModelServerVersionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __model,
            __model_server,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchModelServerVersionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "model" => Ok(__FieldTag::__model),
                            "modelServer" => Ok(__FieldTag::__model_server),
                            "model_server" => Ok(__FieldTag::__model_server),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchModelServerVersionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchModelServerVersionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__model => {
                            if !fields.insert(__FieldTag::__model) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model",
                                ));
                            }
                            result.model = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__model_server => {
                            if !fields.insert(__FieldTag::__model_server) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model_server",
                                ));
                            }
                            result.model_server = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchModelServerVersionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.model.is_empty() {
            state.serialize_entry("model", &self.model)?;
        }
        if !self.model_server.is_empty() {
            state.serialize_entry("modelServer", &self.model_server)?;
        }
        if self.page_size.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if self.page_token.is_some() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FetchModelServerVersionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchModelServerVersionsRequest");
        debug_struct.field("model", &self.model);
        debug_struct.field("model_server", &self.model_server);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for
/// [GkeInferenceQuickstart.FetchModelServerVersions][google.cloud.gkerecommender.v1.GkeInferenceQuickstart.FetchModelServerVersions].
///
/// [google.cloud.gkerecommender.v1.GkeInferenceQuickstart.FetchModelServerVersions]: crate::client::GkeInferenceQuickstart::fetch_model_server_versions
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchModelServerVersionsResponse {
    /// Output only. A list of available model server versions.
    pub model_server_versions: std::vec::Vec<std::string::String>,

    /// Output only. A token which may be sent as
    /// [page_token][FetchModelServerVersionsResponse.page_token] in a subsequent
    /// `FetchModelServerVersionsResponse` call to retrieve the next page of
    /// results. If this field is omitted or empty, then there are no more results
    /// to return.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchModelServerVersionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [model_server_versions][crate::model::FetchModelServerVersionsResponse::model_server_versions].
    pub fn set_model_server_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.model_server_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::FetchModelServerVersionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for FetchModelServerVersionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkerecommender.v1.FetchModelServerVersionsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchModelServerVersionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __model_server_versions,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchModelServerVersionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "modelServerVersions" => Ok(__FieldTag::__model_server_versions),
                            "model_server_versions" => Ok(__FieldTag::__model_server_versions),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchModelServerVersionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchModelServerVersionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__model_server_versions => {
                            if !fields.insert(__FieldTag::__model_server_versions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model_server_versions",
                                ));
                            }
                            result.model_server_versions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchModelServerVersionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.model_server_versions.is_empty() {
            state.serialize_entry("modelServerVersions", &self.model_server_versions)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FetchModelServerVersionsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchModelServerVersionsResponse");
        debug_struct.field("model_server_versions", &self.model_server_versions);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for
/// [GkeInferenceQuickstart.FetchBenchmarkingData][google.cloud.gkerecommender.v1.GkeInferenceQuickstart.FetchBenchmarkingData].
///
/// [google.cloud.gkerecommender.v1.GkeInferenceQuickstart.FetchBenchmarkingData]: crate::client::GkeInferenceQuickstart::fetch_benchmarking_data
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchBenchmarkingDataRequest {
    /// Required. The model server configuration to get benchmarking data for. Use
    /// [GkeInferenceQuickstart.FetchProfiles][google.cloud.gkerecommender.v1.GkeInferenceQuickstart.FetchProfiles]
    /// to find valid configurations.
    ///
    /// [google.cloud.gkerecommender.v1.GkeInferenceQuickstart.FetchProfiles]: crate::client::GkeInferenceQuickstart::fetch_profiles
    pub model_server_info: std::option::Option<crate::model::ModelServerInfo>,

    /// Optional. The instance type to filter benchmarking data. Instance types are
    /// in the format `a2-highgpu-1g`. If not provided, all instance types for the
    /// given profile's `model_server_info` will be returned. Use
    /// [GkeInferenceQuickstart.FetchProfiles][google.cloud.gkerecommender.v1.GkeInferenceQuickstart.FetchProfiles]
    /// to find available instance types.
    ///
    /// [google.cloud.gkerecommender.v1.GkeInferenceQuickstart.FetchProfiles]: crate::client::GkeInferenceQuickstart::fetch_profiles
    pub instance_type: std::string::String,

    /// Optional. The pricing model to use for the benchmarking data. Defaults to
    /// `spot`.
    pub pricing_model: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchBenchmarkingDataRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [model_server_info][crate::model::FetchBenchmarkingDataRequest::model_server_info].
    pub fn set_model_server_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ModelServerInfo>,
    {
        self.model_server_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [model_server_info][crate::model::FetchBenchmarkingDataRequest::model_server_info].
    pub fn set_or_clear_model_server_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ModelServerInfo>,
    {
        self.model_server_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [instance_type][crate::model::FetchBenchmarkingDataRequest::instance_type].
    pub fn set_instance_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_type = v.into();
        self
    }

    /// Sets the value of [pricing_model][crate::model::FetchBenchmarkingDataRequest::pricing_model].
    pub fn set_pricing_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pricing_model = v.into();
        self
    }
}

impl wkt::message::Message for FetchBenchmarkingDataRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkerecommender.v1.FetchBenchmarkingDataRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchBenchmarkingDataRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __model_server_info,
            __instance_type,
            __pricing_model,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchBenchmarkingDataRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "modelServerInfo" => Ok(__FieldTag::__model_server_info),
                            "model_server_info" => Ok(__FieldTag::__model_server_info),
                            "instanceType" => Ok(__FieldTag::__instance_type),
                            "instance_type" => Ok(__FieldTag::__instance_type),
                            "pricingModel" => Ok(__FieldTag::__pricing_model),
                            "pricing_model" => Ok(__FieldTag::__pricing_model),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchBenchmarkingDataRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchBenchmarkingDataRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__model_server_info => {
                            if !fields.insert(__FieldTag::__model_server_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model_server_info",
                                ));
                            }
                            result.model_server_info = map
                                .next_value::<std::option::Option<crate::model::ModelServerInfo>>(
                                )?;
                        }
                        __FieldTag::__instance_type => {
                            if !fields.insert(__FieldTag::__instance_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_type",
                                ));
                            }
                            result.instance_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pricing_model => {
                            if !fields.insert(__FieldTag::__pricing_model) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pricing_model",
                                ));
                            }
                            result.pricing_model = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchBenchmarkingDataRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.model_server_info.is_some() {
            state.serialize_entry("modelServerInfo", &self.model_server_info)?;
        }
        if !self.instance_type.is_empty() {
            state.serialize_entry("instanceType", &self.instance_type)?;
        }
        if !self.pricing_model.is_empty() {
            state.serialize_entry("pricingModel", &self.pricing_model)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FetchBenchmarkingDataRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchBenchmarkingDataRequest");
        debug_struct.field("model_server_info", &self.model_server_info);
        debug_struct.field("instance_type", &self.instance_type);
        debug_struct.field("pricing_model", &self.pricing_model);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for
/// [GkeInferenceQuickstart.FetchBenchmarkingData][google.cloud.gkerecommender.v1.GkeInferenceQuickstart.FetchBenchmarkingData].
///
/// [google.cloud.gkerecommender.v1.GkeInferenceQuickstart.FetchBenchmarkingData]: crate::client::GkeInferenceQuickstart::fetch_benchmarking_data
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchBenchmarkingDataResponse {
    /// Output only. List of profiles containing their respective benchmarking
    /// data.
    pub profile: std::vec::Vec<crate::model::Profile>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchBenchmarkingDataResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [profile][crate::model::FetchBenchmarkingDataResponse::profile].
    pub fn set_profile<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Profile>,
    {
        use std::iter::Iterator;
        self.profile = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for FetchBenchmarkingDataResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkerecommender.v1.FetchBenchmarkingDataResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchBenchmarkingDataResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __profile,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchBenchmarkingDataResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "profile" => Ok(__FieldTag::__profile),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchBenchmarkingDataResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchBenchmarkingDataResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__profile => {
                            if !fields.insert(__FieldTag::__profile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for profile",
                                ));
                            }
                            result.profile = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Profile>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchBenchmarkingDataResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.profile.is_empty() {
            state.serialize_entry("profile", &self.profile)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FetchBenchmarkingDataResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchBenchmarkingDataResponse");
        debug_struct.field("profile", &self.profile);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for
/// [GkeInferenceQuickstart.FetchProfiles][google.cloud.gkerecommender.v1.GkeInferenceQuickstart.FetchProfiles].
///
/// [google.cloud.gkerecommender.v1.GkeInferenceQuickstart.FetchProfiles]: crate::client::GkeInferenceQuickstart::fetch_profiles
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchProfilesRequest {
    /// Optional. The model to filter profiles by. Open-source models follow the
    /// Huggingface Hub `owner/model_name` format. If not provided, all models are
    /// returned. Use
    /// [GkeInferenceQuickstart.FetchModels][google.cloud.gkerecommender.v1.GkeInferenceQuickstart.FetchModels]
    /// to find available models.
    ///
    /// [google.cloud.gkerecommender.v1.GkeInferenceQuickstart.FetchModels]: crate::client::GkeInferenceQuickstart::fetch_models
    pub model: std::string::String,

    /// Optional. The model server to filter profiles by. If not provided, all
    /// model servers are returned. Use
    /// [GkeInferenceQuickstart.FetchModelServers][google.cloud.gkerecommender.v1.GkeInferenceQuickstart.FetchModelServers]
    /// to find available model servers for a given model.
    ///
    /// [google.cloud.gkerecommender.v1.GkeInferenceQuickstart.FetchModelServers]: crate::client::GkeInferenceQuickstart::fetch_model_servers
    pub model_server: std::string::String,

    /// Optional. The model server version to filter profiles by. If not provided,
    /// all model server versions are returned. Use
    /// [GkeInferenceQuickstart.FetchModelServerVersions][google.cloud.gkerecommender.v1.GkeInferenceQuickstart.FetchModelServerVersions]
    /// to find available versions for a given model and server.
    ///
    /// [google.cloud.gkerecommender.v1.GkeInferenceQuickstart.FetchModelServerVersions]: crate::client::GkeInferenceQuickstart::fetch_model_server_versions
    pub model_server_version: std::string::String,

    /// Optional. The performance requirements to filter profiles. Profiles that do
    /// not meet these requirements are filtered out. If not provided, all profiles
    /// are returned.
    pub performance_requirements: std::option::Option<crate::model::PerformanceRequirements>,

    /// Optional. The target number of results to return in a single response. If
    /// not specified, a default value will be chosen by the service. Note that the
    /// response may include a partial list and a caller should only rely on the
    /// response's
    /// [next_page_token][google.cloud.gkerecommender.v1.FetchProfilesResponse.next_page_token]
    /// to determine if there are more instances left to be queried.
    ///
    /// [google.cloud.gkerecommender.v1.FetchProfilesResponse.next_page_token]: crate::model::FetchProfilesResponse::next_page_token
    pub page_size: std::option::Option<i32>,

    /// Optional. The value of
    /// [next_page_token][google.cloud.gkerecommender.v1.FetchProfilesResponse.next_page_token]
    /// received from a previous `FetchProfilesRequest` call.
    /// Provide this to retrieve the subsequent page in a multi-page list of
    /// results. When paginating, all other parameters provided to
    /// `FetchProfilesRequest` must match the call that provided the page
    /// token.
    ///
    /// [google.cloud.gkerecommender.v1.FetchProfilesResponse.next_page_token]: crate::model::FetchProfilesResponse::next_page_token
    pub page_token: std::option::Option<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchProfilesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [model][crate::model::FetchProfilesRequest::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [model_server][crate::model::FetchProfilesRequest::model_server].
    pub fn set_model_server<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model_server = v.into();
        self
    }

    /// Sets the value of [model_server_version][crate::model::FetchProfilesRequest::model_server_version].
    pub fn set_model_server_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.model_server_version = v.into();
        self
    }

    /// Sets the value of [performance_requirements][crate::model::FetchProfilesRequest::performance_requirements].
    pub fn set_performance_requirements<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PerformanceRequirements>,
    {
        self.performance_requirements = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [performance_requirements][crate::model::FetchProfilesRequest::performance_requirements].
    pub fn set_or_clear_performance_requirements<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PerformanceRequirements>,
    {
        self.performance_requirements = v.map(|x| x.into());
        self
    }

    /// Sets the value of [page_size][crate::model::FetchProfilesRequest::page_size].
    pub fn set_page_size<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.page_size = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [page_size][crate::model::FetchProfilesRequest::page_size].
    pub fn set_or_clear_page_size<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.page_size = v.map(|x| x.into());
        self
    }

    /// Sets the value of [page_token][crate::model::FetchProfilesRequest::page_token].
    pub fn set_page_token<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.page_token = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [page_token][crate::model::FetchProfilesRequest::page_token].
    pub fn set_or_clear_page_token<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.page_token = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for FetchProfilesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkerecommender.v1.FetchProfilesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchProfilesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __model,
            __model_server,
            __model_server_version,
            __performance_requirements,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchProfilesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "model" => Ok(__FieldTag::__model),
                            "modelServer" => Ok(__FieldTag::__model_server),
                            "model_server" => Ok(__FieldTag::__model_server),
                            "modelServerVersion" => Ok(__FieldTag::__model_server_version),
                            "model_server_version" => Ok(__FieldTag::__model_server_version),
                            "performanceRequirements" => Ok(__FieldTag::__performance_requirements),
                            "performance_requirements" => {
                                Ok(__FieldTag::__performance_requirements)
                            }
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchProfilesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchProfilesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__model => {
                            if !fields.insert(__FieldTag::__model) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model",
                                ));
                            }
                            result.model = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__model_server => {
                            if !fields.insert(__FieldTag::__model_server) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model_server",
                                ));
                            }
                            result.model_server = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__model_server_version => {
                            if !fields.insert(__FieldTag::__model_server_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model_server_version",
                                ));
                            }
                            result.model_server_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__performance_requirements => {
                            if !fields.insert(__FieldTag::__performance_requirements) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for performance_requirements",
                                ));
                            }
                            result.performance_requirements = map.next_value::<std::option::Option<crate::model::PerformanceRequirements>>()?
                                ;
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchProfilesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.model.is_empty() {
            state.serialize_entry("model", &self.model)?;
        }
        if !self.model_server.is_empty() {
            state.serialize_entry("modelServer", &self.model_server)?;
        }
        if !self.model_server_version.is_empty() {
            state.serialize_entry("modelServerVersion", &self.model_server_version)?;
        }
        if self.performance_requirements.is_some() {
            state.serialize_entry("performanceRequirements", &self.performance_requirements)?;
        }
        if self.page_size.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if self.page_token.is_some() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FetchProfilesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchProfilesRequest");
        debug_struct.field("model", &self.model);
        debug_struct.field("model_server", &self.model_server);
        debug_struct.field("model_server_version", &self.model_server_version);
        debug_struct.field("performance_requirements", &self.performance_requirements);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Performance requirements for a profile and or model deployment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PerformanceRequirements {
    /// Optional. The target Normalized Time Per Output Token (NTPOT) in
    /// milliseconds. NTPOT is calculated as `request_latency /
    /// total_output_tokens`. If not provided, this target will not be enforced.
    pub target_ntpot_milliseconds: std::option::Option<i32>,

    /// Optional. The target Time To First Token (TTFT) in milliseconds. TTFT is
    /// the time it takes to generate the first token for a request.  If not
    /// provided, this target will not be enforced.
    pub target_ttft_milliseconds: std::option::Option<i32>,

    /// Optional. The target cost for running a profile's model server. If not
    /// provided, this requirement will not be enforced.
    pub target_cost: std::option::Option<crate::model::Cost>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PerformanceRequirements {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target_ntpot_milliseconds][crate::model::PerformanceRequirements::target_ntpot_milliseconds].
    pub fn set_target_ntpot_milliseconds<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.target_ntpot_milliseconds = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [target_ntpot_milliseconds][crate::model::PerformanceRequirements::target_ntpot_milliseconds].
    pub fn set_or_clear_target_ntpot_milliseconds<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.target_ntpot_milliseconds = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target_ttft_milliseconds][crate::model::PerformanceRequirements::target_ttft_milliseconds].
    pub fn set_target_ttft_milliseconds<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.target_ttft_milliseconds = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [target_ttft_milliseconds][crate::model::PerformanceRequirements::target_ttft_milliseconds].
    pub fn set_or_clear_target_ttft_milliseconds<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.target_ttft_milliseconds = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target_cost][crate::model::PerformanceRequirements::target_cost].
    pub fn set_target_cost<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Cost>,
    {
        self.target_cost = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [target_cost][crate::model::PerformanceRequirements::target_cost].
    pub fn set_or_clear_target_cost<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Cost>,
    {
        self.target_cost = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PerformanceRequirements {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkerecommender.v1.PerformanceRequirements"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PerformanceRequirements {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __target_ntpot_milliseconds,
            __target_ttft_milliseconds,
            __target_cost,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PerformanceRequirements")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "targetNtpotMilliseconds" => {
                                Ok(__FieldTag::__target_ntpot_milliseconds)
                            }
                            "target_ntpot_milliseconds" => {
                                Ok(__FieldTag::__target_ntpot_milliseconds)
                            }
                            "targetTtftMilliseconds" => Ok(__FieldTag::__target_ttft_milliseconds),
                            "target_ttft_milliseconds" => {
                                Ok(__FieldTag::__target_ttft_milliseconds)
                            }
                            "targetCost" => Ok(__FieldTag::__target_cost),
                            "target_cost" => Ok(__FieldTag::__target_cost),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PerformanceRequirements;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PerformanceRequirements")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__target_ntpot_milliseconds => {
                            if !fields.insert(__FieldTag::__target_ntpot_milliseconds) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_ntpot_milliseconds",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.target_ntpot_milliseconds = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__target_ttft_milliseconds => {
                            if !fields.insert(__FieldTag::__target_ttft_milliseconds) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_ttft_milliseconds",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.target_ttft_milliseconds = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__target_cost => {
                            if !fields.insert(__FieldTag::__target_cost) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_cost",
                                ));
                            }
                            result.target_cost =
                                map.next_value::<std::option::Option<crate::model::Cost>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PerformanceRequirements {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.target_ntpot_milliseconds.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "targetNtpotMilliseconds",
                &__With(&self.target_ntpot_milliseconds),
            )?;
        }
        if self.target_ttft_milliseconds.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "targetTtftMilliseconds",
                &__With(&self.target_ttft_milliseconds),
            )?;
        }
        if self.target_cost.is_some() {
            state.serialize_entry("targetCost", &self.target_cost)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PerformanceRequirements {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PerformanceRequirements");
        debug_struct.field("target_ntpot_milliseconds", &self.target_ntpot_milliseconds);
        debug_struct.field("target_ttft_milliseconds", &self.target_ttft_milliseconds);
        debug_struct.field("target_cost", &self.target_cost);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents an amount of money in a specific currency.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Amount {
    /// Output only. The whole units of the amount.
    /// For example if `currencyCode` is `"USD"`, then 1 unit is one US dollar.
    pub units: i64,

    /// Output only. Number of nano (10^-9) units of the amount.
    /// The value must be between -999,999,999 and +999,999,999 inclusive.
    /// If `units` is positive, `nanos` must be positive or zero.
    /// If `units` is zero, `nanos` can be positive, zero, or negative.
    /// If `units` is negative, `nanos` must be negative or zero.
    /// For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
    pub nanos: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Amount {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [units][crate::model::Amount::units].
    pub fn set_units<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.units = v.into();
        self
    }

    /// Sets the value of [nanos][crate::model::Amount::nanos].
    pub fn set_nanos<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.nanos = v.into();
        self
    }
}

impl wkt::message::Message for Amount {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkerecommender.v1.Amount"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Amount {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __units,
            __nanos,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Amount")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "units" => Ok(__FieldTag::__units),
                            "nanos" => Ok(__FieldTag::__nanos),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Amount;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Amount")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__units => {
                            if !fields.insert(__FieldTag::__units) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for units",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.units = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__nanos => {
                            if !fields.insert(__FieldTag::__nanos) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nanos",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.nanos = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Amount {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.units) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("units", &__With(&self.units))?;
        }
        if !wkt::internal::is_default(&self.nanos) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("nanos", &__With(&self.nanos))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Amount {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Amount");
        debug_struct.field("units", &self.units);
        debug_struct.field("nanos", &self.nanos);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Cost for running a model deployment on a given instance type. Currently, only
/// USD currency code is supported.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Cost {
    /// Optional. The cost per million output tokens, calculated as:
    /// $/output token = GPU $/s / (1/output-to-input-cost-ratio * input tokens/s +
    /// output tokens/s)
    pub cost_per_million_output_tokens: std::option::Option<crate::model::Amount>,

    /// Optional. The cost per million input tokens. $/input token = ($/output
    /// token) / output-to-input-cost-ratio.
    pub cost_per_million_input_tokens: std::option::Option<crate::model::Amount>,

    /// Optional. The pricing model used to calculate the cost. Can be one of:
    /// `3-years-cud`, `1-year-cud`, `on-demand`, `spot`. If not provided, `spot`
    /// will be used.
    pub pricing_model: std::string::String,

    /// Optional. The output-to-input cost ratio. This determines how the total GPU
    /// cost is split between input and output tokens. If not provided, `4.0` is
    /// used, assuming a 4:1 output:input cost ratio.
    pub output_input_cost_ratio: std::option::Option<f32>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Cost {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cost_per_million_output_tokens][crate::model::Cost::cost_per_million_output_tokens].
    pub fn set_cost_per_million_output_tokens<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Amount>,
    {
        self.cost_per_million_output_tokens = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cost_per_million_output_tokens][crate::model::Cost::cost_per_million_output_tokens].
    pub fn set_or_clear_cost_per_million_output_tokens<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::Amount>,
    {
        self.cost_per_million_output_tokens = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cost_per_million_input_tokens][crate::model::Cost::cost_per_million_input_tokens].
    pub fn set_cost_per_million_input_tokens<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Amount>,
    {
        self.cost_per_million_input_tokens = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cost_per_million_input_tokens][crate::model::Cost::cost_per_million_input_tokens].
    pub fn set_or_clear_cost_per_million_input_tokens<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::Amount>,
    {
        self.cost_per_million_input_tokens = v.map(|x| x.into());
        self
    }

    /// Sets the value of [pricing_model][crate::model::Cost::pricing_model].
    pub fn set_pricing_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pricing_model = v.into();
        self
    }

    /// Sets the value of [output_input_cost_ratio][crate::model::Cost::output_input_cost_ratio].
    pub fn set_output_input_cost_ratio<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f32>,
    {
        self.output_input_cost_ratio = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [output_input_cost_ratio][crate::model::Cost::output_input_cost_ratio].
    pub fn set_or_clear_output_input_cost_ratio<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f32>,
    {
        self.output_input_cost_ratio = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Cost {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkerecommender.v1.Cost"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Cost {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cost_per_million_output_tokens,
            __cost_per_million_input_tokens,
            __pricing_model,
            __output_input_cost_ratio,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Cost")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "costPerMillionOutputTokens" => {
                                Ok(__FieldTag::__cost_per_million_output_tokens)
                            }
                            "cost_per_million_output_tokens" => {
                                Ok(__FieldTag::__cost_per_million_output_tokens)
                            }
                            "costPerMillionInputTokens" => {
                                Ok(__FieldTag::__cost_per_million_input_tokens)
                            }
                            "cost_per_million_input_tokens" => {
                                Ok(__FieldTag::__cost_per_million_input_tokens)
                            }
                            "pricingModel" => Ok(__FieldTag::__pricing_model),
                            "pricing_model" => Ok(__FieldTag::__pricing_model),
                            "outputInputCostRatio" => Ok(__FieldTag::__output_input_cost_ratio),
                            "output_input_cost_ratio" => Ok(__FieldTag::__output_input_cost_ratio),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Cost;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Cost")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cost_per_million_output_tokens => {
                            if !fields.insert(__FieldTag::__cost_per_million_output_tokens) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cost_per_million_output_tokens",
                                ));
                            }
                            result.cost_per_million_output_tokens =
                                map.next_value::<std::option::Option<crate::model::Amount>>()?;
                        }
                        __FieldTag::__cost_per_million_input_tokens => {
                            if !fields.insert(__FieldTag::__cost_per_million_input_tokens) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cost_per_million_input_tokens",
                                ));
                            }
                            result.cost_per_million_input_tokens =
                                map.next_value::<std::option::Option<crate::model::Amount>>()?;
                        }
                        __FieldTag::__pricing_model => {
                            if !fields.insert(__FieldTag::__pricing_model) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pricing_model",
                                ));
                            }
                            result.pricing_model = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__output_input_cost_ratio => {
                            if !fields.insert(__FieldTag::__output_input_cost_ratio) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_input_cost_ratio",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.output_input_cost_ratio = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Cost {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.cost_per_million_output_tokens.is_some() {
            state.serialize_entry(
                "costPerMillionOutputTokens",
                &self.cost_per_million_output_tokens,
            )?;
        }
        if self.cost_per_million_input_tokens.is_some() {
            state.serialize_entry(
                "costPerMillionInputTokens",
                &self.cost_per_million_input_tokens,
            )?;
        }
        if !self.pricing_model.is_empty() {
            state.serialize_entry("pricingModel", &self.pricing_model)?;
        }
        if self.output_input_cost_ratio.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "outputInputCostRatio",
                &__With(&self.output_input_cost_ratio),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Cost {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Cost");
        debug_struct.field(
            "cost_per_million_output_tokens",
            &self.cost_per_million_output_tokens,
        );
        debug_struct.field(
            "cost_per_million_input_tokens",
            &self.cost_per_million_input_tokens,
        );
        debug_struct.field("pricing_model", &self.pricing_model);
        debug_struct.field("output_input_cost_ratio", &self.output_input_cost_ratio);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents a range of throughput values in tokens per second.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TokensPerSecondRange {
    /// Output only. The minimum value of the range.
    pub min: i32,

    /// Output only. The maximum value of the range.
    pub max: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TokensPerSecondRange {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [min][crate::model::TokensPerSecondRange::min].
    pub fn set_min<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min = v.into();
        self
    }

    /// Sets the value of [max][crate::model::TokensPerSecondRange::max].
    pub fn set_max<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max = v.into();
        self
    }
}

impl wkt::message::Message for TokensPerSecondRange {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkerecommender.v1.TokensPerSecondRange"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TokensPerSecondRange {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __min,
            __max,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TokensPerSecondRange")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "min" => Ok(__FieldTag::__min),
                            "max" => Ok(__FieldTag::__max),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TokensPerSecondRange;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TokensPerSecondRange")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__min => {
                            if !fields.insert(__FieldTag::__min) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.min = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max => {
                            if !fields.insert(__FieldTag::__max) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TokensPerSecondRange {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.min) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("min", &__With(&self.min))?;
        }
        if !wkt::internal::is_default(&self.max) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("max", &__With(&self.max))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TokensPerSecondRange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TokensPerSecondRange");
        debug_struct.field("min", &self.min);
        debug_struct.field("max", &self.max);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents a range of latency values in milliseconds.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MillisecondRange {
    /// Output only. The minimum value of the range.
    pub min: i32,

    /// Output only. The maximum value of the range.
    pub max: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MillisecondRange {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [min][crate::model::MillisecondRange::min].
    pub fn set_min<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min = v.into();
        self
    }

    /// Sets the value of [max][crate::model::MillisecondRange::max].
    pub fn set_max<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max = v.into();
        self
    }
}

impl wkt::message::Message for MillisecondRange {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkerecommender.v1.MillisecondRange"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MillisecondRange {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __min,
            __max,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MillisecondRange")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "min" => Ok(__FieldTag::__min),
                            "max" => Ok(__FieldTag::__max),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MillisecondRange;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MillisecondRange")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__min => {
                            if !fields.insert(__FieldTag::__min) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.min = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max => {
                            if !fields.insert(__FieldTag::__max) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MillisecondRange {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.min) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("min", &__With(&self.min))?;
        }
        if !wkt::internal::is_default(&self.max) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("max", &__With(&self.max))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MillisecondRange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MillisecondRange");
        debug_struct.field("min", &self.min);
        debug_struct.field("max", &self.max);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Performance range for a model deployment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PerformanceRange {
    /// Output only. The range of throughput in output tokens per second. This is
    /// measured as total_output_tokens_generated_by_server /
    /// elapsed_time_in_seconds.
    pub throughput_output_range: std::option::Option<crate::model::TokensPerSecondRange>,

    /// Output only. The range of TTFT (Time To First Token) in milliseconds. TTFT
    /// is the time it takes to generate the first token for a request.
    pub ttft_range: std::option::Option<crate::model::MillisecondRange>,

    /// Output only. The range of NTPOT (Normalized Time Per Output Token) in
    /// milliseconds. NTPOT is the request latency normalized by the number of
    /// output tokens, measured as request_latency / total_output_tokens.
    pub ntpot_range: std::option::Option<crate::model::MillisecondRange>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PerformanceRange {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [throughput_output_range][crate::model::PerformanceRange::throughput_output_range].
    pub fn set_throughput_output_range<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TokensPerSecondRange>,
    {
        self.throughput_output_range = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [throughput_output_range][crate::model::PerformanceRange::throughput_output_range].
    pub fn set_or_clear_throughput_output_range<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TokensPerSecondRange>,
    {
        self.throughput_output_range = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ttft_range][crate::model::PerformanceRange::ttft_range].
    pub fn set_ttft_range<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MillisecondRange>,
    {
        self.ttft_range = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ttft_range][crate::model::PerformanceRange::ttft_range].
    pub fn set_or_clear_ttft_range<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MillisecondRange>,
    {
        self.ttft_range = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ntpot_range][crate::model::PerformanceRange::ntpot_range].
    pub fn set_ntpot_range<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MillisecondRange>,
    {
        self.ntpot_range = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ntpot_range][crate::model::PerformanceRange::ntpot_range].
    pub fn set_or_clear_ntpot_range<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MillisecondRange>,
    {
        self.ntpot_range = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PerformanceRange {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkerecommender.v1.PerformanceRange"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PerformanceRange {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __throughput_output_range,
            __ttft_range,
            __ntpot_range,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PerformanceRange")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "throughputOutputRange" => Ok(__FieldTag::__throughput_output_range),
                            "throughput_output_range" => Ok(__FieldTag::__throughput_output_range),
                            "ttftRange" => Ok(__FieldTag::__ttft_range),
                            "ttft_range" => Ok(__FieldTag::__ttft_range),
                            "ntpotRange" => Ok(__FieldTag::__ntpot_range),
                            "ntpot_range" => Ok(__FieldTag::__ntpot_range),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PerformanceRange;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PerformanceRange")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__throughput_output_range => {
                            if !fields.insert(__FieldTag::__throughput_output_range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for throughput_output_range",
                                ));
                            }
                            result.throughput_output_range = map.next_value::<std::option::Option<crate::model::TokensPerSecondRange>>()?
                                ;
                        }
                        __FieldTag::__ttft_range => {
                            if !fields.insert(__FieldTag::__ttft_range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ttft_range",
                                ));
                            }
                            result.ttft_range = map
                                .next_value::<std::option::Option<crate::model::MillisecondRange>>(
                                )?;
                        }
                        __FieldTag::__ntpot_range => {
                            if !fields.insert(__FieldTag::__ntpot_range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ntpot_range",
                                ));
                            }
                            result.ntpot_range = map
                                .next_value::<std::option::Option<crate::model::MillisecondRange>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PerformanceRange {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.throughput_output_range.is_some() {
            state.serialize_entry("throughputOutputRange", &self.throughput_output_range)?;
        }
        if self.ttft_range.is_some() {
            state.serialize_entry("ttftRange", &self.ttft_range)?;
        }
        if self.ntpot_range.is_some() {
            state.serialize_entry("ntpotRange", &self.ntpot_range)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PerformanceRange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PerformanceRange");
        debug_struct.field("throughput_output_range", &self.throughput_output_range);
        debug_struct.field("ttft_range", &self.ttft_range);
        debug_struct.field("ntpot_range", &self.ntpot_range);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for
/// [GkeInferenceQuickstart.FetchProfiles][google.cloud.gkerecommender.v1.GkeInferenceQuickstart.FetchProfiles].
///
/// [google.cloud.gkerecommender.v1.GkeInferenceQuickstart.FetchProfiles]: crate::client::GkeInferenceQuickstart::fetch_profiles
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchProfilesResponse {
    /// Output only. List of profiles that match the given model server info and
    /// performance requirements (if provided).
    pub profile: std::vec::Vec<crate::model::Profile>,

    /// Output only. The combined range of performance values observed across all
    /// profiles in this response.
    pub performance_range: std::option::Option<crate::model::PerformanceRange>,

    /// Output only. Additional comments related to the response.
    pub comments: std::string::String,

    /// Output only. A token which may be sent as
    /// [page_token][FetchProfilesResponse.page_token] in a subsequent
    /// `FetchProfilesResponse` call to retrieve the next page of results. If this
    /// field is omitted or empty, then there are no more results to return.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchProfilesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [profile][crate::model::FetchProfilesResponse::profile].
    pub fn set_profile<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Profile>,
    {
        use std::iter::Iterator;
        self.profile = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [performance_range][crate::model::FetchProfilesResponse::performance_range].
    pub fn set_performance_range<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PerformanceRange>,
    {
        self.performance_range = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [performance_range][crate::model::FetchProfilesResponse::performance_range].
    pub fn set_or_clear_performance_range<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PerformanceRange>,
    {
        self.performance_range = v.map(|x| x.into());
        self
    }

    /// Sets the value of [comments][crate::model::FetchProfilesResponse::comments].
    pub fn set_comments<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.comments = v.into();
        self
    }

    /// Sets the value of [next_page_token][crate::model::FetchProfilesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for FetchProfilesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkerecommender.v1.FetchProfilesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for FetchProfilesResponse {
    type PageItem = crate::model::Profile;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.profile
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchProfilesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __profile,
            __performance_range,
            __comments,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchProfilesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "profile" => Ok(__FieldTag::__profile),
                            "performanceRange" => Ok(__FieldTag::__performance_range),
                            "performance_range" => Ok(__FieldTag::__performance_range),
                            "comments" => Ok(__FieldTag::__comments),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchProfilesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchProfilesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__profile => {
                            if !fields.insert(__FieldTag::__profile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for profile",
                                ));
                            }
                            result.profile = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Profile>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__performance_range => {
                            if !fields.insert(__FieldTag::__performance_range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for performance_range",
                                ));
                            }
                            result.performance_range = map
                                .next_value::<std::option::Option<crate::model::PerformanceRange>>(
                                )?;
                        }
                        __FieldTag::__comments => {
                            if !fields.insert(__FieldTag::__comments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for comments",
                                ));
                            }
                            result.comments = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchProfilesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.profile.is_empty() {
            state.serialize_entry("profile", &self.profile)?;
        }
        if self.performance_range.is_some() {
            state.serialize_entry("performanceRange", &self.performance_range)?;
        }
        if !self.comments.is_empty() {
            state.serialize_entry("comments", &self.comments)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FetchProfilesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchProfilesResponse");
        debug_struct.field("profile", &self.profile);
        debug_struct.field("performance_range", &self.performance_range);
        debug_struct.field("comments", &self.comments);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Model server information gives. Valid model server info combinations can
/// be found using
/// [GkeInferenceQuickstart.FetchProfiles][google.cloud.gkerecommender.v1.GkeInferenceQuickstart.FetchProfiles].
///
/// [google.cloud.gkerecommender.v1.GkeInferenceQuickstart.FetchProfiles]: crate::client::GkeInferenceQuickstart::fetch_profiles
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ModelServerInfo {
    /// Required. The model. Open-source models follow the Huggingface Hub
    /// `owner/model_name` format. Use
    /// [GkeInferenceQuickstart.FetchModels][google.cloud.gkerecommender.v1.GkeInferenceQuickstart.FetchModels]
    /// to find available models.
    ///
    /// [google.cloud.gkerecommender.v1.GkeInferenceQuickstart.FetchModels]: crate::client::GkeInferenceQuickstart::fetch_models
    pub model: std::string::String,

    /// Required. The model server. Open-source model servers use simplified,
    /// lowercase names (e.g., `vllm`). Use
    /// [GkeInferenceQuickstart.FetchModelServers][google.cloud.gkerecommender.v1.GkeInferenceQuickstart.FetchModelServers]
    /// to find available servers.
    ///
    /// [google.cloud.gkerecommender.v1.GkeInferenceQuickstart.FetchModelServers]: crate::client::GkeInferenceQuickstart::fetch_model_servers
    pub model_server: std::string::String,

    /// Optional. The model server version. Use
    /// [GkeInferenceQuickstart.FetchModelServerVersions][google.cloud.gkerecommender.v1.GkeInferenceQuickstart.FetchModelServerVersions]
    /// to find available versions. If not provided, the latest available version
    /// is used.
    ///
    /// [google.cloud.gkerecommender.v1.GkeInferenceQuickstart.FetchModelServerVersions]: crate::client::GkeInferenceQuickstart::fetch_model_server_versions
    pub model_server_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ModelServerInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [model][crate::model::ModelServerInfo::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [model_server][crate::model::ModelServerInfo::model_server].
    pub fn set_model_server<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model_server = v.into();
        self
    }

    /// Sets the value of [model_server_version][crate::model::ModelServerInfo::model_server_version].
    pub fn set_model_server_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.model_server_version = v.into();
        self
    }
}

impl wkt::message::Message for ModelServerInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkerecommender.v1.ModelServerInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ModelServerInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __model,
            __model_server,
            __model_server_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ModelServerInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "model" => Ok(__FieldTag::__model),
                            "modelServer" => Ok(__FieldTag::__model_server),
                            "model_server" => Ok(__FieldTag::__model_server),
                            "modelServerVersion" => Ok(__FieldTag::__model_server_version),
                            "model_server_version" => Ok(__FieldTag::__model_server_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ModelServerInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ModelServerInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__model => {
                            if !fields.insert(__FieldTag::__model) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model",
                                ));
                            }
                            result.model = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__model_server => {
                            if !fields.insert(__FieldTag::__model_server) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model_server",
                                ));
                            }
                            result.model_server = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__model_server_version => {
                            if !fields.insert(__FieldTag::__model_server_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model_server_version",
                                ));
                            }
                            result.model_server_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ModelServerInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.model.is_empty() {
            state.serialize_entry("model", &self.model)?;
        }
        if !self.model_server.is_empty() {
            state.serialize_entry("modelServer", &self.model_server)?;
        }
        if !self.model_server_version.is_empty() {
            state.serialize_entry("modelServerVersion", &self.model_server_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ModelServerInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ModelServerInfo");
        debug_struct.field("model", &self.model);
        debug_struct.field("model_server", &self.model_server);
        debug_struct.field("model_server_version", &self.model_server_version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Resources used by a model deployment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ResourcesUsed {
    /// Output only. The number of accelerators (e.g., GPUs or TPUs) used by the
    /// model deployment on the Kubernetes node.
    pub accelerator_count: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResourcesUsed {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [accelerator_count][crate::model::ResourcesUsed::accelerator_count].
    pub fn set_accelerator_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.accelerator_count = v.into();
        self
    }
}

impl wkt::message::Message for ResourcesUsed {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkerecommender.v1.ResourcesUsed"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ResourcesUsed {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __accelerator_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResourcesUsed")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "acceleratorCount" => Ok(__FieldTag::__accelerator_count),
                            "accelerator_count" => Ok(__FieldTag::__accelerator_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ResourcesUsed;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResourcesUsed")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__accelerator_count => {
                            if !fields.insert(__FieldTag::__accelerator_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for accelerator_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.accelerator_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ResourcesUsed {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.accelerator_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("acceleratorCount", &__With(&self.accelerator_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ResourcesUsed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ResourcesUsed");
        debug_struct.field("accelerator_count", &self.accelerator_count);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Performance statistics for a model deployment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PerformanceStats {
    /// Output only. The number of queries per second.
    /// Note: This metric can vary widely based on context length and may not be a
    /// reliable measure of LLM throughput.
    pub queries_per_second: f32,

    /// Output only. The number of output tokens per second. This is the throughput
    /// measured as total_output_tokens_generated_by_server /
    /// elapsed_time_in_seconds.
    pub output_tokens_per_second: i32,

    /// Output only. The Normalized Time Per Output Token (NTPOT) in milliseconds.
    /// This is the request latency normalized by the number of output tokens,
    /// measured as request_latency / total_output_tokens.
    pub ntpot_milliseconds: i32,

    /// Output only. The Time To First Token (TTFT) in milliseconds. This is the
    /// time it takes to generate the first token for a request.
    pub ttft_milliseconds: i32,

    /// Output only. The cost of running the model deployment.
    pub cost: std::vec::Vec<crate::model::Cost>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PerformanceStats {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [queries_per_second][crate::model::PerformanceStats::queries_per_second].
    pub fn set_queries_per_second<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.queries_per_second = v.into();
        self
    }

    /// Sets the value of [output_tokens_per_second][crate::model::PerformanceStats::output_tokens_per_second].
    pub fn set_output_tokens_per_second<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.output_tokens_per_second = v.into();
        self
    }

    /// Sets the value of [ntpot_milliseconds][crate::model::PerformanceStats::ntpot_milliseconds].
    pub fn set_ntpot_milliseconds<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.ntpot_milliseconds = v.into();
        self
    }

    /// Sets the value of [ttft_milliseconds][crate::model::PerformanceStats::ttft_milliseconds].
    pub fn set_ttft_milliseconds<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.ttft_milliseconds = v.into();
        self
    }

    /// Sets the value of [cost][crate::model::PerformanceStats::cost].
    pub fn set_cost<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Cost>,
    {
        use std::iter::Iterator;
        self.cost = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PerformanceStats {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkerecommender.v1.PerformanceStats"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PerformanceStats {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __queries_per_second,
            __output_tokens_per_second,
            __ntpot_milliseconds,
            __ttft_milliseconds,
            __cost,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PerformanceStats")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "queriesPerSecond" => Ok(__FieldTag::__queries_per_second),
                            "queries_per_second" => Ok(__FieldTag::__queries_per_second),
                            "outputTokensPerSecond" => Ok(__FieldTag::__output_tokens_per_second),
                            "output_tokens_per_second" => {
                                Ok(__FieldTag::__output_tokens_per_second)
                            }
                            "ntpotMilliseconds" => Ok(__FieldTag::__ntpot_milliseconds),
                            "ntpot_milliseconds" => Ok(__FieldTag::__ntpot_milliseconds),
                            "ttftMilliseconds" => Ok(__FieldTag::__ttft_milliseconds),
                            "ttft_milliseconds" => Ok(__FieldTag::__ttft_milliseconds),
                            "cost" => Ok(__FieldTag::__cost),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PerformanceStats;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PerformanceStats")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__queries_per_second => {
                            if !fields.insert(__FieldTag::__queries_per_second) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for queries_per_second",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.queries_per_second =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__output_tokens_per_second => {
                            if !fields.insert(__FieldTag::__output_tokens_per_second) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_tokens_per_second",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.output_tokens_per_second =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__ntpot_milliseconds => {
                            if !fields.insert(__FieldTag::__ntpot_milliseconds) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ntpot_milliseconds",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.ntpot_milliseconds =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__ttft_milliseconds => {
                            if !fields.insert(__FieldTag::__ttft_milliseconds) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ttft_milliseconds",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.ttft_milliseconds =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__cost => {
                            if !fields.insert(__FieldTag::__cost) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cost",
                                ));
                            }
                            result.cost = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Cost>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PerformanceStats {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.queries_per_second) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("queriesPerSecond", &__With(&self.queries_per_second))?;
        }
        if !wkt::internal::is_default(&self.output_tokens_per_second) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "outputTokensPerSecond",
                &__With(&self.output_tokens_per_second),
            )?;
        }
        if !wkt::internal::is_default(&self.ntpot_milliseconds) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ntpotMilliseconds", &__With(&self.ntpot_milliseconds))?;
        }
        if !wkt::internal::is_default(&self.ttft_milliseconds) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ttftMilliseconds", &__With(&self.ttft_milliseconds))?;
        }
        if !self.cost.is_empty() {
            state.serialize_entry("cost", &self.cost)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PerformanceStats {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PerformanceStats");
        debug_struct.field("queries_per_second", &self.queries_per_second);
        debug_struct.field("output_tokens_per_second", &self.output_tokens_per_second);
        debug_struct.field("ntpot_milliseconds", &self.ntpot_milliseconds);
        debug_struct.field("ttft_milliseconds", &self.ttft_milliseconds);
        debug_struct.field("cost", &self.cost);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A profile containing information about a model deployment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Profile {
    /// Output only. The model server configuration. Use
    /// [GkeInferenceQuickstart.FetchProfiles][google.cloud.gkerecommender.v1.GkeInferenceQuickstart.FetchProfiles]
    /// to find valid configurations.
    ///
    /// [google.cloud.gkerecommender.v1.GkeInferenceQuickstart.FetchProfiles]: crate::client::GkeInferenceQuickstart::fetch_profiles
    pub model_server_info: std::option::Option<crate::model::ModelServerInfo>,

    /// Output only. The accelerator type. Expected format: `nvidia-h100-80gb`.
    pub accelerator_type: std::string::String,

    /// Output only. The TPU topology (if applicable).
    pub tpu_topology: std::string::String,

    /// Output only. The instance type. Expected format: `a2-highgpu-1g`.
    pub instance_type: std::string::String,

    /// Output only. The resources used by the model deployment.
    pub resources_used: std::option::Option<crate::model::ResourcesUsed>,

    /// Output only. The performance statistics for this profile.
    pub performance_stats: std::vec::Vec<crate::model::PerformanceStats>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Profile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [model_server_info][crate::model::Profile::model_server_info].
    pub fn set_model_server_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ModelServerInfo>,
    {
        self.model_server_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [model_server_info][crate::model::Profile::model_server_info].
    pub fn set_or_clear_model_server_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ModelServerInfo>,
    {
        self.model_server_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [accelerator_type][crate::model::Profile::accelerator_type].
    pub fn set_accelerator_type<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.accelerator_type = v.into();
        self
    }

    /// Sets the value of [tpu_topology][crate::model::Profile::tpu_topology].
    pub fn set_tpu_topology<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tpu_topology = v.into();
        self
    }

    /// Sets the value of [instance_type][crate::model::Profile::instance_type].
    pub fn set_instance_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_type = v.into();
        self
    }

    /// Sets the value of [resources_used][crate::model::Profile::resources_used].
    pub fn set_resources_used<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ResourcesUsed>,
    {
        self.resources_used = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resources_used][crate::model::Profile::resources_used].
    pub fn set_or_clear_resources_used<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ResourcesUsed>,
    {
        self.resources_used = v.map(|x| x.into());
        self
    }

    /// Sets the value of [performance_stats][crate::model::Profile::performance_stats].
    pub fn set_performance_stats<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PerformanceStats>,
    {
        use std::iter::Iterator;
        self.performance_stats = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Profile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkerecommender.v1.Profile"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Profile {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __model_server_info,
            __accelerator_type,
            __tpu_topology,
            __instance_type,
            __resources_used,
            __performance_stats,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Profile")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "modelServerInfo" => Ok(__FieldTag::__model_server_info),
                            "model_server_info" => Ok(__FieldTag::__model_server_info),
                            "acceleratorType" => Ok(__FieldTag::__accelerator_type),
                            "accelerator_type" => Ok(__FieldTag::__accelerator_type),
                            "tpuTopology" => Ok(__FieldTag::__tpu_topology),
                            "tpu_topology" => Ok(__FieldTag::__tpu_topology),
                            "instanceType" => Ok(__FieldTag::__instance_type),
                            "instance_type" => Ok(__FieldTag::__instance_type),
                            "resourcesUsed" => Ok(__FieldTag::__resources_used),
                            "resources_used" => Ok(__FieldTag::__resources_used),
                            "performanceStats" => Ok(__FieldTag::__performance_stats),
                            "performance_stats" => Ok(__FieldTag::__performance_stats),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Profile;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Profile")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__model_server_info => {
                            if !fields.insert(__FieldTag::__model_server_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model_server_info",
                                ));
                            }
                            result.model_server_info = map
                                .next_value::<std::option::Option<crate::model::ModelServerInfo>>(
                                )?;
                        }
                        __FieldTag::__accelerator_type => {
                            if !fields.insert(__FieldTag::__accelerator_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for accelerator_type",
                                ));
                            }
                            result.accelerator_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tpu_topology => {
                            if !fields.insert(__FieldTag::__tpu_topology) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tpu_topology",
                                ));
                            }
                            result.tpu_topology = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance_type => {
                            if !fields.insert(__FieldTag::__instance_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_type",
                                ));
                            }
                            result.instance_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resources_used => {
                            if !fields.insert(__FieldTag::__resources_used) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resources_used",
                                ));
                            }
                            result.resources_used = map
                                .next_value::<std::option::Option<crate::model::ResourcesUsed>>()?;
                        }
                        __FieldTag::__performance_stats => {
                            if !fields.insert(__FieldTag::__performance_stats) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for performance_stats",
                                ));
                            }
                            result.performance_stats =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::PerformanceStats>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Profile {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.model_server_info.is_some() {
            state.serialize_entry("modelServerInfo", &self.model_server_info)?;
        }
        if !self.accelerator_type.is_empty() {
            state.serialize_entry("acceleratorType", &self.accelerator_type)?;
        }
        if !self.tpu_topology.is_empty() {
            state.serialize_entry("tpuTopology", &self.tpu_topology)?;
        }
        if !self.instance_type.is_empty() {
            state.serialize_entry("instanceType", &self.instance_type)?;
        }
        if self.resources_used.is_some() {
            state.serialize_entry("resourcesUsed", &self.resources_used)?;
        }
        if !self.performance_stats.is_empty() {
            state.serialize_entry("performanceStats", &self.performance_stats)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Profile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Profile");
        debug_struct.field("model_server_info", &self.model_server_info);
        debug_struct.field("accelerator_type", &self.accelerator_type);
        debug_struct.field("tpu_topology", &self.tpu_topology);
        debug_struct.field("instance_type", &self.instance_type);
        debug_struct.field("resources_used", &self.resources_used);
        debug_struct.field("performance_stats", &self.performance_stats);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for
/// [GkeInferenceQuickstart.GenerateOptimizedManifest][google.cloud.gkerecommender.v1.GkeInferenceQuickstart.GenerateOptimizedManifest].
///
/// [google.cloud.gkerecommender.v1.GkeInferenceQuickstart.GenerateOptimizedManifest]: crate::client::GkeInferenceQuickstart::generate_optimized_manifest
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerateOptimizedManifestRequest {
    /// Required. The model server configuration to generate the manifest for. Use
    /// [GkeInferenceQuickstart.FetchProfiles][google.cloud.gkerecommender.v1.GkeInferenceQuickstart.FetchProfiles]
    /// to find valid configurations.
    ///
    /// [google.cloud.gkerecommender.v1.GkeInferenceQuickstart.FetchProfiles]: crate::client::GkeInferenceQuickstart::fetch_profiles
    pub model_server_info: std::option::Option<crate::model::ModelServerInfo>,

    /// Required. The accelerator type. Use
    /// [GkeInferenceQuickstart.FetchProfiles][google.cloud.gkerecommender.v1.GkeInferenceQuickstart.FetchProfiles]
    /// to find valid accelerators for a given `model_server_info`.
    ///
    /// [google.cloud.gkerecommender.v1.GkeInferenceQuickstart.FetchProfiles]: crate::client::GkeInferenceQuickstart::fetch_profiles
    pub accelerator_type: std::string::String,

    /// Optional. The kubernetes namespace to deploy the manifests in.
    pub kubernetes_namespace: std::string::String,

    /// Optional. The performance requirements to use for generating Horizontal Pod
    /// Autoscaler (HPA) resources. If provided, the manifest includes HPA
    /// resources to adjust the model server replica count to maintain the
    /// specified targets (e.g., NTPOT, TTFT) at a P50 latency. Cost targets are
    /// not currently supported for HPA generation. If the specified targets are
    /// not achievable, the HPA manifest will not be generated.
    pub performance_requirements: std::option::Option<crate::model::PerformanceRequirements>,

    /// Optional. The storage configuration for the model. If not provided, the
    /// model is loaded from Huggingface.
    pub storage_config: std::option::Option<crate::model::StorageConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateOptimizedManifestRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [model_server_info][crate::model::GenerateOptimizedManifestRequest::model_server_info].
    pub fn set_model_server_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ModelServerInfo>,
    {
        self.model_server_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [model_server_info][crate::model::GenerateOptimizedManifestRequest::model_server_info].
    pub fn set_or_clear_model_server_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ModelServerInfo>,
    {
        self.model_server_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [accelerator_type][crate::model::GenerateOptimizedManifestRequest::accelerator_type].
    pub fn set_accelerator_type<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.accelerator_type = v.into();
        self
    }

    /// Sets the value of [kubernetes_namespace][crate::model::GenerateOptimizedManifestRequest::kubernetes_namespace].
    pub fn set_kubernetes_namespace<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.kubernetes_namespace = v.into();
        self
    }

    /// Sets the value of [performance_requirements][crate::model::GenerateOptimizedManifestRequest::performance_requirements].
    pub fn set_performance_requirements<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PerformanceRequirements>,
    {
        self.performance_requirements = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [performance_requirements][crate::model::GenerateOptimizedManifestRequest::performance_requirements].
    pub fn set_or_clear_performance_requirements<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PerformanceRequirements>,
    {
        self.performance_requirements = v.map(|x| x.into());
        self
    }

    /// Sets the value of [storage_config][crate::model::GenerateOptimizedManifestRequest::storage_config].
    pub fn set_storage_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::StorageConfig>,
    {
        self.storage_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [storage_config][crate::model::GenerateOptimizedManifestRequest::storage_config].
    pub fn set_or_clear_storage_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::StorageConfig>,
    {
        self.storage_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for GenerateOptimizedManifestRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkerecommender.v1.GenerateOptimizedManifestRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GenerateOptimizedManifestRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __model_server_info,
            __accelerator_type,
            __kubernetes_namespace,
            __performance_requirements,
            __storage_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GenerateOptimizedManifestRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "modelServerInfo" => Ok(__FieldTag::__model_server_info),
                            "model_server_info" => Ok(__FieldTag::__model_server_info),
                            "acceleratorType" => Ok(__FieldTag::__accelerator_type),
                            "accelerator_type" => Ok(__FieldTag::__accelerator_type),
                            "kubernetesNamespace" => Ok(__FieldTag::__kubernetes_namespace),
                            "kubernetes_namespace" => Ok(__FieldTag::__kubernetes_namespace),
                            "performanceRequirements" => Ok(__FieldTag::__performance_requirements),
                            "performance_requirements" => {
                                Ok(__FieldTag::__performance_requirements)
                            }
                            "storageConfig" => Ok(__FieldTag::__storage_config),
                            "storage_config" => Ok(__FieldTag::__storage_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GenerateOptimizedManifestRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerateOptimizedManifestRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__model_server_info => {
                            if !fields.insert(__FieldTag::__model_server_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model_server_info",
                                ));
                            }
                            result.model_server_info = map
                                .next_value::<std::option::Option<crate::model::ModelServerInfo>>(
                                )?;
                        }
                        __FieldTag::__accelerator_type => {
                            if !fields.insert(__FieldTag::__accelerator_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for accelerator_type",
                                ));
                            }
                            result.accelerator_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kubernetes_namespace => {
                            if !fields.insert(__FieldTag::__kubernetes_namespace) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kubernetes_namespace",
                                ));
                            }
                            result.kubernetes_namespace = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__performance_requirements => {
                            if !fields.insert(__FieldTag::__performance_requirements) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for performance_requirements",
                                ));
                            }
                            result.performance_requirements = map.next_value::<std::option::Option<crate::model::PerformanceRequirements>>()?
                                ;
                        }
                        __FieldTag::__storage_config => {
                            if !fields.insert(__FieldTag::__storage_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_config",
                                ));
                            }
                            result.storage_config = map
                                .next_value::<std::option::Option<crate::model::StorageConfig>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GenerateOptimizedManifestRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.model_server_info.is_some() {
            state.serialize_entry("modelServerInfo", &self.model_server_info)?;
        }
        if !self.accelerator_type.is_empty() {
            state.serialize_entry("acceleratorType", &self.accelerator_type)?;
        }
        if !self.kubernetes_namespace.is_empty() {
            state.serialize_entry("kubernetesNamespace", &self.kubernetes_namespace)?;
        }
        if self.performance_requirements.is_some() {
            state.serialize_entry("performanceRequirements", &self.performance_requirements)?;
        }
        if self.storage_config.is_some() {
            state.serialize_entry("storageConfig", &self.storage_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GenerateOptimizedManifestRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GenerateOptimizedManifestRequest");
        debug_struct.field("model_server_info", &self.model_server_info);
        debug_struct.field("accelerator_type", &self.accelerator_type);
        debug_struct.field("kubernetes_namespace", &self.kubernetes_namespace);
        debug_struct.field("performance_requirements", &self.performance_requirements);
        debug_struct.field("storage_config", &self.storage_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A Kubernetes manifest.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct KubernetesManifest {
    /// Output only. Kubernetes resource kind.
    pub kind: std::string::String,

    /// Output only. Kubernetes API version.
    pub api_version: std::string::String,

    /// Output only. YAML content.
    pub content: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl KubernetesManifest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::KubernetesManifest::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::KubernetesManifest::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }

    /// Sets the value of [content][crate::model::KubernetesManifest::content].
    pub fn set_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.content = v.into();
        self
    }
}

impl wkt::message::Message for KubernetesManifest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkerecommender.v1.KubernetesManifest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for KubernetesManifest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __api_version,
            __content,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for KubernetesManifest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "apiVersion" => Ok(__FieldTag::__api_version),
                            "api_version" => Ok(__FieldTag::__api_version),
                            "content" => Ok(__FieldTag::__content),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = KubernetesManifest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct KubernetesManifest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__api_version => {
                            if !fields.insert(__FieldTag::__api_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_version",
                                ));
                            }
                            result.api_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__content => {
                            if !fields.insert(__FieldTag::__content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content",
                                ));
                            }
                            result.content = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for KubernetesManifest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self.api_version.is_empty() {
            state.serialize_entry("apiVersion", &self.api_version)?;
        }
        if !self.content.is_empty() {
            state.serialize_entry("content", &self.content)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for KubernetesManifest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("KubernetesManifest");
        debug_struct.field("kind", &self.kind);
        debug_struct.field("api_version", &self.api_version);
        debug_struct.field("content", &self.content);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for
/// [GkeInferenceQuickstart.GenerateOptimizedManifest][google.cloud.gkerecommender.v1.GkeInferenceQuickstart.GenerateOptimizedManifest].
///
/// [google.cloud.gkerecommender.v1.GkeInferenceQuickstart.GenerateOptimizedManifest]: crate::client::GkeInferenceQuickstart::generate_optimized_manifest
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerateOptimizedManifestResponse {
    /// Output only. A list of generated Kubernetes manifests.
    pub kubernetes_manifests: std::vec::Vec<crate::model::KubernetesManifest>,

    /// Output only. Comments related to deploying the generated manifests.
    pub comments: std::vec::Vec<std::string::String>,

    /// Output only. Additional information about the versioned dependencies used
    /// to generate the manifests. See [Run best practice inference with GKE
    /// Inference Quickstart
    /// recipes](https://cloud.google.com/kubernetes-engine/docs/how-to/machine-learning/inference/inference-quickstart)
    /// for details.
    pub manifest_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateOptimizedManifestResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kubernetes_manifests][crate::model::GenerateOptimizedManifestResponse::kubernetes_manifests].
    pub fn set_kubernetes_manifests<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::KubernetesManifest>,
    {
        use std::iter::Iterator;
        self.kubernetes_manifests = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [comments][crate::model::GenerateOptimizedManifestResponse::comments].
    pub fn set_comments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.comments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [manifest_version][crate::model::GenerateOptimizedManifestResponse::manifest_version].
    pub fn set_manifest_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.manifest_version = v.into();
        self
    }
}

impl wkt::message::Message for GenerateOptimizedManifestResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkerecommender.v1.GenerateOptimizedManifestResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GenerateOptimizedManifestResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kubernetes_manifests,
            __comments,
            __manifest_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GenerateOptimizedManifestResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kubernetesManifests" => Ok(__FieldTag::__kubernetes_manifests),
                            "kubernetes_manifests" => Ok(__FieldTag::__kubernetes_manifests),
                            "comments" => Ok(__FieldTag::__comments),
                            "manifestVersion" => Ok(__FieldTag::__manifest_version),
                            "manifest_version" => Ok(__FieldTag::__manifest_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GenerateOptimizedManifestResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerateOptimizedManifestResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kubernetes_manifests => {
                            if !fields.insert(__FieldTag::__kubernetes_manifests) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kubernetes_manifests",
                                ));
                            }
                            result.kubernetes_manifests = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::KubernetesManifest>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__comments => {
                            if !fields.insert(__FieldTag::__comments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for comments",
                                ));
                            }
                            result.comments = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__manifest_version => {
                            if !fields.insert(__FieldTag::__manifest_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for manifest_version",
                                ));
                            }
                            result.manifest_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GenerateOptimizedManifestResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kubernetes_manifests.is_empty() {
            state.serialize_entry("kubernetesManifests", &self.kubernetes_manifests)?;
        }
        if !self.comments.is_empty() {
            state.serialize_entry("comments", &self.comments)?;
        }
        if !self.manifest_version.is_empty() {
            state.serialize_entry("manifestVersion", &self.manifest_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GenerateOptimizedManifestResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GenerateOptimizedManifestResponse");
        debug_struct.field("kubernetes_manifests", &self.kubernetes_manifests);
        debug_struct.field("comments", &self.comments);
        debug_struct.field("manifest_version", &self.manifest_version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Storage configuration for a model deployment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StorageConfig {
    /// Optional. The Google Cloud Storage bucket URI to load the model from. This
    /// URI must point to the directory containing the model's config file
    /// (`config.json`) and model weights. A tuned GCSFuse setup can improve
    /// LLM Pod startup time by more than 7x. Expected format:
    /// `gs://<bucket-name>/<path-to-model>`.
    pub model_bucket_uri: std::string::String,

    /// Optional. The URI for the GCS bucket containing the XLA compilation cache.
    /// If using TPUs, the XLA cache will be written to the same path as
    /// `model_bucket_uri`. This can speed up vLLM model preparation for repeated
    /// deployments.
    pub xla_cache_bucket_uri: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StorageConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [model_bucket_uri][crate::model::StorageConfig::model_bucket_uri].
    pub fn set_model_bucket_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.model_bucket_uri = v.into();
        self
    }

    /// Sets the value of [xla_cache_bucket_uri][crate::model::StorageConfig::xla_cache_bucket_uri].
    pub fn set_xla_cache_bucket_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.xla_cache_bucket_uri = v.into();
        self
    }
}

impl wkt::message::Message for StorageConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkerecommender.v1.StorageConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StorageConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __model_bucket_uri,
            __xla_cache_bucket_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StorageConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "modelBucketUri" => Ok(__FieldTag::__model_bucket_uri),
                            "model_bucket_uri" => Ok(__FieldTag::__model_bucket_uri),
                            "xlaCacheBucketUri" => Ok(__FieldTag::__xla_cache_bucket_uri),
                            "xla_cache_bucket_uri" => Ok(__FieldTag::__xla_cache_bucket_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StorageConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StorageConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__model_bucket_uri => {
                            if !fields.insert(__FieldTag::__model_bucket_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model_bucket_uri",
                                ));
                            }
                            result.model_bucket_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__xla_cache_bucket_uri => {
                            if !fields.insert(__FieldTag::__xla_cache_bucket_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for xla_cache_bucket_uri",
                                ));
                            }
                            result.xla_cache_bucket_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StorageConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.model_bucket_uri.is_empty() {
            state.serialize_entry("modelBucketUri", &self.model_bucket_uri)?;
        }
        if !self.xla_cache_bucket_uri.is_empty() {
            state.serialize_entry("xlaCacheBucketUri", &self.xla_cache_bucket_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for StorageConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StorageConfig");
        debug_struct.field("model_bucket_uri", &self.model_bucket_uri);
        debug_struct.field("xla_cache_bucket_uri", &self.xla_cache_bucket_uri);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}
